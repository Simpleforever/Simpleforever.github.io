<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/02/24/hello-world/"/>
    <url>/2022/02/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——String</title>
    <link href="/2021/04/06/Leetcode%20Notes%E2%80%94%E2%80%94String/"/>
    <url>/2021/04/06/Leetcode%20Notes%E2%80%94%E2%80%94String/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>字符串</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="415-字符串相加-easy"><a href="#415-字符串相加-easy" class="headerlink" title="415. 字符串相加[easy]"></a><a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a>[easy]</h1><h2 id="解法：双指针模拟"><a href="#解法：双指针模拟" class="headerlink" title="解法：双指针模拟"></a>解法：双指针模拟</h2><p>设定 <code>i</code>，<code>j</code> 两指针分别指向 <code>num1</code>，<code>num2</code> 尾部，模拟人工加法：</p><ul><li><strong>计算进位：</strong> 计算 <code>carry = tmp / 10</code>，代表当前位相加是否产生进位；</li><li><strong>添加当前位：</strong> 计算 <code>tmp = n1 + n2 + carry</code>，并将当前位 <code>tmp % 10</code> 添加至 <code>res</code> 头部；</li><li><strong>索引溢出处理：</strong> 当指针 <code>i</code> 或 <code>j</code> 走过数字首部后，给 <code>n1</code>，<code>n2</code> 赋值为 0，相当于给 <code>num1</code>，<code>num2</code> 中长度较短的数字前面填 0，以便后续计算。</li><li>当遍历完 <code>num1</code>，<code>num2</code> 后跳出循环，并根据 <code>carry</code> 值决定是否在头部添加进位 1，最终返回 <code>res</code> 即可。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-type">int</span> i=num1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,j=num2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>||j&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> a=i&gt;=<span class="hljs-number">0</span>?num1[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> b=j&gt;=<span class="hljs-number">0</span>?num2[j]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum=a+b+carry;<br>            carry=sum/<span class="hljs-number">10</span>;<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),sum%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            --i;<br>            --j;           <br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry==<span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="补充题：字符串相减（大数相减）"><a href="#补充题：字符串相减（大数相减）" class="headerlink" title="补充题：字符串相减（大数相减）"></a>补充题：字符串相减（大数相减）</h2><blockquote><p>参考 @一个搬砖的胖子——<a href="https://mp.weixin.qq.com/s/kCue4c0gnLSw0HosFl_t7w">补充题：字符串相减（大数相减）</a></p></blockquote><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串形式的<strong>非负整数</strong> num1 和num2 ，计算它们的差。</p><blockquote><p>注意：</p><ol><li>num1 和num2 都只会包含数字 0-9</li><li>num1 和num2 都不包含任何前导零</li><li>你不能使用任何內建 BigInteger 库</li></ol></blockquote><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>两个非负整数相减的结果可能为负。因此，首先比较两个数的大小。如代码所示，当小减大时，需将两个参数调换一下位置执行减法，在结果前填上<code>负号</code>即可。</p><p>注意：结果为0时不加负号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">subStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    string res;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(num1, num2)) &#123;<br>        res = <span class="hljs-built_in">sub</span>(num2, num1);<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-string">&quot;0&quot;</span>) res.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> res = <span class="hljs-built_in">sub</span>(num1, num2);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何比较两个大数的大小呢？由于是大数，肯定不能直接转成int比较。我们可以比较两个字符串的长度。长度更长的字符串，数一定更大；当长度一样的就去比较字典序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a &lt; b;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>大体框架写完了，接下来实现关键的<code>sub函数</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">sub</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> borrow = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> x = i &gt;= <span class="hljs-number">0</span> ? (a[i] - <span class="hljs-string">&#x27;0&#x27;</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">//字符转整数</span><br>        <span class="hljs-type">int</span> y = j &gt;= <span class="hljs-number">0</span> ? (b[j] - <span class="hljs-string">&#x27;0&#x27;</span>) : <span class="hljs-number">0</span>; <span class="hljs-comment">//字符转整数</span><br>        <span class="hljs-type">int</span> z = (x - borrow - y + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>;<br>        res += (<span class="hljs-string">&#x27;0&#x27;</span> + z); <span class="hljs-comment">//整数转成字符</span><br>        borrow = x - borrow - y &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        i--, j--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//删除前导0，注意边界是res.size()-1！！防止当res为&quot;0000&quot;时，删为&quot;&quot;的清空</span><br>    <span class="hljs-type">int</span> pos;<br>    <span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; pos++) &#123;<br>        <span class="hljs-keyword">if</span> (res[pos] != <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(pos);<br>&#125;<br></code></pre></td></tr></table></figure><p>需要说明的点有2个：</p><ol><li><p><code>z = (x - borrow - y + 10) % 10</code><br>这种写法更简洁，其实等价于以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(x - borrow - y &lt; <span class="hljs-number">0</span>) &#123;<br>    z = (x - borrow - y + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">else</span> z = x - borrow - y;<br></code></pre></td></tr></table></figure></li><li><p>删除前导0<br>例如，当<code>121-120=001</code>，需要将前面的0删除，得到最终结果<code>1</code>。注意<code>121-121=000</code>这种情况，不要把所有0都删了！</p></li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">string <span class="hljs-title">sub</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> borrow = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> x = i &gt;= <span class="hljs-number">0</span> ? a[i] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> y = j &gt;= <span class="hljs-number">0</span> ? b[j] - <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> z = (x - borrow - y + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>;<br>        res += <span class="hljs-string">&#x27;0&#x27;</span> + z;<br>        borrow = x - borrow - y &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        i--, j--;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-comment">//删除前导0。循环条件是res.size()-1是为防止&quot;0000&quot;的情况</span><br>    <span class="hljs-type">int</span> pos;<br>    <span class="hljs-keyword">for</span> (pos = <span class="hljs-number">0</span>; pos &lt; res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; pos++) &#123;<br>        <span class="hljs-keyword">if</span> (res[pos] != <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">substr</span>(pos);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">size</span>() == b.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> a &lt; b;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &lt; b.<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function">string <span class="hljs-title">subStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    string res;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(num1, num2)) &#123;<br>        res = <span class="hljs-built_in">sub</span>(num2, num1);<br>        <span class="hljs-keyword">if</span> (res != <span class="hljs-string">&quot;0&quot;</span>) res.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> res = <span class="hljs-built_in">sub</span>(num1, num2);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string a, b, c;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-built_in">subStrings</span>(a, b) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="67-二进制求和-easy"><a href="#67-二进制求和-easy" class="headerlink" title="67. 二进制求和[easy]"></a><a href="https://leetcode-cn.com/problems/add-binary/">67. 二进制求和</a>[easy]</h1><h2 id="解法：双指针模拟-1"><a href="#解法：双指针模拟-1" class="headerlink" title="解法：双指针模拟"></a>解法：双指针模拟</h2><p>思路与 <a href="https://leetcode-cn.com/problems/add-strings/">415. 字符串相加</a> 相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>||j&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num1=i&gt;=<span class="hljs-number">0</span>?a[i]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> num2=j&gt;=<span class="hljs-number">0</span>?b[j]-<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> sum=num1+num2+carry;<br>            carry=sum/<span class="hljs-number">2</span>;<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),sum%<span class="hljs-number">2</span>+<span class="hljs-string">&#x27;0&#x27;</span>);<br>            --i;<br>            --j;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry==<span class="hljs-number">1</span>)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),<span class="hljs-string">&#x27;1&#x27;</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="8-字符串转换整数-atoi-medium"><a href="#8-字符串转换整数-atoi-medium" class="headerlink" title="8. 字符串转换整数 (atoi)[medium]"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a>[medium]</h1><h2 id="解法：模拟"><a href="#解法：模拟" class="headerlink" title="解法：模拟"></a>解法：模拟</h2><ul><li><p>去掉前导空格</p></li><li><p>再是处理正负号</p></li><li><p>识别数字，注意越界情况（由于题目中说「环境只能保存 32 位整数」，因此这里在每一轮循环之前先要检查乘以 10 以后是否溢出）</p><p>对于溢出的处理方式通常可以转换为 <code>INT_MAX</code> 的逆操作。比如判断某数乘 10 是否会溢出，那么就把该数和 <code>INT_MAX</code> 除 10 进行比较。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 1、去除前导空格</span><br>        <span class="hljs-keyword">while</span>(i&lt;len&amp;&amp;s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            i++;<br>        <span class="hljs-comment">// 2、如果已经遍历完成（针对极端用例 &quot;  &quot;）</span><br>        <span class="hljs-keyword">if</span>(i==len)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 3、如果出现符号字符，仅第 1 个有效，并记录正负</span><br>        <span class="hljs-type">int</span> sign=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>            i++;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>        &#123;<br>            i++;<br>            sign=<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4、将后续出现的数字字符进行转换</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;len)<br>        &#123;<br>            <span class="hljs-comment">// 4.1 先判断不合法的情况</span><br>            <span class="hljs-keyword">if</span>(s[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>||s[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 题目中说：环境只能存储 32 位大小的有符号整数，因此需要提前判断乘以 10 以后是否越界</span><br>            <span class="hljs-keyword">if</span>(res&gt;INT_MAX/<span class="hljs-number">10</span>||(res==INT_MAX/<span class="hljs-number">10</span>&amp;&amp;(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)&gt;INT_MAX%<span class="hljs-number">10</span>))<br>                <span class="hljs-keyword">return</span> sign&gt;<span class="hljs-number">0</span>?INT_MAX:INT_MIN;<br>            <span class="hljs-comment">// 4.2 合法的情况下，才考虑转换</span><br>            res=res*<span class="hljs-number">10</span>+(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">// 将符号位乘上去</span><br>        <span class="hljs-keyword">return</span> sign*res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="151-翻转字符串里的单词-medium"><a href="#151-翻转字符串里的单词-medium" class="headerlink" title="151. 翻转字符串里的单词[medium]"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a>[medium]</h1><h2 id="解法：原地翻转"><a href="#解法：原地翻转" class="headerlink" title="解法：原地翻转"></a>解法：原地翻转</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// 整体反转</span><br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> end=len<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 处理首空格</span><br>        <span class="hljs-keyword">while</span>(start&lt;len&amp;&amp;s[start]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            start++;<br>        <span class="hljs-comment">// 处理尾空格</span><br>        <span class="hljs-keyword">while</span>(end&gt;=<span class="hljs-number">0</span>&amp;&amp;s[end]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            end--;<br>        <span class="hljs-comment">// 特殊情况</span><br>        <span class="hljs-keyword">if</span>(start&gt;end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">// 逐单词反转</span><br>        <span class="hljs-type">int</span> left=start,right=start;<br>        <span class="hljs-keyword">while</span>(right&lt;=end)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(s[right]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;right&lt;=end)<br>                right++;<br>            left=right;<br>            <span class="hljs-keyword">while</span>(s[left]!=<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;left&lt;=end)<br>                left++;<br>            <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>()+right,s.<span class="hljs-built_in">begin</span>()+left);<br>            right=left;<br>        &#125;<br>        <span class="hljs-comment">// 处理中间冗余空格</span><br>        <span class="hljs-type">int</span> tail=start;        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;=end;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            s[tail++]=s[i];<br>        &#125;<br>        <span class="hljs-comment">// string substr (size_t pos = 0, size_t len = npos) const;</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start,tail-start);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="242-有效的字母异位词-easy"><a href="#242-有效的字母异位词-easy" class="headerlink" title="242. 有效的字母异位词[easy]"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a>[easy]</h1><h2 id="解法一：排序"><a href="#解法一：排序" class="headerlink" title="解法一：排序"></a>解法一：排序</h2><p>先对两个数组排序，然后逐个对比他们相应位置上的字符。</p><ul><li>如果都相同，则返回 true</li><li>否则，返回 false</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()!=t.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s==t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h2><ul><li>首先判断两个字符串长度是否相等，不相等则直接返回 false</li><li>若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t</li><li>s 负责在对应位置增加，t 负责在对应位置减少</li><li>如果哈希表的值都为 0，则二者是字母异位词</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len1!=len2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;++i)<br>        &#123;<br>            ++cnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:cnt)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="409-最长回文串-easy"><a href="#409-最长回文串-easy" class="headerlink" title="409. 最长回文串[easy]"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a>[easy]</h1><h2 id="解法：哈希数组"><a href="#解法：哈希数组" class="headerlink" title="解法：哈希数组"></a>解法：哈希数组</h2><p>构造回文串的过程最后会剩下若干个出现奇数次的字串，因此实际做的是统计有多少种字符出现了奇数次，可以用哈希数组来进行统计。</p><p>几个需要注意的地方：</p><ul><li>用一个大小为 52 的数组来保存各字符出现的次数，但 A～Z 和 a～z 在ASCII表上是分开的，所以存数组的时候也要分开存</li><li>如果某字母有偶数个，因为偶数有对称性，可以把它全部用来构造回文串；但如果是奇数个的话，并不是完全不可以用来构建，也不是只能选最长的那个，而是只要砍掉1个，剩下的变成偶数就可以全部计入了</li><li>但奇数字母里，可以保留1个不砍，把它作为回文串的中心，所以最后还要再加回一个1</li><li>但是！如果压根没有奇数的情况，这个 1 也不能随便加，所以还要分情况讨论</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">52</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>)<br>                ++cnt[c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">else</span><br>                ++cnt[c-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-number">26</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> odd=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:cnt)<br>        &#123;<br>            res+=num;<br>            <span class="hljs-keyword">if</span>(num%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                ++odd;<br>        &#125;<br>        <span class="hljs-keyword">return</span> odd==<span class="hljs-number">0</span>?res:res-odd+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="205-同构字符串-easy"><a href="#205-同构字符串-easy" class="headerlink" title="205. 同构字符串[easy]"></a><a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>使用两个哈希表，一个哈希表记录<code>s[i]</code>到<code>t[i]</code>的映射，一个哈希表记录<code>t[i]</code>到<code>s[i]</code>的映射。</p><ul><li>如果两个哈希表都没有对应的映射时，则建立对应映射</li><li>如果建立了映射，则看映射是否正确</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; st;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; ts;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(s[i])!=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(st[s[i]]!=t[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ts.<span class="hljs-built_in">count</span>(t[i])!=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(ts[t[i]]!=s[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                st[s[i]]=t[i];<br>                ts[t[i]]=s[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同。因此只需对比两个字符串对应位置的字符在字符串内第一次出现的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">find</span>(s[i])!=t.<span class="hljs-built_in">find</span>(t[i]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-最长回文子串-medium"><a href="#5-最长回文子串-medium" class="headerlink" title="5. 最长回文子串[medium]"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a>[medium]</h1><h2 id="解法一：暴力破解（超时）"><a href="#解法一：暴力破解（超时）" class="headerlink" title="解法一：暴力破解（超时）"></a>解法一：暴力破解（超时）</h2><p>暴力求解，列举所有的子串，判断是否为回文串，保存最长的回文串。</p><p>以下代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen=<span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i+j&lt;=s.<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                string tmp=s.<span class="hljs-built_in">substr</span>(i,j);<br>                <span class="hljs-keyword">if</span>(tmp.<span class="hljs-built_in">size</span>()&gt;maxLen&amp;&amp;<span class="hljs-built_in">isPalindrome</span>(tmp))<br>                &#123;<br>                    maxLen=tmp.<span class="hljs-built_in">size</span>();<br>                    res=tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            ++i;<br>            --j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>首先定义<code> P(i，j）</code><br>$$<br>P(i, j)&#x3D;\left{\begin{array}{ll}<br>\text { true } &amp; \text { s[i,j]是回文串 } \<br>\text { false } &amp; \text { s[i,j]不是回文串 }<br>\end{array}\right.<br>$$<br>接下来<br>$$<br>P(i, j)&#x3D;(P(i+1, j-1) &amp; &amp; S[i]&#x3D;&#x3D;S[j])<br>$$<br>所以如果想知道 P(i,j) 的情况，不需要调用判断回文串的函数了，只需要知道 P(i+1，j−1) 的情况就可以了。因此可以用动态规划的方法，空间换时间，把已经求出的 P(i,j) 存储起来。</p><p>如果 S[i+1,j−1] 是回文串，那么只要 S[i]&#x3D;&#x3D;S[j]，就可以确定 S[i,j] 也是回文串了。</p><p>求长度为 1 和长度为 2 的 P(i,j) 时不能用上边的公式，因为代入公式后会遇到 P(i,j) 中 i&gt;j 的情况，比如求 P[1] [2] 的话，需要知道 P[2] [1] ，而 P[2] [1] 代表着 S[2,1] 是不是回文串，显然是不对的，所以需要单独判断。</p><p>所以先初始化长度是 1 的回文串的 P[i,j]，这样利用上边提出的公式 P(i,j)&#x3D;(P(i+1,j-1)&amp;&amp;S[i]&#x3D;&#x3D;S[j])，然后两边向外各扩充一个字符，长度为 3 的，为 5 的，所有奇数长度的就都求出来了。</p><p>同理，初始化长度是 2 的回文串 P[i,i+1]，利用公式，长度为 4 的，6 的所有偶数长度的就都求出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>(len,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> maxLen=<span class="hljs-number">0</span>;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> L=<span class="hljs-number">1</span>;L&lt;=len;++L)<span class="hljs-comment">//遍历所有的长度</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;start&lt;len;++start)<br>            &#123;<br>                <span class="hljs-type">int</span> end=start+L<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(end&gt;=len)<span class="hljs-comment">//下标已经越界，结束本次循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span>((L==<span class="hljs-number">1</span>||L==<span class="hljs-number">2</span>||dp[start+<span class="hljs-number">1</span>][end<span class="hljs-number">-1</span>])&amp;&amp;s[start]==s[end])<br>                    dp[start][end]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(dp[start][end]&amp;&amp;L&gt;maxLen)<br>                &#123;<br>                    maxLen=L;<br>                    res=s.<span class="hljs-built_in">substr</span>(start,L);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>递推公式不变，首先知道了 i+1 才会知道 i，所以只需要倒着遍历就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>(len,<span class="hljs-literal">false</span>));<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((j-i&lt;<span class="hljs-number">2</span>||dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])&amp;&amp;s[i]==s[j])<br>                    dp[i][j]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="hljs-number">1</span>&gt;res.<span class="hljs-built_in">size</span>())<br>                    res=s.<span class="hljs-built_in">substr</span>(i,j-i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：中心扩展法"><a href="#解法三：中心扩展法" class="headerlink" title="解法三：中心扩展法"></a>解法三：中心扩展法</h2><p>回文串一定是对称的，所以可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210421204415.png" style="zoom:67%;" /><p>由于存在奇数的字符串和偶数的字符串，所以需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 <code>n+n-1</code> 个中心。</p><p>本质即为：枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。对所有的长度求出最大值，即可得到最终的答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> len1=<span class="hljs-built_in">expandAroundCenter</span>(s,i,i);<br>            <span class="hljs-type">int</span> len2=<span class="hljs-built_in">expandAroundCenter</span>(s,i,i+<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> len=<span class="hljs-built_in">max</span>(len1,len2);<br>            <span class="hljs-keyword">if</span>(len&gt;end-start)<br>            &#123;<br>                start=i-(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>                end=i+len/<span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start,end-start+<span class="hljs-number">1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> L=left,R=right;<br>        <span class="hljs-keyword">while</span>(L&gt;=<span class="hljs-number">0</span>&amp;&amp;R&lt;=s.<span class="hljs-built_in">size</span>()&amp;&amp;s[L]==s[R])<br>        &#123;<br>            L--;<br>            R++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> R-L<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法四：Manacher算法"><a href="#解法四：Manacher算法" class="headerlink" title="解法四：Manacher算法"></a>解法四：Manacher算法</h2><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/">windliang</a> 题解。</p></blockquote><h1 id="647-回文子串-medium"><a href="#647-回文子串-medium" class="headerlink" title="647. 回文子串[medium]"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a>[medium]</h1><p>与 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a> 思路相似。</p><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>这一题可以使用动态规划来进行解决：</p><ul><li>状态：<code>dp[i][j]</code> 表示字符串<code>s</code>在<code>[i,j]</code>区间的子串是否是一个回文串</li><li>状态转移方程：<code>当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1])</code> 时，<code>dp[i][j]=true</code>，否则为<code>false</code></li></ul><p>这个状态转移方程是什么意思呢？</p><ul><li>当只有一个字符时，比如 <code>a</code> 自然是一个回文串。</li><li>当有两个字符时，如果是相等的，比如 <code>aa</code>，也是一个回文串。</li><li>当有三个及以上字符时，比如 <code>ababa</code> 这个字符记作串 1，把两边的 <code>a</code> 去掉，也就是 <code>bab</code> 记串 2，可以看出只要串2是一个回文串，那么左右各多了一个 <code>a</code> 的串 1 必定也是回文串。所以当 <code>s[i]==s[j]</code> 时，自然要看 <code>dp[i+1][j-1]</code> 是不是一个回文串。</li></ul><p>与 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a> 在循环的顺序上写法不同，两种都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>(len,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=j;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((j-i&lt;<span class="hljs-number">2</span>||dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>])&amp;&amp;s[i]==s[j])<br>                &#123;<br>                    dp[i][j]=<span class="hljs-literal">true</span>;<br>                    ++count;<br>                &#125;               <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：中心扩展法"><a href="#解法二：中心扩展法" class="headerlink" title="解法二：中心扩展法"></a>解法二：中心扩展法</h2><p>这是一个比较巧妙的方法，实质的思路和动态规划的思路类似。</p><p>比如对一个字符串 <code>ababa</code>，选择最中间的 <code>a</code> 作为中心点，往两边扩散，第一次扩散发现 <code>left</code> 指向的是 <code>b</code>，<code>right</code> 指向的也是 <code>b</code>，所以是回文串，继续扩散，同理 <code>ababa</code>也是回文串。</p><p>这个是确定了一个中心点后的寻找的路径，然后只要寻找到所有的中心点，问题就解决了。</p><p>中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 <code>abab</code>，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 <code>abab</code>，就可以有中心点 <code>ba</code>扩展一次得到，所以最终的中心点有 <code>2 * len - 1</code>个，分别是 <code>len</code> 个单字符和 <code>len - 1</code> 个个双字符。</p><p>如果上面看不太懂的话，还可以看看下面几个问题：</p><ul><li><p>为什么有 2 * len - 1 个中心点？</p><ul><li>aba 有5个中心点，分别是 a、b、a、ab、ba</li><li>abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba</li></ul></li><li><p>什么是中心点？</p><p>中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个</p></li><li><p>为什么不可能是三个或者更多？</p><p>因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            sum+=<span class="hljs-built_in">expandAroundCenter</span>(s,i,i);<br>            sum+=<span class="hljs-built_in">expandAroundCenter</span>(s,i,i+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">expandAroundCenter</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> L=left,R=right;<br>        <span class="hljs-keyword">while</span>(L&gt;=<span class="hljs-number">0</span>&amp;&amp;R&lt;=s.<span class="hljs-built_in">size</span>()&amp;&amp;s[L]==s[R])<br>        &#123;<br>            L--;<br>            R++;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：Manacher算法"><a href="#解法三：Manacher算法" class="headerlink" title="解法三：Manacher算法"></a>解法三：Manacher算法</h2><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/palindromic-substrings/solution/manacher-zhi-hui-qiu-zui-chang-hui-wen-zi-chuan-ta/">前额叶没长好</a> 题解。</p></blockquote><h1 id="696-计数二进制子串-easy"><a href="#696-计数二进制子串-easy" class="headerlink" title="696. 计数二进制子串[easy]"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a>[easy]</h1><h2 id="解法：按字符分组"><a href="#解法：按字符分组" class="headerlink" title="解法：按字符分组"></a>解法：按字符分组</h2><p>可以将字符串 s 按照 0 和 1 的连续段分组，存在 counts 数组中，例如 s &#x3D; 00111011，可以得到这样的 counts 数组：counts &#x3D; {2, 3, 1, 2}。</p><p>这里 counts 数组中两个相邻的数一定代表的是两种不同的字符。假设 counts 数组中两个相邻的数字为 u 或者 v，它们对应着 u 个 0 和 v 个 1，或者 u 个 1 和 v 个 0。它们能组成的满足条件的子串数目为 min{u,v}，即一对相邻的数字对答案的贡献。</p><p>只要遍历所有相邻的数对，求它们的贡献总和，即可得到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; counts;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> c=s[i];<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i]==c)<br>            &#123;<br>                ++i;<br>                ++cnt;<br>            &#125;<br>            counts.<span class="hljs-built_in">push_back</span>(cnt);<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;counts.<span class="hljs-built_in">size</span>();++i)<br>            res+=<span class="hljs-built_in">min</span>(counts[i],counts[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对于某一个位置 i，其实只关心 i−1 位置的 counts 值是多少，所以可以用一个 last 变量来维护当前位置的前一个位置，这样可以省去一个 counts 数组的空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> last=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> c=s[i];<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[i]==c)<br>            &#123;<br>                ++i;<br>                ++cnt;<br>            &#125;<br>            res+=<span class="hljs-built_in">min</span>(last,cnt);<br>            last=cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Design</title>
    <link href="/2021/03/14/Leetcode%20Notes%E2%80%94%E2%80%94Design/"/>
    <url>/2021/03/14/Leetcode%20Notes%E2%80%94%E2%80%94Design/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>设计</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="146-LRU-缓存机制-medium"><a href="#146-LRU-缓存机制-medium" class="headerlink" title="146. LRU 缓存机制[medium]"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存机制</a>[medium]</h1><p>思路参考  @<a href="https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/">labuladong</a> 题解。</p><h2 id="LRU-算法描述"><a href="#LRU-算法描述" class="headerlink" title="LRU 算法描述"></a>LRU 算法描述</h2><p>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p><p>注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 缓存容量为 2 */</span><br>LRUCache cache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LRUCache</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 你可以把 cache 理解成一个队列</span><br><span class="hljs-comment">// 假设左边是队头，右边是队尾</span><br><span class="hljs-comment">// 最近使用的排在队头，久未使用的排在队尾</span><br><span class="hljs-comment">// 圆括号表示键值对 (key, val)</span><br><br>cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// cache = [(1, 1)]</span><br>cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">// cache = [(2, 2), (1, 1)]</span><br>cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);       <span class="hljs-comment">// 返回 1</span><br><span class="hljs-comment">// cache = [(1, 1), (2, 2)]</span><br><span class="hljs-comment">// 解释：因为最近访问了键 1，所以提前至队头</span><br><span class="hljs-comment">// 返回键 1 对应的值 1</span><br>cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：缓存容量已满，需要删除内容空出位置</span><br><span class="hljs-comment">// 优先删除久未使用的数据，也就是队尾的数据</span><br><span class="hljs-comment">// 然后把新的数据插入队头</span><br>cache.<span class="hljs-built_in">get</span>(<span class="hljs-number">2</span>);       <span class="hljs-comment">// 返回 -1 (未找到)</span><br><span class="hljs-comment">// cache = [(3, 3), (1, 1)]</span><br><span class="hljs-comment">// 解释：cache 中不存在键为 2 的数据</span><br>cache.<span class="hljs-built_in">put</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);    <br><span class="hljs-comment">// cache = [(1, 4), (3, 3)]</span><br><span class="hljs-comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span><br><span class="hljs-comment">// 不要忘了也要将键值对提前到队头</span><br></code></pre></td></tr></table></figure><h2 id="LRU-算法设计"><a href="#LRU-算法设计" class="headerlink" title="LRU 算法设计"></a>LRU 算法设计</h2><p>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</p><p>因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。</p><p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p><p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210314174345.jpeg"></p><p>思想很简单，就是借助哈希表赋予了链表快速查找的特性嘛：可以快速查找某个 key 是否存在缓存（链表）中，同时可以快速删除、添加节点。</p><p>为什么必须要用双向链表？</p><p>因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// key 映射到 Node(key, val)</span><br>HashMap&lt;Integer, Node&gt; map;<br><span class="hljs-comment">// Node(k1, v1) &lt;-&gt; Node(k2, v2)...</span><br>DoubleList cache;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key 不存在) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;        <br>        将数据 (key, val) 提到开头；<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    Node x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, val);<br>    <span class="hljs-keyword">if</span> (key 已存在) &#123;<br>        把旧的数据删除；<br>        将新节点 x 插入到开头；<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (cache 已满) &#123;<br>            删除链表的最后一个数据腾位置；<br>            删除 map 中映射到该数据的键；<br>        &#125; <br>        将新节点 x 插入到开头；<br>        map 中新建 key 对新节点 x 的映射；<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) :<span class="hljs-built_in">cap</span>(capacity)&#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(key)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 将数据 (key, val) 提到开头</span><br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; key_value=*map[key];<br>        cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        cache.<span class="hljs-built_in">push_front</span>(key_value);<br>        map[key]=cache.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">return</span> key_value.second;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(key)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 把旧的数据删除</span><br>            cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">size</span>()==cap)<br>        &#123;<br>            <span class="hljs-comment">// 删除 map 中映射到该数据的键</span><br>            map.<span class="hljs-built_in">erase</span>(cache.<span class="hljs-built_in">back</span>().first);<br>            <span class="hljs-comment">// 删除链表的最后一个数据腾位置</span><br>            cache.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">// 将新节点插入到开头</span><br>        cache.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>        map[key]=cache.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; cache;<br>    unordered_map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator&gt; map;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Bit Operation</title>
    <link href="/2021/03/09/Leetcode%20Notes%E2%80%94%E2%80%94Bit%20Operation/"/>
    <url>/2021/03/09/Leetcode%20Notes%E2%80%94%E2%80%94Bit%20Operation/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>位运算</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>0s 表示一串 0，1s 表示一串 1。</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span> ^ <span class="hljs-number">0</span>s = x      x &amp; <span class="hljs-number">0</span>s = <span class="hljs-number">0</span>      x | <span class="hljs-number">0</span>s = x<br><span class="hljs-attribute">x</span> ^ <span class="hljs-number">1</span>s = ~x     x &amp; <span class="hljs-number">1</span>s = x      x | <span class="hljs-number">1</span>s = <span class="hljs-number">1</span>s<br><span class="hljs-attribute">x</span> ^ x = <span class="hljs-number">0</span>       x &amp; x = x       x | x = x<br></code></pre></td></tr></table></figure><p>利用 x ^ 1s &#x3D; ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x &#x3D; 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>^<span class="hljs-number">1</span>^<span class="hljs-number">2</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>利用 x &amp; 0s &#x3D; 0 和 x &amp; 1s &#x3D; x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">01011011 &amp;<br><span class="hljs-section">00111100</span><br><span class="hljs-section">--------</span><br>00011000<br></code></pre></td></tr></table></figure><p>利用 x | 0s &#x3D; x 和 x | 1s &#x3D; 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">01011011 |<br><span class="hljs-section">00111100</span><br><span class="hljs-section">--------</span><br>01111111<br></code></pre></td></tr></table></figure><h2 id="位与运算技巧"><a href="#位与运算技巧" class="headerlink" title="位与运算技巧"></a>位与运算技巧</h2><p>n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">01011011 &amp;<br><span class="hljs-section">01011010</span><br><span class="hljs-section">--------</span><br>01011010<br></code></pre></td></tr></table></figure><p>n&amp;(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n&#x3D;~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">10110100 &amp;<br><span class="hljs-section">01001100</span><br><span class="hljs-section">--------</span><br>00000100<br></code></pre></td></tr></table></figure><p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p><h2 id="mask-计算"><a href="#mask-计算" class="headerlink" title="mask 计算"></a>mask 计算</h2><p>要获取 111111111，将 0 取反即可，~0。</p><p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p><p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 &#x3D; 00010000-1 &#x3D; 00001111。</p><p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p><h1 id="136-只出现一次的数字-easy"><a href="#136-只出现一次的数字-easy" class="headerlink" title="136. 只出现一次的数字[easy]"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            ++cnt[num];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:cnt)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(elem.second==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> elem.first;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：异或"><a href="#解法二：异或" class="headerlink" title="解法二：异或"></a>解法二：异或</h2><p>思路参考 <a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%80%A7%E8%B4%A8%E4%B8%8E%E6%89%A9%E5%B1%95">牛客左神算法课笔记—算法入门异或运算的性质与扩展</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            eor^=num;<br>        <span class="hljs-keyword">return</span> eor;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="137-只出现一次的数字-II-medium"><a href="#137-只出现一次的数字-II-medium" class="headerlink" title="137. 只出现一次的数字 II[medium]"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a>[medium]</h1><h2 id="解法一：哈希表-1"><a href="#解法一：哈希表-1" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num)!=<span class="hljs-number">0</span>)<br>                m[num]++;<br>            <span class="hljs-keyword">else</span><br>                m[num]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(elem.second==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> elem.first;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：位运算"><a href="#解法二：位运算" class="headerlink" title="解法二：位运算"></a>解法二：位运算</h2><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/">Krahets</a> 题解。</p></blockquote><h1 id="260-只出现一次的数字-III-medium"><a href="#260-只出现一次的数字-III-medium" class="headerlink" title="260. 只出现一次的数字 III[medium]"></a><a href="https://leetcode-cn.com/problems/single-number-iii/">260. 只出现一次的数字 III</a>[medium]</h1><h2 id="解法：异或"><a href="#解法：异或" class="headerlink" title="解法：异或"></a>解法：异或</h2><ul><li>把所有的元素进行异或操作，最终得到一个异或值。因为是不同的两个数字，所以这个值必定不为 0。</li><li>取异或值最后一个二进制位为 1 的数字作为 mask，如果是 1 则表示两个数字在这一位上不同。</li><li>通过与这个 mask 进行与操作，如果为 0 的分为一个数组，为 1 的分为另一个数组。这样就把问题降低成了：“有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字”。对这两个子问题分别进行全异或就可以得到两个解。也就是最终的数组了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] singleNumber(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            eor^=num;<br>        <span class="hljs-type">int</span> rightOne=eor&amp;(~eor+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// int rightOne=eor&amp;(-eor);</span><br>        <span class="hljs-type">int</span> res[]=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((num&amp;rightOne)==<span class="hljs-number">0</span>)<br>                res[<span class="hljs-number">0</span>]^=num;<br>            <span class="hljs-keyword">else</span><br>                res[<span class="hljs-number">1</span>]^=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="191-位1的个数-easy"><a href="#191-位1的个数-easy" class="headerlink" title="191. 位1的个数[easy]"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a>[easy]</h1><h2 id="解法一：移位"><a href="#解法一：移位" class="headerlink" title="解法一：移位"></a>解法一：移位</h2><p>统计二进制中每一位是否为 <code>1</code>：</p><ul><li>使用 <code>n &amp; 1</code> 得到二进制末尾是否为 1</li><li>把 <code>n</code> 右移 1 位，直至结束</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                ++count;<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：n-amp-n-1"><a href="#解法二：n-amp-n-1" class="headerlink" title="解法二：n&amp;(n-1)"></a>解法二：n&amp;(n-1)</h2><p>消除二进制末尾的 1。执行 <code>n &amp; (n - 1)</code> 使得 n 变成 0 的操作次数，就是 n 的二进制中 1 的个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)<br>        &#123;<br>            ++count;<br>            n&amp;=n<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="461-汉明距离-easy"><a href="#461-汉明距离-easy" class="headerlink" title="461. 汉明距离[easy]"></a><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a>[easy]</h1><h2 id="解法一：异或-移位"><a href="#解法一：异或-移位" class="headerlink" title="解法一：异或+移位"></a>解法一：异或+移位</h2><p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num=x^y;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                cnt++;<br>            num=num&gt;&gt;<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：异或-n-amp-n-1"><a href="#解法二：异或-n-amp-n-1" class="headerlink" title="解法二：异或+n&amp;(n-1)"></a>解法二：异或+n&amp;(n-1)</h2><p>使用 n&amp;(n-1) 去除 n 位级表示最低的那一位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num=x^y;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            num&amp;=num<span class="hljs-number">-1</span>;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="268-丢失的数字-easy"><a href="#268-丢失的数字-easy" class="headerlink" title="268. 丢失的数字[easy]"></a><a href="https://leetcode-cn.com/problems/missing-number/">268. 丢失的数字</a>[easy]</h1><h2 id="解法一：哈希表-2"><a href="#解法一：哈希表-2" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>直接查询每个数是否在数组中出现过来找出缺失的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(i)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：位运算-1"><a href="#解法二：位运算-1" class="headerlink" title="解法二：位运算"></a>解法二：位运算</h2><p>数组中有 n 个数，并且缺失的数在 [0..n] 中。因此可以先得到 [0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            res=res^i^nums[i];<br>        <span class="hljs-keyword">return</span> res^nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：数学"><a href="#解法三：数学" class="headerlink" title="解法三：数学"></a>解法三：数学</h2><p>求出 [0..n] 的和，减去数组中所有数的和，就得到了缺失的数字。只需要遍历一遍数组，在把 0-n 这 n 个自然数全加起来的同时也减去 nums[i]，这样不但效率高，也防止了数据溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            sum+=i;<br>            sum-=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="231-2的幂-easy"><a href="#231-2的幂-easy" class="headerlink" title="231. 2的幂[easy]"></a><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2的幂</a>[easy]</h1><h2 id="解法：n-amp-n-1"><a href="#解法：n-amp-n-1" class="headerlink" title="解法：n&amp;(n-1)"></a>解法：n&amp;(n-1)</h2><ul><li>2 的幂二进制表示只含有一个 1。</li><li>x &amp; (x - 1) 操作会去除 x 的位级表示中最低的那一位 1，因此判断是否为 2 的幂：判断 x &amp; (x - 1)是否为 0。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415161814.jpeg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; (n&amp;(n<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="342-4的幂-easy"><a href="#342-4的幂-easy" class="headerlink" title="342. 4的幂[easy]"></a><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a>[easy]</h1><h2 id="解法一：暴力循环"><a href="#解法一：暴力循环" class="headerlink" title="解法一：暴力循环"></a>解法一：暴力循环</h2><p>不停的去除以 4 ，看最终结果是否为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)<br>            n/=<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">return</span> n==<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：位运算-2"><a href="#解法二：位运算-2" class="headerlink" title="解法二：位运算"></a>解法二：位运算</h2><ul><li><p>首先检查 num 是否为 2 的幂：x &gt; 0 and x &amp; (x - 1) &#x3D;&#x3D; 0。</p></li><li><p>现在的问题是区分 2 的偶数幂（当 x 是 4 的幂时）和 2 的奇数幂（当 x 不是 4 的幂时）。在二进制表示中，这两种情况都只有一位为 1，其余为 0。</p></li><li><p>有什么区别？在第一种情况下（4 的幂），1 处于偶数位置：第 0 位、第 2 位、第 4 位等；在第二种情况下，1 处于奇数位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210415221251.jpeg"></p></li><li><p>因此 4 的幂与数字 (101010…10)(2) 相与会得到 0。用十六进制表示为：(aaaaaaaa)(16)。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; (n&amp;(n<span class="hljs-number">-1</span>))==<span class="hljs-number">0</span> &amp;&amp; (n&amp;<span class="hljs-number">0xaaaaaaaa</span>)==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="476-数字的补数-easy"><a href="#476-数字的补数-easy" class="headerlink" title="476. 数字的补数[easy]"></a><a href="https://leetcode-cn.com/problems/number-complement/">476. 数字的补数</a>[easy]</h1><h2 id="解法：位运算"><a href="#解法：位运算" class="headerlink" title="解法：位运算"></a>解法：位运算</h2><p>5的二进制是：0101，7的二进制是： 0111，它们的抑或为：0010，去掉前导零位即为取反。再来一个例子，假设a为1110 0101，b为1111 1111，a^b &#x3D; 0001 1010是a的取反。</p><p>也就是说二进制位数与num相同，且全为1的数tmp与num的异或即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(tmp&lt;num)<br>        &#123;<br>            tmp&lt;&lt;=<span class="hljs-number">1</span>;<br>            tmp+=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> tmp^num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="371-两整数之和-medium"><a href="#371-两整数之和-medium" class="headerlink" title="371. 两整数之和[medium]"></a><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371. 两整数之和</a>[medium]</h1><h2 id="解法：位运算-1"><a href="#解法：位运算-1" class="headerlink" title="解法：位运算"></a>解法：位运算</h2><p>位运算中的加法等价于异或运算结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>+ <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>+ <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span>+ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span>+ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>（进位 <span class="hljs-number">1</span>）<br></code></pre></td></tr></table></figure><p>异或和与运算操作：在位运算操作中，<strong>异或</strong>的一个重要特性是<strong>无进位加法</strong>。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">a = 5 = 0101<br>b = 4 = 0100<br>a ^ b 如下：<br>0 1 0 1<br><span class="hljs-section">0 1 0 0</span><br><span class="hljs-section">-------</span><br>0 0 0 1<br></code></pre></td></tr></table></figure><p><code>a ^ b</code> 得到了一个<strong>无进位加法</strong>结果，如果要得到 <code>a + b</code> 的最终值，还要找到<strong>进位</strong>的数，把这二者相加。在位运算中，可以使用<strong>与</strong>操作获得进位：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">a = 5 = 0101<br>b = 4 = 0100<br>a &amp; b 如下：<br>0 1 0 1<br><span class="hljs-section">0 1 0 0</span><br><span class="hljs-section">-------</span><br>0 1 0 0<br></code></pre></td></tr></table></figure><p>由计算结果可见，<code>0100</code> 并不是想要的进位，<code>1 + 1</code> 所获得的进位应该要放置在它的更高位，即左侧位上，因此还要把 <code>0100</code> 左移一位，才是所要的进位结果。</p><p>那么问题就容易了，总结一下：</p><ul><li>a + b 的问题拆分为 (a 和 b 的无进位结果) + (a 和 b 的进位结果)</li><li>无进位加法使用<strong>异或运算</strong>计算得出</li><li>进位结果使用<strong>与运算和移位</strong>运算计算得出</li><li>循环此过程，直到进位为 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum,carry;<br>        <span class="hljs-keyword">while</span>(carry!=<span class="hljs-number">0</span>)<br>        &#123;<br>            sum=a^b;<br>            carry=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)a&amp;b)&lt;&lt;<span class="hljs-number">1</span>;<br>            a=sum;<br>            b=carry;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="338-比特位计数-medium"><a href="#338-比特位计数-medium" class="headerlink" title="338. 比特位计数[medium]"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a>[medium]</h1><h2 id="解法一：遍历每一个数字"><a href="#解法一：遍历每一个数字" class="headerlink" title="解法一：遍历每一个数字"></a>解法一：遍历每一个数字</h2><p>遍历<code>[0, num]</code>，计算每个数字的<code>bit 1</code>。计算<code>bit 1</code>的方法参考 <a href="https://leetcode-cn.com/problems/number-of-1-bits/">191. 位1的个数</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(num+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;++i)<br>            res[i]=<span class="hljs-built_in">numbits</span>(i);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numbits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            ++count;<br>            num&amp;=num<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：bitset"><a href="#解法二：bitset" class="headerlink" title="解法二：bitset"></a>解法二：bitset</h2><p>使用<code>bitset</code>计算每个数字的<code>bit 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(num+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;++i)<br>            res[i]=<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;(i).<span class="hljs-built_in">count</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h2><p>对于所有的数字，只有两类：</p><ul><li><p>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>= <span class="hljs-number">0</span>       <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span>= <span class="hljs-number">10</span>      <span class="hljs-number">3</span> = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure></li><li><p>偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>= <span class="hljs-number">10</span>       <span class="hljs-number">4</span> = <span class="hljs-number">100</span>       <span class="hljs-number">8</span> = <span class="hljs-number">1000</span><br><span class="hljs-symbol">3 </span>= <span class="hljs-number">11</span>       <span class="hljs-number">6</span> = <span class="hljs-number">110</span>       <span class="hljs-number">12</span> = <span class="hljs-number">1100</span><br></code></pre></td></tr></table></figure></li></ul><p>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(num+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        res[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                res[i]=res[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                res[i]=res[i/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bit Operation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>牛客题霸—高频TOP200</title>
    <link href="/2021/03/07/%E7%89%9B%E5%AE%A2%E9%A2%98%E9%9C%B8%E2%80%94%E9%AB%98%E9%A2%91TOP200/"/>
    <url>/2021/03/07/%E7%89%9B%E5%AE%A2%E9%A2%98%E9%9C%B8%E2%80%94%E9%AB%98%E9%A2%91TOP200/</url>
    
    <content type="html"><![CDATA[<p>题目来源于 <a href="https://www.nowcoder.com/activity/oj?tab=0">牛客题霸—高频TOP200</a>。</p><span id="more"></span><h1 id="NC-78-反转链表"><a href="#NC-78-反转链表" class="headerlink" title="NC 78 反转链表"></a><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=117&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC 78 反转链表</a></h1><p><a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#15-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8">剑指offer题解—15.反转链表</a>。</p><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        ListNode *pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode *next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(pHead!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next=pHead-&gt;next;<br>            pHead-&gt;next=pre;<br>            pre=pHead;<br>            pHead=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">nullptr</span>||pHead-&gt;next==<span class="hljs-literal">nullptr</span>)<br>           <span class="hljs-keyword">return</span> pHead;<br>        ListNode* head=<span class="hljs-built_in">ReverseList</span>(pHead-&gt;next);<br>        pHead-&gt;next-&gt;next=pHead;<br>        pHead-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC-140-排序"><a href="#NC-140-排序" class="headerlink" title="NC 140 排序"></a><a href="https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896?tpId=117&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC 140 排序</a></h1><p><a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E6%8E%92%E5%BA%8F">牛客左神算法课笔记——算法入门：排序</a>。</p><h2 id="选择排序（超时）"><a href="#选择排序（超时）" class="headerlink" title="选择排序（超时）"></a>选择排序（超时）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> minIndex=i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;arr.<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr[j]&lt;arr[minIndex])<br>                    minIndex=j;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(arr[i],arr[minIndex]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="冒泡排序（超时）"><a href="#冒泡排序（超时）" class="headerlink" title="冒泡排序（超时）"></a>冒泡排序（超时）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>])<br>                    <span class="hljs-built_in">swap</span>(arr[j],arr[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="插入排序（超时）"><a href="#插入排序（超时）" class="headerlink" title="插入排序（超时）"></a>插入排序（超时）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;arr.<span class="hljs-built_in">size</span>();++i) <span class="hljs-comment">//从1开始</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>&amp;&amp;arr[j]&gt;arr[j+<span class="hljs-number">1</span>];--j) <span class="hljs-comment">//直接将比较放入for中</span><br>                <span class="hljs-built_in">swap</span>(arr[j],arr[j+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="归并排序（通过）"><a href="#归并排序（通过）" class="headerlink" title="归并排序（通过）"></a>归并排序（通过）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">mergeSort</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(arr,l,mid);<br>        <span class="hljs-built_in">mergeSort</span>(arr,mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-built_in">merge</span>(arr,l,mid,r);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 合并两个有序数组</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(r-l+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,p=l,q=m+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(p&lt;=m&amp;&amp;q&lt;=r)<br>            tmp[k++]=arr[p]&lt;arr[q]?arr[p++]:arr[q++];<br>        <span class="hljs-keyword">while</span>(p&lt;=m)<br>            tmp[k++]=arr[p++];<br>        <span class="hljs-keyword">while</span>(q&lt;=r)<br>            tmp[k++]=arr[q++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r-l+<span class="hljs-number">1</span>;++i)<br>            arr[l+i]=tmp[i];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="堆排序（通过）"><a href="#堆排序（通过）" class="headerlink" title="堆排序（通过）"></a>堆排序（通过）</h2><p><strong>注意arr[left+1]和arr[left]顺序不能颠倒！！！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>            <span class="hljs-built_in">heapify</span>(arr,i,arr.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-type">int</span> heapSize=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>],arr[--heapSize]);<br>        <span class="hljs-comment">// 循环弹出堆顶元素并heapify</span><br>        <span class="hljs-keyword">while</span>(heapSize&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">heapify</span>(arr,<span class="hljs-number">0</span>,heapSize);<br>            <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>],arr[--heapSize]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> heapSize)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">// 左孩子的下标</span><br>        <span class="hljs-keyword">while</span>(left&lt;heapSize)<span class="hljs-comment">// 下方还有孩子的时候</span><br>        &#123;<br>            <span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span><br>            <span class="hljs-type">int</span> largest=left+<span class="hljs-number">1</span>&lt;heapSize &amp;&amp; arr[left+<span class="hljs-number">1</span>]&gt;arr[left]?left+<span class="hljs-number">1</span>:left;<br>            <span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span><br>            largest=arr[largest]&gt;arr[index]?largest:index;<br>            <span class="hljs-keyword">if</span>(largest==index)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(arr[largest],arr[index]);<br>            index=largest;<br>            left=index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="快速排序（通过）"><a href="#快速排序（通过）" class="headerlink" title="快速排序（通过）"></a>快速排序（通过）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">quickSort</span>(arr,<span class="hljs-number">0</span>,arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l&lt;r)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; range=<span class="hljs-built_in">partition</span>(arr,l,r);<br>            <span class="hljs-built_in">quickSort</span>(arr,l,range[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>);<br>            <span class="hljs-built_in">quickSort</span>(arr,range[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,r);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> less=l<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> more=r;<br>        <span class="hljs-type">int</span> index=l;<br>        <span class="hljs-keyword">while</span>(index&lt;more)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[index]&lt;arr[r])<br>                <span class="hljs-built_in">swap</span>(arr[++less],arr[index++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[index]&gt;arr[r])<br>                <span class="hljs-built_in">swap</span>(arr[--more],arr[index]);<br>            <span class="hljs-keyword">else</span><br>                ++index;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[more],arr[r]);<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;less+<span class="hljs-number">1</span>,more&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC93-设计LRU缓存结构"><a href="#NC93-设计LRU缓存结构" class="headerlink" title="NC93 设计LRU缓存结构"></a><a href="https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=117&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC93 设计LRU缓存结构</a></h1><p>Leetcode Notes——Design-&gt;146. LRU 缓存机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * lru design</span><br><span class="hljs-comment">     * @param operators int整型vector&lt;vector&lt;&gt;&gt; the ops</span><br><span class="hljs-comment">     * @param k int整型 the k</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">LRU</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; operators, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        cap=k;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;op:operators)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">set</span>(op[<span class="hljs-number">1</span>],op[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">get</span>(op[<span class="hljs-number">1</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>       <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(key)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 将数据 (key, val) 提到开头</span><br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; key_value=*map[key];<br>        cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        cache.<span class="hljs-built_in">push_front</span>(key_value);<br>        map[key]=cache.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">return</span> key_value.second;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-built_in">count</span>(key)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 把旧的数据删除</span><br>            cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">size</span>()==cap)<br>        &#123;<br>            <span class="hljs-comment">// 删除 map 中映射到该数据的键</span><br>            map.<span class="hljs-built_in">erase</span>(cache.<span class="hljs-built_in">back</span>().first);<br>            <span class="hljs-comment">// 删除链表的最后一个数据腾位置</span><br>            cache.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-comment">// 将新节点插入到开头</span><br>        cache.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">make_pair</span>(key,value));<br>        map[key]=cache.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; cache;<br>    unordered_map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator&gt; map;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC4-判断链表中是否有环"><a href="#NC4-判断链表中是否有环" class="headerlink" title="NC4 判断链表中是否有环"></a><a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=117&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC4 判断链表中是否有环</a></h1><p><a href="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy">Leetcode Notes——Linked List-&gt;141. 环形链表</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC45-实现二叉树先序，中序和后序遍历"><a href="#NC45-实现二叉树先序，中序和后序遍历" class="headerlink" title="NC45 实现二叉树先序，中序和后序遍历"></a><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=117&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC45 实现二叉树先序，中序和后序遍历</a></h1><p>Leetcode Notes——Tree-&gt;<a href="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium">144.二叉树的前序遍历</a>、<a href="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-medium">94.二叉树的中序遍历</a>、<a href="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/#145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-hard">145.二叉树的后序遍历</a>。</p><h2 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 the root of binary tree</span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">threeOrders</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">preorder</span>(root));<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">inorder</span>(root));<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">postorder</span>(root));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 先序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                cur=cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 中序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 后序</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    last=tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC119-最小的K个数"><a href="#NC119-最小的K个数" class="headerlink" title="NC119 最小的K个数"></a>NC119 最小的K个数</h1><h1 id="NC15-求二叉树的层序遍历"><a href="#NC15-求二叉树的层序遍历" class="headerlink" title="NC15 求二叉树的层序遍历"></a>NC15 求二叉树的层序遍历</h1><p>Leetcode Notes——Tree-&gt;<a href="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-medium">102.二叉树的层序遍历</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct TreeNode *left;</span><br><span class="hljs-comment"> *struct TreeNode *right;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode类 </span><br><span class="hljs-comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>           <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cursize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cursize;++i)<br>            &#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="NC33-合并有序链表"><a href="#NC33-合并有序链表" class="headerlink" title="NC33 合并有序链表"></a><a href="https://www.nowcoder.com/practice/a479a3f0c4554867b35356e0d57cf03d?tpId=117&tqId=37735&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking&tab=answerKey">NC33 合并有序链表</a></h1><h2 id="非递归-1"><a href="#非递归-1" class="headerlink" title="非递归"></a>非递归</h2><p>Leetcode Notes——Linked List-&gt;<a href="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-easy">21. 合并两个有序链表</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *int val;</span><br><span class="hljs-comment"> *struct ListNode *next;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param l1 ListNode类 </span><br><span class="hljs-comment">     * @param l2 ListNode类 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;=l2-&gt;val)<br>        &#123;<br>            l1-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            l2-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Dynamic Programming</title>
    <link href="/2021/02/23/Leetcode%20Notes%E2%80%94%E2%80%94Dynamic%20Programming/"/>
    <url>/2021/02/23/Leetcode%20Notes%E2%80%94%E2%80%94Dynamic%20Programming/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>动态规划</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="动态规划方法论"><a href="#动态规划方法论" class="headerlink" title="动态规划方法论"></a>动态规划方法论</h1><h2 id="动态规划（Dynamic-Programming，DP）"><a href="#动态规划（Dynamic-Programming，DP）" class="headerlink" title="动态规划（Dynamic Programming，DP）"></a>动态规划（Dynamic Programming，DP）</h2><p>如果某一问题有很多重叠子问题，使用动态规划是最有效的。</p><p>所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p><h2 id="动态规划的解题步骤"><a href="#动态规划的解题步骤" class="headerlink" title="动态规划的解题步骤"></a>动态规划的解题步骤</h2><p><strong>对于动态规划问题，拆解为如下五步曲：</strong></p><ul><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ul><h1 id="基本动态规划：一维"><a href="#基本动态规划：一维" class="headerlink" title="基本动态规划：一维"></a>基本动态规划：一维</h1><h2 id="509-斐波那契数-easy"><a href="#509-斐波那契数-easy" class="headerlink" title="509. 斐波那契数[easy]"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a>[easy]</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>参考 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#7-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">剑指offer题解—7.斐波那契数列</a>。</p><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>这里要用一个一维 dp 数组来保存递归的结果。</p><ul><li><p>确定 dp 数组以及下标的含义</p><p>dp[i] 的定义为：第 i 个数的斐波那契数值是 dp[i]</p></li><li><p>确定递推公式</p><p>题目已经把递推公式直接给了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p></li><li><p>dp 数组如何初始化</p><p>题目中把如何初始化也直接给了，即 dp[0] &#x3D; 0，dp[1] &#x3D; 1</p></li><li><p>确定遍历顺序</p><p>从递归公式中可以看出，dp[i] 是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p></li><li><p>举例推导dp数组</p><p>按照递推公式，当 N 为 10 的时候，dp 数组应该是如下的数列：<code>0 1 1 2 3 5 8 13 21 34 55</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h4 id="「状态压缩」"><a href="#「状态压缩」" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，所以并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=dp[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>]=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h2 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70. 爬楼梯[easy]"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a>[easy]</h2><h3 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><p>爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。所以到第三层楼梯的状态可以由到第二层楼梯和到第一层楼梯状态推导出来，因此使用动态规划。</p><p>定义一个一维数组来记录不同楼层的状态。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i]：爬到第 i 层楼梯，有 dp[i] 种方法</p></li><li><p>确定递推公式</p><p>从 dp[i] 的定义可以看出，dp[i] 可以有两个方向推出来。首先是 dp[i - 1]，上 i-1层楼梯，有 dp[i - 1] 种方法，那么再跳一个台阶就是dp[i]。还有就是dp[i - 2]，上 i-2 层楼梯，有 dp[i - 2] 种方法，那么再跳两个台阶就是dp[i]。因此dp[i] 就是 dp[i - 1] 与 dp[i - 2] 之和，即 dp[i] &#x3D; dp[i - 1] + dp[i - 2] </p></li><li><p>dp数组如何初始化</p><p>不考虑 dp[0] 的初始化，只初始化 dp[1] &#x3D; 1，dp[2] &#x3D; 2，然后从 i &#x3D; 3 开始递推</p></li><li><p>确定遍历顺序</p><p>从递推公式中可以看出，遍历顺序一定是从前向后遍历的</p></li><li><p>举例推导dp数组</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)<span class="hljs-comment">// 注意i是从3开始的</span><br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h4 id="「状态压缩」-1"><a href="#「状态压缩」-1" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=dp[<span class="hljs-number">1</span>]+dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">1</span>]=dp[<span class="hljs-number">2</span>];<br>            dp[<span class="hljs-number">2</span>]=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h2 id="746-使用最小花费爬楼梯-easy"><a href="#746-使用最小花费爬楼梯-easy" class="headerlink" title="746. 使用最小花费爬楼梯[easy]"></a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a>[easy]</h2><h3 id="解法：动态规划-1"><a href="#解法：动态规划-1" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">70. 爬楼梯</a> 的花费版本，最后一步可以理解为<strong>不用花费</strong>。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>只需要一个一维数组 dp[i]，dp[i] 的定义：第 i 个台阶所花费的最少体力为 dp[i]。</p></li><li><p>确定递推公式</p><p>可以有两个途径得到 dp[i]，一个是 dp[i-1] 一个是 dp[i-2]。选最小的，所以dp[i] &#x3D; min(dp[i - 1], dp[i - 2]) + cost[i]</p></li><li><p>dp数组如何初始化</p><p>只初始化 dp[0] 和 dp[1] ，其他的最终都是 dp[0]、dp[1] 推出。</p></li><li><p>确定遍历顺序</p><p>因为是模拟台阶，而且dp[i] 由 dp[i-1]、dp[i-2] 推出，所以是从前到后遍历 cost 数组</p></li><li><p>举例推导dp数组</p><p>拿示例 2：cost &#x3D; [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下 dp 数组的状态变化，如下：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210223153058.png" style="zoom:67%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=cost[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>]=cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>])+cost[i];<br>        <span class="hljs-comment">// 最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp[n<span class="hljs-number">-1</span>],dp[n<span class="hljs-number">-2</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h5 id="「状态压缩」-2"><a href="#「状态压缩」-2" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h5><p>因为 dp[i] 就是由前两位推出来的，那么不需要 dp数组，只需要维护前两个状态变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp0=cost[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> dp1=cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;cost.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> dpi=<span class="hljs-built_in">min</span>(dp0,dp1)+cost[i];<br>            dp0=dp1;<br>            dp1=dpi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(dp0,dp1);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>可以定义 dp[i] 为:第一步是不花费体力，最后一步是花费体力的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=cost.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            dp[i]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>]+cost[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+cost[i<span class="hljs-number">-2</span>]);<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="「状态压缩」-3"><a href="#「状态压缩」-3" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCostClimbingStairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp0=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dp1=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=cost.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> dpi=<span class="hljs-built_in">min</span>(dp0+cost[i<span class="hljs-number">-2</span>],dp1+cost[i<span class="hljs-number">-1</span>]);<br>            dp0=dp1;<br>            dp1=dpi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="413-等差数列划分-medium"><a href="#413-等差数列划分-medium" class="headerlink" title="413. 等差数列划分[medium]"></a><a href="https://leetcode-cn.com/problems/arithmetic-slices/">413. 等差数列划分</a>[medium]</h2><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>判断后一对元素的差值是不是跟之前区间中的差值相等。一旦当前区间不满足等差数列了，那就不需要继续判断了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> d=nums[i+<span class="hljs-number">1</span>]-nums[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">2</span>;j&lt;nums.<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[j]-nums[j<span class="hljs-number">-1</span>]==d)<br>                    ++count;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p><h3 id="解法二：动态规划-1"><a href="#解法二：动态规划-1" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p><p>当 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dp<span class="hljs-selector-attr">[2]</span> = <span class="hljs-number">1</span><br>    <span class="hljs-selector-attr">[0, 1, 2]</span><br>dp<span class="hljs-selector-attr">[3]</span> = dp<span class="hljs-selector-attr">[2]</span> + <span class="hljs-number">1</span> = <span class="hljs-number">2</span><br>    <span class="hljs-selector-attr">[0, 1, 2, 3]</span>, <span class="hljs-comment">// [0, 1, 2] 之后加一个 3</span><br>    <span class="hljs-selector-attr">[1, 2, 3]</span>     <span class="hljs-comment">// 新的递增子区间</span><br>dp<span class="hljs-selector-attr">[4]</span> = dp<span class="hljs-selector-attr">[3]</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span><br>    <span class="hljs-selector-attr">[0, 1, 2, 3, 4]</span>, <span class="hljs-comment">// [0, 1, 2, 3] 之后加一个 4</span><br>    <span class="hljs-selector-attr">[1, 2, 3, 4]</span>,    <span class="hljs-comment">// [1, 2, 3] 之后加一个 4</span><br>    <span class="hljs-selector-attr">[2, 3, 4]</span>        <span class="hljs-comment">// 新的递增子区间</span><br></code></pre></td></tr></table></figure><p>综上，在 A[i] - A[i-1] &#x3D;&#x3D; A[i-1] - A[i-2] 时，dp[i] &#x3D; dp[i-1] + 1。</p><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]-nums[i<span class="hljs-number">-1</span>]==nums[i<span class="hljs-number">-1</span>]-nums[i<span class="hljs-number">-2</span>])<br>                dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;cnt:dp)<br>            count+=cnt;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h1 id="基本动态规划：二维"><a href="#基本动态规划：二维" class="headerlink" title="基本动态规划：二维"></a>基本动态规划：二维</h1><h2 id="62-不同路径-medium"><a href="#62-不同路径-medium" class="headerlink" title="62. 不同路径[medium]"></a><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a>[medium]</h2><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>用 DFS 来枚举出来有多少种路径。机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点，此时问题就可以转化为求二叉树叶子节点的个数。</p><p>以下代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m,n);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//第i行第j列到第m行第n列共有多少种路径</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;m||j&gt;n) <span class="hljs-comment">// 越界了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i==m&amp;&amp;j==n) <span class="hljs-comment">// 找到一种方法，相当于找到了叶子节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//从右边走有多少条路径</span><br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,m,n);<br>        <span class="hljs-comment">//从下边走有多少条路径</span><br>        <span class="hljs-type">int</span> down=<span class="hljs-built_in">dfs</span>(i,j+<span class="hljs-number">1</span>,m,n);<br>        <span class="hljs-comment">//返回总的路径</span><br>        <span class="hljs-keyword">return</span> right+down;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种会超出时间限制，因为包含了大量的重复计算。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210224215247.png" style="zoom:50%;" /><p>图中红色，黑色等都表示重复的计算，优化方式是把计算过的值用一个 map 存储起来，用的时候先查看是否计算过，如果计算过就直接拿来用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; cache;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,m,n,cache);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,unordered_map&lt;string,<span class="hljs-type">int</span>&gt; &amp;cache)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;m||j&gt;n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(i==m&amp;&amp;j==n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        string key=<span class="hljs-built_in">to_string</span>(i)+<span class="hljs-string">&quot;*&quot;</span>+<span class="hljs-built_in">to_string</span>(j);<br>        <span class="hljs-keyword">if</span>(cache.<span class="hljs-built_in">count</span>(key)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> cache[key];<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,m,n,cache);<br>        <span class="hljs-type">int</span> down=<span class="hljs-built_in">dfs</span>(i,j+<span class="hljs-number">1</span>,m,n,cache);<br>        <span class="hljs-type">int</span> total=right+down;<br>        cache[key]=total;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：动态规划-2"><a href="#解法二：动态规划-2" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j] ：表示从(0,0)出发，到(i, j) 有 dp[i] [j] 条不同的路径</p></li><li><p>确定递推公式</p><p>想要求dp[i] [j]，只能有两个方向来推导出来，即 dp[i-1] [j] 和 dp[i] [j-1]。那么 dp[i] [j] &#x3D;  dp[i-1] [j] + dp[i] [j-1]，因为dp[i] [j] 只有这两个方向过来</p></li><li><p>dp数组如何初始化</p><p>首先 dp[i] [0] 一定都是 1，因为从(0, 0)的位置到(i, 0)的路径只有一条，dp[0] [j] 同理</p></li><li><p>确定遍历顺序</p><p>dp[i] [j] 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了</p></li><li><p>举例推导dp数组</p></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210224223912" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            dp[<span class="hljs-number">0</span>][j]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)<br>                dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="「状态压缩」-4"><a href="#「状态压缩」-4" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><p>上面二维数组的递推公式，当前坐标的值只和左边与上面的值有关，和其他的无关，这样二维数组造成大量的空间浪费，可以把它改为一维数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>            dp[i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)<br>                dp[j]+=dp[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一维的dp数组定义为当前行中，每个元素对应的步数。 二维dp数组<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>很好理解，转化为一维数组， 对于第i行来说，<code>dp[j] = dp[j] + dp[j-1]</code>, 等号右边的未赋值之前的dp[j]就是上一行的第j个数据对应的步数，即<code>dp[i-1][j]</code> 等号右边的dp[j-1]是已经更新过的本行的第j-1个数据对应的步数，即<code>dp[i][j-1]</code> 则，本行的<code>dp[j] = 上一行的dp[j] + 本行的dp[j-1]</code>， 所以<code>dp[j] = dp[j] + dp[j-1]</code>，即<code>dp[j] += dp[j-1]</code>。</p><h3 id="解法三：排列组合"><a href="#解法三：排列组合" class="headerlink" title="解法三：排列组合"></a>解法三：排列组合</h3><p>要想到达终点，需要往右走 n-1步，往下走 m-1 步，总共需要走 n+m-2 步。无论往右走还是往下走总的步数是不会变的。也就相当于总共要走 n+m-2 步，往下走 m-1 步总共有多少种走法，很明显这就是一个排列组合问题，即</p><p>$$<br>C_{m+n-2}^{m-1}<br>$$<br>排列组合的计算公式如下：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210224230729.png" style="zoom:50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> N=n+m<span class="hljs-number">-2</span>;<br>        <span class="hljs-type">double</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>            res=res*(N-(m<span class="hljs-number">-1</span>)+i)/i;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="63-不同路径-II-medium"><a href="#63-不同路径-II-medium" class="headerlink" title="63. 不同路径 II[medium]"></a><a href="https://leetcode-cn.com/problems/unique-paths-ii/">63. 不同路径 II</a>[medium]</h2><h3 id="解法：动态规划-2"><a href="#解法：动态规划-2" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><p><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a> 的有障碍版。与 62 题的区别只在于，障碍如何处理：</p><ul><li>遇到障碍绕着走，但这种“动态”的想法不符合 DP “状态”的思路</li><li>思考单个点的“状态”：<ul><li>障碍点，是无法抵达的点，是到达方式数为 0 的点</li><li>是无法从它这里走到别的点的点，即无法给其他点“贡献”路径数</li></ul></li></ul><p>因此，标记对应的dp table（dp数组）保持初始值(0)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePathsWithObstacles</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=obstacleGrid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 一旦遇到obstacleGrid[i][0] == 1的情况就停止dp[i][0]的赋值1的操作，dp[0][j]同理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m&amp;&amp;obstacleGrid[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>;++i)<br>            dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n&amp;&amp;obstacleGrid[<span class="hljs-number">0</span>][j]==<span class="hljs-number">0</span>;++j)<br>            dp[<span class="hljs-number">0</span>][j]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(obstacleGrid[i][j]==<span class="hljs-number">0</span>) <span class="hljs-comment">// 当(i, j)没有障碍的时候，再推导dp[i][j]</span><br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+dp[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="64-最小路径和-medium"><a href="#64-最小路径和-medium" class="headerlink" title="64. 最小路径和[medium]"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/">64. 最小路径和</a>[medium]</h2><h3 id="解法：动态规划-3"><a href="#解法：动态规划-3" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j] 表示从左上角开始走到 (i, j) 位置的最小路径和</p></li><li><p>确定递推公式</p><p>走到当前单元格 (i,j) 的最小路径和 &#x3D; **“从左方单元格 (i-1,j) 与从上方单元格 (i,j−1) 走来的两个最小路径和中较小的 ” + 当前单元格值 <code>grid[i][j]</code>**。具体分为以下 4 种情况：</p><ul><li>当左边和上边都不是矩阵边界时： 即当 <code>i!=0,j!=0 </code> 时，<code>dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j] </code>；</li><li>当只有左边是矩阵边界时：只能从上面来，即当<code>i!=0,j=0</code> 时，<code>dp[i][j]=dp[i-1][j]+grid[i][j] </code>；</li><li>当只有上边是矩阵边界时：只能从左面来，即当<code>i=0,j!=0</code>时，<code>dp[i][j]=dp[i][j-1]+grid[i][j] </code>；</li><li>当左边和上边都是矩阵边界时： 即当<code>i=0,j=0</code>时，其实就是起点，<code>dp[i][j]=grid[i][j] </code>；</li></ul></li><li><p>dp数组如何初始化</p><p>dp 初始化即可，不需要修改初始 0 值</p></li><li><p>确定遍历顺序</p><p>dp[i] [j] 都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了</p></li><li><p>举例推导dp数组</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>)<br>                    dp[i][j]=grid[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>                    dp[i][j]=dp[i][j<span class="hljs-number">-1</span>]+grid[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j]+grid[i][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j]=<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])+grid[i][j];<br>            &#125;<br>        &#125;    <br>        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="「状态压缩」-5"><a href="#「状态压缩」-5" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><p>因为 dp 矩阵的每一个值只和左边和上面的值相关，可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i] [j-1]的值，而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1] [j] 的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>&amp;&amp;j==<span class="hljs-number">0</span>)<br>                    dp[j]=grid[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>                    dp[j]=dp[j<span class="hljs-number">-1</span>]+grid[i][j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    dp[j]=dp[j]+grid[i][j];<br>                <span class="hljs-keyword">else</span><br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j<span class="hljs-number">-1</span>],dp[j])+grid[i][j];<br>            &#125;<br>        &#125;    <br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="221-最大正方形-medium"><a href="#221-最大正方形-medium" class="headerlink" title="221. 最大正方形[medium]"></a><a href="https://leetcode-cn.com/problems/maximal-square/">221. 最大正方形</a>[medium]</h2><h3 id="解法：动态规划-4"><a href="#解法：动态规划-4" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><ul><li><p><code>dp</code> 具体定义：<code>dp[i + 1][j + 1]</code> 表示 「以第 <code>i</code> 行、第 <code>j</code> 列为右下角的正方形的最大边长」</p><ul><li>为何不是 <code>dp[i][j]</code><br>任何一个正方形，都「依赖」当前格左、上、左上三个方格的情况，但第一行的上层已经没有格子，第一列左边已经没有格子，需要做特殊 if 判断来处理。为了代码简洁，<strong>假设补充</strong>了多一行全 <code>&#39;0&#39;</code>、多一列全 <code>&#39;0&#39;</code></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210302234700.png" style="zoom:67%;" /></li><li><p>此时 <code>dp</code> 数组的大小也明确为 <code>dp[m + 1][n + 1]</code></p></li><li><p>递推公式：<code>dp(i, j) = min(dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1))</code>，即 min(上, 左, 左上) + 1</p><ul><li><p>若某格子值为 <code>1</code>，则以此为<strong>右下角</strong>的正方形的最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格</p></li><li><p>如何理解？</p></li><li><p>阐述简单共识</p><ul><li>若形成正方形（非单 <code>1</code>），以当前为右下角的视角看，则需要：当前格、上、左、左上都是 <code>1</code></li><li>可以换个角度：当前格、上、左、左上都不能受 <code>0</code> 的限制，才能成为正方形</li></ul><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210302235342.png"></p></li><li><p>上面详解了 三者取最小 的含义：</p><ul><li>图 1：受限于左上的 0</li><li>图 2：受限于上边的 0</li><li>图 3：受限于左边的 0</li><li>数字表示：以此为正方形右下角的最大边长</li><li>黄色表示：格子 <code>?</code> 作为右下角的正方形区域</li></ul></li><li><p>就像 <strong>[木桶的短板理论]</strong> 那样——附近的最小边长，才与 <code>?</code> 的最长边长有关。</p></li></ul></li><li><p>初始值就是将第一列 <code>dp[i][0]</code> 、第一行 <code>dp[0][j]</code> 都赋为 <code>0</code>，相当于已经计算了所有的第一行、第一列的 <code>dp</code> 值</p></li><li><p>题目要求面积。根据 「面积 &#x3D; 边长 x 边长」可知，只需求出 <strong>最大边长</strong> 即可</p><ul><li>定义 <code>maxSide</code> 表示最长边长，每次得出一个 <code>dp</code>，就 <code>maxSide = max(maxSide, dp);</code></li><li>最终返回 <code>return maxSide * maxSide;</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 相当于已经预处理新增第一行、第一列均为0</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> maxSide=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[i][j],dp[i][j+<span class="hljs-number">1</span>]),dp[i+<span class="hljs-number">1</span>][j])+<span class="hljs-number">1</span>;<br>                    maxSide=<span class="hljs-built_in">max</span>(maxSide,dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSide*maxSide;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="「状态压缩」-6"><a href="#「状态压缩」-6" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><p>其实只需关注”当前格子的周边”，故可二维降一维优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 相当于已经预处理新增第一行、第一列均为0</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> maxSide=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftOn=<span class="hljs-number">0</span>;<span class="hljs-comment">// 左上角</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            leftOn=<span class="hljs-number">0</span>;<span class="hljs-comment">// 遍历每行时，还原回辅助的原值0</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-type">int</span> nextLeftOn=dp[j+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    dp[j+<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(dp[j],dp[j+<span class="hljs-number">1</span>]),leftOn)+<span class="hljs-number">1</span>;<br>                    maxSide=<span class="hljs-built_in">max</span>(maxSide,dp[j+<span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                    dp[j+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>                leftOn=nextLeftOn;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxSide*maxSide;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="分割类型题"><a href="#分割类型题" class="headerlink" title="分割类型题"></a>分割类型题</h1><h2 id="343-整数拆分-medium"><a href="#343-整数拆分-medium" class="headerlink" title="343. 整数拆分[medium]"></a><a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a>[medium]</h2><h3 id="解法一：暴力递归"><a href="#解法一：暴力递归" class="headerlink" title="解法一：暴力递归"></a>解法一：暴力递归</h3><p>对于给定的一个整数 <code>n</code>，穷举它的每一种分解情况，然后对所有情况，求最大值。<br><code>n</code> 可以拆成如下情况：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210307151911.png"></p><p>通过上图，得到一个递归表达式：<br>$$<br>F(n)&#x3D;max{i∗F(n−i)}，i&#x3D;1，2，…，n−1<br>$$<br>上述表达式是表明 <code>n - i</code> 需要继续分解的情况，但如果 <code>n - i</code> 比 <code>F(n - i)</code> 要大，显然就不用再继续分解了。故还需要比较 <code>i * (n - i)</code> 与 <code>i * F(n - i)</code> 的大小关系。所以完整的表达式应该为：</p><p>$$<br>F(n)&#x3D;max{i∗F(n−i), i∗(n−i)},i&#x3D;1,2,…,n−1<br>$$<br>以下代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">max</span>(i*(n-i),i*<span class="hljs-built_in">integerBreak</span>(n-i)));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：记忆化搜索"><a href="#解法二：记忆化搜索" class="headerlink" title="解法二：记忆化搜索"></a>解法二：记忆化搜索</h3><p>暴力搜索在递归的过程中计算了很多<strong>重复值</strong>。如果每次求完一个 F(i)，都将其保存起来，下次再求的时候直接读取保存的值就行了，这显然会节省大量时间。只要用一个数组存放每次的 F(i)，记为 <code>memory</code>，这个数组一般称之为<strong>备忘录数组</strong>。</p><p>Cpp代码超时！！！Java代码不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// 记忆化搜索-自顶向下</span><br>    <span class="hljs-type">int</span>[] memory;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    memory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> integerBreakHelper(n);<br>&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">integerBreakHelper</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// memory的初始值为0，如果它不为0，说明已经计算过了，直接返回即可</span><br>        <span class="hljs-keyword">if</span> (memory[n]!=<span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> memory[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; i++) <br>            res = Math.max(res, Math.max(i * integerBreakHelper(n - i), i * (n - i)));<br>    <span class="hljs-comment">// 将每次计算的结果保存到备忘录数组中</span><br>        memory[n] = res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记忆化搜索是将目标 F(n) 不断转化为求 F(n-1),F(n - 2),…,F(2),F(1)，过程中将计算过的值存起来，从递归树中看出来这是一个从上到下的过程，一般将之称为 <strong>自顶向下</strong>。</p><p>时间复杂度 O(n^2)，空间复杂度 O(n)。</p><h3 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h3><p>将<code>自顶向下</code>的思路转换为<code>自底向上</code>。</p><p>dp[i]：分拆数字 i，可以得到的最大乘积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*dp[i-j],j*(i-j)));<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(n)。</p><h3 id="解法四：贪心"><a href="#解法四：贪心" class="headerlink" title="解法四：贪心"></a>解法四：贪心</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210307154748.png" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210307154808.png" style="zoom: 50%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210307154825.png" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">4</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-comment">// 接下来就是 n &gt;= 5 的时候的逻辑了</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">4</span>)<br>        &#123;<br>            res*=<span class="hljs-number">3</span>;<br>            n-=<span class="hljs-number">3</span>;<br>        &#125;<br>        res*=n;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h2 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279. 完全平方数[medium]"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a>[medium]</h2><p>见 <a href="https://simpleforever.github.io/2020/11/05/Leetcode%20Notes%E2%80%94%E2%80%94Search/#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium">Leetcode Notes——Search</a>。</p><h2 id="91-解码方法-medium"><a href="#91-解码方法-medium" class="headerlink" title="91. 解码方法[medium]"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a>[medium]</h2><h3 id="解法一：暴力递归-1"><a href="#解法一：暴力递归-1" class="headerlink" title="解法一：暴力递归"></a>解法一：暴力递归</h3><p>很容易想到递归去解决，将大问题化作小问题。比如 232232323232。对于第一个字母有两种划分方式，即 2|<strong>32232323232</strong> 和 23|<strong>2232323232</strong>。如果分别知道了上边划分的右半部分 32232323232 的解码方式是 ans1 种，2232323232 的解码方式是 ans2 种，那么整体 232232323232 的解码方式就是 ans1 + ans2 种。看一下下边的类比：</p><p>假如从深圳到北京可以经过武汉和上海两条路，而从武汉到北京有 8 条路，从上海到北京有 6 条路。那么从深圳到北京就有 8 + 6 &#x3D; 14 条路。</p><p>以下代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(s,<span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//划分到了最后返回 1</span><br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//开头是 0,0 不对应任何字母，直接返回 0</span><br>        <span class="hljs-keyword">if</span>(s[start]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//得到第一种的划分的解码方式</span><br>        <span class="hljs-type">int</span> ans1=<span class="hljs-built_in">helper</span>(s,start+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断前两个数字是不是小于等于 26 的</span><br>        <span class="hljs-keyword">if</span>(start&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> ten=<span class="hljs-number">10</span>*(s[start]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> one=s[start+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(ten+one&lt;=<span class="hljs-number">26</span>)<br>                <span class="hljs-comment">//得到第二种的划分的解码方式</span><br>                ans2=<span class="hljs-built_in">helper</span>(s,start+<span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans1+ans2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：记忆化搜索-1"><a href="#解法二：记忆化搜索-1" class="headerlink" title="解法二：记忆化搜索"></a>解法二：记忆化搜索</h3><p>解法一的递归中，走完左子树，再走右子树会把一些已经算过的结果重新算，所以可以用 memoization 技术，就是算出一个结果很就保存，第二次算这个的时候直接拿出来就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; memory;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(s,<span class="hljs-number">0</span>,memory);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;memory)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(s[start]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//判断之前是否计算过</span><br>        <span class="hljs-keyword">if</span>(memory.<span class="hljs-built_in">count</span>(start)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> memory[start];<br>        <span class="hljs-type">int</span> ans1=<span class="hljs-built_in">helper</span>(s,start+<span class="hljs-number">1</span>,memory);<br>        <span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(start&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> ten=<span class="hljs-number">10</span>*(s[start]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> one=s[start+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(ten+one&lt;=<span class="hljs-number">26</span>)<br>                ans2=<span class="hljs-built_in">helper</span>(s,start+<span class="hljs-number">2</span>,memory);<br>        &#125;<br>        <span class="hljs-comment">//将结果保存</span><br>        memory[start]=ans1+ans2;<br>        <span class="hljs-keyword">return</span> ans1+ans2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：动态规划-1"><a href="#解法三：动态规划-1" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h3><p>将<code>自顶向下</code>的思路转换为<code>自底向上</code>。用一个 dp 数组， dp[i] 代表字符串从 i 开始到结尾的字符串的解码方式。这样得到和递归完全一样的递推式。</p><p>如果 s [i] 和 s [i+1] 组成的数字小于等于 26，那么 dp[i] &#x3D; dp[i+1]+dp[i+2].</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;   <br>        dp[len]=<span class="hljs-number">1</span>;<span class="hljs-comment">//将递归法的结束条件初始化为 1 </span><br>        <span class="hljs-comment">//最后一个数字不等于 0 就初始化为 1</span><br>        <span class="hljs-keyword">if</span>(s[len<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;0&#x27;</span>)<br>            dp[len<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-comment">//当前数字时 0 ，直接跳过，0 不代表任何字母</span><br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> ans1=dp[i+<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">//判断两个字母组成的数字是否小于等于 26</span><br>            <span class="hljs-type">int</span> ans2=<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> ten=<span class="hljs-number">10</span>*(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-type">int</span> one=s[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(one+ten&lt;=<span class="hljs-number">26</span>)<br>                ans2=dp[i+<span class="hljs-number">2</span>];<br>            dp[i]=ans1+ans2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h1><h2 id="300-最长递增子序列-medium"><a href="#300-最长递增子序列-medium" class="headerlink" title="300. 最长递增子序列[medium]"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a>[medium]</h2><p>详细思路参考 @<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/">liweiwei1419</a> 题解。</p><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><ul><li><p>定义状态：</p><p><code>dp[i]</code> 表示：<strong>以 <code>nums[i]</code></strong> 结尾 的「上升子序列」的长度。注意：这个定义中 <strong><code>nums[i]</code> 必须被选取，且必须是这个子序列的最后一个元素</strong>。</p></li><li><p>状态转移方程：</p><p>如果一个较大的数接在较小的数后面，就会形成一个更长的子序列。只要 <code>nums[i]</code> 严格大于在它位置之前的某个数，那么 <code>nums[i]</code> 就可以接在这个数后面形成一个更长的上升子序列。</p></li></ul><p>$$<br>dp[i] &#x3D; \max_{0 \le j &lt; i, nums[j] &lt; nums[i]} {dp[j] + 1}<br>$$</p><ul><li><p>初始化：</p><p><code>dp[i] = 1</code>，1 个字符显然是长度为 1 的上升子序列。</p></li><li><p>输出：<br>不能返回最后一个状态值，最后一个状态值只表示以 <code>nums[len - 1]</code> 结尾的「上升子序列」的长度，状态数组 <code>dp</code> 的最大值才是题目要求的结果。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// base case：dp 数组全都初始化为 1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[j]&lt;nums[i])<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);      <br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:dp)<br>            res=<span class="hljs-built_in">max</span>(res,elem);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(n)。</p><h3 id="解法二：贪心-二分查找"><a href="#解法二：贪心-二分查找" class="headerlink" title="解法二：贪心+二分查找"></a>解法二：贪心+二分查找</h3><p>状态设计思想：依然着眼于某个上升子序列的 结尾的元素，如果已<strong>经得到的上升子序列的结尾的数越小，那么遍历的时候后面接上一个数，会有更大的可能构成一个长度更长的上升子序列</strong>。既然结尾越小越好，可以记录<strong>在长度固定的情况下，结尾最小的那个元素的数值</strong>，这样定义以后容易得到「状态转移方程」。</p><ol><li><p><strong>定义新状态</strong></p><p><code>tail[i]</code> 表示：长度为 <code>i + 1</code> 的 <strong>所有</strong> 上升子序列的结尾的最小值。</p><p>说明：</p><ul><li><strong>数组 <code>tail</code> 不是问题中的「最长上升子序列」</strong></li><li><code>tail[0]</code> 表示长度为 1 的所有上升子序列中，结尾最小的元素的数值。以题目中的示例为例 <code>[10, 9, 2, 5, 3, 7, 101, 18]</code> 中，容易发现长度为 <code>2</code>的<strong>所有</strong>上升子序列中，结尾最小的是子序列 <code>[2, 3]</code> ，因此 <code>tail[1] = 3</code></li><li>下标和长度有数值为 <code>1</code> 的偏差</li></ul></li><li><p><strong>状态转移方程</strong></p><p>数组 <code>tail</code> 也是一个严格上升数组。因为只需要维护状态数组 <code>tail</code> 的定义，它的长度就是最长上升子序列的长度。下面说明在遍历中，如何维护状态数组 <code>tail</code> 的定义。</p><ol><li><p>在遍历数组 <code>nums</code> 的过程中，看到一个新数 <code>num</code>，如果这个数 <strong>严格</strong> 大于有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code>的后面，否则进入第 2 点。</p><p>注意：这里的大于是「严格大于」，不包括等于的情况。</p></li><li><p>在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小；</p><ul><li>如果有序数组 <code>tail</code> 中存在 <strong>等于</strong> <code>num</code> 的元素，什么都不做，因为以 <code>num</code> 结尾的最短的「上升子序列」已经存在；</li><li>如果有序数组 <code>tail</code> 中存在 <strong>大于</strong> <code>num</code> 的元素，找到第 1 个，让它变小，这样就找到了一个 <strong>结尾更小</strong>的<strong>相同长度</strong>的上升子序列。</li></ul></li></ol><p><strong>说明</strong>：</p><ul><li>再看一下数组 <code>tail[i]</code> 的定义：长度为 <code>i + 1</code> 的 <strong>所有</strong> 最长上升子序列的结尾的最小值。因此，在遍历的过程中，试图让一个大的值变小是合理的；</li><li>这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 <code>nums[i]</code>的数变小，变成 <code>nums[i]</code>，这一步操作是「无后效性」的；</li><li>由于是在有序数组中的操作，因此可以使用「二分查找算法」。</li></ul></li><li><p><strong>初始化</strong></p><p>遍历第 1 个数 <code>nums[0]</code>，直接放在有序数组 <code>tail</code> 的开头 <code>tail[0] = nums[0]</code>。</p></li><li><p>有序数组 <code>tail</code> 的长度，就是所求的「最长上升子序列」的长度。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tail</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 遍历第 1 个数，直接放在有序数组 tail 的开头</span><br>        tail[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// end 表示有序数组 tail 的最后一个已经赋值元素的索引</span><br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-comment">// 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大</span><br>            <span class="hljs-keyword">if</span>(nums[i]&gt;tail[end])<br>            &#123;<br>                <span class="hljs-comment">// 直接添加在那个元素的后面，所以 end 先加 1</span><br>                ++end;<br>                tail[end]=nums[i];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 使用二分查找法，在有序数组 tail 中找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小</span><br>                <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> right=end;<br>                <span class="hljs-keyword">while</span>(left&lt;right)<br>                &#123;<br>                    <span class="hljs-comment">// 选左中位数不是偶然，而是有原因的，原因请见二分查找专题</span><br>                    <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(tail[mid]&lt;nums[i])<br>                        <span class="hljs-comment">// 中位数肯定不是要找的数，把它写在分支的前面</span><br>                        left=mid+<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span><br>                        right=mid;<br>                &#125;<br>                <span class="hljs-comment">// 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素</span><br>                <span class="hljs-comment">// 因此，无需再单独判断</span><br>                tail[left]=nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 此时 end 是有序数组 tail 最后一个元素的索引</span><br>        <span class="hljs-comment">// 题目要求返回的是长度，因此 +1 后返回</span><br>        ++end;<br>        <span class="hljs-keyword">return</span> end;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(n)。</p><h2 id="646-最长数对链-medium"><a href="#646-最长数对链-medium" class="headerlink" title="646. 最长数对链[medium]"></a><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a>[medium]</h2><h3 id="解法一：动态规划-1"><a href="#解法一：动态规划-1" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>排序后，转化为最长上升子序列问题。与 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a> 思路相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)&#123;<br>            <span class="hljs-built_in">return</span> (a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>]&amp;&amp;a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>])||(a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>]);<br>        &#125;);<br>        <span class="hljs-type">int</span> n=pairs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(pairs[j][<span class="hljs-number">1</span>]&lt;pairs[i][<span class="hljs-number">0</span>])<br>                    dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[j]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:dp)<br>            res=<span class="hljs-built_in">max</span>(res,elem);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：贪心"><a href="#解法二：贪心" class="headerlink" title="解法二：贪心"></a>解法二：贪心</h3><p>将 pair 看成区间，问题转化为：删除某些区间，使得剩余的不相交区间最多。与 <a href="https://simpleforever.github.io/2020/10/29/Leetcode%20Notes%E2%80%94%E2%80%94Greedy/#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-medium">435. 无重叠区间</a> 思路相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-comment">// 排序：按照结束时间</span><br>        <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>(),[](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)&#123;<br>            <span class="hljs-built_in">return</span> ((a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>]||a[<span class="hljs-number">1</span>]==b[<span class="hljs-number">1</span>]&amp;&amp;a[<span class="hljs-number">0</span>]&lt;b[<span class="hljs-number">0</span>]));<br>        &#125;);<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> end=pairs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;pairs.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pairs[i][<span class="hljs-number">0</span>]&gt;end) <span class="hljs-comment">// 不相交</span><br>            &#123;<br>                ++res;<br>                end=pairs[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="376-摆动序列-medium"><a href="#376-摆动序列-medium" class="headerlink" title="376. 摆动序列[medium]"></a><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a>[medium]</h2><h3 id="解法一：动态规划-2"><a href="#解法一：动态规划-2" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设 <code>up[i]</code> 表示 <code>nums[0:i]</code> 中最后两个数字递增的最长摆动序列长度，<code>down[i]</code> 表示 <code>nums[0:i]</code>中最后两个数字递减的最长摆动序列长度，只有一个数字时默认为 <code>1</code>。</p><p>接下来进行分类讨论：</p><ul><li><code>nums[i+1] &gt; nums[i]</code><ul><li>假设 <code>down[i]</code> 表示的最长摆动序列的最远末尾元素下标正好为 <code>i</code>，遇到新的上升元素后，<code>up[i+1] = down[i] + 1</code> ，这是因为 <code>up</code> 一定从 <code>down</code> 中产生（初始除外），并且 <code>down[i]</code>此时最大。</li><li>假设 <code>down[i]</code> 表示的最长摆动序列的最远末尾元素下标小于 <code>i</code>，设为 <code>j</code>，那么 <code>nums[j:i]</code> 一定是递增的，因为若完全递减，最远元素下标等于 <code>i</code>，若波动，那么 <code>down[i] &gt; down[j]</code>。由于 <code>nums[j:i]</code> 递增，<code>down[j:i]</code> 一直等于 <code>down[j]</code> ，依然满足 <code>up[i+1] = down[i] + 1</code>。</li></ul></li><li><code>nums[i+1] &lt; nums[i]</code>，类似第一种情况</li><li><code>nums[i+1] = nums[i]</code>，新的元素不能用于任何序列，保持不变</li></ul><p><code>nums=[1,7,4,9,2,5]</code> 时，演示如下：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210309172115.png" style="zoom: 67%;" /><p>注意到 <code>down</code> 和 <code>up</code> 只和前一个状态有关，所以我们可以优化存储，分别用一个变量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> up=<span class="hljs-number">1</span>,down=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i<span class="hljs-number">-1</span>])<br>                up=down+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i<span class="hljs-number">-1</span>])<br>                down=up+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(up,down);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：贪心-1"><a href="#解法二：贪心-1" class="headerlink" title="解法二：贪心"></a>解法二：贪心</h3><p>只需要统计数组的峰值数量，详细思路参考 @<a href="https://leetcode-cn.com/problems/wiggle-subsequence/solution/376-bai-dong-xu-lie-tan-xin-jing-dian-ti-vyxt/">代码随想录</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> preDiff=<span class="hljs-number">0</span>;<span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> curDiff=<span class="hljs-number">0</span>;<span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            curDiff=nums[i]-nums[i<span class="hljs-number">-1</span>];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span>((curDiff&gt;<span class="hljs-number">0</span>&amp;&amp;preDiff&lt;=<span class="hljs-number">0</span>)||(curDiff&lt;<span class="hljs-number">0</span>&amp;&amp;preDiff&gt;=<span class="hljs-number">0</span>))<br>            &#123;<br>                ++res;<br>                preDiff=curDiff;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1143-最长公共子序列-medium"><a href="#1143-最长公共子序列-medium" class="headerlink" title="1143. 最长公共子序列[medium]"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a>[medium]</h2><h3 id="解法：动态规划-5"><a href="#解法：动态规划-5" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]</p></li><li><p>确定递推公式</p><p>主要就是两大情况：</p><ul><li>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1</li><li>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的，即：dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1])</li></ul></li><li><p>dp数组如何初始化</p><p>test1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i] [0] &#x3D; 0，同理dp[0] [j]也是0。其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为0</p></li><li><p>确定遍历顺序</p><p>从递推公式，可以看出，有三个方向可以推出dp[i] [j]，那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵</p></li><li><p>举例推导dp数组</p><p>以输入：text1 &#x3D; “abcde”, text2 &#x3D; “ace” 为例，dp状态如图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210309195523.jpeg" style="zoom: 33%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=text1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len1;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=len2;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>]==text2[j<span class="hljs-number">-1</span>])<br>                    dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="32-最长有效括号-hard"><a href="#32-最长有效括号-hard" class="headerlink" title="32. 最长有效括号[hard]"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a>[hard]</h2><h3 id="解法一：动态规划-3"><a href="#解法一：动态规划-3" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>结合题目，有最长这个字眼，可以考虑尝试使用动态规划进行分析。这是一个 最值型 动态规划的题目。</p><p>动态规划题目分析的 4 个步骤：</p><ul><li><p>确定状态</p><ul><li>研究最优策略的最后一步</li><li>化为子问题</li></ul></li><li><p>转移方程</p><p>根据子问题定义得到</p></li><li><p>初始条件和边界情况</p></li><li><p>计算顺序</p></li></ul><p>首先，定义一个 dp 数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度。</p><p><strong>确定状态</strong>：</p><p>对于最优的策略，一定有最后一个元素 s[i]。</p><p>所以，先看第 i 个位置，这个位置的元素 s[i] 可能有如下两种情况：</p><ul><li><p>s[i]&#x3D;&#x3D;′(′ :</p><p>这时，s[i] 无法和其之前的元素组成有效的括号对，所以，dp[i] &#x3D; 0</p></li><li><p>s[i]&#x3D;&#x3D;′)′ :</p><p>这时，需要看其前面对元素来判断是否有有效括号</p><ul><li><p>情况1：s[i - 1] &#x3D;&#x3D; ‘(‘</p><p>即 s[i] 和 s[i−1] 组成一对有效括号，有效括号长度新增长度2，i 位置对最长有效括号长度为 <strong>其之前2个位置的最长括号长度加上当前位置新增的2</strong>，我们无需知道 i−2 位置对字符是否可以组成有效括号对。</p><p>那么有：dp[i]&#x3D;dp[i−2]+2</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210424103027.png" style="zoom:67%;" /></li><li><p>情况2：s[i - 1] &#x3D;&#x3D; ‘)’</p><p>这种情况下，如果前面有和 s[i] 组成有效括号对的字符，即形如 ( (….) )，这样的话，就要求 s[i - 1] 位置必然是有效的括号对，否则 s[i] 无法和前面对字符组成有效括号对。</p><p>这时，我们只需要找到和 s[i] 配对的位置，并判断其是否是 ( 即可。和其配对的位置为：i−dp[i−1]−1。</p><p>如果：s[i−dp[i−1]−1]&#x3D;&#x3D; ′( ′ ：</p><p>有效括号长度新增长度2，i 位置对最长有效括号长度为 <strong>i-1位置的最长括号长度加上当前位置新增的2</strong>，那么有：</p><p>dp[i]&#x3D;dp[i−1]+2</p><p>值得注意的是，i−dp[i−1]−1 和 i 组成了有效括号对，这将是一段独立的有效括号序列，如果之前的子序列是形如 (…) 这种序列，那么当前位置的最长有效括号长度还需要加上这一段。所以：</p><p>dp[i]&#x3D;dp[i−1]+dp[i−dp[i−1]−2]+2</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210424103731.png" style="zoom:67%;" /></li></ul></li></ul><p><strong>子问题</strong>：</p><p>根据上面的分析，得到了如下两个计算公式：</p><p>dp[i]&#x3D;dp[i−2]+2</p><p>dp[i]&#x3D;dp[i−1]+dp[i−dp[i−1]−2]+2</p><p>那么，求 dp[i] 就变成了求 dp[i−1]、 dp[i−2]、dp[i−dp[i−1]−2] 的子问题。</p><p>这样状态也明确了：</p><p><strong>设 dp 数组，其中第 i 个元素表示以下标为 i 的字符结尾的最长有效子字符串的长度</strong>。</p><p><strong>转移方程：</strong></p><p>子问题明确后，转移方程直接由子问题得到：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">if s[i] == <span class="hljs-string">&#x27;(&#x27;</span> :<br>    dp[i] = <span class="hljs-number">0</span><br>if s[i] == <span class="hljs-string">&#x27;)&#x27;</span> :<br>    if s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> :<br>        dp[i] = dp[i - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span> #要保证i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span><br><br>    if s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span> and s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> :<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] + <span class="hljs-number">2</span> #要保证i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>初始条件和边界情况：</strong></p><p>初始条件： dp[i]&#x3D;0</p><p>边界情况：需要保证计算过程中：i−2&gt;&#x3D;0 和 i−dp[i−1]−2&gt;&#x3D;0</p><p><strong>计算顺序：</strong></p><p>无论第一个字符是什么，都有：dp[0]&#x3D;0</p><p>然后依次计算：dp[1],dp[2],…,dp[n−1]</p><p>结果是： max(dp[i])</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> maxLen=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                dp[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(i<span class="hljs-number">-2</span>&gt;=<span class="hljs-number">0</span>)<br>                        dp[i]=dp[i<span class="hljs-number">-2</span>]+<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span><br>                        dp[i]=<span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>)<br>                    &#123;<br>                        <span class="hljs-type">int</span> index=i-dp[i<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;<br>                        <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span> &amp;&amp; s[index]==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                        &#123;<br>                            dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>;<br>                            <span class="hljs-keyword">if</span>(index<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                                dp[i]+=dp[index<span class="hljs-number">-1</span>];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            maxLen=<span class="hljs-built_in">max</span>(maxLen,dp[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：栈"><a href="#解法二：栈" class="headerlink" title="解法二：栈"></a>解法二：栈</h3><p><strong>起初的想法：</strong></p><ul><li><p>从左往右扫描，已扫描的左括号等待被匹配，用一个栈暂存起来。</p></li><li><p>题目是求长度，存左括号的索引即可，没必要存符号本身。</p></li><li><p>当扫描到右括号，它匹配「最近一个」左括号，栈顶被匹配而出栈，有效长度 &#x3D; 当前索引-出栈的索引+1，并挑战一下全局的最大</p></li><li><p>如图，当遍历到索引为 6 的右括号时，此时栈中的左括号匹配光了，但左边有一整段长度为 6 的有效子串，没有被计算，让索引 6 减 0？不对。或许让 5 减 -1？</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210424105639.png"></p></li></ul><p><strong>修改思路：</strong></p><ul><li><p>在栈中预置 -1 作为一个“参照物”，并改变计算方式：当前索引 - 出栈后新的栈顶索引。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210424105720.png"></p></li><li><p>当遍历到索引 5 的右括号，此时栈顶为 2，出栈，栈顶变为 -1，有效长度为 5 - (-1) &#x3D; 6。如果像之前那样，5 找不到 -1 减。</p></li><li><p>当遍历到索引 6 的右括号，它不是需要入栈的左括号，又匹配不到左括号，好似废物，怎么利用它呢？</p></li><li><p>它后面可能也出现这么一段有效长度，它要成为 -1 那样的“参照物”。它之前出现的有效长度都求过了，-1 的使命已经完成了，要被替代。</p></li><li><p>所以照常让 -1 出栈。不同的是，此时栈空了，让索引 6 入栈当 “参照物”。</p></li></ul><p><strong>总结：两种索引会入栈</strong></p><ol><li>等待被匹配的左括号索引。</li><li>充当「参照物」的右括号索引。因为：当左括号匹配光时，栈需要留一个垫底的参照物，用于计算一段连续的有效长度。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen=<span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">// 左括号的索引，入栈</span><br>                st.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">else</span><span class="hljs-comment">// 遍历到右括号</span><br>            &#123;<br>                <span class="hljs-comment">// 栈顶的左括号被匹配，出栈</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<span class="hljs-comment">// 栈空了</span><br>                    <span class="hljs-comment">// 入栈充当参照</span><br>                    st.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">else</span><span class="hljs-comment">// 栈未空</span><br>                    <span class="hljs-comment">// 挑战最大值</span><br>                    maxLen=<span class="hljs-built_in">max</span>(maxLen,i-st.<span class="hljs-built_in">top</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><blockquote><p>b站大雪菜—<a href="https://www.bilibili.com/video/BV1qt411Z7nE">背包九讲专题</a></p></blockquote><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><blockquote><p><a href="https://www.acwing.com/solution/content/1374/">AcWing 2. 01背包问题（状态转移方程讲解）</a></p></blockquote><h3 id="416-分割等和子集-medium"><a href="#416-分割等和子集-medium" class="headerlink" title="416. 分割等和子集[medium]"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a>[medium]</h3><blockquote><p>另一个题解：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/0-1-bei-bao-wen-ti-xiang-jie-zhen-dui-ben-ti-de-yo/">动态规划（转换为 0-1 背包问题）</a></p></blockquote><p>首先，本题要求集合里能否出现总和为 sum &#x2F; 2 的子集，那么来一一对应一下本题，看看背包问题如何来解决。</p><p>只有确定了如下四点，才能把 01背包问题套到本题上来。</p><ul><li>背包的体积为 sum &#x2F; 2</li><li>背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值</li><li>背包如何正好装满，说明找到了总和为 sum &#x2F; 2 的子集</li><li>背包中每一个元素不可重复放入</li></ul><p>动规五部曲分析如下：</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>01背包中，dp[i] 表示：容量为 i 的背包，所背的物品价值可以最大为 dp[i]。</p><p>套到本题，dp[i] 表示：背包总容量是 i，最大可以凑成 i 的子集总和为 dp[i]。</p></li><li><p>确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i])；</p><p>本题，相当于背包里放入数值，那么物品 i 的重量是nums[i]，其价值也是 nums[i]。</p><p>所以递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p></li><li><p>dp数组如何初始化</p><p>从dp[i]的定义来看，首先dp[0]一定是0。如果题目给的价值都是正整数那么非 0 下标都初始化为 0 就可以了，如果题目给的价值有负数，那么非 0 下标就要初始化为负无穷。<strong>这样才能让dp数组在递归公式的过程中取得最大的价值，而不是被初始值覆盖了</strong>。本题题目中只包含正整数的非空数组，所以非 0 下标的元素初始化为 0 就可以了。</p></li><li><p>确定遍历顺序</p><p>如果使用一维 dp 数组，物品遍历的 for 循环放在外层，遍历背包的 for 循环放在内层，且内层 for 循环倒叙遍历！</p></li><li><p>举例推导dp数组</p><p>dp[i] 的数值一定是小于等于 i 的。<strong>如果 dp[i]&#x3D;i 说明，集合中的子集总和正好可以凑成总和 i</strong>。</p><p>输入[1,5,11,5] 为例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210405103421.png"></p><p>最后 dp[11]&#x3D;11，说明可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            sum+=num;<br>        <span class="hljs-keyword">if</span>(sum%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> target=sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// dp[i]中的i表示背包内总和</span><br>        <span class="hljs-comment">// 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200</span><br>        <span class="hljs-comment">// 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">10001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 开始 01背包 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target;j&gt;=nums[i];--j)<br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);<br>        <span class="hljs-comment">// 集合中的元素正好可以凑成总和target </span><br>        <span class="hljs-keyword">if</span>(dp[target]==target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1049-最后一块石头的重量-II-medium"><a href="#1049-最后一块石头的重量-II-medium" class="headerlink" title="1049. 最后一块石头的重量 II[medium]"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a>[medium]</h3><p>本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。思路与 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a> 基本一致。物品的重量为 stones[i]，物品的价值也为stones[i]。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p><strong>dp[j] 表示容量（这里说容量更形象，其实就是重量）为 j 的背包，最多可以背 dp[j] 这么重的石头</strong>。</p></li><li><p>确定递推公式</p><p>01背包的递推公式为：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p><p>本题则是：dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i])；</p></li><li><p>dp数组如何初始化</p><p>既然 dp[j] 中的 j 表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。</p><p>因为提示中给出1&lt;&#x3D;stones.length&lt;&#x3D; 30，1&lt;&#x3D;stones[i]&lt;&#x3D;1000，所以最大重量就是30 * 1000 。而要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。当然也可以把石头遍历一遍，计算出石头总重量 然后除 2，得到dp数组的大小。</p><p>因为重量都不会是负数，所以 dp[j] 都初始化为 0 就可以了，这样在递推公式中 dp[j] 才不会初始值所覆盖。</p></li><li><p>确定遍历顺序</p><p>如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历！</p></li><li><p>举例推导dp数组</p><p>举例，输入：[2,4,1,1]，此时target &#x3D; (2 + 4 + 1 + 1)&#x2F;2 &#x3D; 4 ，dp数组状态图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210405111607.webp"></p><p>最后dp[target]里是容量为target的背包所能背的最大重量。那么分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是 sum - dp[target]。</p><p><strong>在计算target的时候，target &#x3D; sum &#x2F; 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的</strong>。那么相撞之后剩下的最小石头重量就是 (sum - dp[target]) - dp[target]。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; stones)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:stones)<br>            sum+=num;<br>        <span class="hljs-type">int</span> target=sum/<span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">15001</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;stones.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=target;j&gt;=stones[i];--j)<br>                dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);<br>        <span class="hljs-keyword">return</span> sum-dp[target]-dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="494-目标和-medium"><a href="#494-目标和-medium" class="headerlink" title="494. 目标和[medium]"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a>[medium]</h3><h4 id="解法一：暴力搜索"><a href="#解法一：暴力搜索" class="headerlink" title="解法一：暴力搜索"></a>解法一：暴力搜索</h4><p>暴力解法就是 dfs 了，这道题而言，暴力解法是完全可以的，而且不会超时，因为题目中说了数组长度不会超过20，20个数字的序列，组合方式撑死了 2^20 种，算下来才1024 × 1024。也就是说，可以把数组中每个数字前面都用负号和正号，然后进行组合的求和，并判断这个和是否会等于 S，然后就标记，最后统计出等于 S 的组合个数就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,S);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> S)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum==S)<br>                ++count;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(nums,index+<span class="hljs-number">1</span>,sum+nums[index],S);<br>            <span class="hljs-built_in">dfs</span>(nums,index+<span class="hljs-number">1</span>,sum-nums[index],S);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(2^N)，空间复杂度 O(N)。</p><h4 id="解法二：动态规划-3"><a href="#解法二：动态规划-3" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h4><p>本题要如何使表达式结果为 S，既然为 S，那么就一定有 left组合 - right组合 &#x3D; S。left + right 等于 sum，而 sum 是固定的。公式来了， left - (sum - left) &#x3D; S-&gt;  left &#x3D; (S+ sum)&#x2F;2 。S 是固定的，sum 是固定的，left 就可以求出来。此时问题就是在集合 nums 中找出和为 left 的组合。<strong>转化为，装满容量为 left 背包，有几种方法</strong>。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[j] 表示：填满 j（包括 j）这么大容积的包，有 dp[j] 种方法</p></li><li><p>确定递推公式</p><p>不考虑 nums[i] 的情况下，填满容量为 j - nums[i] 的背包，有 dp[j - nums[i]] 种方法。那么只要搞到 nums[i] 的话，凑成 dp[j] 就有 dp[j - nums[i]] 种方法。</p><p>举一个例子，nums[i] &#x3D; 2：dp[3]，填满背包容量为3的话，有 dp[3] 种方法。那么只需要搞到一个2（nums[i]），就有 dp[3] 种方法可以凑齐容量为 5 的背包。那么需要把这些方法累加起来就可以了，dp[i] +&#x3D; dp[j - nums[j]]。</p></li><li><p>dp数组如何初始化</p><p>在初始化的时候 dp[0]  一定要初始化为 1，因为 dp[0] 是在公式中一切递推结果的起源，如果 dp[0] 是 0 的话，递归结果将都是0。dp[0]&#x3D;1，理论上也很好解释，装满容量为 0 的背包，有 1 种方法，就是装 0 件物品。dp[j]其他下标对应的数值应该初始化为 0，从递归公式也可以看出，dp[j] 要保证是 0 的初始值，才能正确的由 dp[j - nums[i]] 推导出来。</p></li><li><p>确定遍历顺序</p><p>对于01背包问题一维 dp 的遍历，nums 放在外循环，target 在内循环，且内循环倒序。</p></li><li><p>举例推导dp数组</p><p>输入：nums: [1, 1, 1, 1, 1], S: 3。left&#x3D; (S + sum) &#x2F; 2 &#x3D;  (3 + 5) &#x2F; 2 &#x3D; 4。dp数组状态变化如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210405142732.webp"></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            sum+=num;<br>        <span class="hljs-keyword">if</span>(S&gt;sum||S&lt;-sum||(sum+S)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 此时没有方案</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=(sum+S)/<span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(left+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left;j&gt;=nums[i];--j)<br>                dp[j]+=dp[j-nums[i]];<br>        <span class="hljs-keyword">return</span> dp[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N*sum)，空间复杂度 O(sum)。</p><h3 id="474-一和零-medium"><a href="#474-一和零-medium" class="headerlink" title="474. 一和零[medium]"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a>[medium]</h3><p>思路：把总共的 0 和 1 的个数视为背包的容量，每一个字符串视为装进背包的物品。这道题就可以使用 01背包问题的思路完成，这里的目标值是能放进背包的字符串的数量。动态规划的思路是：物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：选与不选。</p><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p><code>dp[i][j]</code> 表示最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小。</p></li><li><p>确定递推公式</p><p><code>dp[i][j]</code> 可以由前一个 strs 里的字符串推导出来，strs里的字符串有 zeroNum 个 0，oneNum 个 1。<code>dp[i][j]</code> 就可以是 <code>dp[i-zeroNum][j-oneNum]+1</code> 。然后在遍历的过程中，取 <code>dp[i][j]</code> 的最大值。所以递推公式：<code>dp[i][j] = max(dp[i][j],dp[i-zeroNum][j-oneNum]+1)</code>。对比一下01背包的递推公式，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。这就是一个典型的01背包，只不过物品的重量有了两个维度而已。</p></li><li><p>dp数组如何初始化</p><p>01背包的 dp 数组初始化为 0 就可以。因为物品价值不会是负数，初始为 0，保证递推的时候 <code>dp[i][j]</code> 不会被初始值覆盖。</p></li><li><p>确定遍历顺序</p><p>与 01 背包遍历次序相同，物品就是 strs 里的字符串，背包容量就是题目描述中的 m 和 n。</p></li><li><p>举例推导dp数组</p><p>以输入：[“10”,”0001”,”111001”,”1”,”0”]，m &#x3D; 3，n &#x3D; 3为例，最后dp数组的状态如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210405151526.webp"></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(string str:strs)<br>        &#123;<br>            <span class="hljs-type">int</span> zeroNum=<span class="hljs-number">0</span>,oneNum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c:str)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;0&#x27;</span>)<br>                    ++zeroNum;<br>                <span class="hljs-keyword">else</span><br>                    ++oneNum;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m;i&gt;=zeroNum;--i)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n;j&gt;=oneNum;--j)<br>                    dp[i][j]=<span class="hljs-built_in">max</span>(dp[i][j],dp[i-zeroNum][j-oneNum]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="322-零钱兑换-medium"><a href="#322-零钱兑换-medium" class="headerlink" title="322. 零钱兑换[medium]"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a>[medium]</h3><h4 id="解法一：动态规划-4"><a href="#解法一：动态规划-4" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h4><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p><strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p></li><li><p>确定递推公式</p><p>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。</p><p>凑足总额为 j - coins[i] 的最少个数为 dp[j - coins[i]]，那么只需要加上一个钱币 coins[i] 即 dp[j - coins[i]] + 1 就是dp[j]（考虑coins[i]）</p><p>所以 dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。</p><p>递推公式：dp[j] &#x3D;  min(dp[j - coins[i]] + 1, dp[j])</p></li><li><p>dp数组如何初始化</p><p>首先凑足总金额为 0 所需钱币的个数一定是 0，那么dp[0] &#x3D; 0;</p><p>其他下标对应的数值呢？</p><p>考虑到递推公式的特性，dp[j] 必须初始化为一个最大的数，否则就会在 min(dp[j - coins[i]] + 1, dp[j]) 比较的过程中被初始值覆盖。</p><p>所以下标非 0 的元素都是应该是最大值。</p></li><li><p>确定遍历顺序</p><p>本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。</p><p>所以本题的两个for循环的关系是：外层for循环遍历物品，内层for遍历背包或者外层for遍历背包，内层for循环遍历物品都是可以的！</p></li><li><p>举例推导dp数组</p><p>以输入：coins &#x3D; [1, 2, 5], amount &#x3D; 5为例</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210424115856.webp" style="zoom: 67%;" /><p>dp[amount]为最终结果。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount+<span class="hljs-number">1</span>,INT_MAX)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coins[i];j&lt;=amount;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dp[j-coins[i]]!=INT_MAX)<br>                    dp[j]=<span class="hljs-built_in">min</span>(dp[j],dp[j-coins[i]]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[amount]==INT_MAX)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/">liweiwei1419</a> 题解。</p></blockquote><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h2 id="198-打家劫舍-medium"><a href="#198-打家劫舍-medium" class="headerlink" title="198. 打家劫舍[medium]"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍</a>[medium]</h2><h3 id="解法：动态规划-6"><a href="#解法：动态规划-6" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h3><ul><li><p>确定dp数组（dp table）以及下标的含义</p><p>dp[i]：考虑下标 i（包括i）以内的房屋，最多可以偷窃的金额为 dp[i]</p></li><li><p>确定递推公式</p><p>决定 dp[i] 的因素就是第 i 房间偷还是不偷。</p><ul><li>如果偷第 i 房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第 i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为 dp[i-2] 加上第 i 房间偷到的钱。</li><li>如果不偷第 i 房间，那么dp[i] &#x3D; dp[i - 1]，即考虑 i-1 房</li><li>然后 dp[i] 取最大值，即 dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1])</li></ul></li><li><p>dp数组如何初始化</p><p>从递推公式可以看出，递推公式的基础就是dp[0] 和 dp[1]，从 dp[i] 的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是 nums[0] 和 nums[1] 的最大值即：dp[1] &#x3D; max(nums[0], nums[1])</p></li><li><p>确定遍历顺序</p><p>dp[i] 是根据 dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历</p></li><li><p>举例推导dp数组</p><p>以示例二，输入 [2,7,9,3,1] 为例，红框 dp[nums.size() - 1] 为结果：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20210223161427" style="zoom:67%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="「状态压缩」-7"><a href="#「状态压缩」-7" class="headerlink" title="「状态压缩」"></a>「<strong>状态压缩</strong>」</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];      <br>        <span class="hljs-type">int</span> dp0=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> dp1=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> dpi=<span class="hljs-built_in">max</span>(dp0+nums[i],dp1);<br>            dp0=dp1;<br>            dp1=dpi;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 阅读笔记</title>
    <link href="/2021/01/08/Effective%20C++_Scott%20Meyers/"/>
    <url>/2021/01/08/Effective%20C++_Scott%20Meyers/</url>
    
    <content type="html"><![CDATA[<p>《Effective C++——改善程序与设计的55个具体做法》是 Scott Meyers 大师的巨作。本篇记录下自己的阅读笔记，在记录过程中，参考了 @<a href="https://github.com/arkingc">arkingc</a> 的仓库，在此表示感谢！</p><span id="more"></span><h1 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一.让自己习惯C++"></a>一.让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><br><h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h2><p><strong>这个条款或许改为“宁可以编译器替换预处理器”比较好</strong></p><h3 id="1）以const替换-define"><a href="#1）以const替换-define" class="headerlink" title="1）以const替换#define"></a>1）以const替换#define</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br>替换为：<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure><ul><li><strong>调试的需要</strong>：#define的记号会被预处理器移走，记号名称可能没进入记号表内。因此当#define的宏名称获得一个编译错误时，会引起困惑，浪费大量时间追踪错误。而AspectRatio肯定会被编译器看到</li><li><strong>更小的代码量</strong>：对浮点数而言，使用常量可能比使用#define导致较小量的代码，因为预处理器“盲目地将ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653</li></ul><p>但是，以常量替换#define时要注意：</p><ul><li><p><strong>定义常量指针时：由于常量定义式通常被定义在头文件内，因此有必要将指针声明为const</strong>。如：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>class专属常量</strong>：class专属常量需要声明在class内部，并且被class使用，而为确保此常量至多只有一份实体，须让它成为一个static成员：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">//常量声明式</span><br>    <span class="hljs-type">int</span> scores[NumTurns];          <span class="hljs-comment">//使用该常量</span><br>&#125;;<br><span class="hljs-comment">//通常定义出现在头文件中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns;    <span class="hljs-comment">//NumTurns的定义</span><br></code></pre></td></tr></table></figure><p>  对于static修饰的class专属整形常量，如果需要对该常量取地址或编译器坚持要看到一个定义式。那么必须提供类外定义。如果类内声明时提供了初始值，类外定义就不能再设初值。</p></li></ul><h3 id="2）以enum替换-define"><a href="#2）以enum替换-define" class="headerlink" title="2）以enum替换#define"></a>2）以enum替换#define</h3><p>某些编译器不允许“static整数型class常量”完成“in class 初值设定”，可改用”<strong>the enum hack</strong>“补偿做法，理论基础是“一个属于枚举类型的数值可权充ints被使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];   <span class="hljs-comment">//这就没问题了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>enum hack</strong>的行为比较像#define而不像const。例如取一个const的地址时合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。</p><h3 id="3）以inline替换-define"><a href="#3）以inline替换-define" class="headerlink" title="3）以inline替换#define"></a>3）以inline替换#define</h3><p>以#define实现宏看起来像函数，并且不会导致函数调用带来的开销，但是可能引发错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ?  (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b);       <span class="hljs-comment">//a被累加2次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b + <span class="hljs-number">10</span>);  <span class="hljs-comment">//a被累加1次</span><br></code></pre></td></tr></table></figure><p>使用inline函数可以减轻为参数加上括号以及参数被核算多次等问题。同时，inline可以实现一个“类内的private inline函数”，但一般而言宏无法完成此事。</p><br><h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><h3 id="1）const修饰变量"><a href="#1）const修饰变量" class="headerlink" title="1）const修饰变量"></a>1）const修饰变量</h3><p>如果变量本身不应该被修改，应该使用const修饰。这样编译器可以进行保护，确保这个变量不会被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p = greeting;                    <span class="hljs-comment">// non-const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = greeting;              <span class="hljs-comment">// non-const pointer, const data</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;             <span class="hljs-comment">// const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;       <span class="hljs-comment">// const pointer, const data </span><br></code></pre></td></tr></table></figure><ul><li>如果关键字const出现在星号左边，表示被指物是常量</li><li>如果出现在星号右边，表示指针自身是常量</li></ul><h3 id="2）const修饰函数"><a href="#2）const修饰函数" class="headerlink" title="2）const修饰函数"></a>2）const修饰函数</h3><ul><li>修饰参数时，和修饰一般变量相同</li><li><strong>修饰返回值，可以降低因客户错误而造成的意外</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rational a, b, c;<br>...<br><span class="hljs-keyword">if</span> (a * b = c)&#123; <span class="hljs-comment">//其实是想做一个比较动作，使用const修饰返回值可以避免这种错误</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果a和b都是内置类型。这样的代码直截了当就是不合法。而一个“良好的用户自定义类型”的特征是他们避免与内置类型不兼容。因此对operator*的定义应该如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure><h3 id="3）const修饰成员函数"><a href="#3）const修饰成员函数" class="headerlink" title="3）const修饰成员函数"></a>3）const修饰成员函数</h3><p>const修饰成员函数有2个好处：</p><ol><li><strong>可读性</strong>：使得接口容易被理解，可以知道哪个函数可以改动对象哪个函数不行</li><li><strong>const修饰的成员函数可以作用于const对象</strong></li></ol><p>但是，使用const修饰成员函数时需要注意，C++对常量性的定义是bitwise constness，即函数const成员函数不应该修改对象的任何成员变量。因此，如果成员变量是一个指针，那么不修改指针而修改指针所指之物，也符合bitwise constness，因此如果不是从bitwise constness的角度，这样也是修改了对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>   <span class="hljs-comment">// bitwise constness声明</span><br>  &#123; <span class="hljs-keyword">return</span> pText[position]; &#125;                    <span class="hljs-comment">// 但其实不恰当</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* pText;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">//声明一个常量对象</span><br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];            <span class="hljs-comment">//调用const operator[]取得一个指针，</span><br>                                <span class="hljs-comment">//指向cctb的数据</span><br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>;                      <span class="hljs-comment">//cctb现在有了“Jello”这样的内容</span><br></code></pre></td></tr></table></figure><p>还有一种logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 最近一次计算的文本区块长度</span><br>  <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 目前的长度是否有效</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//错误！在const成员函数内不能复制给</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//textLength和lengthIsValid</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，C++对常量性的定义是bitwise constness的，所以这样的操作非法。解决办法是使用mutable，mutable释放掉non-static成员变量的bitwise constness约束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 这些成员变量可能总是会被更改</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 即使在const成员函数内</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//现在可以这样</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//也可以这样</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，上面提到了2种“修改”const成员函数中修改对象（修改const对象）的方法。</p><p>最后，const和non-const版本的函数可能含有重复的代码，如果抽离出来单独成为一个成员函数还是有重复。如果希望去重，可以使用“运用const成员函数实现出其non-const孪生兄弟”的技术：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)<br>                [pos]   <br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><br><h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p><strong>读取未初始化对象的后果</strong>：读取未被初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值就可能让程序终止，更可能的情况是读入一些“半随机”bits，污染了正在进行读取动作的那个对象，最终导致不可预知的程序行为，以及许多令人不愉快的调试过程。</p><p>按对象的类型划分：</p><ul><li><strong>对于内置类型的对象</strong>：永远在使用前初始化</li><li><strong>类类型的对象</strong>：初始化责任落在构造函数身上<ul><li><strong>效率上的问题</strong>：<ul><li>类类型成员的初始化动作发生在构造函数本体之前。比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数比较高效。因此，善用初始化列表有助于提升效率</li><li>内置类型成员的初始化不一定发生在赋值动作的的时间点之前。对于内置类型成员，一般为了保持一致也在初始化列表中给出初始值</li></ul></li><li><strong>初始化顺序</strong>：成员的初始化顺序与类内声明顺序相同</li></ul></li></ul><p> 按对象的作用域与生命周期划分</p><ul><li><strong>static对象</strong><ul><li><strong>non-local static对象</strong>：C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确定义<ul><li>global对象</li><li>定义于namespace作用域内的对象</li><li>classes内、file作用域内被声明为static的对象</li></ul></li><li><strong>local static对象</strong>：函数内的local static对象会在“该函数被调用期间、首次遇上该对象的定义式”时被初始化<ul><li>函数内被声明为static的对象</li></ul></li></ul></li></ul><p>因此，如果一个non-local static对象的初始化依赖于另外一个non-local static的初始化，那么可能造成错误。解决方法是使用local static对象替换non-local static对象（参考单例模式）。</p><br><br><h1 id="二-构造-x2F-析构-x2F-赋值运算"><a href="#二-构造-x2F-析构-x2F-赋值运算" class="headerlink" title="二.构造&#x2F;析构&#x2F;赋值运算"></a>二.构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>一般情况下，编译器会为类合成下列函数：</p><ul><li><strong>default构造函数</strong></li><li><strong>copy构造函数</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li><li><strong>copy assignment操作符</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li><li><strong>析构函数</strong>：编译器生成的版本是<strong>non-virtual</strong>的</li></ul><p>更深层次的理解：深度探索C++对象模型（第2章、第5章）</p><p>以下情况编译器不会合成<strong>copy assignment操作符</strong>：</p><ul><li><strong>含有引用成员</strong>：原因在于这种情况下，赋值的目的不明确。是修改引用还是修改引用的对象？如果是修改引用，这是被禁止的。因此编译器干脆拒绝这样的赋值行为</li><li><strong>含有const成员</strong>：const对象不应该修改</li><li><strong>父类的copy assignment操作符被声明为private</strong>：无法处理基类子对象，因此也就无法合成</li></ul><br><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为什么要拒绝</strong>？比如，房产应该是独一无二的，这种情况下应该拒绝对象拷贝动作</p><p>一般情况下，不声明相应函数即可拒绝。但是编译器会为类合成一些函数，因此需要显式拒绝</p><p>还是以拒绝对象拷贝为例子，拒绝方法包括：</p><ol><li><p><strong>将copy构造函数或copy assignment操作符声明为private，并且不实现</strong>（这被用于C++ iostream程序库中）</p><ul><li><p>这种情况下member函数和friend函数还是可以调用，如果member函数或friend函数中执行了复制，会引发<strong>链接错误</strong></p></li><li><p>可以使用一个基类，在基类中将copy构造函数或copy assignment操作符声明为private，并且继承这个基类。这样可以将<strong>链接错误</strong>移至<strong>编译期</strong>，因为尝试拷贝时，编译器会试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器合成版”会尝试调用其基类的对应兄弟，而那些调用会被编译器拒绝，因为base class的拷贝函数是private</p></li></ul></li><li><p><strong>使用delete</strong>（书中没有提到）</p></li></ol><br><h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul><li><strong>为基类声明virtual析构函数</strong>：当派生类对象经由一个基类指针被删除，而该基类带有一个non-virtual析构函数，结果未定义——实际执行时通常发生的是对象的derived成分没有销毁，即“局部销毁”，造成资源泄露（因为存在这个问题，所以不要继承一个不被用作基类的类）</li><li>给base classes一个 virtual析构函数”，这个规则只适用于polymorphic（带多态性质的）base classes身上。这种base classes的设计目的是为了用来“通过 base class 接口处理derived class 对象”。polymorphic（带多态性质的）base classes 应该声明一个virtual析构函数。如果 class 带有任何virtual函数，它就应该拥有一个virtual析构函数</li><li><strong>class不用作基类时，不要将析构函数声明为virtual</strong>：Classes的设计目的如果不是作为base classes 用，或不是为了具备多态性，就不该声 virtual析构函数。virtual会引入虚函数指针，这会增加空间开销，并且使得类无法被C函数使用，从而不再具有移植性</li><li><strong>析构函数可以为pure virtual函数</strong>：抽象class总是企图被当作一个base class来用，又由于base class应该有个virtual析构函数，因此为成为抽象的那个class声明一个pure virtual析构函数</li></ul><br><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><strong>C++并不禁止析构函数吐出异常，但是并不鼓励这样做</strong></p><h3 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h3><p>如果析构函数吐出异常，程序可能过早结束（比如某个函数调用发生异常，在回溯寻找catch过程中，每离开一个函数，这个函数内的局部对象会被析构，如果此时析构函数又抛出异常，前一个异常还没得到处理又来一个，因此一般会引起程序过早结束）。异常从析构函数中传播出去，可能会导致不明确的行为</p><p><a href="https://www.zhihu.com/question/28592504">知乎相关描述</a></p><h3 id="2）如何解决"><a href="#2）如何解决" class="headerlink" title="2）如何解决"></a>2）如何解决</h3><ol><li><strong>在析构函数中catch异常</strong>，然后调用<strong>abort终止</strong>程序。通过abort抢先置“不明确行为”于死地</li><li><strong>在析构函数中catch异常</strong>，然后记录该失败，即<strong>吞下异常</strong>（通常是个坏主意，因为这样压制了“某些动作失败”的重要信息。但是也比负担“草率结束程序”或”不明确行为带来的风险“好）</li><li>较佳策略是重新设计接口，让客户能够在析构前主动调用可能引起异常的函数，然后析构函数中使用一个bool变量，根据用户是否主动调用来决定析构函数中是否应该调用可能引起异常的函数，<strong>让客户拥有主动权</strong>（如果客户没有主动调用，那么当发生异常时也不应该抱怨，因为已经给出了客户自己处理异常的机会）。如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险</li></ol><br><h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>如果希望在继承体系中根据类型在构建对象时表现出不同行为，会想到在基类的构造函数中调用一个虚函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                           <span class="hljs-comment">//所有交易的基类</span><br><span class="hljs-keyword">public</span>:                                           <br>    <span class="hljs-built_in">Transaction</span>()&#123;           <br>        ...                           <br>        <span class="hljs-built_in">logTransaction</span>();                         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//做出一份因类型不同而不同的日志记录</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;        <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br></code></pre></td></tr></table></figure><p>但是最终调用的virtual函数都是基类的版本。同时，因为是纯虚函数，除非定义该函数，否则将报链接错误。</p><p><strong>在base class构造期间，virtual函数绝不会下降到派生类阶层。取而代之的是，对象的作为就像隶属基类类型一样。即派生类对象的基类构造期间，对象的类型是基类而不是派生类。因此，若使用运行期类型信息</strong>（如dynamic_cast和typeid），也会把对象视为基类类型（这样对待是合理的：因为derived class部分尚未初始化，如果调用的是derived class的虚函数，通常会访问derived class成员变量，会引发安全问题）。</p><p><strong>相同道理也适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入base class析构函数后对象就成为一个base class对象</strong>。</p><p>如果希望实现最初的功能，即根据类型产生不同日志记录，那么可以将虚函数改为非虚函数，然后要求派生类构造函数在成员初始化列表中，向基类构造函数传递必要信息，基类构造函数根据这些信息，调用非虚函数，生成不同的日志记录。换句话说，由于无法使用虚函数从基类向下调用，在构造期间，可以藉由“令派生类将必要的构造信息向上传递至基类构造函数”替换之而加以弥补，另外，利用辅助函数创建一个值传给基类构造函数往往比较方便且可读。</p><br><h2 id="条款10：令operator-x3D-返回一个reference-to-this"><a href="#条款10：令operator-x3D-返回一个reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个reference to *this"></a>条款10：令operator&#x3D;返回一个reference to *this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x,y,z;<br>x = y = z = <span class="hljs-number">15</span>; <span class="hljs-comment">//赋值连锁形式</span><br></code></pre></td></tr></table></figure><p>为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。这个协议除了适用于operator&#x3D;，还适用于+&#x3D;、-&#x3D;、*&#x3D;等所有赋值相关运算。</p><blockquote><p>这只是个协议，并无强制性，如果不遵循，代码一样可通过编译。</p></blockquote><br><h2 id="条款11：在operater-x3D-中处理“自我赋值”"><a href="#条款11：在operater-x3D-中处理“自我赋值”" class="headerlink" title="条款11：在operater&#x3D;中处理“自我赋值”"></a>条款11：在operater&#x3D;中处理“自我赋值”</h2><p>考虑如下Widget类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面的operator&#x3D;实现是一份不安全的实现，在自赋值时会出现问题，也不具备异常安全性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <br>Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要处理自赋值，可以有以下几种方式：</p><ol><li><p><strong>在开头添加“证同测试”</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 证同测试</span><br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 这样做虽然能处理自赋值，但不是异常安全的，如果new时发生异常，对象会持有一个指针指向一块被删除的内存</p></li><li><p>精心周到的语句顺序，<strong>通过确保异常安全来获得自赋值安全的回报</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap *pOrig = pb;               <span class="hljs-comment">// remember original pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// make pb point to a copy of *pb</span><br>    <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// delete the original pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 现在，如果new失败，pb会保持原状。同时也能处理自赋值。如果担心效率可以在开头加上“证同测试”。但是if判断也会引入开销，因此需要权衡自赋值发生的频率</p></li><li><p><strong>使用copy and swap技术</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <span class="hljs-comment">// 交换*this和rhs的数据，见item29</span><br><span class="hljs-comment">//参数为pass by reference</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)<br>&#123;<br>    Widget <span class="hljs-built_in">temp</span>(rhs);       <br>    <span class="hljs-built_in">swap</span>(temp);               <span class="hljs-comment">// swap *this&#x27;s data with the copy&#x27;s</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <br>&#125;<br><span class="hljs-comment">//参数为pass by value</span><br><span class="hljs-comment">//这种方式的缺点是代码不够清晰，但是将“copying动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget rhs) <span class="hljs-comment">//rhs是被传对象的一份复件（副本）</span><br>&#123;<br>    <span class="hljs-built_in">swap</span>(rhs);                <span class="hljs-comment">// swap *this&#x27;s data with the copy&#x27;s</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;            <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><br><h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>如果声明自己的copying函数（copy构造函数和copy assignment操作符），意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的，会以一种奇怪的方式回敬：如果你自己写出的copying函数代码不完全，它也不会告诉你，具体表现为：</p><ul><li><strong>非继承中</strong>：当为类添加一个新成员变量时，须同时修改copying函数，为新成员添加拷贝代码（也需要修改class的所有构造函数以及任何非标准形式的operator&#x3D;）。否则会调用新成员的默认构造函数初始化新成员</li><li><strong>继承中</strong>：在派生类的copying函数中，不要忘记调用相应的base class函数拷贝基类部分。否则会调用基类的默认构造函数初始化基类部分</li></ul><p>当编写一个copying函数，请确保：</p><ul><li>复制所有local成员变量</li><li>调用所有base class内的适当的copying函数</li></ul><p>如果copy构造函数和copy assignment操作符有相近的代码，不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</p><br><br><h1 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p>当程序申请资源，例如一块动态内存时，可能会发生资源泄漏：</p><ul><li><strong>忘记delete</strong></li><li><strong>有delete，但是delete之前跳出控制流</strong>：在代码的维护过程中，动态分配内存和delete之间可能会加入return之类的控制流变更语句，或者是可能引发异常的代码，这样可能会使程序执行不到delete从而造成资源泄露</li></ul><p><strong>总结起来就是，手工delete一个是需要时刻记住delete，增加编码负担，另一个是即使明确delete，在delete之前控制流可能发生改变从而还是会造成资源泄露</strong>。</p><p>为确保返回的资源总是被释放，需要将资源放进对象内，当控制流离开时，该对象的析构函数会自动释放那些资源，即把资源放进对象内，便可依赖C++的“析构函数自动调用机制”确保资源被释放。</p><p>“以对象管理资源”的两个关键想法：</p><ul><li><strong>获得资源后立刻放进管理对象内</strong>：“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”(Resource Acquisition Is Initialization;<strong>RAII</strong>)。几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象，或者获得的资源被拿来赋值某个管理对象</li><li><strong>管理对象运用析构函数确保资源被释放</strong></li></ul><p>一个对象管理资源的例子是auto_ptr:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pIntv</span><span class="hljs-params">(createInvestment())</span></span>;    <br>    ...     <br>&#125;           <span class="hljs-comment">//经由auto_ptr的析构函数自动删除pInv</span><br></code></pre></td></tr></table></figure><p>对于<strong>对象管理资源，需要注意对象的复制行为</strong>：auto_ptr被销毁时会自动删除它所指之物，所以要注意别让auto_ptr同时指向同一对象。如果是那样，对象会被删除一次以上，程序产生“未定义行为”。为预防这个问题，auto_ptrs有一个性质：<strong>若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权</strong>。</p><p>auto_ptr的替代方案是“引用计数型智慧指针”（RCSP），持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源，一个例子是shared_ptr。RCSPs的缺点是无法打破环状引用（例如两个其实已经没被使用的对象彼此互指，因而好像还处在“被使用”状态）。</p><p>auto_ptr和shared_ptr两者都在其析构函数内做delete而不是delete[]动作，意味着在动态分配而得的array身上使用auto_ptr或shared_ptr是个馊主意。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::auto_ptr&lt;std::string&gt; <span class="hljs-title">aps</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 馊主意！</span><br></code></pre></td></tr></table></figure><blockquote><p>没有特别针对“C++动态分配数组”而设计的类似auto_ptr或tr1::shared_ptr那样的东西，甚至TR1中也没有。那是因为vector和string几乎总是可以取代动态分配而得的数组。因此当需要动态分配数组时，提倡使用vector（[可以使用unique_ptr管理动态数组](C++Primer_Stanley B. Lippman.md#23-unique_ptr)）。</p></blockquote><br><h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>并非所有资源都是动态内存，除此之外还有锁等资源，也应该通过“对象管理资源”来确保获取资源后能够正确的释放，<strong>根据资源的类型，和不同的需求，可能需要定义不同的RAII对象copy行为</strong>：</p><ol><li><strong>禁止复制</strong>：比方说锁资源，管理锁资源的对象复制通常并不合理。因此应该禁止这类对象的复制，可以通过继承一个copying操作被声明为private的基类来禁止复制，这点在条款06中有提到</li><li><strong>对底层资源使用“引用计数法”</strong>：如果希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的“被引用数”递增。tr1::shared_ptr便是如此。当资源引用计数减为0时，如果不希望删除资源（缺省行为），比方说锁资源想要的释放动作是解除锁定而非删除，可以指定shared_ptr的“删除器”（一个函数或函数对象，当引用次数为0时被调用，此机能并不存在于auto_ptr——它总是将其指针删除）</li><li><strong>复制底部资源</strong>：在此情况下复制管理资源对象，应该同时也复制其所包覆的资源。也就是说，复制资源管理对象时，进行的是“深度拷贝”</li><li><strong>转移底部资源的拥有权</strong>：如果希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物，原RAII对象拥有的资源设为null（auto_ptr奉行的复制意义）</li></ol><br><h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>APIs往往要求访问原始资源（即被RAII对象管理的资源，而不是直接访问RAII对象），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法</strong>。</p><p>取得RAII对象所管理资源的办法可以通过显式转换或隐式转换：</p><ul><li>**显式转换(比较安全，但不易用)**：如shared_ptr和auto_ptr的get成员函数，返回智能指针内部的原始指针（的复件）</li><li>**隐式转换(对客户比较方便，但不安全)**：如shared_ptr和auto_ptr重载了指针取值操作符（operator*和operator-&gt;），允许隐式转换至底部原始指针</li></ul><p>如果通过实现隐式转换（比如，实现operator()）来提供对原始资源的访问，可能不安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//以下，Font是一个RAII对象，FontHandle是一个原始资源</span><br><br><span class="hljs-function">Font <span class="hljs-title">f1</span><span class="hljs-params">(getFont())</span></span>;  <br>...<br>FontHandle f2 = f1; <span class="hljs-comment">//原意是想使用Font，复制一个RAII对象</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，如果实现了隐式转换，底层资源会被复制，如果f1销毁，f2会成为“虚吊的”（dangle）</p><p>是否该提供一个显式转换函数将RAII class转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAII class被设计执行的特定工作，以及它被使用的情况。</p><br><h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h2><p>当使用new和delete时，发生2件事：</p><ul><li>new<ul><li>内存被分配出来（通过名为operator new的函数）</li><li>针对此内存会有一个（或更多）构造函数被调用</li></ul></li><li>delete<ul><li>针对此内存会有一个（或更多）析构函数被调用</li><li>内存被释放（通过名为operator delete的函数）</li></ul></li></ul><p>单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数，布局可能像下面这个样子：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160045.png"></p><p><strong>当对着一个指针使用delete时，唯一能够让delete知道内存中是否存在一个“数组大小记录”的办法是：由你来告诉它。即加上[]，delete便认定指针指向一个数组，否则它便认为指针指向单一对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string* stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string* stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1; <span class="hljs-comment">//删除一个对象</span><br><span class="hljs-keyword">delete</span> [] stringPtr2; <span class="hljs-comment">//删除一个由对象组成的数组</span><br></code></pre></td></tr></table></figure><ul><li>如果对stringPtr1使用“delete []”形式，结果未定义，但不太可能让人愉快。假设内存布局如上，delete会读取若干内存并将它解释为“数组大小”，然后开始多次调用析构函数，浑然不知它所处理的那块内存不但不是个数组，也或许并未持有它正忙着销毁的那种类型的对象</li><li>如果没有对stringPtr2使用“delete []”形式，结果亦未定义，但可以猜想可能导致太少的析构函数被调用。犹有进者，这对内置类型如int者亦未定义，即使这类类型并没有析构函数</li></ul><p>因此，**如果调用new时使用了[]，必须在对应调用delete时也使用[]；如果调用new时没使用[]，那么也不该在对应调用delete时使用[]**。</p><p>这点在typedef中尤其需要注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];  <span class="hljs-comment">//每个人的地址有4行，每行是一个string</span><br><br>std::string *pa1 = <span class="hljs-keyword">new</span> AddressLines;  <span class="hljs-comment">//返回一个string*，就像new string[4]一样</span><br><br><span class="hljs-keyword">delete</span> pa1;             <span class="hljs-comment">//错误！行为未定义</span><br><span class="hljs-keyword">delete</span> [] pa1;          <span class="hljs-comment">//很好</span><br></code></pre></td></tr></table></figure><p>为避免这类错误，最好尽量不要对数组形式做typedefs动作。</p><br><h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><p>考虑如下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">func1</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类),<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure><p>在调用func1之前，编译器必须创建代码，做以下3件事</p><ul><li>执行func2</li><li>执行”new 原始资源类”创建一个原始资源</li><li>调用tr1::shared_ptr构造函数</li></ul><p>但是执行顺序弹性很大。如果执行顺序如下；</p><ol><li>执行”new 原始资源类”创建一个原始资源</li><li>执行func2</li><li>调用tr1::shared_ptr构造函数</li></ol><p>现在，如果2发生异常，那么因为1创建的资源未被置入tr1::shared_ptr内，因此会发生内存泄露。也就是说，在“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。为避免这类问题，应该使用独立语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类) p; <span class="hljs-comment">//单独语句</span><br><br><span class="hljs-built_in">func1</span>(p,<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure><p>编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度）。</p><br><br><h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><ol><li><p><strong>通过引入新类型来防止误用</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month,<span class="hljs-type">int</span> day,<span class="hljs-type">int</span> year);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p> 上面日期类的构造函数中，年月日都是int，那么很容易传入顺序错误的参数。可以导入3个表示年月日的新类：Year、Month、Day来区分，从而防止这种问题。更进一步，为了使得传入的数据有效，比如月份，可以设计生成12个月份对象的static成员函数，并将构造函数声明为explicit强制要求通过调用static成员函数得到月份对象。使用enums没有那么安全，enums可被拿来当作一个ints使用（条款02）</p><p> 预防客户错误的另一个办法是，限制类型内什么事可做，什么事不能做。常见的限制是加上const</p></li><li><p><strong>除非有好理由，否则应该尽量让你的types的行为与内置类型一致</strong>：如<code>if(a * b = c)</code>对内置类型来说不合法，那么你的type在实现operator*时就应该返回一个const对象</p></li><li><p><strong>提供行为一致的接口</strong>：如C++ STL容器都提供size()返回容器大小，但是Java和.Net对于不同容器大小接口可能不同，这会增加使用负担</p></li><li><p><strong>返回“资源管理对象”而不是原始资源</strong>：如用shared_ptr管理资源时，客户可能会忘记使用智能指针，从而开启了忘记释放和重复释放的大门。通过修改接口的返回类型为智能指针（有需要时还可绑定“删除器”），从而确保元素资源处于“资源管理对象”的掌控之中（可防范潜在的客户错误：“cross-DLL problem”）</p></li></ol><br><h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><p>在设计class时，对下列问题的回答将导致你的class设计规范：</p><ul><li>新type的对象应该如何被创建和销毁？</li><li>对象的初始化和对象的赋值该有什么样的差别？</li><li>新type的对象如果被passed by value，意味着什么？</li><li>什么是新type的“合法值”？</li><li>你的新type需要配合某个继承图系吗？</li><li>你的新type需要什么样的转换？</li><li>什么样的操作符和函数对此新type而言是合理的？</li><li>什么样的标准函数应该驳回？</li><li>谁该取用新type的成员？</li><li>什么是新type的“未声明接口”？</li><li>你的新type有多么一般化？</li><li>你真的需要一个新type吗？</li></ul><br><h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><p>pass-by-reference-to-const有下列好处：</p><ul><li><strong>更高的效率</strong>：如果一个类处于继承体系的底部，并且包含大量成员，pass-by-value会导致大量的构造函数被调用，在函数调用完成后，又有大量的析构函数被调用</li><li><strong>防止继承中的对象切割问题</strong>：当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用，传入的derived class对象会被切割，只保有base class对象的部分，从而无法表现多态</li><li><strong>const是重要的</strong>，可以阻止传入的参数被修改</li></ul><p>references往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此，对于<strong>内置类型</strong>，pass by value往往比pass by reference的效率高些。pass by value同样适用于<strong>STL的迭代器</strong>和<strong>函数对象</strong>。</p><p>并不是所有小型对象都是pass-by-value的合格候选者：</p><ul><li>对象小并不意味着copy构造函数不昂贵。许多对象——包括大多数STL容器——内含的东西比一个指针多一些，但是复制这种对象却需承担“复制那些指针所指的每一样东西”，那将非常昂贵</li><li>即使copy构造函数不昂贵，还是可能有效率上的争议。某些编译器对待“内置类型”和“用户自定义类型”的态度截然不同，纵使两者拥有相同的底层表述，“用户自定义类型”也不会被编译器放入缓存器，因此pass by reference更适合</li></ul><blockquote><p>可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。其它任何东西，尽量以pass-by-reference-to-const替换pass-by-value</p></blockquote><br><h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>必须返回对象的最常见例子是运算符函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs);<br></code></pre></td></tr></table></figure><p>在必须返回对象时，不要企图返回reference，可以通过反面来说，也就是如果返回reference会是什么情况？</p><ul><li><p><strong>使用stack构造一个局部对象，返回局部对象的reference</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n,lhs.d * rhs.d)</span></span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>  注意！使用reference的本意是避免构造新对象，但是一个新的对象result还是经由构造函数构造。更严重的是，result是个local对象，而local对象在函数退出前被销毁了，reference将指向一个被销毁的对象。任何函数如果返回一个reference指向某个local对象，都将一败涂地（如果函数返回指针指向一个local对象，也是一样）。</p></li><li><p><strong>在heap内构造一个局部对象，返回这个对象的reference</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br>Rational w,x,y,z;<br>w = x * y *z;<br></code></pre></td></tr></table></figure><p>  这样虽然reference不再引用一个被销毁的对象，但还是必须付出一个“构造函数调用”代价，并且谁该对new出来的对象实施delete也成为问题。同时，在上面的连乘例子中，会多次动态分配内存，但是只返回最后一次的指针，因此会导致资源泄露。</p></li><li><p><strong>构造一个static局部对象，每次计算结果保存在这个对象中，返回其reference</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-type">static</span> Rational result<br>    result = ...;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br>Rational w,x,y,z;<br><span class="hljs-keyword">if</span>((w * x) == (y * z))&#123;...&#125;<br></code></pre></td></tr></table></figure><p>  首先，显而易见的问题是这个函数在多线程情况下是不安全的，多个线程会修改相同的static对象；除此之外，在上面的if判断中，不管传入的w,x,y,z是什么，由于operator*传回的reference都指向同一个static对象，因此上面的判断永远都会为true（由于返回reference，调用端看到的永远是static对象的“现值”）。</p></li></ul><p>一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>请记住：绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</p></blockquote><br><h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><h3 id="1）为什么不能是public"><a href="#1）为什么不能是public" class="headerlink" title="1）为什么不能是public"></a>1）为什么不能是public</h3><p>3个原因：</p><ol><li><p><strong>语法一致性</strong>：如果成员变量和成员函数一样，都是public，那么调用时会困惑于该不该使用括号。如果想获取大小时使用size，但是这到底是一个成员变量还是一个成员函数？</p></li><li><p><strong>细微划分之访问控制</strong>：通过将成员变量声明为private，通过成员函数提供访问，可以实现更精准的访问控制</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccessLevels</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadOnly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   </span>&#123;<span class="hljs-keyword">return</span> readOnly;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>    </span>&#123;readWrite = value;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123;<span class="hljs-keyword">return</span> readWrite;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteOnly</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>    </span>&#123;writeOnly = value;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> noAccess;   <span class="hljs-comment">//对此int无访问动作</span><br>    <span class="hljs-type">int</span> readOnly;   <span class="hljs-comment">//对此int做只读访问</span><br>    <span class="hljs-type">int</span> readWrite;  <span class="hljs-comment">//对此int做读写访问</span><br>    <span class="hljs-type">int</span> writeOnly;  <span class="hljs-comment">//对此int做只写访问</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>**封装(主要)**：private将成员变量封装，如果通过public暴露，在需要改成员变量的大量实现代码中，会直接使用。当这个成员变量被修改或删除时，所有直接访问该成员变量的代码将会变得不可用</p></li></ol><h3 id="2）那么protected行不行"><a href="#2）那么protected行不行" class="headerlink" title="2）那么protected行不行"></a>2）那么protected行不行</h3><p>protected成员变量和public成员变量的论点十分相同。“语法一致性”和“细微划分的访问控制”等理由也适用于protected数据。同时，protected也并不比public更具封装性。</p><p>假设有一个public成员变量，而我们最终取消了它。所有使用它的客户代码都会被破坏。因此，public成员变量完全没有封装性。假设有一个protected变量，而我们最终取消了它，所有使用它的派生类都会被破坏。因此，protected成员变量也缺乏封装性。</p><p>从封装的角度观之，只有两种访问权限：private（提供封装）和其他（不提供封装）。</p><br><h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>假设有个浏览器类，包含一些功能用来清除下载元素高速缓冲区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCookies</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>此时，如果想整个执行所有这些动作，那么有两种选择，一种实现成member函数，一种实现成non-member函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//实现成成员函数，能访问private成员</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">clearCache</span>();<br>    <span class="hljs-built_in">clearCookies</span>();<br>    <span class="hljs-built_in">clearHistory</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//或者实现成非成员函数，不能访问private成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearCookies</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>问题是应该如何选择？这个问题主要在于<strong>封装性</strong>。</p><p>如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。越少人看到它，就有越大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物。</p><p>因此，对于对象内的代码。越少代码可以看到数据（也就是访问它），越多的数据可被封装，我们也就越能自由地改变对象数据。作为一种粗糙的测量，越多函数可访问它，数据的封装性就越低。</p><p>条款22所说，成员变量应该是private。能够访问private成员变量的函数只有class的member函数加上friend函数而已。<strong>如果要在一个member函数和一个non-member，non-friend函数之间做选择，而且两者提供相同机能，那么，导致较大封装性的是non-member，non-friend函数</strong>，因为它并不增加“能够访问class内之private成分”的函数数量。也就是本条款这样选择的原因。这个论述只适用于non-member non-friend函数。friends函数对class private成员的访问权力和member函数相同。</p><p>一个扩展性的问题是——这些non-member，non-friend函数应该实现于何处?</p><p>自然做法是位于同一个namespace内。</p><p>一个像WebBrowser这样的class可能拥有大量便利函数，某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…通常客户只对其中某些感兴趣。没道理一个只对书签相关便利函数感兴趣的客户却与一个cookie相关便利函数发生编译相依关系。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关…以此类推：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160131.png"></p><p>这正是C++标准库的组织方式。标准库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间内的每一样东西，而是有数十个头文件（&lt;vector&gt;,&lt;algorithm&gt;,…），每个头文件声明std的某些机能。客户可以根据需要使用的机能选择性的包含头文件。</p><p>将所有便利函数放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组便利函数。这是class无法提供的另一个性质，因为class定义式对客户而言是不能扩展的。</p><br><h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>令class支持隐式类型转换不是个好主意，但是在建立数值类型时颇为合理。考虑有理数和内置整形之间的相乘运算。具有如下有理数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>); <span class="hljs-comment">//构造函数刻意不为explicit，提供了Int-to-Rational的隐式转换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">//分子的访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//分母的访问函数</span><br><span class="hljs-keyword">private</span>:<br>...<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，有理数提供了Int-to-Rational的隐式转换方式，那么operator*应该实现成member，还是non-member？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">//实现为member</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-comment">//实现为non-member</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure><p>问题发生在混合运算上。如果实现成member，那么下面的混合运算只有一半行得通：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = oneHalf * <span class="hljs-number">2</span>;                  <span class="hljs-comment">// OK</span><br>result = <span class="hljs-number">2</span> * oneHalf;                  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>因为内置类型int并没有相应的class，也就没有operator*成员函数。所以后者会出错。但是当实现为non-member时，具有2个参数，都能通过int隐式转换为Rational，所以上面2行代码都能运行。因此，如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，请为此采用non-member函数。</p><br><h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p>“以指针指向一个对象，内含真正数据”。这种设计的常见表现形式是所谓的“pimpl手法”（“pointer to implementation”）。如下，WidgetImpl包含了Widget的真正数据，而Widget只包含一个WidgetImpl类型的指针，指向一个WidgetImpl对象。这种设计特点，决定了Widget的copying行为应该表现出一种“深拷贝”的行为：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160201.png"></p><p>因此，如果使用标准库的swap交换2个Widget对象，会引起WidgetImpl对象的拷贝，由于其内含有Widget的大量数据，因此效率可能十分低。实际上这种情况下，交换2个指针就可以了。为此，我们可能实现出下图右边上方的swap特化版来提升效率，但是由于其内直接访问Widget的private成员，因此无法通过编译。所以我们采用下图右边下方的方案，在Widget类内实现一个public的swap函数，然后特化版的swap调用这个public的swap函数：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160230.png"></p><p>当问题更进一步发展时，即Widget和WidgetImpl为class template时，可能会将相同的思想迁移过来，实现出下图上方的偏特化版本。但是问题是：<strong>C++只允许偏特化class templates，而不允许偏特化function templates</strong>。所以行不通，因此可以使用下图右下角的重载方式，但是<strong>客户可以全特化std内的模板，但是不能添加新的模板到std内</strong>，因此正确的做法是下图左下角：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160304.png"></p><p>如果想让你的“class 专属版”swap在尽可能多的语境下被调用，需要同时在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。</p><p>从客户的观点看，应写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T&amp; obj1,T&amp; obj2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap; <span class="hljs-comment">//令std::swap在此函数内可用</span><br>    ...<br>    <span class="hljs-built_in">swap</span>(obj1,obj2); <span class="hljs-comment">//为T型对象调用最佳swap版本</span><br>    ...<br>&#125;<br><br>std::<span class="hljs-built_in">swap</span>(obj1,obj2); <span class="hljs-comment">//这是错误的swap调用方式，强迫编译器只认std内的swap版本</span><br></code></pre></td></tr></table></figure><p>总结起来就是：</p><ul><li>首先，如果swap的缺省实现对你的class或class template提供可接受的效率，不需要额外做任何事</li><li>其次，如果swap的缺省实现效率不足（那几乎总是意味着你的class或template使用了某种pimpl手法），试着做以下事情：<ul><li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象值（<strong>这个public swap成员函数绝不可抛出异常。这个约束不可施行于非成员版，因为swap缺省版本是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的swap，往往提供的不只是高效置换对象值的方法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效的swaps几乎总是基于对内置类型的操作，而内置类型上的操作绝对不会抛出异常</strong>）</li><li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数</li><li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它调用你的swap成员函数</li></ul></li><li>最后，如果你调用swap，请确定包含一个using声明，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符地调用swap</li></ul><br><br><h1 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>只要定义了一个变量而其类型带有一个构造函数或析构函数，那么</p><ul><li>当程序的控制流到达这个变量定义式时，你便得承受构造成本</li><li>当这个变量离开作用域时，你便得承受析构成本</li></ul><p>即使这个变量最终并未被使用，仍需耗费这些成本，所以你应尽可能避免这种情形，即延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p><p>当考虑循环时，有下列2种情况：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160331.png"></p><p>两种写法的成本如下；</p><ul><li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li><li>做法B：n个构造函数 + n个析构函数</li></ul><p><strong>从效率上看</strong>：如果class的一个赋值成本低于一组构成+析构成本，做法A大体而言比较高效，尤其当n比较大时。否则做法B或许更好。</p><p><strong>从可理解性和维护性上看</strong>：A造成名称w的作用域比做法B更大，可理解性和维护性相对较差。</p><p>因此，除非</p><ol><li>你知道赋值成本比“构造 + 析构”成本低</li><li>你正在处理代码中效率高度敏感的部分</li></ol><p>否则，应该使用做法B。</p><br><h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型分类：</p><ul><li>旧式转型  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C风格的转型</span><br>(T)expression   <span class="hljs-comment">//将expression转型为T</span><br><span class="hljs-comment">//函数风格的转型</span><br><span class="hljs-built_in">T</span>(expression)   <span class="hljs-comment">//将expression转型为T</span><br></code></pre></td></tr></table></figure></li><li>C++提供的新式转型（new-style或C++-style casts）  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure><ul><li><strong>const_cast</strong>：通常被用来将对象的常量性转除。只能改变底层const，例如指向const的指针(指向的对象不一定是常量，但是无法通过指针修改)​，如果指向的对象是常量，则这种转换在修改对象时，结果未定义</li><li><strong>dynamic_cast</strong>：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。一种动态类型识别。转换的目标类型，即type，是指针或者左右值引用，主要用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如果转换失败，返回0（转换目标类型为指针类型时）或抛出bad_cast异常（转换目标类型为引用类型时）</li><li><strong>reinterpret_cast</strong>：意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。通常为算术对象的位模式提供较低层次上的重新解释。如将int*转换成char*。很危险！</li><li><strong>static_cast</strong>：用来强迫隐式转换，例如将non-const对象转换为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换。但它无法将const转为non-const（只有const_cast才办得到）</li></ul></li></ul><p>应该尽可能使用新式转型：</p><ol><li>它们很容易在代码中被辨别出来（无论是人工还是使用工具如grep），因而得以简化“找出类型系统在哪个地点被破坏”的过程</li><li>各转型动作的目标越窄化，编译器越可能诊断出错误的运用</li></ol><p><strong>尽量少做转型</strong>：</p><ol><li><p><strong>转型不只是告诉编译器把某种类型视为另一种类型这么简单。任何一个类型转换（显式或隐式）往往令编译器编译出运行期间执行的代码</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//示例一</span><br><span class="hljs-type">int</span> x,y;<br>...<br><span class="hljs-type">double</span> d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(x)/y;<br><span class="hljs-comment">//示例二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;...&#125;;<br>Derived d;<br>Base *pd = &amp;d;  <span class="hljs-comment">//隐式地将Derived*转换为Base*</span><br></code></pre></td></tr></table></figure><ul><li>在示例一中：int转型为double几乎肯定会产生一些代码，因为在大部分体系结构中，int的底层表述不同于double的底层表述</li><li>在示例二中：会有个偏移量在运行期被施行于Derived*指针身上，用以取得正确的Base*指针值</li></ul></li><li><p><strong>很容易写出似是而非的代码</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//错误的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();  <br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//正确的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;<br>        Window::<span class="hljs-built_in">onResize</span>();  <span class="hljs-comment">//调用Window::onResize作用于*this身上</span><br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p> 上面的例子中，派生类的虚函数可能希望调用基类虚函数的版本执行一些固定操作，然后再执行一些专属行为。在前面的做法中，转型并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。而是在“当前对象的base class成分”的副本上调用Window::onResize，然后在当前对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。如果专属动作也修改对象，那么当前对象真的会被改动，进而进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。</p><p> 解决之道是拿掉转型动作，代之以真正想说的话，即后面的做法。</p></li><li><p><strong>继承中的类型转换效率低</strong></p><ul><li>C++通过dynamic_cast实现继承中的类型转换，dynamic_cast的大多数实现版本执行速度都是相当慢的。因此，应该避免继承中的类型转换。之所以需要dynamic_cast，通常是因为想在一个认定为derived class对象身上执行derived class操作函数，但是只有一个“指向base”的指针或引用。这种情况下有两个一般性做法可以避免这个问题：<ul><li><strong>使用容器并在其中存储直接指向derived class对象的指针</strong>：这种做法无法在同一个容器内存储指针“指向所有可能之各种派生类”。如果真要处理多种类型，可能需要多个容器，它们都必须具备类型安全性</li><li><strong>将derived class中的操作上升到base class内，成为virtual函数，base class提供一份缺省实现</strong>：缺省实现代码可能是个馊主意，条款34中有分析，但是也比使用dynamic_cast来转型要好</li></ul></li><li>绝对必须避免的一件事是所谓的“连串dynamic_casts”</li></ul></li><li><p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内</p></li></ol><br><h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><blockquote><p>References、指针和迭代器统统都是所谓的handles（号码牌，用来取得某个对象）。</p></blockquote><p>如果返回一个“代表对象内部数据”的handle，会造成以下结果：</p><ul><li><p>降低对象封装性</p><p>成员变量的封装性最多只等于“返回其reference”的函数的访问级别。如果public成员函数返回handles，那么相当于成员变量的封装性从private上升到public。这与<a href="#%E6%9D%A1%E6%AC%BE22%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate">条款22</a>相悖</p></li><li><p>导致“虽然调用const成员函数却造成对象状态被更改”</p><p>如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是bitwise constness的附带结果：在<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>提到过“pimpl手法”，即：“以指针指向一个对象，内含真正数据”，也就是对象只包含指针成员，实际数据通过这个指针指向。而在<a href="#%E6%9D%A1%E6%AC%BE03%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款3</a>中也提到，C++对const成员函数的要求是，符合bitwise constness。因此，const成员函数返回一个这个指针所指对象的引用，并不会造成指针被修改，也就符合bitwise constness，但是通过这个引用却可以改变对象实际的数据</p></li></ul><p>如果返回的是指针或迭代器，相同情况也会发生，原因也相同。</p><p>不被公开使用的成员函数（被声明为protected或private）也是对象“内部”的一部分，因此也应该留心不要返回它们的handles。</p><p>解决方法是<strong>对它们的返回类型加上const</strong>：有了这样的改变，客户可以读取数据，但不能涂写。</p><p>即使如此，还是返回了“代表对象内部”的handles，有可能在其他场合带来问题：</p><ul><li><p>可能导致dangling handles（空悬的号码牌）：这种handles所指东西（的所属对象）不复存在</p><p>最常见的来源是函数返回值。如果返回的handles指向一个临时对象，那么返回后临时对象被销毁，handles会成为“虚吊的”。只要handle被传出去，就暴露在“handle比其所指对象更长寿”的风险下</p></li></ul><br><h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>考虑下面例子，有一个菜单类，changeBg函数可以改变它的背景，切换背景计数，同时提供线程安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    Mutex mutex;            <span class="hljs-comment">//提供多线程互斥访问</span><br>    Image *bg;          <span class="hljs-comment">//背景图片</span><br>    <span class="hljs-type">int</span> changeCount;    <span class="hljs-comment">//切换背景计数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBg</span><span class="hljs-params">(istream&amp; sr)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-built_in">lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">delete</span> bg;<br>    ++changeCount;<br>    bg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src);<br>    <span class="hljs-built_in">unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1）异常安全的2个条件"><a href="#1）异常安全的2个条件" class="headerlink" title="1）异常安全的2个条件"></a>1）异常安全的2个条件</h3><ol><li><strong>不泄露任何资源</strong>：即发生异常时，异常发生之前获得的资源都应该释放，不会因为异常而泄露。在上面的例子中，如果new Image发生异常，那么unlock就不会调用，因此锁资源会泄露</li><li><strong>不允许数据败坏</strong>：上面的例子也不符合，如果new Image抛出异常，背景图片会被删除，计数也会改变。但是新背景并未设置成功</li></ol><p><strong>对于资源泄露</strong>，<a href="">条款13</a>讨论过如何以对象管理资源。锁资源也可以为shared_ptr指定“删除器”，当引用为0时，即异常发生，管理所资源的对象被销毁后，删除器会调用unlock</p><p><strong>对于数据败坏</strong>：见下文</p><h3 id="2）异常安全函数的3个保证"><a href="#2）异常安全函数的3个保证" class="headerlink" title="2）异常安全函数的3个保证"></a>2）异常安全函数的3个保证</h3><ol><li><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。然而程序的现实状态不可预料，不确定处于哪个状态（对于前面的例子，可以撰写如果发生异常，PrettyMenu可以继续拥有原背景图像，或是令它拥有某个“缺省”的背景图像，但客户无法预期哪一种情况）</li><li><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态</li><li><strong>不抛掷保证</strong>：这是最强的保证，承诺绝不抛出异常，函数总是能完成它们原先承诺的功能（作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础）</li></ol><p>异常安全码必须提供上述三种保证之一，否则不具备异常安全性。</p><p>对于前面的PrettyMenu对象，可以通过使用智能指针管理资源，以及重排changeBg内的语句次序来满足“强烈保证”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    shared_ptr&lt;Image&gt; bg;<br>    ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;    <span class="hljs-comment">//Lock以对象管理资源</span><br>    bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src));<br>    ++changeCount;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，上述实现只能为PrettyMenu对象提供“强烈保证”，不能提供完美（即全局状态）的“强烈保证”。比如Image构造函数抛出异常，有可能istream&amp; src的读取记号已被移走，那么系统还是处于一个被改变的状态。 这是一种对整个系统的副作用，类似的副作用还包括数据库操作，因为没有通用的办法可以撤销数据库操作。 不过这一点可以忽略，我们暂且认为它提供了完美的强烈保证。</p><p><strong>copy and swap策略</strong>：</p><p>“copy and swap”设计策略通常能够<strong>为对象</strong>提供异常安全的“强烈保证”。其原则：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。关于swap的详细讨论可以参见<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>。</p><p>实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象（即副本）——pimpl idiom手法，详见<a href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E5%B0%86%E8%87%B3%E6%9C%80%E4%BD%8E">条款31</a>。</p><p>这种策略用在前面的例子中会像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    std::shared_ptr&lt;MenuImpl&gt; pImpl;<br>&#125;;<br>Menu::<span class="hljs-built_in">changeBg</span>(std::istream&amp; src)&#123;<br>    <span class="hljs-keyword">using</span> std::swap;            <span class="hljs-comment">// 见 Item 25</span><br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;            <span class="hljs-comment">// 获得mutex的副本数据</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;MenuImpl&gt; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MenuImpl(*pImpl))</span></span>;<br>    copy-&gt;bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src)); <span class="hljs-comment">//修改副本数据</span><br>    ++copy-&gt;changeCount;<br><br>    <span class="hljs-built_in">swap</span>(pImpl, copy);              <span class="hljs-comment">//置换数据，释放mutex</span><br>&#125;<br></code></pre></td></tr></table></figure><p>copy and swap策略是对对象状态做出“全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性。也就是说，如果某个函数使用copy and swap策略为某个对象提供了异常安全的“强烈保证”。但是这个函数可能调用其它函数，而这些函数可能改变一些全局状态（如数据库状态），那么“整个函数”就不是“强烈保证”。</p><blockquote><p>函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p></blockquote><p>除此之外，copy and swap必须为每一个即将被改动的对象作出一个副本，从而可能造成时间和空间上的问题。</p><h3 id="3）最终目标是什么"><a href="#3）最终目标是什么" class="headerlink" title="3）最终目标是什么"></a>3）最终目标是什么</h3><p>当“强烈保证”不切实际时（比如前面提到的全局状态改变难以保证，或者效率问题），就必须提供“基本保证”。现实中你或许会发现，可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，“异常安全性的基本保证”是一个绝对同情达理的选择。</p><p>总的来说就是，应该为自己的函数努力实现尽可能高级别的异常安全，但是由于种种原因并不是说一定需要实现最高级别的异常安全，而是应该以此为目标而努力。</p><br><h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><strong>inline的优劣</strong>：</p><ul><li><strong>优</strong>：<ul><li>较少函数调用的开销</li><li>编译器对inline的优化</li></ul></li><li><strong>劣</strong>：<ul><li>目标码大小的增加，程序体积增大，导致额外的换页行为，降低指令高速缓存装置的命中率</li></ul></li></ul><blockquote><p>inline只是对编译器的一个申请，不是强制命令。</p></blockquote><p>inline提出方式包括2种：1）显式提出（在定义式前加上关键字inline）；2）隐喻提出（将函数定义于class定义式内）。</p><p>inline在大多数C++程序中是<strong>编译期行为</strong>。大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给出一个警告。</p><p>不要只因为function templates出现在头文件中，就将它们声明为inline。Template的具现化与inlining无关。除非正在写一个template而认为所有根据此template具现出来的函数都应该inlined，才声明为inline，否则应该避免。inlining需要成本。</p><p><strong>对virtual函数的调用也都会使inlining落空。因为virtual意味着“等待，直到运行期才确定调用哪个函数”，而inline意味着“执行前，先将调用动作替换为被调用函数的本体</strong>”。</p><p>如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。毕竟编译器没有能力提出一个指针指向并不存在的函数。与此并提，编译器通常不对“通过函数指针而进行的调用”实施inlining。</p><p><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>。C++对于“对象被创建和被销毁时发生什么事”做了各式各样的保证。在对象构造期间如果抛出异常，该对象已经构造好的部分会被自动销毁等。<strong>程序内一定有某些代码让那些事情发生</strong>。对于下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string bm1,bm2;    <span class="hljs-comment">//base成员1和2</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()  &#123;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string dm1,dm2,dm3; <span class="hljs-comment">//derived成员1-3</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>虽然看上去Derived的构造函数为空，符合一个函数成为inline的的特性。但是为了确保C++对于“对象被创建和被销毁时发生什么事”做出的各式各样的保证，编译器会在其中安插代码，因此实际的Derived构造函数可能是这个样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derived::<span class="hljs-built_in">Derived</span>()<br>&#123;<br>    Base::<span class="hljs-built_in">Base</span>();<br>    <span class="hljs-keyword">try</span>&#123;dm1.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm2.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm1.std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm3.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm2.std::string::~<span class="hljs-built_in">string</span>();<br>        dm1.std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大部分的调试器面对inline函数都束手无策。因为无法在一个不存在的函数内设立断点。因此，一个合乎逻辑的策略是，一开始先不要将任何函数声明为inline，或至少将inlining施行范围局限在那些“一定成为inline”或“十分平淡无奇”的函数身上。</p><br><h2 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h2><p>C++并没有把“将接口从实现中分离”这件事做得很好。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string theName;    <span class="hljs-comment">//实现细目</span><br>    Date    theBirthDate;   <span class="hljs-comment">//实现细目</span><br>    Address theAddress;     <span class="hljs-comment">//实现细目</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果没有前面3行引入头文件，那么编译无法通过。但是如此却<strong>会在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些文件所依赖的其它头文件有任何改变。那么每个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译</strong>。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p><p>你可能会想着将实现细目分开：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>;   <span class="hljs-comment">//前置声明，但不正确</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <span class="hljs-comment">//前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果可以这么做，Person的客户就只需要在Person接口被修改过时才重新编译。但是这种想法存在2个问题：</p><ul><li>string并不是个class，它是个typedef，上述前置声明不正确，正确的前置声明比较复杂</li><li>重点是，<strong>编译器必须在编译期间知道对象的大小</strong>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;           <span class="hljs-comment">//定义一个int</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(...)</span></span>;   <span class="hljs-comment">//定义一个Person</span><br>&#125;<br></code></pre></td></tr></table></figure>  这和Java，Smalltalk中不同，因为它们在定义对象时，编译器只分配足够空间给一个指针使用。也就是说，它们将上述代码视为这样：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;          <span class="hljs-comment">//定义一个int</span><br>    Person* p;      <span class="hljs-comment">//定义一个指针指向Person对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>解决方法是<strong>将接口与实现分离</strong>。主要有两种方法：</p><ul><li><strong>Handle class</strong></li></ul><p>把Person分割为两个类：1）一个只提供接口(Person)；2）一个负责实现接口(PersonImpl)；使用“pimpl idiom(pointer to implementation)”设计：接口class中只包含一个负责实现接口的class的指针，因此任何改变都只是在负责实现接口的class中进行。那么Person的客户就完全与Date,Address,以及Person的实现细目分离了。那些classes的任何实现修改都不需要Person客户端重新编译。此外，由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目的代码”。这种情况下，像Person这样使用pimpl的classes往往被称为handle classes。它们的所有函数都转交给相应的实现类并由后者完成实际工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string&amp; name);<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br>Person::<span class="hljs-built_in">Person</span>(string&amp; name): <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name))&#123;&#125;<br><span class="hljs-function">string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：让头文件自我满足，万一做不到，则让它与其他头文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略：</p><ol><li><p>如果使用object references或object pointers可以完成任务，就不要使用objects</p></li><li><p>如果能够，尽量以class声明式替换class定义式。当声明一个函数而它用到某个class时，并不需要该class的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;   <span class="hljs-comment">//class声明式</span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//这里并不需要</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>; <span class="hljs-comment">//Date的定义式</span><br></code></pre></td></tr></table></figure></li><li><p>为声明式和定义式提供不同的头文件。为了促使这个准则，需要两个头文件：一个用于声明式，一个用于定义式。因此，上面的例子应该是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;datefwd.h&quot;</span>    <span class="hljs-comment">//包含了class Date的声明</span></span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//同前</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li><strong>Interface class</strong></li></ul><p>另一个制作Handle class的办法是，令Person成为一种特殊的abstract base class，称为interface class。其目的是详细描述derived classes的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">birthday</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>客户不能实例化它，只能使用它的引用和指针。然而客户一定需要某种方法来获得一个实例，比如factory（工厂）函数。它们返回指针（或智能指针），指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数往往声明为static：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> shared_ptr&lt;Person&gt; <span class="hljs-title">create</span><span class="hljs-params">(string&amp; name)</span></span>;<br>&#125;;<br><span class="hljs-comment">// RealPerson为Person的具象派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPerson</span>:<span class="hljs-keyword">public</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealPerson</span>(<span class="hljs-type">const</span> string&amp; name)<br>        :<span class="hljs-built_in">theName</span>(name)<br>        &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RealPerson</span>() &#123;&#125;;<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    string theName;<br>&#125;<br><span class="hljs-comment">//Person::create的实现</span><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">Person::create</span><span class="hljs-params">(string&amp; name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealPerson</span>(name));<br>&#125;<br><span class="hljs-comment">//客户使用</span><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">p</span><span class="hljs-params">(Person::create(name))</span></span>;<br></code></pre></td></tr></table></figure><p>Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性，但也需要付出运行期速度和若干内存的代价。</p><br><br><h1 id="六-继承与面向对象设计"><a href="#六-继承与面向对象设计" class="headerlink" title="六.继承与面向对象设计"></a>六.继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h2><p><strong>public继承隐含的寓意</strong>：每个派生类对象同时也是一个基类对象(反之不成立)，只不过基类比派生类表现出更一般化的概念，派生类比基类表现出更特殊化的概念。</p><p>可以举一个例子验证一下上面的说法。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>显然，每个学生都是人，但并非每个人都是学生。对人可以成立的每一件事对学生也都成立（例如每个人都有生日），但对学生都成立的每件事并不一定对每个人也成立(例如注册于某个学校)。</p><p>因此，C++中，任何函数如果期望获得一个类型为基类的实参，都也愿意接收一个派生类对象。但是反之不成立：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;s)</span></span>;<br>Person p;<br>Student s;<br><span class="hljs-built_in">eat</span>(p);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">eat</span>(s);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(s);   <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(p);   <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>谨记<strong>public继承</strong>和<strong>is-a</strong>之间的等价关系以及背后隐藏的规则可以防止因为“经验主义”而使用不合理的public继承：</p><ul><li>从“经验主义”上看，企鹅也是鸟，如果为鸟定义了虚拟(virtual)的飞的方法，然后企鹅类以public继承鸟类，那么是不合理的方式。这种情况下，可以设计一个会飞的鸟的类，虚拟(virtual)的飞的方法声明在这个类中，而鸟类里面没有声明飞的方法。或者根本不声明飞的方法</li><li>从“经验主义”上看，正方形也是矩形，如果矩形有成员方法会修改长或宽，那么正方形以public继承矩形就显得不合理。某些可施行于矩形身上的事情却不可施行于正方形身上</li></ul><p>软件世界不同于现实世界。对于上面的鸟的设计，某些软件系统可能不需要区分会飞的鸟和不会飞的鸟。那么即使鸟类声明了飞的方法，然后企鹅类以public继承，也不会有多大问题。也就是说，不存在一个适用于所有软件的设计。最佳的设计取决于系统希望做什么事，包括现在和未来。如果程序对飞行一无所知，而且也不打算未来对飞行有所知，那么不去区分会飞的鸟和不会飞的鸟不失为一个完美而有效的设计。实际上可能比对两者做出区隔的设计更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。因此，<strong>应该根据实际软件需求，合理使用public</strong>。</p><blockquote><ul><li>“public继承”意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</li><li>private继承的意义与此完全不同（条款39）。</li></ul></blockquote><br><h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><h3 id="1）继承中的作用域嵌套"><a href="#1）继承中的作用域嵌套" class="headerlink" title="1）继承中的作用域嵌套"></a>1）继承中的作用域嵌套</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160411.png"  /><p>名字查找会从内层作用域向外层作用域延伸，仅与名称有关，和pure virtual，impure virtual和non-virtual等其他无关。</p><h3 id="2）名称遮掩会遮掩基类所有重载版本"><a href="#2）名称遮掩会遮掩基类所有重载版本" class="headerlink" title="2）名称遮掩会遮掩基类所有重载版本"></a>2）名称遮掩会遮掩基类所有重载版本</h3><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160438.png"></p><p>派生类中同名的名称会遮掩基类中相同的名称，如果基类包含重载函数，所有重载函数都会被遮掩。即base class内所有mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉了。</p><p>如果正在使用public继承而又不继承那些重载函数，就是违反base和derived classes之间的<strong>is-a</strong>关系。几乎总是想要推翻C++对“继承而来的名称”的缺省遮掩行为。解决办法是使用using引入被遮掩的名字：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160513.png"></p><p>意味着如果继承base class并加上重载函数，而又希望重新定义或覆写其中一部分，那么必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些希望继承的名称会被遮掩。</p><p>如果只想引入基类被遮掩函数中某个版本（注意，这种需求一般只在private继承中出现，因为如果只继承基类的部分操作，违反了<a href="#%E6%9D%A1%E6%AC%BE32%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32</a>）using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。我们需要不同的技术，可以直接定义一个同名同参的函数，然后在这个函数内调用基类的版本，做一个转调用（即转交函数）：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160539.png"></p><br><h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><blockquote><p>pure virtual函数一般作为接口，基类一般不提供定义，但是基类可以为纯虚函数提供定义。派生类必须声明纯虚函数，如果想要使用纯虚函数，派生类必须提供一份定义，即使基类已经为该纯虚函数提供了定义。如果派生类不提供定义，仍然是一个抽象基类。</p></blockquote><p>函数接口继承和函数实现继承不同。在public继承之下，derived classes总是继承base class的成员函数的接口（条款32）。</p><ol><li><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口</strong></li><li><strong>声明(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现</strong></li><li><strong>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现</strong></li></ol><h3 id="1）pure-virtual函数"><a href="#1）pure-virtual函数" class="headerlink" title="1）pure virtual函数"></a>1）pure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且没有相同的缺省实现，那么应该使用pure virtual函数，此时派生类只继承接口。此外，它可以实现一种机制，为impure virtual函数提供更平常更安全的缺省实现。</p><h3 id="2）impure-virtual函数"><a href="#2）impure-virtual函数" class="headerlink" title="2）impure virtual函数"></a>2）impure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且具有相同的缺省实现，那么应该使用impure virtual函数，此时派生类继承接口和缺省实现。</p><p><strong>但是，允许impure virtual函数同时指定函数声明和缺省行为，却可能造成危险：假设引入了一个新的派生类，但是缺省行为并不适用于新的派生类，而新的派生类忘记重新定义新的行为，那么调用该操作将表现出缺省行为，这是不合理的</strong>。</p><p>例如，某个航空公司有A,B两种类型的飞机，他们有相同的fly行为，这个fly行为在基类Airplane中声明为impure virtual函数，并且具有缺省的飞行实现。现在引入了一种新机型C，但是这个缺省的fly行为并不适合C，如果C忘记重新定义fly，那么它将按照A,B缺省的行为飞行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 缺省的fly代码</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br>Airplane* p = <span class="hljs-keyword">new</span> ModelC;<br>p-&gt;<span class="hljs-built_in">fly</span>();   <span class="hljs-comment">//调用Airplane::fly</span><br></code></pre></td></tr></table></figure><p>a）要避免这种错误，可以将fly改为pure virtual函数，并且将缺省的飞行行为实现为一个protected函数，且为non-virtual函数。若想使用缺省实现，可以在其fly函数中对defaultFly做一个inline调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//这是合理的，因为它是Airplane及其derived classes的实现细目。乘客应该只在意飞机能不能飞，不在意它怎么飞</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//non-virtual函数，因为没有任何一个派生类应该重新定义缺省行为</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，fly变成了pure virtual函数，ModelC class不可能意外继承不正确的fly实现代码了，因为飞机C必须声明fly函数，如果需要使用，必须为其定义。那么就可以防止因为忘记重新定义而引起的错误。</p><p>b）有些人反对以不同函数分别提供接口和缺省实现，像上面的fly和defaultFly。因为他们关心因过渡雷同函数名称而引起的class命名空间污染问题。可以利用“pure virtual函数必须在derived classes中重新声明，但它们也可以拥有自己的实现”这一事实，将缺省的行为定义在fly中，即为fly实现一份缺省的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//pure virtual</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//pure virtual函数实现</span><br>    <span class="hljs-comment">// 缺省的fly代码</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        Airplane::<span class="hljs-built_in">fly</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>:<span class="hljs-keyword">public</span> Airplane&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//自己的实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在的fly被分割为两个基本要素：其声明部分表现的是接口（那是derived classes必须使用的），其定义部分则表现出缺省行为（那是derived classes可能使用的，但只有在它们明确提出申请时才是）。如果合并fly和defaultFly，就丧失了“让两个函数享有不同保护级别”的机会：被设为protected的函数（defaultFly）如今成了public（因为它在fly之中）。</p><h3 id="3）non-virtual函数"><a href="#3）non-virtual函数" class="headerlink" title="3）non-virtual函数"></a>3）non-virtual函数</h3><p>如果成员函数是个non-virtual函数，意味是它并不打算在derived classes中有不同的行为。实际上一个non-virtual成员函数所表现的不变性凌驾其特异性，因为它表示不论derived class变得多么特异化，它的行为都不可以改变。此时派生类继承接口和一份强制性实现。</p><br><h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><blockquote><p>在面向对象中，如果希望某个操作函数存在缺省行为，并且各派生类可以定制适合自己的操作。可以使用public virtual函数，这是最简单直白且容易想到的方法，但是除此之外，也存在其它可替代的方案。它们有各自的优缺点，应该将所有方案全部列入考虑。</p></blockquote><p>以一个例子来介绍其它几种可替代方案。在一个游戏人物的类中，存在一个健康值计算的函数，不同的角色可以提供不同的健康值计算方法，并且存在一个缺省实现。以传统的public virtual函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//健康值计算函数，派生类可以重新定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1）藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#1）藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="1）藉由Non-Virtual Interface手法实现Template Method模式"></a>1）藉由Non-Virtual Interface手法实现Template Method模式</h3><p>这种方案的主要思想是：保留healthValue为public成员函数，但是让其成为non-virtual，并调用一个private(也可以是protected) virtual函数进行实际工作。即以public non-virtual成员函数包裹较低访问性（private或protected）的virtual函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的外覆器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...                             <span class="hljs-comment">//做一些事前工作</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();   <span class="hljs-comment">//负责真正的健康值计算</span><br>        ...                             <span class="hljs-comment">//做一些事后工作</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">//派生类可以重新定义</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...     <span class="hljs-comment">//缺省的健康值计算方法，缺省算法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>NVI（non-virtual interface）手法的一个优点是外覆器确保得以在一个virtual函数被调用之前设定好适当场景，并在调用结束之后清理场景。如“事前”进行一些锁的分配，日志记录。“事后”进行解锁等操作。NVI手法允许derived classes重新定义virtual函数，从而赋予它们“如何实现机能”的控制能力，但base class保留诉说“函数何时被调用”的权利。</p><h3 id="2）藉由Function-Pointers实现Strategy模式"><a href="#2）藉由Function-Pointers实现Strategy模式" class="headerlink" title="2）藉由Function Pointers实现Strategy模式"></a>2）藉由Function Pointers实现Strategy模式</h3><p>上面的方案本质还是使用virtual函数，人物的健康值计算(操作)还是与人物(类)相关。另一个设计主张“人物健康指数的计算与任务类型无关”，这样的计算完全不需要“人物”这个成分。例如可能要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际的计算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个做法提供了一些弹性：</p><ul><li>同一人物类型之不同实体可以有不同的健康计算函数</li><li>某已知人物之健康指数计算函数可在运行期变更</li></ul><h3 id="3）藉由tr1-function完成Strategy模式"><a href="#3）藉由tr1-function完成Strategy模式" class="headerlink" title="3）藉由tr1::function完成Strategy模式"></a>3）藉由tr1::function完成Strategy模式</h3><p>这种方案是前一种的加强，将函数指针改成任何可调用对象。因此允许使用任何与可调用声明相兼容(即可以通过类型转换与声明相符)的可调用物（也就是函数指针、函数对象、或成员函数指针）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//现在，类型HealthCalcFunc从函数指针变成了可调用物</span><br>    <span class="hljs-keyword">typedef</span> std::tr1::function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4）古典的Stategy模式"><a href="#4）古典的Stategy模式" class="headerlink" title="4）古典的Stategy模式"></a>4）古典的Stategy模式</h3><p>传统的Stategy模式做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数，设计结果看起来像这样:</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160609.png"></p><p>每一个GameCharacter对象都内含一个指针，指向一个来自HealthCalcFunc继承体系的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCalcFunc</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">cacl</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span> <span class="hljs-type">const</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br><span class="hljs-comment">//创建一个HealthCalcFunc对象，可以通过它调用缺省的健康值计算方法</span><br>HealthCalcFunc defaultHealthCalc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pHealthCalc-&gt;<span class="hljs-built_in">cacl</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc *pHealthCalc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个方案的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可。</p><br><h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p>从规范上说，<a href="#%E6%9D%A1%E6%AC%BE34%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34</a>提到，如果某个操作在整个继承体系应该是不变的，那么使用non-virtual函数，此时派生类从基类继承接口以及一份强制实现。如果派生类希望表现出不同行为，那么应该使用virtual函数。</p><p>另一方面，假设真的重新定义了继承而来的non-virtual函数，会表现出下列令人困惑的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//重新定义了继承而来的non-virtual函数</span><br>&#125;;<br><br>D x;<br>B *pB = &amp;x;<br>D *pD = &amp;x;<br><br>pB-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用B::mf</span><br>pD-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用D::mf</span><br></code></pre></td></tr></table></figure><p>你可能会觉得因为pB和pD指向的是相同的对象，因此调用的non-virtual函数也应该相同，但是事实并非如此。因为<strong>non-virtual函数是静态绑定</strong>，因此实际上调用的函数决定因素不在对象自身，而在于“指向该对象之指针（或引用）”当初的声明类型。virtual函数才是动态绑定。</p><p>任何情况下都不该重新定义一个继承而来的non-virtual函数。</p><br><h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p><a href="#%E6%9D%A1%E6%AC%BE36%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0">条款36</a>论述了non-virtual函数不应该被重新定义，那么non-virtual函数中的参数也就不存在被重新定义的机会。因此这里主要针对的是“继承一个缺省参数值的virtual函数”。</p><blockquote><ul><li>对象的所谓静态类型，就是它在程序中被声明时所采用的类型</li><li>对象的所谓动态类型则是指“目前所指对象的类型”</li></ul></blockquote><p>绝对不要重新定义一个继承而来的缺省参数值。<strong>原因就在于，virtual函数是动态绑定，而缺省参数值却是静态绑定</strong>。所以你可能调用了一个定义于派生类内的virtual函数的同时，却使用base class为它所指定的缺省参数值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br>Rectangle r;<br>Circle c;<br><br>r.<span class="hljs-built_in">draw</span>();           <span class="hljs-comment">//调用Rectangle::draw，静态类型为Rectangle，所以缺省参数为Shape::Green</span><br><span class="hljs-comment">//c.draw();         //调用Circle::draw，静态类型为Circle，没有缺省参数，因此错误，必须显式指定！</span><br><br>Shape *pr = &amp;r;<br>Shape *pc = &amp;c;<br><br><span class="hljs-comment">//以下为容易引起困惑的地方，函数与参数不一致</span><br>pr-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Rectangle::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br>pc-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Shape::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br></code></pre></td></tr></table></figure><p>但是，即使派生类严格遵循基类的缺省参数，也存在问题：当基类的缺省参数发生变化时，派生类的所有缺省参数也需要跟着修改。因此，<strong>本质在于，不应该在virtual函数中使用缺省参数</strong>，如果有这样的需求，那么这种场景就适合使用<a href="#">条款35</a>中，public virtual函数的几种替代方案，比如NVI手法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-comment">//此时，带缺省参数的已经不是virtual函数，是个non-virtual</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">doDraw</span>(color);  <span class="hljs-comment">//调用一个virtual</span><br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//完成真正的工作</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于non-virtual函数应该绝对不被derived classes覆写，这个设计使得draw函数的color缺省参数值总是为Red。</p><br><h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><blockquote><p>复合是类型间的一种关系，当某种类型的对象含有另一种类型的对象，便是这种关系</p></blockquote><p>在应用域，复合意味着has-a(有一个)。在实现域，复合意味着is-implemented-in-terms-of(根据某物实现出)。</p><ul><li><p>has-a：</p><p>  程序中的对象相当于所塑造的世界中的某些事物，例如人、汽车、视频画面等等。这样的对象属于应用域。下面的例子中，Person有一个名称，一个地址，以及语音和传真两笔电话号码。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    Address address;<br>    PhoneNumber voiceNumber;<br>    PhoneNumber faxNumber;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>根据某物实现出：</p><p>  其他对象纯碎是实现细节上的人工制品，像是缓冲区、互斥器、查找树等。这些对象相当于软件的实现域。下面的例子中，由于每个栈只能从栈顶压入弹出元素，而队列不同，is-a的性质是所有对基类为true的操作，对派生类也应该为true。所以stack不应该通过public继承deque来实现。正确的做法是，stack对象可根据一个deque对象实现出来。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack &#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>  Sequence c;   <span class="hljs-comment">//底层容器</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>上面两者情况都应该使用复合，而不是public继承。</p><br><h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><p><strong>private继承和public继承的不同之处</strong>：</p><ul><li><p>编译器不会自动将一个derived class对象（例如Student）转换为一个base对象（例如Person）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// private继承</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;                 <span class="hljs-comment">// 任何人都会吃</span><br>Person p;                                  <span class="hljs-comment">// p是人</span><br>Student s;                                 <span class="hljs-comment">// s是学生</span><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 没问题，p是人，会吃</span><br><span class="hljs-built_in">eat</span>(s);                                    <span class="hljs-comment">// 错误！难道学生不是人？！</span><br></code></pre></td></tr></table></figure><p>  如果使用public继承，编译器在必要的时候可以将Student隐式转换成Person，但是private继承时不会，所以eat(s)调用失败。从这个例子中表达了，private继承并不表现出is-a的关系。</p></li><li><p>由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性</p></li></ul><p><strong>private继承的意义</strong>：</p><p><strong>private继承意味implemented-in-terms-of（根据某物实现出）</strong>。如果让class D以private形式继承class B，用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在有任何观念上的关系。private继承纯碎只是一种实现技术。private继承意味只有实现部分被继承，接口部分应略去。如果D以private形式继承B，意思是D对象根据B对象实现而得，再没有其他意涵了。</p><p><a href="#%E6%9D%A1%E6%AC%BE38%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA">条款38</a>指出，复合也意味”is-implemented-in-terms-of”，那么如何取舍？</p><h3 id="1）private继承"><a href="#1）private继承" class="headerlink" title="1）private继承"></a>1）private继承</h3><p>假设Widget类需要执行周期性任务，于是希望继承Timer的实现。 因为Widget不是一个Timer，所以选择了private继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 每滴答一次，该函数就被自动调用一次</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 查看Widget的数据...等等</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在Widget中重写虚函数onTick，使得Widget可以周期性地执行某个任务。</p><p>通过private继承来表现”is-implemented-in-terms-of”关系实现非常简单，而且下列情况也只能使用这种方式：</p><ul><li>当Widget需要访问Timer的protected成员时。因为对象组合后只能访问public成员，而private继承后可以访问protected成员。</li><li>当Widget需要重写Timer的虚函数时。比如上面的例子中，需要重写onTick。单纯的复合是做不到的</li></ul><h3 id="2）复合"><a href="#2）复合" class="headerlink" title="2）复合"></a>2）复合</h3><p>如果使用复合，上面的例子可以这样实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    &#125;;<br>    WidgetTimer timer;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过复合来表现”is-implemented-in-terms-of”关系，实现较为复杂，但是具有下列优点：</p><ul><li>如果希望阻止Widget的子类重定义onTick。因为派生类无法访问私有的WidgetTimer类</li><li>可以减小Widget和Timer的编译依存性。如果是private继承，在定义Widget的文件中势必需要引入#include Timer.h。 但如果采用复合的方式，可以把WidgetTimer放到另一个文件中，Widget内含指针指向一个WidgetTimer，Widget可以只带一个WidgetTimer声明式</li></ul><h3 id="3）激进情况"><a href="#3）激进情况" class="headerlink" title="3）激进情况"></a>3）激进情况</h3><p>有一种激进情况设计空间最优化，促使选择“private继承”而不是“继承加复合”。这个特殊情况只适用于你所处理的class不带任何数据时。</p><p>所谓的empty classes：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;  <span class="hljs-comment">//没有数据，所以其对象应该不使用任何内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldsAnInt</span>&#123;    <span class="hljs-comment">//应该只需要一个int空间</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    Empty e;    <span class="hljs-comment">//应该不需要任何内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然而<strong>C++裁定凡是独立（非附属）对象都必须有非零大小</strong>，通常安插一个char到空对象中。所以sizeof(HoldsAnInt)&gt;sizeof(int)。</p><p>这个约束不适用于derived class对象内的base class成分，因为它们并非独立（非附属）。如果继承Empty，而不是内含一个那种类型的对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldsAnInt</span>:<span class="hljs-keyword">private</span> Empty&#123;    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以确定sizeof(HoldsAnInt)&#x3D;&#x3D;sizeof(int)。这是所谓的EBO（empty base optimization；空白基类最优化）。EBO一般只在单一继承（而非多重继承）下才可行。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>总的来说，在需要表现”is-implemented-in-terms-of”关系时。如果一个类需要访问另一个的protected成员，或需要重新定义其一个或多个virtual函数，private继承极有可能成为正统设计策略。一个混合了public继承和复合的设计，往往能够释出你要的行为，尽管有较大的复杂度。“明智而审慎地使用private继承”意味，在考虑过所有其它方案后，如果仍然认为private继承是最佳办法，才使用它。</p><br><h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>使用多重继承时，程序可能从一个以上的base classes继承相同名称（如函数、typedef等等）。那会导致较多的歧义（即使一个名字public，另一个private）。</p><blockquote><p>在看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。</p></blockquote><p>一般有两种方式使用多重继承：</p><ul><li><p>一般的多重继承：缺省做法是执行复制</p><ul><li>如果某个基类到派生类之间存在多条路径，那么派生类会包含重复的基类成员。IOFile存在两份File数据</li></ul><p>  <img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160646.png"></p></li><li><p>虚继承（此时基类是虚基类）</p><ul><li>某个基类到派生类之间存在多条路径，虚继承使得派生类只包含一份基类成员，但是这会带来额外开销<ul><li>为避免重复，编译器必须提供一些机制，后果就是virtual继承的那些classes所产生的对象往往比使用non-virtual继承的体积大，访问virtual base classes的成员变量时，速度也更慢</li><li>virtual base的初始化由继承体系中的最低层class负责，这暗示<ul><li>classes若派生自virtual bases而需要初始化，必须认知其virtual bases——无论那些bases距离多远</li><li>当一个新derived class加入继承体系中，它必须承担其virtual bases的初始化责任</li></ul></li></ul></li><li>如果virtual base classes不带任何数据，将是最具实用价值的情况</li></ul><p>  <img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160727.png"></p></li></ul><p>如果你有一个单一继承的设计方案，而它大约等价于一个多重继承方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候是完成任务的最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎的情况下使用它。</p><p>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。</p><br><br><h1 id="七-模板与泛型编程"><a href="#七-模板与泛型编程" class="headerlink" title="七.模板与泛型编程"></a>七.模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><blockquote><p>编译期多态：以不同的template参数具现化function templates会导致调用不同的函数。</p></blockquote><p>面向对象设计中的类（class）考虑的是显式接口（explicit interface）和运行时多态， 而模板编程中的<strong>模板（template）考虑的是隐式接口（implicit interface）和编译期多态</strong>。</p><ul><li>对类而言，显式接口是由函数签名（也就是函数名称、参数类型、返回类型）表征的，多态则是通过virtual函数发生于运行期</li><li>对模板参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期</li></ul><br><h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>声明template参数时，前缀关键字class和typename的意义完全相同，可互换。</p><p>以下代码中，typename和class等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure><p>但是如果在template中，遇到嵌套从属名称，需要明确声明是一种类型时，必须使用typename。</p><blockquote><p>template内出现的名称如果相依于某个template参数，称之为从属名称。如果从属名称在class内呈嵌套状，称它为嵌套从属名称。</p></blockquote><p>嵌套从属名称有可能导致解析困难。</p><p>考虑如下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>我们认为C::const_iterator表示容器C的迭代器类型，因此上述代码定义一个该迭代器类型的指针。但是这是一种先入为主的思想。如果C::const_iterator不是一个类型呢？比如恰巧有个static成员变量被命名为const_iterator，或如果x碰巧是个global变量名称？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作。</p><p>C++有个规则可以解析这种歧义：如果解析器在template中遭遇一个嵌套从属名称，它<strong>便假设这名称不是个类型</strong>，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。那么怎么告诉它是一个类型，当然就是typename了，所以上述代码应该像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一般性规则是：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。</strong>（注意：typename只被用来验明嵌套从属类型名称，其他名称不该有它存在）。</p><p>上述规则有两个例外：</p><ol><li><strong>typename不可以出现在base classes list内的嵌套从属名称之前</strong></li><li><strong>typename也不可出现在成员初始值列表中作为base class修饰符</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="hljs-comment">//typename不可出现在此</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">explict <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //typename也不可出现在此</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;  <span class="hljs-comment">//嵌套从属类型名称，这里必须使用typename</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; container)</span></span>;  <span class="hljs-comment">//非嵌套从属类型，不允许使用typename</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>typename相关规则在不同的编译器上有不同的实践。某些编译器接收的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属类型名称”之间的互动，也许会在移植性方面给你带来一些麻烦。</p><br><h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>假设以下MsgSender类可以通过两种方式发送信息到各个公司：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//1.发送原始文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...<br>        Company c;<br>        c.<span class="hljs-built_in">sendCleartext</span>(...);   <br>    &#125;<br>    <span class="hljs-comment">//2.发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设我们有时候想要在每次送出信息时志记(log)某些信息。因此有了以下派生类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);             <span class="hljs-comment">//调用base class函数，无法通过编译</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>问题在于，当编译器遭遇class template LoggingMsgSender定义式时，并不知道它继承什么样的class。Company是个template参数，不到后来无法确切知道它是什么。</p><p>假设有一个公司CompanyZ只支持加密传送，那么泛化的MsgSender就不适合，因此需要为其产生一个特化版的MsgSender：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">//特化版，所谓的模板全特化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//只支持发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>当base class被指定为MsgSender<CompanyZ>时，其内不包含sendClear方法，那么derived class LoggingMsgSender的sendClearMsg方法就会调用不存在的sendClear。</p><p><strong>因此，正是因为知道base class templates有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此C++往往拒绝在templatized base classes（模板化基类，本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear）</strong>。</p><p><strong>解决办法有3个，它们会通知编译器:进入base class作用域查找继承而来的名称</strong>：</p><ol><li><p>在base class函数调用动作之前加上<strong>this-&gt;</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用using</strong>声明式</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//告诉编译器，请它假设sendClear位于base class内</span><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>通过作用域符明确指出</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(...);  <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p> 这种方法往往最不让人满意，因为如果被调用的是virtual函数，这样会关闭“virtual绑定行为”。</p></li></ol><p>上述每一种解法做的事情都相同：对编译器承诺“base class template的任何特化版本都将支持其一般（泛化）版本所提供的接口”。</p><p>要注意的是，它们只是通知编译器进去查找。如果找到了自然是没问题。但是如同上面的CompanyZ，如果基类还是不存在相应名称，编译器还是会报错。</p><br><h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><p>模板提供的是编译期的多态， 即使你的代码看起来非常简洁短小，生成的二进制文件也可能包含大量的冗余代码。 因为模板每次实例化都会生成一个完整的副本，所以其中与模板参数无关的部分会造成代码膨胀。</p><p>把模板中参数无关的代码重构到模板外便可以有效地控制模板产生的代码膨胀：</p><ul><li><p><strong>对于非类型模板参数造成的代码膨胀，以函数参数或class成员变量替换模板参数即可消除冗余</strong></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非类型模板参数造成代码膨胀</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//求逆矩阵</span><br>&#125;;<br><span class="hljs-comment">//以下会实例化两个类：Square&lt;double, 5&gt;和Square&lt;double, 10&gt;</span><br><span class="hljs-comment">//会具现化两份invert。除了常量5和10，两个函数的其它部分完全相同</span><br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; s1;<br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; s2;<br>s1.<span class="hljs-built_in">invert</span>();<br>s2.<span class="hljs-built_in">invert</span>();<br><span class="hljs-comment">//以下，使用函数参数消除重复</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareBase</span>&#123;<br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-comment">//以下函数只是作为避免代码重复的方法，并不应该被外界调用，</span><br>    <span class="hljs-comment">//同时，该函数希望被子类调用，因此使用protected</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>:<span class="hljs-keyword">private</span> SquareBase&lt;T&gt;&#123;<span class="hljs-comment">//只要T相同，都会使用同一份父类实例，</span><br><span class="hljs-keyword">private</span>:                           <span class="hljs-comment">//因此，只有一份invert(int size)</span><br>    <span class="hljs-keyword">using</span> SquareBase&lt;T&gt;::invert; <span class="hljs-comment">//避免遮掩base版的invert</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//调用父类invert的代价为零，因为Square::invert是隐式的inline函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  最后是父类如何访问矩阵数据。原本这些数据在派生类中，但是因为invert核心代码转移到了父类，那么父类必须有办法访问这些数据。可以在调用SquareBase::invert时把内存地址也一起告知父类，但如果矩阵类中有很多函数都需要这些信息就需要为每个函数添加一个这样的参数。因此，可以把数据地址直接放在父类中。</p></li><li><p><strong>对于类型模板参数造成的代码膨胀，做法是让带有完全相同二进制表述的具体类型共享实现码</strong></p><ul><li>int和long在多数平台都是一样的底层实现，然而模板却会实例化为两份，因为它们类型不同</li><li>List&lt;int *&gt;, List&lt;const int *&gt;, List&lt;double *&gt;的底层实现也是一样的。但因为指针类型不同，也会实例化为多份模板类<br>  如果某些成员函数操作强型指针(T*)，应该令它们调用另一个操作无类型指针(void*)的函数，由后者完成实际工作。</li></ul></li></ul><br><h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>需要使用成员函数模板的一个例子是构造函数和copy赋值运算符。</p><p>例如，假设SmartPtr是一种智能指针，并且它是一个template class。现在有一个继承体系：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Top &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span> : <span class="hljs-keyword">public</span> Middle &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>现在希望通过一个SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;来初始化一个SmartPtr&lt;Top&gt;。如果是指针，即Middle*和Bottom*可以隐式转换成Top*，问题是：<strong>同一个template的不同具现体之间不存在什么与生俱来的固有关系，即使具现体之间具有继承关系</strong>。因此，SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;并不能隐式转化成SmartPtr&lt;Top&gt;。因此，我们需要一个构造函数模板（也称为泛化构造函数），来实现这种转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数模板</span><br>    <span class="hljs-comment">//意思是：对任何类型T和任何类型U，可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt; &amp;other)</span>  <span class="hljs-comment">//以other的heldPtr初始化this的heldPtr</span></span><br><span class="hljs-function">     : heldPtr(other.get()) &#123;</span>...&#125;<br>    <span class="hljs-comment">//原始指针为private成员，需要一个接口来获取</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    T* heldPtr;   <span class="hljs-comment">//智能指针所持有的原始指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们当然不希望一个SmartPtr&lt;Top&gt;可以转化成SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs heldPtr(other.get())```为此提供了保证。这个行为只有当“存在某个隐式转换可将一个U\*指针转为一个T\*指针”时才能通过编译。"><br>最后需要指明的是：**member templates并不改变语言规则**，而语言规则说，如果程序需要一个copy构造函数，你却没声明它，编译器会为你暗自生成一个。因此，如果你想要控制copy构造的方方面面，你必须同时声明泛化的copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值（assignment）操作。<br><br>&lt;br&gt;<br><br>## 条款46：需要类型转换时请为模板定义非成员函数<br><br>**template实参推导过程中从不将隐式类型转换函数纳入考虑**，下面的例子将[条款24](#条款24若所有参数皆需类型转换请为此采用non-member函数)中的Rational和operator\*改成了template，混合运算会编译错误：<br><br>```c++<br>template&lt;typename T&gt;<br>class Rational&#123;<br>public:<br>    Rational(const T &amp;numerator = 0, const T &amp;denominator = 1);<br>    const T numerator() const;<br>    const T denominator() const;<br>    ...<br>&#125;;<br><br>template&lt;typename T&gt;<br>const Rational&lt;T&gt; operator*(const Rational&lt;T&gt; &amp;lhs,const Rational&lt;T&gt; &amp;rhs)<br>&#123; ... &#125;<br><br>Rational&lt;int&gt; oneHalt(1,2);<br>Rational&lt;int&gt; result = oneHalf * 2   //编译错误<br></code></pre></td></tr></table></figure><p>将oneHalf传递给operator*时，它将T推断为int，因此期待第二个参数也为Rational，但是第二个参数为int，前面我们说了，template实参推导过程中从不将隐式类型转换函数纳入考虑。因此编译错误。</p><p>那么解决办法是什么？在class template将其声明为friend，从而具现化一个operator*，具现化后就可以不受template的限制了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//也可以是Rational&lt;T&gt;，但是省去&lt;T&gt;更简洁</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.numerator,<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果上面只有函数声明，而函数定义在类外，那么会报链接错误。当传入第一个参数oneHalt时，会具现化Rational&lt;int&gt;，编译器也就知道了我们要调用传入两个Rational&lt;int&gt;的版本，但是那个函数只在类中进行了声明，并没有定义，不能依赖类外的operator* template提供定义，我们必须自己定义，所以会出现链接错误。解决方法就是像上面一样定义于类内。</p><p>这样看起来有点像是member函数，但是因为friend关键字，所以实际是non-member函数，如果去掉friend关键字，就成了member函数，但是此时参数也只能有1个，就不能让类型转换可能发生于所有实参身上。</p><p>上面的代码可能还有一个问题，虽然有friend，上述函数仍是隐式的inline。如果函数实体代码量较大，可以令operator*不做任何事，只调用一个定义于class外部的辅助函数（当然这里没必要，因为本身只有1行）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;<br><br><span class="hljs-comment">//helper template</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs);<span class="hljs-comment">//令friend调用helper</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。</p><br><h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><ul><li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现</li><li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试</li></ul><p>详细实现可参考 STL源码分析 中对traits的介绍。</p><br><h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2><ul><li>Template metaprogramming(TMP，模板元编程)是编写template-based C++程序并执行于编译期的过程</li><li>Template metaprogram(模板元程序)是以C++写成、执行于C++编译器内的程序</li></ul><p><strong>TMP的两个重要特点：1）基于template；2）编译期执行</strong></p><p>TMP有2个伟大的效力：</p><ol><li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的</li><li>执行于编译期，因此可将工作从运行期转移到编译期。会导致以下几个结果<ul><li>某些原本在运行期才能侦测到的错误现在可在编译期找出来</li><li>使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求</li><li>编译时间变长了</li></ul></li></ol><p>traits解法就是TMP，traits引发“编译器发生于类型身上的if…else计算”</p><p>另一个TMP的例子是循环，TMP并没有真正的循环构件，所以循环效果藉由递归完成。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函数调用，而是涉及“递归模板具现化”。以在编译期计算阶乘为例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&#123;    <span class="hljs-comment">//一般情况，Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;的值</span><br>    <span class="hljs-keyword">enum</span> &#123;value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt;&#123;    <span class="hljs-comment">//特殊情况：Factorial&lt;0&gt;的值是1</span><br>    <span class="hljs-keyword">enum</span> &#123;value = <span class="hljs-number">1</span>;&#125;<br>&#125;;<br><span class="hljs-comment">//可以这样使用Factorial</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value;    <span class="hljs-comment">//打印120</span><br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;   <span class="hljs-comment">//打印3628800</span><br>&#125;<br></code></pre></td></tr></table></figure><p>TMP还有许多用途，可以达成以下三个目标（这部分可以等有实际需求了再去详细了解）：</p><ul><li>确保量度单位正确</li><li>优化矩阵运算</li><li>可以生成客户定制之设计模式实现品</li></ul><br><br><h1 id="八-定制new和delete"><a href="#八-定制new和delete" class="headerlink" title="八.定制new和delete"></a>八.定制new和delete</h1><ul><li>operator new和operator delete只适合用来分配单一对象</li><li>Arrays所用的内存由operator new[]分配出来，并由operator delete[]归还</li><li>STL容器所使用的heap内存是由容器所拥有的分配器对象（allocator objects）管理，不是被new和delete直接管理</li></ul><h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>当operator new无法满足某一内存分配需求时，它会抛出异常。当operator new抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，一个所谓的new-handler。为了指定这个“用以处理内存不足”的函数，客户必须调用<code>std::set_new_handler()</code>，<code>std::set_new_handler()</code>声明在&lt;new&gt;中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-comment">//以上，throw()是一个异常声明，括号内无任何内容，表示该函数不抛出任何异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。一个设计良好的new-handler函数必须做以下事情；</p><ul><li><strong>让更多内存可被使用</strong>：一个做法是程序一开始执行就分配一大块内存，而后当new-handler第一次被调用，将它们释还给程序使用。这便造成operator new内的下一次内存分配动作可能成功</li><li><strong>安装另一个new-handler</strong>：如果当前new-handler无法取得更多可用内存，可用安装另一个，下次operator new时会调用新的new-handler</li><li><strong>卸除new-handler</strong>：将null指针传给set_new_handler</li><li><strong>抛出bad_alloc(或派生自bad_alloc)的异常</strong>：这样的异常不会被operator new捕获，因此会被传播到内存索求处</li><li><strong>不返回</strong>：通常调用abort或exit（abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort）</li></ul><h3 id="实现class专属的new-handlers"><a href="#实现class专属的new-handlers" class="headerlink" title="实现class专属的new-handlers"></a>实现class专属的new-handlers</h3><p>这个设计的base class部分让derived class继承它们所需的set_new_handler和operator new，而template部分则确保每一个derived class获得一个实体互异的current成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerHolder</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span><span class="hljs-params">(std::new_handler nh)</span>: handler(nh)&#123;</span>&#125; <span class="hljs-comment">//取得目前的new_handler</span><br>    ~<span class="hljs-built_in">NewHandlerHolder</span>()&#123; std::<span class="hljs-built_in">set_new_handler</span>(handler); &#125; <span class="hljs-comment">//释放它</span><br><span class="hljs-keyword">private</span>:<br>    std::new_handler handler;<br>    <span class="hljs-built_in">NewHandlerHolder</span>(<span class="hljs-type">const</span> HandlerHolder&amp;);     <span class="hljs-comment">// 禁用拷贝构造函数</span><br>    <span class="hljs-type">const</span> NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NewHandlerHolder&amp;); <span class="hljs-comment">// 禁用赋值运算符</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">//“mixin”风格的base class，用以支持class专属的set_new_handler</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::new_handler current;   <span class="hljs-comment">//class专属的new-handlers</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">throw</span>()&#123;<br>    std::new_handler old = current;<br>    current = p;    <span class="hljs-comment">//将class专属的new-handlers设置为新的new_handler</span><br>    <span class="hljs-keyword">return</span> old;     <span class="hljs-comment">//返回旧的class专属的new-handlers</span><br>&#125;<br><br><span class="hljs-comment">//new时会调用该operator new</span><br><span class="hljs-comment">//它会设置全局的new-handlers为该class专属的new-handlers，然后调用全局operator new申请内存</span><br><span class="hljs-comment">//h对象销毁后，其析构函数会将全局new-handlers恢复为调用前的状态</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> * NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>&#123;<br>    <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(std::set_new_handler(current))</span></span>;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>&#125;<br><br><span class="hljs-comment">//以下将每一个current初始化为null</span><br><span class="hljs-comment">//class专属的new-handlers初始化为null</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::current = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>有了<code>NewHandlerSupport</code>这个模板基类后，给Widget添加set_new-handler支持只需要public继承即可:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123; ... &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>class。Template机制会自动为每一个T（NewHandlerSupport赖以具现化的根据）生成一份current，即使current为static成员变量。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs NewHandlerSupport```的实现和模板参数T完全无关，添加模板参数是因为handler是静态成员，这样编译器才能为每个类型生成一个handler实例。类型参数T只是用来区分不同的derived"><br>### nothrow new<br><br>1993年之前C++的operator new在失败时会返回null而不是抛出异常。如今的C++仍然支持这种nothrow的operator new<br><br>```c++<br>Widget *p1 = new Widget;    // 失败时抛出 bad_alloc 异常<br>if(p1 == 0) ...             // 这个测试一定失败<br><br>Widget *p2 = new (std::nothrow) Widget; //失败时返回0<br>if(p2 == 0) ...             // 这个测试可能成功<br></code></pre></td></tr></table></figure><p>nothrow new只能保证所调用的nothrow版的operator new不抛出异常，但是构造对象也属于表达式new的一个步骤，而它没法强制构造函数不抛出异常，所以并不能保证<code>new (std::nothrow) Widget</code>这样的表达式绝不导致异常。因此没有运用nothrow new的需要。</p><br><h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>一般出于下列原因可能想要替换编译器提供的operator new或operator delete：</p><ul><li>为了检测运用错误</li><li>为了收集动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p>下面是一个为了检测运用错误（overruns，写入点在分配区块尾端之后，或underruns，写入点在分配区块起点之前）而实现的简单定制型operator new的例子，通过在首部和尾部插入一个签名，返回中间内存块给程序使用，如果程序在使用内存时发生过在区块前或区块后写入的行为，那么签名就会被修改，因此可以检测这种行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;    <span class="hljs-comment">// 边界符</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Byte; <br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>    <span class="hljs-comment">// 多申请一些内存来存放占位符 </span><br>    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <br><br>    <span class="hljs-comment">// 申请内存</span><br>    <span class="hljs-type">void</span> *pMem = <span class="hljs-built_in">malloc</span>(realSize);<br>    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>(); <br><br>    <span class="hljs-comment">// 将signature写入内存的最前段落和最后段落</span><br>    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) <br>        = *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;<br><br>    <span class="hljs-comment">// 返回真正的内存区域，指向恰位于第一个signature之后的内存位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子主要是展示，它存在很多错误：</p><ol><li>所有的operator news都应该内含一个循环，反复调用某个new-handling函数，这里却没有</li><li>C++要求所有operator new返回的指针都有适当的对齐。这里malloc返回的指针是满足要求的，但是因为上述实现并不是直接返回malloc的结果，而是返回一个int偏移后的地址，因此无法保证它的安全</li></ol><br><h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>前一条款是解释什么时候会想实现自己的 operator new 和 operator delete，这个条款是解释当实现自己的 operator new 和 operator delete 时，必须遵守的规则。</p><h3 id="1）operator-new"><a href="#1）operator-new" class="headerlink" title="1）operator new"></a>1）operator new</h3><p>实现一致性的operator new必得返回正确的值，内存不足时必得调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p><blockquote><p>C++规定，即使客户要求0bytes，operator new也得返回一个合法指针。</p></blockquote><p>下面是non-member operator new的伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">//处理0-byte申请</span><br>        size = <span class="hljs-number">1</span>;           <span class="hljs-comment">//将它视为1-byte</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        尝试分配<span class="hljs-function">size bytes</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(分配成功)</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(一个指针，指向分配得来的内存)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-comment">//分配失败：找出目前的new-handling函数</span></span><br><span class="hljs-function">        new_handler globalHandler </span>= <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">set_new_handler</span>(globalHandler);<br>        <br>        <span class="hljs-keyword">if</span>(globalHandler) (*globalHandler)();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>operator new内含一个无穷循环，即while(true)，退出此循环的唯一办法是：内存被成功分配或new-handling函数做了一件描述于<a href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA">条款49</a>的事情。</p><p>写出定制型内存管理器的一个最常见理由是为针对某特定class的对象分配行为提供最优化，却不是为了该class的任何derived classes。也就是说，针对class X而设计的operator new，其行为很典型地只为大小刚好为sizeof(X)的对象而设计。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base  <span class="hljs-comment">//假设Derived未声明operator new</span><br>&#123;...&#125;;<br><br>Derived *p = <span class="hljs-keyword">new</span> Derived;    <span class="hljs-comment">//这里调用的是Base::operator new</span><br></code></pre></td></tr></table></figure><p>如果Base class专属的operator new并非被设计用来对付上述情况（实际上往往如此），处理此情势的最佳做法是将“内存申请量错误”的调用行为改采标准operator new，像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))            <span class="hljs-comment">//如果大小错误</span><br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">//交给标准的operator new处理</span><br>    ...                                 <span class="hljs-comment">//否则在这里处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>size为0这份申请也会被转交到::operator new手上，因为sizeof(Base)不能为0（所有非附属&#x2F;独立式对象必须有非零大小）。</p><blockquote><p>非附属&#x2F;独立式对象，指的是不以“某对象之base class成分”存在的对象。</p></blockquote><p>operator new[]唯一需要做的事是分配一块非加工内存，因为无法对array之内迄今尚未存在的元素对象做任何事情。实际上甚至无法计算这个array将含有多少个元素对象。因此，不能在Base::operator new[]内假设array的每个元素对象的大小是sizeof(Base)，因为base class的operator new[]有可能经由继承被调用。此外，传递给operator new[]的size_t参数，其值有可能比“将被填以对象”的内存数量更多，因为动态分配的arrays可能包含额外空间用来存放元素个数。</p><h3 id="2）operator-delete"><a href="#2）operator-delete" class="headerlink" title="2）operator delete"></a>2）operator delete</h3><p>operator delete比起operator new更简单，需要记住的唯一事情就是C++保证“删除null指针永远安全”。下面是non-member operator delete的伪码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果将被删除的是个null指针，那就什么都不做</span><br>    现在，归还rawMemory所指的内存；<br>&#125;<br></code></pre></td></tr></table></figure><p>member版本也很简单，只需要多一个动作检查删除数量。万一class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory,std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;         <span class="hljs-comment">//检查null指针</span><br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))&#123;           <span class="hljs-comment">//如果大小错误，令标准版</span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;   <span class="hljs-comment">//operator delete处理此一申请</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    现在，归还rawMemory所指的内存<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果即将被删除的对象派生自某个base class，而后者欠缺virtual析构函数，那么C++传给operator delete的size_t数值可能不正确。这是“让你的base classes拥有virtual析构函数”的一个够好的理由。</p><br><h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><p>placement new是带有额外参数的operator new。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”的operator new。这个版本被纳入了C++标准程序库，只要#include&lt;new&gt;就可以使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>new会先调用operator new，然后调用构造函数构造对象。如果对象构造过程中发生异常，那么需要调用相应的operator delete来取消内存分配所得并恢复旧观，否则会发生内存泄露。而operator delete必须和相应的operator new匹配：</p><ul><li>对于正常版本的operator new，匹配的operator delete就是不带额外参数的版本</li><li>对于非正常版本的operator new(placement new)，匹配的operator delete是带相应参数的版本(placement delete)</li></ul><p>如果构造函数抛出异常，运行期系统寻找“参数个数和类型都与operator new相同的”某个operator delete。如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete，当么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。</p><p>此外，<strong>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针施行delete绝不会导致调用placement delete</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> pw; <span class="hljs-comment">//调用正常的operator delete</span><br></code></pre></td></tr></table></figure><p>这意味着如果要对所有与placement new相关的内存泄露宣战，我们必须同时提供一个正常的operator delete（用于构造期间无任何异常被抛出）和一个placement版本（用于构造期间有异常被抛出）。后者的额外参数必须和operator new一样。只要这样做，就再也不会因为难以察觉的内存泄露而失眠。</p><p>另外，由于成员函数的名称会掩盖其外围作用域中的相同名称，需要注意名称掩盖的问题，必须小心避免让class专属的news掩盖客户期望的其他news（包括正常版本）：</p><ul><li>成员函数的名称会掩盖外围作用域中的相同名称</li><li>子类的名称会掩盖所有父类相同的名称</li></ul><p>一个比较好的方法是，建立一个base class，内含所有正常形式的new和delete。凡是想以自定义形式扩充标准形式的客户，可利用继承机制以及using声明式取得标准形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardNewDeleteForms</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//正常的 new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;&#125;<br><br>    <span class="hljs-comment">//placement new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(pMemory, ptr); &#125;<br><br>    <span class="hljs-comment">// nothrow new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, nt); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms &#123;      <span class="hljs-comment">//继承标准形式</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;     <span class="hljs-comment">//让这些形式可见</span><br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; log)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;    <span class="hljs-comment">// 自定义 placement new</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 对应的 placement delete</span><br>&#125;;<br></code></pre></td></tr></table></figure><br><br><h1 id="九-杂项讨论"><a href="#九-杂项讨论" class="headerlink" title="九.杂项讨论"></a>九.杂项讨论</h1><h2 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h2><ul><li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉</li><li>不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失</li></ul><br><h2 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h2><br><h2 id="条款55：让自己熟悉Boost"><a href="#条款55：让自己熟悉Boost" class="headerlink" title="条款55：让自己熟悉Boost"></a>条款55：让自己熟悉Boost</h2><p><a href="https://www.boost.org/">Boost</a>是一个C++开发者集结的社群，也是一个可自由下载的C++程序库群。</p><br><hr><p>完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>CPP_kernal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Math</title>
    <link href="/2021/01/03/Leetcode%20Notes%E2%80%94%E2%80%94Math/"/>
    <url>/2021/01/03/Leetcode%20Notes%E2%80%94%E2%80%94Math/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>数学问题</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="204-计数质数-easy"><a href="#204-计数质数-easy" class="headerlink" title="204. 计数质数[easy]"></a><a href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a>[easy]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>思路：验证某个数是否为质数时，将其对每一个比其小的数进行取余运算，并对取余为零的情况进行计数。由于质数是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。所以，当计数结果为 1 时，该数为质数。在实际操作中，由于 1 和任意一个数必然取余为零，所以可以直接排除。并当没有取余为零的情况时，其才为质数。</p><p>cpp 代码超时！！！</p><figure class="highlight axapta"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> countPrimes(<span class="hljs-built_in">int</span> n) &#123;<br>       <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>=<span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>       &#123;<br>           bool sign=<span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">2</span>;j&lt;i;++j)<br>           &#123;<br>               <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)<br>               &#123;<br>                   sign=<span class="hljs-literal">false</span>;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(sign)<br>                ++<span class="hljs-keyword">count</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>细究暴力计算的方法，可以发现，假如一个数为 9 ，那么其二分之一（4.5）后的数都可以不用进行计算，因为肯定是有余的 。事实上情况会比这更好一些：对正整数 n ，如果用 2 到 √n 之间(包含边界)的所有整数去除，均无法整除，则 n 为质数。</p><p>并且，可以发现，一切非 2 偶数一定不可能为质数。所以，可以在此处进行另一步的优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">3</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-comment">//从3开始验算，所以初始值为1（2为质数）</span><br>       <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;n;++i)<br>       &#123;<br>           <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>               <span class="hljs-keyword">continue</span>;<br>           <span class="hljs-type">bool</span> sign=<span class="hljs-literal">true</span>;<br>           <span class="hljs-comment">// 用 j * j &lt;= i 代替 j &lt;= √i 会更好。</span><br>           <span class="hljs-comment">// 因为已经排除了所有偶数，所以每次循环加二将规避偶数会减少循环次数</span><br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">3</span>;j*j&lt;=i;j+=<span class="hljs-number">2</span>)<br>           &#123;<br>               <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)<br>               &#123;<br>                   sign=<span class="hljs-literal">false</span>;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(sign)<br>                ++count;<br>       &#125;<br>       <span class="hljs-keyword">return</span> count; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：厄拉多塞筛法"><a href="#解法二：厄拉多塞筛法" class="headerlink" title="解法二：厄拉多塞筛法"></a>解法二：厄拉多塞筛法</h2><p>在进行顺序遍历时，每取得一个数（排除0、1），就将它所有的倍数（排除0、1、本身）都清除，那么，剩下的数必为素数。</p><p>使用厄拉多塞筛法进行质数查找的过程如下：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210104213623.gif"></p><p>对此，可以声明一个长度为最大限制数的布尔数组，用布尔值来区别筛选出的数和质数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始默认所有数为质数</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">signs</span><span class="hljs-params">(n,<span class="hljs-literal">true</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(signs[i])<br>            &#123;<br>                ++count;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;n;j+=i)<br>                    <span class="hljs-comment">// 排除不是质数的数</span><br>                    signs[j]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="504-七进制数-easy"><a href="#504-七进制数-easy" class="headerlink" title="504. 七进制数[easy]"></a><a href="https://leetcode-cn.com/problems/base-7/">504. 七进制数</a>[easy]</h1><h2 id="解法：迭代"><a href="#解法：迭代" class="headerlink" title="解法：迭代"></a>解法：迭代</h2><p>迭代除 7 取余，进制可以推广到 n。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        string s;<br>        <span class="hljs-type">bool</span> negative=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(num&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            num=-num;<br>            negative=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(num&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            s=<span class="hljs-built_in">to_string</span>(num%<span class="hljs-number">7</span>)+s;<br>            num/=<span class="hljs-number">7</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> negative?<span class="hljs-string">&quot;-&quot;</span>+s:s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="405-数字转换为十六进制数"><a href="#405-数字转换为十六进制数" class="headerlink" title="405. 数字转换为十六进制数"></a><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/">405. 数字转换为十六进制数</a></h1><h2 id="解法：移位运算"><a href="#解法：移位运算" class="headerlink" title="解法：移位运算"></a>解法：移位运算</h2><p>int 是 32 位二进制存储，转换成 16 进制就该有 8 位，每次让 num 向右移位 4 位，并和 0xf (二进制的00000000 00000000 00000000 00001111)做与运算，即可得到本四位的十六进制表示。<br>由于负数右移动不能保证最终 num&#x3D;&#x3D;0，因此限制右移动的次数不超过 8。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        string hex=<span class="hljs-string">&quot;0123456789abcdef&quot;</span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//右移动的次数</span><br>        <span class="hljs-comment">// 32位转换成16进制就是八位</span><br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>&amp;&amp;cnt&lt;<span class="hljs-number">8</span>)<br>        &#123;<br>            ++cnt;<br>            res=hex[num&amp;<span class="hljs-number">0xf</span>]+res;<br>            num&gt;&gt;=<span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">empty</span>()?<span class="hljs-string">&quot;0&quot;</span>:res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="168-Excel表列名称-easy"><a href="#168-Excel表列名称-easy" class="headerlink" title="168. Excel表列名称[easy]"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a>[easy]</h1><h2 id="解法：进制转换"><a href="#解法：进制转换" class="headerlink" title="解法：进制转换"></a>解法：进制转换</h2><p>本质上是进制转换，把 <code>10</code> 进制转为 <code>26</code> 进制表示。详细思路参考 @<a href="https://leetcode-cn.com/problems/excel-sheet-column-title/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-2/">windliang</a> 题解。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210119222925.png" style="zoom: 67%;" /><h3 id="实现一：非递归"><a href="#实现一：非递归" class="headerlink" title="实现一：非递归"></a>实现一：非递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            n-=<span class="hljs-number">1</span>;<br>            res+=<span class="hljs-string">&#x27;A&#x27;</span>+(n%<span class="hljs-number">26</span>);<br>            n/=<span class="hljs-number">26</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现二：递归"><a href="#实现二：递归" class="headerlink" title="实现二：递归"></a>实现二：递归</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        --n;      <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertToTitle</span>(n/<span class="hljs-number">26</span>)+(<span class="hljs-type">char</span>)(<span class="hljs-string">&#x27;A&#x27;</span>+n%<span class="hljs-number">26</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="172-阶乘后的零-easy"><a href="#172-阶乘后的零-easy" class="headerlink" title="172. 阶乘后的零[easy]"></a><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a>[easy]</h1><h2 id="解法：计算因子5"><a href="#解法：计算因子5" class="headerlink" title="解法：计算因子5"></a>解法：计算因子5</h2><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p><p>对于一个数 N，它所包含 5 的个数为：N&#x2F;5 + N&#x2F;5^2 + N&#x2F;5^3 + …，其中 N&#x2F;5 表示不大于 N 的数中 5 的倍数贡献一个 5，N&#x2F;5^2 表示不大于 N 的数中 5^2 的倍数再贡献一个 5 …。</p><p>详细解释参考 @<a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/">windliang</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            count+=n/<span class="hljs-number">5</span>;<br>            n/=<span class="hljs-number">5</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自编程之美2.2。和求解有多少个 5 一样，2 的个数为 N&#x2F;2 + N&#x2F;2^2 + N&#x2F;2^3 + …</p><h1 id="470-用-Rand7-实现-Rand10-medium"><a href="#470-用-Rand7-实现-Rand10-medium" class="headerlink" title="470. 用 Rand7() 实现 Rand10()[medium]"></a><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a>[medium]</h1><blockquote><p>参考 @kkbill 题解 <a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/">从最基础的讲起如何做到均匀的生成随机数</a>。</p></blockquote><p>这里记录一下结论：</p><ul><li>已知 rand_N() 可以等概率的生成[1, N]范围的随机数。那么：<br>(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数。即实现了 rand_XY()。</li><li>只要 <code>rand_N()</code> 中N是2的倍数，就都可以用来实现 <code>rand2()</code>，方法是  <code>rand_N()%2+1</code> 。</li></ul><p>**要实现 <code>rand10()</code>，就需要先实现 <code>rand_N()</code>，并且保证N大于10且是10的倍数。这样再通过<code>rand_N() % 10 + 1</code>**就可以得到[1,10]范围的随机数了。如下：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(rand7()</span><span class="hljs-number">-1</span>) × <span class="hljs-number">7</span> + ra<span class="hljs-symbol">nd7</span><span class="hljs-comment">()</span>  ==&gt; ra<span class="hljs-symbol">nd49</span><span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><p>但是这样实现的N不是10的倍数啊！这该怎么处理？这里就涉及到了“<strong>拒绝采样</strong>”的知识了，也就是说，如果某个采样结果不在要求的范围内，则丢弃它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> num=(<span class="hljs-built_in">rand7</span>()<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span>+<span class="hljs-built_in">rand7</span>();<span class="hljs-comment">// 等概率生成[1,49]范围的随机数</span><br>            <span class="hljs-keyword">if</span>(num&lt;=<span class="hljs-number">40</span>)<br>                <span class="hljs-comment">// 拒绝采样，并返回[1,10]范围的随机数</span><br>                <span class="hljs-keyword">return</span> num%<span class="hljs-number">10</span>+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="9-回文数-easy"><a href="#9-回文数-easy" class="headerlink" title="9. 回文数[easy]"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a>[easy]</h1><h2 id="解法：反转一半数字"><a href="#解法：反转一半数字" class="headerlink" title="解法：反转一半数字"></a>解法：反转一半数字</h2><p>第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。但是，如果反转后的数字大于 INT_MAX，将遇到整数溢出问题。</p><p>按照第二个想法，为了避免数字反转可能导致的溢出问题，考虑只反转 int 数字的一半。毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。</p><p>首先，应该处理一些临界情况。所有负数都不可能是回文，可以对所有负数返回 false。除了 0 以外，所有个位是 0 的数字不可能是回文，因为最高位不等于 0。所以可以对所有大于 0 且个位是 0 的数字返回 false。</p><p>除此之外，考虑如何反转后半部分的数字。</p><p>对于数字 1221，如果执行 1221 % 10，将得到最后一位数字 1，要得到倒数第二位数字，可以先通过除以 10 把最后一位数字从 1221 中移除，1221 &#x2F; 10 &#x3D; 122，再求出上一步结果除以 10 的余数，122 % 10 &#x3D; 2，就可以得到倒数第二位数字。如果把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 &#x3D; 12，就得到了想要的反转后的数字。如果继续这个过程，将得到更多位数的反转数字。</p><p>剩余的问题是，如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于或等于反转后的数字时，就意味着已经处理了一半位数的数字了。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210412220040.png" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 特殊情况</span><br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||(x%<span class="hljs-number">10</span>==<span class="hljs-number">0</span>&amp;&amp;x!=<span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> reverseNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x&gt;reverseNum)<br>        &#123;<br>            reverseNum=reverseNum*<span class="hljs-number">10</span>+x%<span class="hljs-number">10</span>;<br>            x/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当数字长度为奇数时，可以通过 revertedNumber/10 去除处于中位的数字</span><br>        <span class="hljs-keyword">return</span> x==reverseNum||x==reverseNum/<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="367-有效的完全平方数-easy"><a href="#367-有效的完全平方数-easy" class="headerlink" title="367. 有效的完全平方数[easy]"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a>[easy]</h1><h2 id="解法：数学"><a href="#解法：数学" class="headerlink" title="解法：数学"></a>解法：数学</h2><p>1，4&#x3D;1+3，9&#x3D;1+3+5，16&#x3D;1+3+5+7…以此类推，模仿它可以使用一个 while 循环，不断减去一个从 1 开始不断增大的奇数，若最终减成了 0，说明是完全平方数，否则，不是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> odd=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(num&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            num-=odd;<br>            odd+=<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="326-3的幂-easy"><a href="#326-3的幂-easy" class="headerlink" title="326. 3的幂[easy]"></a><a href="https://leetcode-cn.com/problems/power-of-three/">326. 3的幂</a>[easy]</h1><h2 id="解法一：循环迭代"><a href="#解法一：循环迭代" class="headerlink" title="解法一：循环迭代"></a>解法一：循环迭代</h2><p>找出数字 n 是否是数字 b 的幂的一个简单方法是，n%3 只要余数为 0，就一直将 n 除以 b。</p><p>$$<br>\begin{aligned} n &amp;&#x3D; b^xn &#x3D; b \times b \times \ldots \times b \end{aligned}<br>$$</p><p>因此，应该可以将 <code>n</code> 除以 <code>b</code> x 次，每次都有 0 的余数，最终结果是 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(n%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>)<br>            n/=<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">return</span> n==<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：数学"><a href="#解法二：数学" class="headerlink" title="解法二：数学"></a>解法二：数学</h2><p>INT_MAX 为 2147483647，因此 <code>n</code> 的最大值为 1162261467&#x3D;3^19，只需要将 3^19 除以 <code>n</code>。若余数为 <strong>0</strong> 意味着 <code>n</code> 是 3^19 的除数，即是 3 的幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span>%n==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="238-除自身以外数组的乘积-medium"><a href="#238-除自身以外数组的乘积-medium" class="headerlink" title="238. 除自身以外数组的乘积[medium]"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a>[medium]</h1><h2 id="解法：左右乘积列表"><a href="#解法：左右乘积列表" class="headerlink" title="解法：左右乘积列表"></a>解法：左右乘积列表</h2><h3 id="两个数组"><a href="#两个数组" class="headerlink" title="两个数组"></a>两个数组</h3><p>利用索引左侧所有数字的乘积和右侧所有数字的乘积（即前缀与后缀）相乘得到答案。</p><ul><li>初始化两个空数组 <code>L</code> 和 <code>R</code>。对于给定索引 <code>i</code>，<code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</li><li>我们需要用两个循环来填充 <code>L</code> 和 <code>R</code> 数组的值。对于数组 <code>L</code>，<code>L[0]</code> 应该是 <code>1</code>，因为第一个元素的左边没有元素。对于其他元素：<code>L[i] = L[i-1] * nums[i-1]</code>。</li><li>同理，对于数组 <code>R</code>，<code>R[length-1]</code> 应为 <code>1</code>。<code>length</code> 指的是输入数组的大小。其他元素：<code>R[i] = R[i+1] * nums[i+1]</code>。</li><li>当 <code>R</code> 和 <code>L</code> 数组填充完成，我们只需要在输入数组上迭代，且索引 <code>i</code> 处的值为：<code>L[i] * R[i]</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        left[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>            left[i]=left[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        right[len<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>            right[i]=right[i+<span class="hljs-number">1</span>]*nums[i+<span class="hljs-number">1</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            res[i]=left[i]*right[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h3 id="无需额外空间（结果数组除外）"><a href="#无需额外空间（结果数组除外）" class="headerlink" title="无需额外空间（结果数组除外）"></a>无需额外空间（结果数组除外）</h3><p>由于输出数组不算在空间复杂度内，那么可以将 <code>L</code> 或 <code>R</code> 数组用输出数组来计算。先把输出数组当作 <code>L</code> 数组来计算，然后再动态构造 <code>R</code> 数组得到结果。这种方法的唯一变化就是没有构造 <code>R</code> 数组，而是用一个变量来跟踪右边元素的乘积。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(len,<span class="hljs-number">0</span>)</span></span>;<br>        res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>            res[i]=res[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 注意从 len-1 开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            res[i]=res[i]*right;<br>            right*=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="7-整数反转-easy"><a href="#7-整数反转-easy" class="headerlink" title="7. 整数反转[easy]"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a>[easy]</h1><h2 id="解法：取模和除法"><a href="#解法：取模和除法" class="headerlink" title="解法：取模和除法"></a>解法：取模和除法</h2><p>首先想一下，怎么去反转一个整数。用栈？或者把整数变成字符串，再去反转这个字符串？这两种方式是可以，但并不好。实际上只要能拿到这个整数的<strong>末尾数字</strong>就可以了。</p><p>以<code>12345</code>为例，先拿到<code>5</code>，再拿到<code>4</code>，之后是<code>3</code>，<code>2</code>，<code>1</code>，按这样的顺序就可以反向拼接一个数字了，也就能达到 <strong>反转</strong> 的效果。</p><p>怎么拿末尾数字呢？好办，用取模运算就可以了。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210430155038.jpeg" style="zoom:67%;" /><p>这么看起来，一个循环就搞定了，循环的判断条件是是<code>x&gt;0</code>。但这样不对，因为忽略了 <strong>负数</strong>。循环的判断条件应该是<code>while(x!=0)</code>，无论正数还是负数，按照上面不断的<code>/10</code>这样的操作，最后都会变成<code>0</code>，所以判断终止条件就是<code>!=0</code>。<br>有了取模和除法操作，对于像<code>12300</code>这样的数字，也可以完美的解决掉了。</p><p>接下来考虑溢出：参考 @<a href="https://leetcode-cn.com/problems/reverse-integer/solution/tu-jie-7-zheng-shu-fan-zhuan-by-wang_ni_ma/">王尼玛</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> end=x%<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(res&gt;<span class="hljs-number">214748364</span> || (res==<span class="hljs-number">214748364</span>&amp;&amp;end&gt;<span class="hljs-number">7</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(res&lt;<span class="hljs-number">-214748364</span> || (res==<span class="hljs-number">214748364</span>&amp;&amp;end&lt;<span class="hljs-number">-8</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            res=res*<span class="hljs-number">10</span>+end;<br>            x/=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Graph</title>
    <link href="/2020/12/21/Leetcode%20Notes%E2%80%94%E2%80%94Graph/"/>
    <url>/2020/12/21/Leetcode%20Notes%E2%80%94%E2%80%94Graph/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>图</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="133-克隆图-medium"><a href="#133-克隆图-medium" class="headerlink" title="133. 克隆图[medium]"></a><a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a>[medium]</h1><p>详细思路解释查看<a href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/">官方题解</a>。</p><h2 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><p>使用<code>HashMap</code>记录原图中的结点和新生成的克隆图中的结点。</p><ul><li>如果结点为空，则返回<code>NULL</code>。</li><li>如果当前结点在<code>HashMap</code>中，即当前结点已经被克隆过，则直接返回其映射结点。</li><li>否则，克隆当前结点，并在<code>HashMap</code>中建立映射，然后遍历当前结点的所有<code>neighbor</code>结点，调用递归函数并且加到克隆结点的<code>neighbors</code>数组中。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*,Node*&gt; visited;<span class="hljs-comment">// 新旧结点 Map</span><br>    <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> node;<br>        <span class="hljs-comment">// 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> visited[node];<br>        <span class="hljs-comment">// 克隆节点，为了深拷贝不会克隆它的邻居的列表</span><br>        Node *cloneNode=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>        <span class="hljs-comment">// 哈希表存储</span><br>        visited[node]=cloneNode;<br>        <span class="hljs-comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neighbor:node-&gt;neighbors)<br>            cloneNode-&gt;neighbors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">cloneGraph</span>(neighbor));<br>        <span class="hljs-keyword">return</span> cloneNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h2><p>除了使用<code>HashMap</code>记录原图中的结点和新生成的克隆图中的结点，还需要队列<code>queue</code>来辅助图的遍历。</p><ul><li>先克隆当前结点，然后建立映射，并加入<code>queue</code>中，进行循环。</li><li>在循环中，取出队首结点，遍历其所有<code>neighbor</code>结点，若不在<code>HashMap</code>中，根据<code>neighbor</code>结点值克隆一个新<code>neighbor</code>结点，建立映射，并且放入<code>queue</code>中。然后将<code>neighbor</code>结点在<code>HashMap</code>中的映射结点加入到克隆结点的<code>neighbors</code>数组中。</li><li>循环直到队列为空为止。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> node;<br>        unordered_map&lt;Node*,Node*&gt; visited;<br>        queue&lt;Node*&gt; q;<br>        <span class="hljs-comment">// 克隆第一个节点并存储到哈希表中</span><br>        Node *cloneNode=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>        visited[node]=cloneNode;<br>        <span class="hljs-comment">// 将题目给定的节点添加到队列</span><br>        q.<span class="hljs-built_in">push</span>(node);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 取出队列的头节点</span><br>            <span class="hljs-keyword">auto</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 遍历该节点的邻居</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neighbor:cur-&gt;neighbors)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(neighbor)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将邻居节点加入队列中</span><br>                    q.<span class="hljs-built_in">push</span>(neighbor);<br>                    <span class="hljs-comment">// 如果没有被访问过，就克隆并存储在哈希表中</span><br>                    visited[neighbor]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(neighbor-&gt;val);<br>                &#125;<br>                <span class="hljs-comment">// 更新当前节点的邻居列表</span><br>                visited[cur]-&gt;neighbors.<span class="hljs-built_in">push_back</span>(visited[neighbor]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="841-钥匙和房间-medium"><a href="#841-钥匙和房间-medium" class="headerlink" title="841. 钥匙和房间[medium]"></a><a href="https://leetcode-cn.com/problems/keys-and-rooms/">841. 钥匙和房间</a>[medium]</h1><h2 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><ul><li>首先找到 0 号房间，把所有 ０ 号房间的钥匙都开一遍；</li><li>进入刚刚开过的房间，再把它们房间里的钥匙再开一遍；</li><li>重复以往，层层递进，直到找不到符合要求的节点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<span class="hljs-comment">// 标记房间是否被访问过</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-comment">//  0 号房间开始</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        visited.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> room=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; keys=rooms[room];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;key:keys)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(key)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(key);<br>                    visited.<span class="hljs-built_in">insert</span>(key);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检查房间是不是都遍历过了</span><br>        <span class="hljs-keyword">return</span> visited.<span class="hljs-built_in">size</span>()==rooms.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><ul><li>先找第 ０ 个房间的第一个钥匙；</li><li>进入那个房间，再找它的第一个钥匙；</li><li>重复以往，直到没钥匙了，那么退回刚刚的房间；</li><li>找刚刚房间的第二把钥匙；</li><li>重复以往。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;      <br>        <span class="hljs-built_in">dfs</span>(rooms,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 检查房间是不是都遍历过了</span><br>        <span class="hljs-keyword">return</span> visited.<span class="hljs-built_in">size</span>()==rooms.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;rooms,<span class="hljs-type">int</span> room)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(room)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        visited.<span class="hljs-built_in">insert</span>(room);<br>        vector&lt;<span class="hljs-type">int</span>&gt; keys=rooms[room];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;key:keys)<br>            <span class="hljs-built_in">dfs</span>(rooms,key);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="207-课程表-medium"><a href="#207-课程表-medium" class="headerlink" title="207. 课程表[medium]"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a>[medium]</h1><h2 id="解法一：拓扑排序（Kahn-算法，其实就是广度优先遍历的思路）"><a href="#解法一：拓扑排序（Kahn-算法，其实就是广度优先遍历的思路）" class="headerlink" title="解法一：拓扑排序（Kahn 算法，其实就是广度优先遍历的思路）"></a>解法一：拓扑排序（Kahn 算法，其实就是广度优先遍历的思路）</h2><blockquote><ul><li><p>拓扑排序本质是<strong>广度优先遍历+贪心算法</strong>；</p></li><li><p>拓扑排序是广度优先遍历和贪心算法应用于有向图的一个专有名词；</p></li><li><p>应用场景：任务调度计划、课程安排，例：《机器学习》课程的先导课程为《高等数学》；</p></li><li><p>拓扑排序的作用：</p><ul><li><p>得到一个拓扑序，拓扑序不唯一；</p></li><li><p>检测有向图是否存在环。</p><p>补充：无向图中检测是否有环，使用的数据结构是并查集。</p></li></ul></li></ul></blockquote><p>拓扑排序实际上应用的是<strong>贪心算法</strong>。贪心算法简而言之：每一步最优，全局就最优。</p><p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（-1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p><p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。</p><p><strong>算法流程</strong>：</p><ul><li>在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</li><li>只要队列非空，就从队首取出入度为 0 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</li><li>当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</li></ul><p>在代码具体实现的时候，除了保存入度为 0 的队列，还需要两个辅助的数据结构：</p><ul><li>邻接表：通过结点的索引，能够得到这个结点的后继结点；</li><li>入度数组：通过结点的索引，能够得到指向这个结点的结点个数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 邻接表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 各结点的入度</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 入度为 0 的结点队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++indegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            adj[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 首先加入入度为 0 的结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(indegrees[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 记录已经出队的课程数量</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ++cnt;<br>            <span class="hljs-comment">// 遍历当前出队结点的所有后继结点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[cur])<br>            &#123;<br>                --indegrees[successor];<br>                <span class="hljs-comment">// 检测该结点的入度是否为 0，如果为 0，加入队列</span><br>                <span class="hljs-keyword">if</span>(indegrees[successor]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(successor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt==numCourses;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：深度优先遍历"><a href="#解法二：深度优先遍历" class="headerlink" title="解法二：深度优先遍历"></a>解法二：深度优先遍历</h2><p>深度优先遍历的思路有 2 个。</p><ul><li>首先检测是否存在环，然后使用「深度优先遍历」，在「后序」的部分把课程添加到结果集，然后再逆序，就是「拓扑排序」的结果（没有提供参考代码）；</li><li>在深度优先遍历的过程中，设置个别有特殊意义的变量，通过这些变量得到「拓扑排序」的结果（下面提供了参考代码）。</li></ul><p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p><p>具体方法是：</p><ol><li>构建逆邻接表；</li><li>递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。</li><li>如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flags</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>            adj[prerequisites[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i,adj,flags))<br>                <span class="hljs-comment">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span><br>        <span class="hljs-comment">// 所有课程任务可以完成，应该返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// flags 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span><br>    <span class="hljs-comment">// return true 表示图中存在环，false 表示访问过了，不用再访问了</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;adj,vector&lt;<span class="hljs-type">int</span>&gt; &amp;flags)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 从正在访问中，到正在访问中，表示遇到了环</span><br>        <span class="hljs-keyword">if</span>(flags[i]==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 表示在访问的过程中没有遇到环，这个节点访问过了</span><br>        <span class="hljs-keyword">if</span>(flags[i]==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 走到这里，是因为初始化 flags[i] == 0</span><br>        <span class="hljs-comment">// 表示正在访问中</span><br>        flags[i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历后继结点的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(successor,adj,flags))<br>                <span class="hljs-comment">// 层层递归返回 true ，表示图中存在环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span><br>        <span class="hljs-comment">// 状态设置为 2</span><br>        flags[i]=<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// false 表示图中不存在环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="210-课程表-II-medium"><a href="#210-课程表-II-medium" class="headerlink" title="210. 课程表 II[medium]"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a>[medium]</h1><p>思路与 <a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a> 相同，这里仅给出广度优先遍历解法代码。</p><h2 id="解法：拓扑排序（Kahn-算法、类似广度优先遍历的思路）"><a href="#解法：拓扑排序（Kahn-算法、类似广度优先遍历的思路）" class="headerlink" title="解法：拓扑排序（Kahn 算法、类似广度优先遍历的思路）"></a>解法：拓扑排序（Kahn 算法、类似广度优先遍历的思路）</h2><p>拓扑序不唯一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 邻接表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 各结点的入度</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 入度为 0 的结点队列</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(numCourses,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++indegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            adj[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 首先加入入度为 0 的结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(indegrees[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 记录已经出队的课程数量，正好可以作为结果下标</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            res[cnt]=cur;<br>            ++cnt;<br>            <span class="hljs-comment">// 遍历当前出队结点的所有后继结点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[cur])<br>            &#123;<br>                --indegrees[successor];<br>                <span class="hljs-comment">// 检测该结点的入度是否为 0，如果为 0，加入队列</span><br>                <span class="hljs-keyword">if</span>(indegrees[successor]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(successor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==numCourses)<br>            <span class="hljs-keyword">return</span> res;<br>         <span class="hljs-comment">// 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="802-找到最终的安全状态-medium"><a href="#802-找到最终的安全状态-medium" class="headerlink" title="802. 找到最终的安全状态[medium]"></a><a href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a>[medium]</h1><h2 id="解法：拓扑排序"><a href="#解法：拓扑排序" class="headerlink" title="解法：拓扑排序"></a>解法：拓扑排序</h2><p>定义安全的点：路径终点，也就是出度为 0 的点。</p><p>定义最终安全的点：从起始节点开始，可以沿某个路径到达终点，那么起始节点就是最终安全的点。</p><p>思路：从出度为 0 的弧尾反向拓扑到弧头。</p><ul><li>找到出度为 0 的顶点，这些点是安全的点；</li><li>逆向删除以出度为 0 的顶点为弧头的边，弧尾的出度减一；</li><li>重复上面两步，直到不存在出度为 0 的顶点。</li></ul><p>由于需要回推边，所以建立逆向邻接图。此外，题目要求返回的节点有序，因此最后将结果数组排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">eventualSafeNodes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outDegree</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 维护出度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">revGraph</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            outDegree[i]=graph[i].<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;end:graph[i])<br>                revGraph[end].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(outDegree[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;start:revGraph[cur])<br>            &#123;<br>                --outDegree[start];<br>                <span class="hljs-keyword">if</span>(outDegree[start]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(start);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 保证结果有序</span><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="990-等式方程的可满足性-medium"><a href="#990-等式方程的可满足性-medium" class="headerlink" title="990. 等式方程的可满足性[medium]"></a><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a>[medium]</h1><h2 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>并查集模板参考 <a href="https://labuladong.gitbook.io/algo">Union-Find 算法详解</a>。</p><p>由于等式相等具有传递性，比较容易想到使用并查集。为此设计算法如下：</p><ul><li>扫描所有等式，将等式两边的顶点进行合并；</li><li>再扫描所有不等式，检查每一个不等式的两个顶点是不是在一个连通分量里，如果在，则返回 <code>false</code> 表示等式方程有矛盾。如果所有检查都没有矛盾，返回 <code>true</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;eq:equations)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(eq[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;=&#x27;</span>)<br>                uf.<span class="hljs-built_in">unionTree</span>(eq[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>,eq[<span class="hljs-number">3</span>]-<span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;eq:equations)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(eq[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;!&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(eq[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>,eq[<span class="hljs-number">3</span>]-<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-comment">// 如果合并失败，表示等式有矛盾，根据题意，返回 false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果检查了所有不等式，都没有发现矛盾，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="684-冗余连接-medium"><a href="#684-冗余连接-medium" class="headerlink" title="684. 冗余连接[medium]"></a><a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a>[medium]</h1><h2 id="解法：并查集-1"><a href="#解法：并查集-1" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>判断节点第一次出现环的边 edge 进行返回，如下图，当 1 的根节点是 4 的时候，从 1-&gt;2-&gt;3-&gt;4 出现一条路径，大概 [1,4] 这个 edge 进来后，发现 1 可以直接指向 4，这时候出现了环，这条边是冗余边。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210105213709.png" style="zoom: 67%;" /><p>在这条边出现之前，图中没有环。这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边。然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边。</p><p>具体实现：</p><p>改写 union 方法，第一次当 p 与 q 没有联通时，将其设置联通关系，返回 ture，第二次 p 和 q 的跟节点发现一致时，他们已经联通了，返回 false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=edges.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意此处下标多放一个</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;edge:edges)<br>        &#123;<br>            <span class="hljs-type">int</span> x=edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y=edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">unionTree</span>(x,y))<br>                <span class="hljs-comment">// 第二次出现了联通的边时，表示已经找到了</span><br>                <span class="hljs-keyword">return</span> edge;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1319-连通网络的操作次数-medium"><a href="#1319-连通网络的操作次数-medium" class="headerlink" title="1319. 连通网络的操作次数[medium]"></a><a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a>[medium]</h1><h2 id="解法：并查集-2"><a href="#解法：并查集-2" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>将<strong>互相连通</strong>的电脑压缩成<strong>一个点</strong>，若最后存在 N 个点，通过观察可以发现只需要 <code>N - 1</code> 条线就可以进行相连。那接下来的问题就是如何去寻找这 <code>N - 1</code> 条线。考虑每一条线，如果线的两头已经连通，则这条线是多余的，可以拿去当做 <code>N - 1</code>条线的其中一条。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">// 记录连通分量个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 多余的线缆数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:connections)<br>        &#123;<br>            <span class="hljs-type">int</span> l=c[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r=c[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 两个点已经连通，不需要这个线缆</span><br>            <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(l,r))<br>            &#123;<br>                ++cnt;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            uf.<span class="hljs-built_in">unionTree</span>(l,r);<br>        &#125;<br>        <span class="hljs-comment">// 所需要的线缆数量</span><br>        <span class="hljs-type">int</span> cnt2=uf.<span class="hljs-built_in">getCount</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> cnt&lt;cnt2?<span class="hljs-number">-1</span>:cnt2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="685-冗余连接-II-hard"><a href="#685-冗余连接-II-hard" class="headerlink" title="685. 冗余连接 II[hard]"></a><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">685. 冗余连接 II</a>[hard]</h1><h2 id="解法：并查集-拓扑排序"><a href="#解法：并查集-拓扑排序" class="headerlink" title="解法：并查集+拓扑排序"></a>解法：并查集+拓扑排序</h2><p>这个问题与 <a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a> 的区别是：</p><ul><li>第 684 题基于<strong>无向图</strong>，在无向图中判断是否有环，使用<strong>并查集</strong>；</li><li>第 685 题基于<strong>有向图</strong>，在有向图中判断是是否有环，使用<strong>拓扑排序</strong>。</li></ul><p>第 685 题需要返回多余的一条边。拓扑排序主要回答拓扑序，顺便回答了图中是否有环，对于这个问题来说，使用拓扑排序找到多余的一条边是相对麻烦的。但是拓扑排序中的重要概念<strong>结点的入度</strong>可以帮助解决这个问题。</p><p><strong>什么是有根树</strong>：</p><p>有根树指满足以下条件的<strong>有向图</strong>。该树<strong>只有</strong>一个根结点，<strong>所有其他结点都是该根结点的后继</strong>。每一个结点<strong>只有</strong> 一个父结点，除了根结点没有父结点。</p><p>树区别与图的特点是：没有环（不论是对于有向边还是无向边）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110842.png" style="zoom: 33%;" /><p>由此，可以归纳出，有根树的特点：</p><ul><li>只有唯一的一个入度为 0 的结点，它是根结点；</li><li>不是根结点的其它所有的结点入度为 1；</li><li>不可能存在入度为 2 的结点。</li></ul><p><strong>结合示例分析</strong>：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110953.png" style="zoom:50%;" /><p>根据示例 1 ，不能有入度为 2 的结点；<br>根据示例 2 ，在不能有入度为 2 的结点的前提下，不能形成回路。</p><p>为此设计算法如下：</p><ul><li>先统计每一个结点的入度，如果有入度为 2 的结点，考虑删除一条边（根据题目意思，删除的是输入的边的列表中最后出现的），剩下的<strong>有向边</strong>是否形成回路（形成环）。如果不能形成环，就应该删除这条边；</li><li>在没有入度为 2 的结点的前提下，尝试删除形成入度为 1 的<strong>有向边</strong>（不能删除入度为 0 的有向边），判断剩下的<strong>有向边</strong>是否形成环。</li></ul><p>说明：在没有入度为 2 的结点的情况下（结合示例 2 来理解），判断有向图是否形成回路，可以把有向图当成无向图来看，因此可以使用<strong>并查集</strong>。</p><p><strong>编码说明</strong>：</p><ul><li>这个问题里，题目输入的边的条数等于结点的个数，因为就是刚刚好多了 1 条边，题目才让删，3 个顶点的有根树只可能有 2 条边，注意代码中 +1 是因为从 1 开始计算；</li><li>题目要求，有多个结果的时候，返回 <code>edges</code> 里最后出现的边，因此<strong>从后向前遍历</strong>，删除某条边的意思是：不把它加入并查集。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 边的条数（在这个问题里等于结点个数）</span><br>        <span class="hljs-type">int</span> len=edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 步骤 1：预处理入度数组（记录指向某个结点的边的条数）</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;edge:edges)<br>            ++inDegree[edge[<span class="hljs-number">1</span>]];<br>        <span class="hljs-comment">// 步骤 2：先尝试删除构成入度为 2 的边，看看是否形成环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-comment">// 如果不构成环，这条边就是要去掉的那条边</span><br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judgeCircle</span>(edges,len,i))<br>                    <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 步骤 3：再尝试删除构成入度为 1 的边，看看是否形成环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 如果不构成环，这条边就是要去掉的那条边</span><br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judgeCircle</span>(edges,len,i))<br>                    <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 removeEdgeIndex 去掉以后，剩下的有向边是否构成环</span><br>    <span class="hljs-comment">// len：结点总数（从 1 开始，因此初始化的时候 + 1）</span><br>    <span class="hljs-comment">// removeEdgeIndex：删除的边的下标</span><br>    <span class="hljs-comment">// 构成环，返回 true</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;edges,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> removeEdgeIndex)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(len+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==removeEdgeIndex)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 合并失败，表示 edges[i][0] 和 edges[i][1] 在一个连通分量里，即构成了环</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">unionTree</span>(edges[i][<span class="hljs-number">0</span>],edges[i][<span class="hljs-number">1</span>]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="399-除法求值-medium"><a href="#399-除法求值-medium" class="headerlink" title="399. 除法求值[medium]"></a><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a>[medium]</h1><h2 id="解法：并查集-3"><a href="#解法：并查集-3" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><blockquote><p>由于 <strong>变量之间的倍数关系具有传递性</strong>，处理有传递性关系的问题，可以使用「并查集」，需要在并查集的「合并」与「查询」操作中 <strong>维护这些变量之间的倍数关系</strong>。</p></blockquote><p>详细思路参考<a href="https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">官方解答</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; weight;<span class="hljs-comment">//指向的父结点的权值</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            weight.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1.0</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])<br>        &#123;<br>            <span class="hljs-type">int</span> origin=parent[x];<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=<span class="hljs-built_in">find</span>(parent[x]);<br>            weight[x]*=weight[origin];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q,<span class="hljs-type">double</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        parent[rootP]=rootQ;<br>        weight[rootP]=weight[q]*value/weight[p];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> weight[p]/weight[q];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-type">int</span> equationSize=equations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(<span class="hljs-number">2</span>*equationSize)</span></span>;<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; dict;<br>        <span class="hljs-type">int</span> id=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;equationSize;++i)<br>        &#123;<br>            string var1=equations[i][<span class="hljs-number">0</span>];<br>            string var2=equations[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var1)==<span class="hljs-number">0</span>)<br>            &#123;<br>                dict[var1]=id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var2)==<span class="hljs-number">0</span>)<br>            &#123;<br>                dict[var2]=id;<br>                ++id;<br>            &#125;<br>            uf.<span class="hljs-built_in">unionTree</span>(dict[var1],dict[var2],values[i]);<br>        &#125;<br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        vector&lt;<span class="hljs-type">double</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;queries.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            string var1=queries[i][<span class="hljs-number">0</span>];<br>            string var2=queries[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var1)==<span class="hljs-number">0</span>||dict.<span class="hljs-built_in">count</span>(var2)==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1.0</span>);<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(uf.<span class="hljs-built_in">isConnected</span>(dict[var1],dict[var2]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="785-判断二分图-medium"><a href="#785-判断二分图-medium" class="headerlink" title="785. 判断二分图[medium]"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a>[medium]</h1><blockquote><p>染色问题。</p></blockquote><h2 id="解法一：BFS-1"><a href="#解法一：BFS-1" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><p>使用图搜索算法从各个连通域的任一顶点开始遍历整个连通域，遍历的过程中用两种不同的颜色对顶点进行染色，相邻顶点染成相反的颜色。这个过程中倘若发现相邻的顶点被染成了相同的颜色，说明它不是二分图；反之，如果所有的连通域都染色成功，说明它是二分图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-comment">// 因为图中可能含有多个连通域，所以需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 bfs 染色</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            visited[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 每出队一个顶点，将其所有邻接点染成相反的颜色并入队</span><br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>                &#123;<br>                    <span class="hljs-comment">// 如果当前顶点的某个邻接点已经被染过色了，且颜色和当前顶点相同，说明此无向图无法被正确染色，返回 false</span><br>                    <span class="hljs-keyword">if</span>(visited[neighbour]==visited[cur])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(visited[neighbour]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        visited[neighbour]=-visited[cur];<br>                        q.<span class="hljs-built_in">push</span>(neighbour);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：DFS-1"><a href="#解法二：DFS-1" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><p>思路与 BFS 相同，只是搜索方式不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 因为图中可能含有多个连通域，所以需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 dfs 染色</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]==<span class="hljs-number">0</span>&amp;&amp;!<span class="hljs-built_in">dfs</span>(graph,visited,i,<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph,vector&lt;<span class="hljs-type">int</span>&gt; &amp;visited,<span class="hljs-type">int</span> cur,<span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果要对某顶点染色时，发现它已经被染色了，则判断它的颜色是否与本次要染的颜色相同，如果矛盾，说明此无向图无法被正确染色，返回 false</span><br>        <span class="hljs-keyword">if</span>(visited[cur]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> visited[cur]==color;<br>        <span class="hljs-comment">// 对当前顶点进行染色，并将当前顶点的所有邻接点染成相反的颜色</span><br>        visited[cur]=color;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(graph,visited,neighbour,-color))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：并查集"><a href="#解法三：并查集" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h2><p>如果是二分图的话，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合。因此可以使用并查集来解决这个问题：遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点已经和当前顶点处于同一个集合中了，若是，则说明不是二分图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">// 遍历每个顶点，将当前顶点的所有邻接点进行合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[i])<br>            &#123;<br>                <span class="hljs-comment">// 若某个邻接点与当前顶点已经在一个集合中了，说明不是二分图，返回 false</span><br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(neighbour,i))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                uf.<span class="hljs-built_in">unionTree</span>(graph[i][<span class="hljs-number">0</span>],neighbour);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="886-可能的二分法-medium"><a href="#886-可能的二分法-medium" class="headerlink" title="886. 可能的二分法[medium]"></a><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a>[medium]</h1><blockquote><p>染色问题。</p></blockquote><h2 id="解法：BFS、DFS、并查集"><a href="#解法：BFS、DFS、并查集" class="headerlink" title="解法：BFS、DFS、并查集"></a>解法：BFS、DFS、并查集</h2><p>思路与 <a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a> 相似。那道题给的是建好的邻接表，但是本质上和这道题是一样的，同一条边上的两点是不能在同一个集合中的，那么这就相当于本题中的 dislike 的关系，也可以把每个 dislike 看作是一条边，那么两端的两个人不能在同一个集合中。跟之前的题相比，这里唯一不同的就是邻接表没有建好，需要自己去建。这里只给出 BFS 代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleBipartition</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;<br>        <span class="hljs-comment">// 编号从1开始</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(N+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 建立无向邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;dislike:dislikes)<br>        &#123;<br>            graph[dislike[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(dislike[<span class="hljs-number">1</span>]);<br>            graph[dislike[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(dislike[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">colors</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(colors[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            colors[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(colors[neighbour]==colors[cur])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(colors[neighbour]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        colors[neighbour]=-colors[cur];<br>                        q.<span class="hljs-built_in">push</span>(neighbour);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="1042-不邻接植花-medium"><a href="#1042-不邻接植花-medium" class="headerlink" title="1042. 不邻接植花[medium]"></a><a href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a>[medium]</h1><h2 id="解法：染色问题"><a href="#解法：染色问题" class="headerlink" title="解法：染色问题"></a>解法：染色问题</h2><ol><li>根据 paths 建立邻接表；</li><li>默认所有的花园先不染色，即染 0；</li><li>从第一个花园开始走，把与它邻接的花园的颜色从 color{1,2,3,4} 这个颜色集中删除；</li><li>删完了所有与它相邻的颜色，就可以把集合中剩下的颜色随机选一个给它了，为了简单，将集合中的第一个颜色赋给当前花园；</li><li>循环 3 和 4 到最后一个花园。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">gardenNoAdj</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;<br>        <span class="hljs-comment">// 编号从1开始</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 建立无向邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;path:paths)<br>        &#123;<br>            graph[path[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(path[<span class="hljs-number">1</span>]);<br>            graph[path[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(path[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 初始化全部未染色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            set&lt;<span class="hljs-type">int</span>&gt; color&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>            <span class="hljs-comment">// 把已染过色的去除</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> neighbour:graph[i])<br>                color.<span class="hljs-built_in">erase</span>(res[neighbour<span class="hljs-number">-1</span>]);<br>            <span class="hljs-comment">// 染色</span><br>            res[i<span class="hljs-number">-1</span>]=*color.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="997-找到小镇的法官-easy"><a href="#997-找到小镇的法官-easy" class="headerlink" title="997. 找到小镇的法官[easy]"></a><a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a>[easy]</h1><h2 id="解法：入度和出度"><a href="#解法：入度和出度" class="headerlink" title="解法：入度和出度"></a>解法：入度和出度</h2><h3 id="思路一：两个数组"><a href="#思路一：两个数组" class="headerlink" title="思路一：两个数组"></a>思路一：两个数组</h3><p>有向图问题。法官实际上就是出度为 0，入度为 N - 1 的节点。因此一个思路就是统计所有人的入度和出度信息，将满足条件的节点输出。用两个数组 inDegree 和 outDegree 分别记录入度和出度的信息，为了简单起见，初始化的数组长度为 N + 1，而不是 N。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outDegree</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:trust)<br>        &#123;<br>            ++inDegree[elem[<span class="hljs-number">1</span>]];<br>            ++outDegree[elem[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i]==N<span class="hljs-number">-1</span>&amp;&amp;outDegree[i]==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二：一个数组"><a href="#思路二：一个数组" class="headerlink" title="思路二：一个数组"></a>思路二：一个数组</h3><p>换个角度来思考，<strong>法官同样是 入度 - 出度 &#x3D;&#x3D; N - 1 的点</strong>，并且不是法官的人不可能是。这样无需同时维护入度和出度的信息，转而维护 <code>入读和出度的差值</code> 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:trust)<br>        &#123;<br>            ++cnt[elem[<span class="hljs-number">1</span>]];<br>            --cnt[elem[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt[i]==N<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="433-最小基因变化-medium"><a href="#433-最小基因变化-medium" class="headerlink" title="433. 最小基因变化[medium]"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化</a>[medium]</h1><p>整体思路与 <a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a> 相似。</p><h2 id="解法一：BFS-2"><a href="#解法一：BFS-2" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><p>具体步骤如下：</p><ul><li>把 begin 放入队列中；</li><li>出队一个元素，修改这个元素上第一字母，修改值在这四个字母中选择<code>&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;</code>，四个字母都遍历一遍，如果和最后一个元素匹配，那么就退出，返回当前的层级（step）加一，如果修改后元素的在 bank 中出现，那么就放入队列中，同时删除 bank 中的相同的元素；</li><li>然后把第一个元素还原原先的字母，然后开始修改第二个字母。执行和第2步一致。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">bankset</span><span class="hljs-params">(bank.begin(),bank.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(end)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        queue&lt;string&gt; q;<br>        vector&lt;<span class="hljs-type">char</span>&gt; str&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        bankset.<span class="hljs-built_in">erase</span>(start);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                string cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cur.<span class="hljs-built_in">size</span>();++j)<br>                &#123;<br>                    <span class="hljs-type">char</span> old=cur[j];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>                    &#123;<br>                        cur[j]=str[k];<br>                        <span class="hljs-keyword">if</span>(cur==end)<br>                            <span class="hljs-keyword">return</span> steps+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(cur);<br>                            bankset.<span class="hljs-built_in">erase</span>(cur);<br>                        &#125;<br>                    &#125;<br>                    cur[j]=old;<br>                &#125;<br>            &#125;<br>            ++steps;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：双向BFS"><a href="#解法二：双向BFS" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h2><p>用两个 set 从两个方向来进行 BFS。具体走过的路径会比较少，一般来说会减少一倍的路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">bankset</span><span class="hljs-params">(bank.begin(),bank.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(end)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">char</span>&gt; str=&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        unordered_set&lt;string&gt; left&#123;start&#125;;<br>        unordered_set&lt;string&gt; right&#123;end&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>()&amp;&amp;!right.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//优先选择小的哈希表进行扩散</span><br>            <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">size</span>()&gt;right.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                unordered_set&lt;string&gt; temp=left;<br>                left=right;<br>                right=temp;<br>            &#125;<br>            unordered_set&lt;string&gt; nextLevel;<br>            <span class="hljs-keyword">for</span>(string item:left)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;item.<span class="hljs-built_in">size</span>();++i)<br>                &#123;<br>                    <span class="hljs-type">char</span> old=item[i];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                    &#123;<br>                        item[i]=str[j];<br>                        <span class="hljs-keyword">if</span>(right.<span class="hljs-built_in">count</span>(item)!=<span class="hljs-number">0</span>)<br>                            <span class="hljs-keyword">return</span> steps+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(item)!=<span class="hljs-number">0</span>)<br>                        &#123;<br>                            bankset.<span class="hljs-built_in">erase</span>(item);<br>                            nextLevel.<span class="hljs-built_in">insert</span>(item);<br>                        &#125;<br>                    &#125;<br>                    item[i]=old;<br>                &#125;<br>            &#125;<br>            left=nextLevel;<br>            ++steps;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="863-二叉树中所有距离为-K-的结点-medium"><a href="#863-二叉树中所有距离为-K-的结点-medium" class="headerlink" title="863. 二叉树中所有距离为 K 的结点[medium]"></a><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a>[medium]</h1><h2 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><p>这道题让返回所有跟目标结点 target 相距 K 的结点。在子树中寻找距离为 K 的结点很容易，只需要一层一层的向下遍历即可，难点就在于符合题意的结点有可能是祖先结点，或者是在旁边的兄弟子树中，这就比较麻烦了，因为二叉树只有从父结点到子结点的路径，反过来就不行。既然没有，就手动创建这样的反向连接，这样树的遍历问题就转为了图的遍历（树也是一种特殊的图）。建立反向连接就是用一个 HashMap 来建立每个结点和其父结点之间的映射，使用先序遍历建立好所有的反向连接，然后再开始查找和目标结点距离 K 的所有结点，这里需要一个 HashSet 来记录所有已经访问过了的结点。</p><p>在递归函数中，首先判断当前结点是否已经访问过，是的话直接返回，否则就加入到 visited 中。再判断此时 K 是否为 0，是的话说明当前结点已经是距离目标结点为 K 的点了，将其加入结果 res 中，然后直接返回。否则分别对当前结点的左右子结点调用递归函数，注意此时带入 K-1，这两步是对子树进行查找。之前说了，还得对父结点，以及兄弟子树进行查找，这是就体现出建立的反向连接 HashMap 的作用了，若当前结点的父结点存在，也要对其父结点调用递归函数，并同样带入 K-1，这样就能正确的找到所有满足题意的点了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;TreeNode*,TreeNode*&gt; parent;<br>        unordered_set&lt;TreeNode*&gt; visited;<br>        <span class="hljs-built_in">findparent</span>(root,parent);<br>        <span class="hljs-built_in">dfs</span>(target,K,parent,visited,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findparent</span><span class="hljs-params">(TreeNode* node,unordered_map&lt;TreeNode*,TreeNode*&gt; &amp;parent)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>            parent[node-&gt;left]=node;<br>        <span class="hljs-keyword">if</span>(node-&gt;right)<br>            parent[node-&gt;right]=node;<br>        <span class="hljs-built_in">findparent</span>(node-&gt;left,parent);<br>        <span class="hljs-built_in">findparent</span>(node-&gt;right,parent);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> K,unordered_map&lt;TreeNode*,TreeNode*&gt; &amp;parent,unordered_set&lt;TreeNode*&gt; &amp;visited,vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        visited.<span class="hljs-built_in">insert</span>(node);<br>        <span class="hljs-keyword">if</span>(K==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>            <span class="hljs-built_in">dfs</span>(node-&gt;left,K<span class="hljs-number">-1</span>,parent,visited,res);<br>        <span class="hljs-keyword">if</span>(node-&gt;right)<br>            <span class="hljs-built_in">dfs</span>(node-&gt;right,K<span class="hljs-number">-1</span>,parent,visited,res);<br>        <span class="hljs-keyword">if</span>(parent[node])<br>            <span class="hljs-built_in">dfs</span>(parent[node],K<span class="hljs-number">-1</span>,parent,visited,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>解法二：BFS</p><p>既然是图的遍历，也可以使用 BFS 。为了方便起见，直接建立一个邻接链表，即每个结点最多有三个跟其相连的结点，左右子结点和父结点，使用一个 HashMap 来建立每个结点和其相邻的结点数组之间的映射，这样就几乎完全将其当作图来对待了，建立好邻接链表之后，原来的树的结构都不需要用了。既然是 BFS 进行层序遍历，就要使用队列 queue，还要一个 HashSet 来记录访问过的结点。在 while 循环中，若 K 为 0 了，说明当前这层的结点都是符合题意的，就把当前队列中所有的结点加入结果 res，并返回即可。否则就进行层序遍历，取出当前层的每个结点，并在邻接链表中找到和其相邻的结点，若没有访问过，就加入 visited 和 queue 中。每层遍历完成之后，K 自减 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;TreeNode*,vector&lt;TreeNode*&gt;&gt; graph;<br>        <span class="hljs-built_in">findparent</span>(root,<span class="hljs-literal">nullptr</span>,graph);<br>        queue&lt;TreeNode*&gt; q;<br>        unordered_set&lt;TreeNode*&gt; visited;<br>        q.<span class="hljs-built_in">push</span>(target);<br>        visited.<span class="hljs-built_in">insert</span>(target);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(K==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">front</span>()-&gt;val);<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;node:graph[cur])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    visited.<span class="hljs-built_in">insert</span>(node);<br>                    q.<span class="hljs-built_in">push</span>(node);<br>                &#125;<br>            &#125;<br>            --K;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findparent</span><span class="hljs-params">(TreeNode* node,TreeNode* pre,unordered_map&lt;TreeNode*,vector&lt;TreeNode*&gt;&gt; &amp;graph)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            graph[node].<span class="hljs-built_in">push_back</span>(pre);<br>            graph[pre].<span class="hljs-built_in">push_back</span>(node);<br>        &#125;<br>        <span class="hljs-built_in">findparent</span>(node-&gt;left,node,graph);<br>        <span class="hljs-built_in">findparent</span>(node-&gt;right,node,graph);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="743-网络延迟时间-medium"><a href="#743-网络延迟时间-medium" class="headerlink" title="743. 网络延迟时间[medium]"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>[medium]</h1><h2 id="解法：最短路径问题"><a href="#解法：最短路径问题" class="headerlink" title="解法：最短路径问题"></a>解法：最短路径问题</h2><p>最短路算法的分类：</p><ul><li>单源最短路<ul><li>所有边权都是正数<ul><li>朴素的Dijkstra算法 O(n^2) 适合稠密图</li><li>堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图</li></ul></li><li>存在负权边<ul><li>Bellman-Ford O(nm)</li><li>spfa 一般O(m),最坏O(nm)</li></ul></li></ul></li><li>多源汇最短路 Floyd算法 O(n^3)</li></ul><p>模版及思路参考 <a href="https://www.acwing.com/blog/content/405/">y总算法基础课——常用代码模板3——搜索与图论</a>。</p><h3 id="实现一：朴素Dijkstra算法"><a href="#实现一：朴素Dijkstra算法" class="headerlink" title="实现一：朴素Dijkstra算法"></a>实现一：朴素Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,INF));<span class="hljs-comment">// 存储每条边</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INF)</span></span>;<span class="hljs-comment">// 距离起始点的最短距离</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;time:times)<br>            graph[time[<span class="hljs-number">0</span>]][time[<span class="hljs-number">1</span>]]=time[<span class="hljs-number">2</span>];<br>        dist[k]=<span class="hljs-number">0</span>;<span class="hljs-comment">// 起始点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>            &#123;<br>                <span class="hljs-comment">// 在还未确定最短路的点中，寻找到起始点距离最小的点</span><br>                <span class="hljs-keyword">if</span>(!visited[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                    t=j;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>                <span class="hljs-comment">// 用t更新其他点的距离</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+graph[t][j]);<br>            visited[t]=<span class="hljs-literal">true</span>;<span class="hljs-comment">// t号点的最短路已经确定</span><br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dist[i]==INF)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            res=<span class="hljs-built_in">max</span>(res,dist[i]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="实现二：堆优化版Dijkstra算法"><a href="#实现二：堆优化版Dijkstra算法" class="headerlink" title="实现二：堆优化版Dijkstra算法"></a>实现二：堆优化版Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INF)</span></span>;<span class="hljs-comment">// 距离起始点的最短距离</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br>        <span class="hljs-keyword">using</span> PII=pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>        unordered_map&lt;<span class="hljs-type">int</span>,vector&lt;PII&gt;&gt; graph;<span class="hljs-comment">// 邻接表；u-&gt;v,权重w</span><br>        priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">// 小顶堆；维护到起始点的最短距离和点</span><br>        <span class="hljs-comment">// 初始化邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;time:times)<br>            graph[time[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(time[<span class="hljs-number">1</span>],time[<span class="hljs-number">2</span>]));<br>        <span class="hljs-comment">// first存储距离，second存储节点编号</span><br>        heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,k&#125;);<br>        dist[k]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> ver=t.second,distance=t.first;<br>            <span class="hljs-keyword">if</span>(visited[ver])<br>                <span class="hljs-comment">// 之前更新过，是冗余备份</span><br>                <span class="hljs-keyword">continue</span>;<br>            visited[ver]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 用t去更新其他点到起始点的最短距离</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;point:graph[ver])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dist[point.first]&gt;distance+point.second)<br>                &#123;<br>                    dist[point.first]=distance+point.second;<br>                    heap.<span class="hljs-built_in">push</span>(&#123;dist[point.first],point.first&#125;);<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dist[i]==INF)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            res=<span class="hljs-built_in">max</span>(res,dist[i]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="787-K-站中转内最便宜的航班-medium"><a href="#787-K-站中转内最便宜的航班-medium" class="headerlink" title="787. K 站中转内最便宜的航班[medium]"></a><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班[medium]</a></h1><h2 id="解法：最短路径问题-1"><a href="#解法：最短路径问题-1" class="headerlink" title="解法：最短路径问题"></a>解法：最短路径问题</h2><blockquote><p>有边数限制的最短路径问题使用Bellman-Ford算法较方便。</p></blockquote><p>模版及思路参考 <a href="https://www.acwing.com/blog/content/405/">y总算法基础课——常用代码模板3——搜索与图论</a>。</p><h3 id="实现：Bellman-Ford算法"><a href="#实现：Bellman-Ford算法" class="headerlink" title="实现：Bellman-Ford算法"></a>实现：Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n,INF)</span></span>;<br>        dist[src]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">backup</span><span class="hljs-params">(dist)</span></span>;<span class="hljs-comment">// backup数组为了防止串联</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;flight:flights)<br>                dist[flight[<span class="hljs-number">1</span>]]=<span class="hljs-built_in">min</span>(dist[flight[<span class="hljs-number">1</span>]],backup[flight[<span class="hljs-number">0</span>]]+flight[<span class="hljs-number">2</span>]);<span class="hljs-comment">// 仅用上一次迭代的结果来更新当前距离就不会发生串联</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(dist[dst]&gt;INF/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dist[dst];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="332-重新安排行程-medium"><a href="#332-重新安排行程-medium" class="headerlink" title="332. 重新安排行程[medium]"></a><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a>[medium]</h1><h2 id="解法：欧拉路径"><a href="#解法：欧拉路径" class="headerlink" title="解法：欧拉路径"></a>解法：欧拉路径</h2><blockquote><p>如果在一张图中，从一个点出发可以走完所有的边，则这个遍历走过的路径就叫欧拉路径。<br>可以理解为：一张图可以一笔画出来。</p></blockquote><p>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p><ul><li>从起点出发，进行深度优先搜索。</li><li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li><li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li></ul><p>实际是关于有向图的边的遍历，每张机票都是有向图的一条边。首先把图建立起来，通过邻接链表来建立。由于题目要求解法按字母顺序小的，那么考虑用multiset，可以自动排序。等图建立好了以后，从节点JFK开始遍历，只要当前节点映射的multiset里有节点，就取出这个节点，将其在multiset里删掉，然后继续递归遍历这个节点。由于题目中限定了一定会有解，那么等图中所有的multiset中都没有节点的时候，把当前节点存入结果中，然后再一层层回溯回去，将当前节点都存入结果，那么最后结果中存的顺序和需要的是相反的，再翻转一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        unordered_map&lt;string,multiset&lt;string&gt;&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:tickets)<br>            m[elem[<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(elem[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">dfs</span>(m,<span class="hljs-string">&quot;JFK&quot;</span>,res);<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;string,multiset&lt;string&gt;&gt; &amp;m,string s,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(m[s].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            string tmp=*m[s].<span class="hljs-built_in">begin</span>();<br>            m[s].<span class="hljs-built_in">erase</span>(m[s].<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-built_in">dfs</span>(m,tmp,res);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(s);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Divide and Conquer</title>
    <link href="/2020/12/15/Leetcode%20Notes%E2%80%94%E2%80%94Divide%20and%20Conquer/"/>
    <url>/2020/12/15/Leetcode%20Notes%E2%80%94%E2%80%94Divide%20and%20Conquer/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>分治算法</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。</p><p>归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终会得到多个长度为 1 的子数组;“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为 1 的子数组开始，最终合成一个大数组。</p><p>另外，自上而下的分治可以和 memoization 结合，避免重复遍历相同的子问题。如果方便推<br>导，也可以换用自下而上的动态规划方法求解。</p><h1 id="241-为运算表达式设计优先级-medium"><a href="#241-为运算表达式设计优先级-medium" class="headerlink" title="241. 为运算表达式设计优先级[medium]"></a><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">241. 为运算表达式设计优先级</a>[medium]</h1><h2 id="解法一：分治算法"><a href="#解法一：分治算法" class="headerlink" title="解法一：分治算法"></a>解法一：分治算法</h2><p>对于一个形如 <code>x op y</code>（<code>op</code> 为运算符，<code>x</code> 和 <code>y</code> 为数）的算式而言，<strong>它的结果组合取决于 <code>x</code> 和 <code>y</code> 的结果组合数</strong>，而 <code>x</code> 和 <code>y</code> 又可以写成形如 <code>x op y</code> 的算式。</p><p>因此，该问题的子问题就是 <code>x op y</code> 中的 <code>x</code> 和 <code>y</code>：<strong>以运算符分隔的左右两侧算式解</strong>。</p><p>然后进行 <strong>分治算法三步走</strong>：</p><ul><li>分解：按运算符分成左右两部分，分别求解；</li><li>解决：实现一个递归函数，输入算式，返回算式解；</li><li>合并：根据运算符合并左右两部分的解，得出最终解。</li></ul><p><code>substr</code>：第一个参数为起始位置，第二个参数为长度。如果不设置长度的话，默认为到最尾部。<code>string substr (size_t pos = 0, size_t len = npos) const;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string input)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;input.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">char</span> ch=input[i];<br>            <span class="hljs-comment">// 分解：遇到运算符，计算左右两侧的结果集</span><br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>||ch==<span class="hljs-string">&#x27;*&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// 解决：diffWaysToCompute 递归函数求出子问题的解</span><br>                <span class="hljs-comment">// </span><br>                vector&lt;<span class="hljs-type">int</span>&gt; left=<span class="hljs-built_in">diffWaysToCompute</span>(input.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i));<span class="hljs-comment">// 符号左边的组合</span><br>                vector&lt;<span class="hljs-type">int</span>&gt; right=<span class="hljs-built_in">diffWaysToCompute</span>(input.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>));<span class="hljs-comment">// 符号右边的组合</span><br>                <span class="hljs-comment">// 合并：根据运算符合并子问题的解</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x:left)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y:right)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x+y);<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x-y);<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x*y);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// input 只是一个数字</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">empty</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(input));<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="memoization-优化"><a href="#memoization-优化" class="headerlink" title="memoization 优化"></a><code>memoization</code> 优化</h3><p>由于递归是两个分支，所以会有一些解进行了重复计算，可以使用 <code>memoization</code> 技术，用 HashMap 来保存已经计算过的情况，提升运算速度，以空间换时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string input)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果已经有当前解了，直接返回</span><br>        <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(input)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> m[input];<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;input.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">char</span> ch=input[i];<br>            <span class="hljs-comment">// 分解：遇到运算符，计算左右两侧的结果集</span><br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>||ch==<span class="hljs-string">&#x27;*&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// 解决：diffWaysToCompute 递归函数求出子问题的解</span><br>                <span class="hljs-comment">// </span><br>                vector&lt;<span class="hljs-type">int</span>&gt; left=<span class="hljs-built_in">diffWaysToCompute</span>(input.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i));<span class="hljs-comment">// 符号左边的组合</span><br>                vector&lt;<span class="hljs-type">int</span>&gt; right=<span class="hljs-built_in">diffWaysToCompute</span>(input.<span class="hljs-built_in">substr</span>(i+<span class="hljs-number">1</span>));<span class="hljs-comment">// 符号右边的组合</span><br>                <span class="hljs-comment">// 合并：根据运算符合并子问题的解</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x:left)<br>                &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y:right)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x+y);<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x-y);<br>                        <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;*&#x27;</span>)<br>                            res.<span class="hljs-built_in">push_back</span>(x*y);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// input 只是一个数字</span><br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">empty</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(input));<br>        <span class="hljs-comment">// 存到 map</span><br>        m[input]=res;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string,vector&lt;<span class="hljs-type">int</span>&gt;&gt; m;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>为了比较好定义 <code>dp</code> 数组的含义，先做一个预处理，把每个数字提前转为 <code>int</code> 然后存起来，同时把运算符也都存起来。这样就有了两个 <code>list</code>，一个保存了所有数字，一个保存了所有运算符。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">2 *<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>* 5<br>存起来的数字是 numList = [2<span class="hljs-number"> 3 </span>4 5]，<br>存起来的运算符是 opList = [*, -, *]。<br></code></pre></td></tr></table></figure><p><code>dp[i][j]</code> 也比较好定义了，含义是第 <code>i</code> 到第 <code>j</code> 个数字（从 <code>0</code> 开始计数）范围内的表达式的所有解。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">举个例子，2 *<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 5 </span><br>dp[1][3] 就代表第一个数字<span class="hljs-number"> 3 </span>到第三个数字<span class="hljs-number"> 5 </span>范围内的表达式<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 5 </span>的所有解。<br></code></pre></td></tr></table></figure><p>初始条件的话，也很简单了，就是范围内只有一个数字。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">2 * 3 - 4 * 5 <br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[0]</span> = <span class="hljs-comment">[2]</span>，dp<span class="hljs-comment">[1]</span><span class="hljs-comment">[1]</span> = <span class="hljs-comment">[3]</span>，dp<span class="hljs-comment">[2]</span><span class="hljs-comment">[2]</span> = <span class="hljs-comment">[4]</span>，dp<span class="hljs-comment">[3]</span><span class="hljs-comment">[3]</span> = <span class="hljs-comment">[5]</span>。<br></code></pre></td></tr></table></figure><p>有了一个数字的所有解，然后两个数字的所有解就可以求出来。有了两个数字的所有解，然后三个数字的所有解可以把三个数字分成两部分，将两部分的解两两组合起来即可。</p><p>两部分之间的运算符的话，因为表达式是一个数字一个运算符，所以运算符的下标就是左部分最后一个数字的下标。看下边的例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">2 *<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>* 5<br>存起来的数字是 numList = [2<span class="hljs-number"> 3 </span>4 5]，<br>存起来的运算符是 opList = [*, -, *]。<br><br>假设求 dp[1][3]<br>也就是计算<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 5 </span>的解<br>分成<span class="hljs-number"> 3 </span>和<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 5 </span>两部分，3 对应的下标是<span class="hljs-number"> 1 </span>，对应的运算符就是 opList[1] = &#x27;-&#x27; 。<br>也就是计算<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 20 </span>= -17<br>    <br>分成<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 5 </span>两部分，4 的下标是<span class="hljs-number"> 2 </span>，对应的运算符就是 opList[2] = &#x27;*&#x27;。<br>也就是计算 -1 *<span class="hljs-number"> 5 </span>= -5<br>    <br>所以 dp[1][3] = [-17 -5]<br></code></pre></td></tr></table></figure><p>四个、五个… 都可以分成两部分，然后通过之前的解求出来。</p><p>直到包含了所有数字的解求出来，假设数字总个数是 <code>n</code>，<code>dp[0][n-1]</code> 就是最后返回的了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string input)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; numVec;<br>        vector&lt;<span class="hljs-type">char</span>&gt; opVec;<br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 预处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;input.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">char</span> ch=input[i];<br>            <span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;+&#x27;</span>||ch==<span class="hljs-string">&#x27;-&#x27;</span>||ch==<span class="hljs-string">&#x27;*&#x27;</span>)<br>            &#123;<br>                opVec.<span class="hljs-built_in">push_back</span>(ch);<br>                numVec.<span class="hljs-built_in">push_back</span>(num);<br>                num=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            num=num*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 存最后一个数字</span><br>        numVec.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-type">int</span> cnt=numVec.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// 数字的个数</span><br>        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(cnt, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(cnt, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;()));<br>        <span class="hljs-comment">// 一个数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; res;<br>            res.<span class="hljs-built_in">push_back</span>(numVec[i]);<br>            dp[i][i]=res;<br>        &#125;<br>        <span class="hljs-comment">// 2 个数字到 N 个数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">2</span>;n&lt;=cnt;++n)<br>        &#123;<br>            <span class="hljs-comment">// 开始下标</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;++i)<br>            &#123;<br>                <span class="hljs-comment">// 结束下标</span><br>                <span class="hljs-type">int</span> j=i+n<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(j&gt;=cnt)<br>                    <span class="hljs-keyword">break</span>;<br>                vector&lt;<span class="hljs-type">int</span>&gt; res;<br>                <span class="hljs-comment">// 分成 i ~ s 和 s+1 ~ j 两部分</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=i;s&lt;j;++s)<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; left=dp[i][s];<br>                    vector&lt;<span class="hljs-type">int</span>&gt; right=dp[s+<span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x:left)<br>                    &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y:right)<br>                        &#123;<br>                            <span class="hljs-comment">// 第 s 个数字下标对应是第 s 个运算符</span><br>                            <span class="hljs-type">char</span> op=opVec[s];<br>                            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">calculate</span>(x,op,y));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                dp[i][j]=res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][cnt<span class="hljs-number">-1</span>];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">char</span> op,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;+&#x27;</span>)<br>            <span class="hljs-keyword">return</span> x+y;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            <span class="hljs-keyword">return</span> x-y;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> x*y;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="169-多数元素-easy"><a href="#169-多数元素-easy" class="headerlink" title="169. 多数元素[easy]"></a><a href="https://leetcode-cn.com/problems/majority-element/">169. 多数元素</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用哈希表存储每个元素以及出现的次数。用一个循环遍历数组 <code>nums</code> 并将数组中的每个元素加入哈希表中。在这之后，遍历哈希表中的所有键值对，返回超过二分之一数组大小的键。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; counts;       <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> num:nums)       <br>            ++counts[num];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> kv:counts)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(kv.second&gt;nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">return</span> kv.first;<br>        &#125;    <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>在遍历数组 <code>nums</code> 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希表的遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; counts;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> majority=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> num:nums)<br>        &#123;<br>            ++counts[num];<br>            <span class="hljs-keyword">if</span>(counts[num]&gt;cnt)<br>            &#123;<br>                majority=num;<br>                cnt=counts[num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> majority;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h2 id="解法二：排序"><a href="#解法二：排序" class="headerlink" title="解法二：排序"></a>解法二：排序</h2><p>将将数组 <code>nums</code> 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 ⌊ n&#x2F;2 ⌋ 的元素（下标从 <code>0</code> 开始）一定是众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(logn)。</p><h2 id="解法三：分治算法"><a href="#解法三：分治算法" class="headerlink" title="解法三：分治算法"></a>解法三：分治算法</h2><p>如果数 <code>a</code> 是数组 <code>nums</code> 的众数，将 <code>nums</code> 分成两部分，那么 <code>a</code> 必定是至少一部分的众数。这样以来，就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 <code>a1</code> 以及右半部分的众数 <code>a2</code>，随后在 <code>a1</code> 和 <code>a2</code> 中选出正确的众数。</p><p>使用递归求解，直到所有的子问题都是长度为 <code>1</code> 的数组。长度为 <code>1</code> 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 <code>1</code>，必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">majorrityRange</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>: <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorrityRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(lo==hi)<br>            <span class="hljs-keyword">return</span> nums[lo];<br>        <span class="hljs-type">int</span> mid=lo+(hi-lo)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">majorrityRange</span>(nums,lo,mid);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">majorrityRange</span>(nums,mid+<span class="hljs-number">1</span>,hi);<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-type">int</span> leftCount=<span class="hljs-built_in">countRange</span>(nums,left,lo,hi);<br>        <span class="hljs-type">int</span> rightCount=<span class="hljs-built_in">countRange</span>(nums,right,lo,hi);<br>        <span class="hljs-keyword">return</span> leftCount&gt;=rightCount?left:right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lo;i&lt;=hi;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==num)<br>                ++count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(logn)。</p><h2 id="解法四：摩尔投票算法"><a href="#解法四：摩尔投票算法" class="headerlink" title="解法四：摩尔投票算法"></a>解法四：摩尔投票算法</h2><p>如果把众数记为 +1，把其他数记为 -1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身可以看出众数比其他数多。</p><p>摩尔投票算法步骤：</p><ul><li>维护一个候选众数 <code>candidate</code> 和它出现的次数 <code>count</code>。初始时 <code>candidate</code> 可以为任意值，<code>count</code> 为 <code>0</code>；</li><li>遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 <code>0</code>，先将 <code>x</code> 的值赋予 <code>candidate</code>，随后判断 <code>x</code>：<ul><li>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count</code> 的值增加 <code>1</code>；</li><li>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count</code> 的值减少 <code>1</code>。</li></ul></li><li>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</li></ul><p>为何这行得通呢？<br>投票法是遇到相同的则 <code>票数 + 1</code>，遇到不同的则 <code>票数 - 1</code>。且“多数元素”的个数 <code>&gt; ⌊ n/2 ⌋</code>，其余元素的个数总和 <code>&lt;= ⌊ n/2 ⌋</code>。因此“多数元素”的个数 <code>-</code> 其余元素的个数总和的结果肯定 <code>&gt;= 1</code>。这就相当于每个“多数元素”和其他元素两两相互抵消，抵消到最后肯定还剩余<strong>至少<code>1</code>个</strong>“多数元素”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> candidate=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)<br>                candidate=num;<br>            count+=num==candidate?<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> candidate;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Divide and Conquer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Search</title>
    <link href="/2020/11/05/Leetcode%20Notes%E2%80%94%E2%80%94Search/"/>
    <url>/2020/11/05/Leetcode%20Notes%E2%80%94%E2%80%94Search/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>搜索算法</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。方法论、部分题解等搬运自 @<a href="https://leetcode-cn.com/u/liweiwei1419/">liweiwei1419</a>。</p><span id="more"></span><h1 id="搜索算法方法论"><a href="#搜索算法方法论" class="headerlink" title="搜索算法方法论"></a>搜索算法方法论</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（breadth-first search，BFS）不同于深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理<strong>最短路径</strong>等问题。</p><h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。</p><p>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有[修改当前节点状态]-&gt;[递归子节点] 的步骤，只是多了回溯的步骤，变成了[修改当前节点状态]-&gt;[递归子节点]-&gt;[回改当前节点状态]。</p><p>回溯算法要点：</p><ul><li>如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法；</li><li>回溯算法是在一棵树上的 <strong>深度优先遍历</strong>（<strong>因为要找所有的解，所以需要遍历</strong>）；</li><li>组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即 <code>[1, 2, 3]</code> 与 <code>[1, 3, 2]</code>认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。</li><li>回溯算法首先需要画出递归树，不同的树决定了不同的代码实现。</li></ul><h2 id="回溯算法与深度优先遍历"><a href="#回溯算法与深度优先遍历" class="headerlink" title="回溯算法与深度优先遍历"></a>回溯算法与深度优先遍历</h2><p>以下是维基百科中「回溯算法」和「深度优先遍历」的定义。</p><p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p><ul><li>找到一个可能存在的正确的答案；</li><li>在尝试了所有可能的分步方法后宣告该问题没有答案。</li></ul><p><strong>深度优先搜索</strong> 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 <strong>尽可能深</strong> 的搜索树的分支。当结点 <code>v</code>的所在边都己被探寻过，搜索将 <strong>回溯</strong> 到发现结点 <code>v</code>的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 <strong>不断变化</strong> 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 <strong>回退</strong> 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。</p><h2 id="搜索与遍历"><a href="#搜索与遍历" class="headerlink" title="搜索与遍历"></a>搜索与遍历</h2><p>我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。</p><p>搜索问题的解，可以通过 <strong>遍历</strong> 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 <strong>搜索一个问题的所有的解</strong> ，通过深度优先遍历的思想实现。</p><h2 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>用于求解多阶段决策问题。多阶段决策问题即：</p><ul><li>求解一个问题分为很多步骤（阶段）；</li><li>每一个步骤（阶段）可以有多种选择。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li><li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li></ul><h1 id="题型一：排列、组合、子集相关问题"><a href="#题型一：排列、组合、子集相关问题" class="headerlink" title="题型一：排列、组合、子集相关问题"></a>题型一：排列、组合、子集相关问题</h1><p>提示：这部分练习可以帮助熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件，<strong>为什么有的时候用 <code>used</code> 数组，有的时候设置搜索起点 <code>begin</code> 变量</strong>，理解状态变量设计的想法。排列例题为 <a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">46.全排列</a>，组合例题为 <a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">39.组合总和</a>，子集例题为 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>。此外，关于这三种问题的理解也可以参考 @<a href="https://leetcode-cn.com/problems/subsets/solution/hui-su-si-xiang-tuan-mie-pai-lie-zu-he-zi-ji-wen-t/">labuladong</a> 题解。</p><h2 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46. 全排列[medium]"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>[medium]</h2><h3 id="解法：回溯"><a href="#解法：回溯" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>回溯法详细思路叙述参考 @<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">liweiwei1419</a> 题解。</p><h4 id="从全排列问题开始理解回溯算法"><a href="#从全排列问题开始理解回溯算法" class="headerlink" title="从全排列问题开始理解回溯算法"></a>从全排列问题开始理解回溯算法</h4><p>以数组 <code>[1, 2, 3]</code> 的全排列为例。</p><ul><li>先写以 1 开头的全排列，它们是：<code>[1, 2, 3], [1, 3, 2]</code>，即 <code>1</code> + <code>[2, 3]</code>的全排列（注意：<strong>递归结构体现在这里</strong>）；</li><li>再写以 2 开头的全排列，它们是：<code>[2, 1, 3], [2, 3, 1]</code>，即 <code>2</code> + <code>[1, 3]</code>的全排列；</li><li>最后写以 3 开头的全排列，它们是：<code>[3, 1, 2], [3, 2, 1]</code>，即 <code>3</code> + <code>[1, 2]</code>的全排列。</li></ul><p>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 <strong>当前</strong> 要选择的数字中不能出现。按照这种策略搜索就能够做到 <strong>不重不漏</strong>。这样的思路，可以用一个树形结构表示。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118211043.png" style="zoom:80%;" /><p>说明：</p><ul><li><strong>每一个结点表示了求解全排列问题的不同的阶段</strong>，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；</li><li>使用深度优先遍历有「回头」的过程，在「回头」以后， <strong>状态变量需要设置成为和先前一样</strong> ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；</li><li>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，<code>path</code>变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 <code>path</code>变量是一个栈；</li><li>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。</li></ul><p>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 <strong>遍历</strong>，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p><h4 id="设计状态变量"><a href="#设计状态变量" class="headerlink" title="设计状态变量"></a>设计状态变量</h4><ul><li>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 <strong>递归</strong> 结构；</li><li>递归的终止条件是： <strong>一个排列中的数字已经选够了</strong> ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 <code>depth</code>，或者命名为 <code>index</code>，表示当前要确定的是某个全排列中下标为 <code>index</code>的那个数是多少；</li><li>布尔数组 <code>used</code>，初始化的时候都为 <code>false</code> 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 <code>true</code>，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</li></ul><p>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><h4 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 保存所有可能的全排列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!used[i])<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                used[i]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//print(&quot;  递归之前 =&gt; &quot; + path);</span><br>                <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,path,used,res);<br>                <span class="hljs-comment">// 注意：下面这两行代码发生「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的</span><br>                used[i]=<span class="hljs-literal">false</span>;<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">//print(&quot;递归之后 =&gt; &quot; + path);</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="通过打印输出观察"><a href="#通过打印输出观察" class="headerlink" title="通过打印输出观察"></a>通过打印输出观察</h5><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">  递归之前 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>输出 =&gt; <span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h4><p>让未排列的元素交换到当前位置上都排一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 是后面的数字都在 start 位置上排一次</span><br>            <span class="hljs-built_in">swap</span>(nums[start],nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,start+<span class="hljs-number">1</span>,res);<br>            <span class="hljs-built_in">swap</span>(nums[start],nums[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>参考 @<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">liweiwei1419</a> 题解。</p><h4 id="理解回溯"><a href="#理解回溯" class="headerlink" title="理解回溯"></a>理解回溯</h4><p>从 <code>[1, 2, 3]</code> 到 <code>[1, 3, 2]</code>，深度优先遍历是这样做的，从 <code>[1, 2, 3]</code> 回到 <code>[1, 2]</code>的时候，需要撤销刚刚已经选择的数 <code>3</code>，因为在这一层只有一个数 <code>3</code> 我们已经尝试过了，因此程序回到上一层，需要撤销对 <code>2</code> 的选择，好让后面的程序知道，选择 <code>3</code>了以后还能够选择 <code>2</code>。</p><p>执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做「状态重置」，即「回到过去」、「恢复现场」。</p><h3 id="几点说明帮助理解「回溯算法」"><a href="#几点说明帮助理解「回溯算法」" class="headerlink" title="几点说明帮助理解「回溯算法」"></a>几点说明帮助理解「回溯算法」</h3><h4 id="每一次尝试都「复制」，则不需要回溯"><a href="#每一次尝试都「复制」，则不需要回溯" class="headerlink" title="每一次尝试都「复制」，则不需要回溯"></a>每一次尝试都「复制」，则不需要回溯</h4><p>如果在每一个 <strong>非叶子结点</strong> 分支的尝试，都创建 <strong>新的变量</strong> 表示状态，那么</p><ul><li>在回到上一层结点的时候不需要「回溯」；</li><li>在递归终止的时候也不需要做拷贝。</li></ul><p>这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p><h5 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!used[i])<br>            &#123;<br>                <span class="hljs-comment">// 每一次尝试都创建新的变量表示当前的&quot;状态&quot;</span><br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newPath</span><span class="hljs-params">(path)</span></span>;<br>                newPath.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">newUsed</span><span class="hljs-params">(used)</span></span>;<br>                newUsed[i]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,newPath,newUsed,res);<br>                <span class="hljs-comment">// 无需回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：</p><ul><li>每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；</li><li>每一次尝试都使用同样的<strong>新的材料</strong>做实验。</li></ul><h4 id="为什么不是广度优先遍历"><a href="#为什么不是广度优先遍历" class="headerlink" title="为什么不是广度优先遍历"></a>为什么不是广度优先遍历</h4><ul><li>首先是正确性，只有遍历状态空间，才能得到所有符合条件的解，这一点 BFS 和 DFS 其实都可以；</li><li>在深度优先遍历的时候，<strong>不同状态之间的切换很容易</strong> ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；</li><li>如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；</li><li>如果使用广度优先遍历就得使用队列，然后编写结点类。队列中需要存储每一步的状态信息，<strong>需要存储的数据很大，真正能用到的很少</strong> 。</li><li>使用深度优先遍历，直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。我们不用编写结点类，不必手动编写栈完成深度优先遍历。</li></ul><h4 id="不回溯可不可以"><a href="#不回溯可不可以" class="headerlink" title="不回溯可不可以"></a>不回溯可不可以</h4><p>可以。搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。</p><p>就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 O(N)。路径变量在深度优先遍历的时候，结点之间的转换只需要 O(1)。</p><p>最后，由于回溯算法的时间复杂度很高，因此在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称为 <strong>剪枝</strong>。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><ul><li><p>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；</p><blockquote><p>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p></blockquote></li><li><p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做题的时候，建议 <strong>先画树形图</strong> ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p><p>在画图的过程中思考清楚：</p><ul><li>分支如何产生；</li><li>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？</li><li>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li></ul><h2 id="47-全排列-II-medium"><a href="#47-全排列-II-medium" class="headerlink" title="47. 全排列 II[medium]"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>[medium]</h2><h3 id="解法：回溯-剪枝"><a href="#解法：回溯-剪枝" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><p>详细思路叙述参考 @<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">liweiwei1419</a> 题解。</p><p>在 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a> 的基础上增加了 <strong>序列中的元素可重复</strong> 这一条件，但要求：返回的结果又不能有重复元素。</p><p>思路是：在遍历的过程中，一边遍历一遍检测，<strong>在一定会产生重复结果集的地方剪枝</strong>。</p><p>一个比较容易想到的办法是在结果集中去重。但是问题来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。</p><p>如果要比较两个列表是否一样，一个容易想到的办法是对列表分别排序，然后逐个比对。既然要排序，我们就可以 <strong>在搜索之前就对候选数组排序</strong>，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复列表。</p><p>画出树形结构如下：重点想象深度优先遍历在这棵树上执行的过程，哪些地方遍历下去一定会产生重复，这些地方的状态的特点是什么？<br>对比图中标注 ① 和 ② 的地方。相同点是：这一次搜索的起点和上一次搜索的起点一样。不同点是：</p><ul><li>标注 ① 的地方上一次搜索的相同的数刚刚被撤销；</li><li>标注 ② 的地方上一次搜索的相同的数刚刚被使用。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118221858.png" style="zoom:80%;" /><p>产生重复结点的地方，正是图中标注了「剪刀」，且被红色框框住的地方。</p><p>大家也可以把第 2 个 <code>1</code> 加上 <code>&#39;</code> ，即 <code>[1, 1&#39;, 2]</code>去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。这里还有一个很细节的地方：</p><ul><li>在图中 ② 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 还在使用中；</li><li><strong>在图中 ① 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支</strong>。</li></ul><p>代码实现方面，在第 46 题的基础上，要加上这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就能检测到标注为 ① 的两个结点，跳过它们。注意：这里 <code>used[i - 1]</code> 不加 <code>!</code>，测评也能通过。可以想一想这是为什么。建议做这样几个对比实验：</p><ul><li>干脆就不写 <code>!used[i - 1]</code>结果是什么样？</li><li>写 <code>used[i - 1]</code>结果是什么，代码又是怎样执行的。这里给出的结论是：<code>!used[i - 1]</code>这样的剪枝更彻底。附录会分析原因。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序（升序或者降序都可以），排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span><br>            <span class="hljs-comment">// 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;!used[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,path,used,res);<br>            <span class="hljs-comment">// 回溯部分的代码，和 dfs 之前的代码是对称的</span><br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p><strong>写 <code>used[i - 1]</code> 代码正确，但是不推荐的原因</strong>。参考 @<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">liweiwei1419</a> 题解。</p><h2 id="784-字母大小写全排列-medium"><a href="#784-字母大小写全排列-medium" class="headerlink" title="784. 字母大小写全排列[medium]"></a><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a>[medium]</h2><h3 id="解法：回溯-1"><a href="#解法：回溯-1" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><ul><li>这一类搜索问题是在一个隐式的树上进行的搜索问题，即「树形问题」。解决这一类问题， <strong>先画出递归树是十分重要的，可以帮助打开思路</strong> ，然后看着图形把代码写出来；</li><li>这个问题所求的解，是这棵树的叶子结点上的值。因此，可以使用深度优先遍历，收集 <strong>所有</strong> 叶子结点的值，<strong>深度优先遍历用于搜索也叫回溯算法</strong>；</li><li>回溯算法因为有回头的过程，因此其显著特征是 <strong>状态重置</strong>。参考 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174228.png" style="zoom:67%;" /><h4 id="技巧：使用异或运算转换字母大小写"><a href="#技巧：使用异或运算转换字母大小写" class="headerlink" title="技巧：使用异或运算转换字母大小写"></a><strong>技巧</strong>：使用异或运算转换字母大小写</h4><p>先看一看 <a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">ASCII 表</a>，A 到 Z，Z 完了以后没有直接到 a，中间隔了 6 个字符。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174205.png" style="zoom:67%;" /><p>（中间省略）</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174327.png" style="zoom:67%;" /><p>发现大写字符与其对应的小写字符的 ASCII 的差为 32，即 2^5，在编程语言中，可以表示为 <code>1 &lt;&lt; 5</code>。而变换大小写这件事等价于：</p><ul><li>如果字符是小写字符，减去 32 得到大写字符；</li><li>如果字符是大写字符，加上 32 得到小写字符。</li></ul><p>而这两者合并起来，就是给这个字符做一次不进位的加法，即异或上 <code>1 &lt;&lt; 5</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(S,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;S,<span class="hljs-type">int</span> index,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==S.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(S);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 未修改当前字符(字母或者数字)的一条分支</span><br>        <span class="hljs-built_in">dfs</span>(S,index+<span class="hljs-number">1</span>,res);<br>        <span class="hljs-comment">// 修改当前字母的的另一条分支</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(S[index]))<br>        &#123;<br>            S[index]^=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>;<br>            <span class="hljs-built_in">dfs</span>(S,index+<span class="hljs-number">1</span>,res);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39. 组合总和[medium]"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a>[medium]</h2><h3 id="解法：回溯-2"><a href="#解法：回溯-2" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>详细思路叙述参考 @<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419</a> 题解。</p><h4 id="思路一：根据搜索起点画出二叉树"><a href="#思路一：根据搜索起点画出二叉树" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>思路分析：根据示例 1：输入: <code>candidates = [2, 3, 6, 7]</code>，<code>target = 7</code>。</p><ul><li>候选数组里有 <code>2</code>，如果找到了组合总和为 <code>7 - 2 = 5</code> 的所有组合，再在之前加上 <code>2</code> ，就是 <code>7</code>的所有组合；</li><li>同理考虑 <code>3</code>，如果找到了组合总和为 <code>7 - 3 = 4</code> 的所有组合，再在之前加上 <code>3</code> ，就是 <code>7</code>的所有组合，依次这样找下去。</li></ul><p>基于以上的想法，可以画出如下的树形图。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119195422.png" style="zoom:80%;" /><p>说明：</p><ul><li>以 <code>target = 7</code>为 <strong>根结点</strong> ，创建一个分支的时 <strong>做减法</strong> ；</li><li>每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 <code>candidate</code>数组的每个元素的值；</li><li>减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；</li><li>所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。</li></ul><p>这棵树有 4 个叶子结点的值 0，对应的路径列表是 <code>[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]</code>，而示例中给出的输出只有 <code>[[7], [2, 2, 3]]</code>。即：题目中要求每一个符合要求的解是 <strong>不计算顺序</strong> 的。下面分析为什么会产生重复。</p><h5 id="针对具体例子分析重复路径产生的原因（难点）"><a href="#针对具体例子分析重复路径产生的原因（难点）" class="headerlink" title="针对具体例子分析重复路径产生的原因（难点）"></a>针对具体例子分析重复路径产生的原因（难点）</h5><p>产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说 <strong>每一个元素可以重复使用</strong>，我们考虑了 <strong>所有的</strong> 候选数，因此出现了重复的列表。</p><p>一种简单的去重方案是借助哈希表的天然去重的功能，但实际操作一下，就会发现并没有那么容易。</p><p>可不可以在搜索的时候就去重呢？答案是可以的。遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 <strong>按某种顺序</strong> 搜索。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起</strong>点 <code>begin</code>，请看下图。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119200033.png" style="zoom: 80%;" /><p>即：从每一层的第 22 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。</p><blockquote><p>友情提示：如果题目要求，结果集不计算顺序，此时需要按顺序搜索，才能做到不重不漏。「力扣」第 47 题（ <a href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a> ）、「力扣」第 15 题（ <a href="https://leetcode-cn.com/problems/3sum/">三数之和</a> ）也使用了类似的思想，使得结果集没有重复。</p></blockquote><h6 id="实现一-1"><a href="#实现一-1" class="headerlink" title="实现一"></a>实现一</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-comment">// 从根结点到叶子结点的路径</span><br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// target 为负数和 0 的时候不再产生新的孩子结点</span><br>        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 重点理解这里从 begin 开始搜索的语意</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span><br>            <span class="hljs-built_in">dfs</span>(candidates,i,path,target-candidates[i],res);<br>            <span class="hljs-comment">// 状态重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="剪枝提速"><a href="#剪枝提速" class="headerlink" title="剪枝提速"></a>剪枝提速</h5><ul><li>根据上面画树形图的经验，如果 <code>target</code>减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的；</li><li>排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。</li></ul><h6 id="实现二-1"><a href="#实现二-1" class="headerlink" title="实现二"></a>实现二</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span><br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 重点理解这里剪枝，前提是候选数组已经有序</span><br>            <span class="hljs-keyword">if</span>(target-candidates[i]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">dfs</span>(candidates,i,path,target-candidates[i],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h5><p>如果对于「回溯算法」的理解还很模糊，建议在「递归」之前和「递归」之后，把 <code>path</code> 变量的值打印出来看一下，以加深对于程序执行流程的理解。</p><p>直接查阅@<a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419</a> 题解。</p><h4 id="思路二：按照每一个数选与不选画出二叉树"><a href="#思路二：按照每一个数选与不选画出二叉树" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>对于组合来说，还可以根据一个数选和不选画树形图。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119202112.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==candidates.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(candidates,begin+<span class="hljs-number">1</span>,path,target,res);<br>        <span class="hljs-comment">// 选择当前数</span><br>        <span class="hljs-keyword">if</span>(target-candidates[begin]&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[begin]);<br>            <span class="hljs-built_in">dfs</span>(candidates,begin,path,target-candidates[begin],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119201031.png" style="zoom:67%;" /><h4 id="什么时候使用-used-数组，什么时候使用-begin-变量"><a href="#什么时候使用-used-数组，什么时候使用-begin-变量" class="headerlink" title="什么时候使用 used 数组，什么时候使用 begin 变量"></a>什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code> 变量</h4><p>有些朋友可能会疑惑什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code>变量。这里为大家简单总结一下：</p><ul><li>排列问题，讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code> 视为不同列表时），需要记录哪些数字已经使用过，此时用 <code>used</code>数组；</li><li>组合问题，不讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code>视为相同列表时），需要按照某种顺序搜索，此时使用 <code>begin</code>变量。</li></ul><p>注意：具体问题应该具体分析， <strong>理解算法的设计思想</strong> 是至关重要的，请不要死记硬背。</p><h2 id="40-组合总和-II-medium"><a href="#40-组合总和-II-medium" class="headerlink" title="40. 组合总和 II[medium]"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a>[medium]</h2><h3 id="解法：回溯-剪枝-1"><a href="#解法：回溯-剪枝-1" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><p>详细思路叙述参考 @<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">liweiwei1419</a> 题解。</p><p>与 <a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 的差别：</p><p>39  <code>candidates</code> 中的数字可以无限制重复被选取；40 <code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p>相同点是：相同数字列表的不同排列视为一个结果。</p><h4 id="如何去掉重复的集合（重点）"><a href="#如何去掉重复的集合（重点）" class="headerlink" title="如何去掉重复的集合（重点）"></a>如何去掉重复的集合（重点）</h4><p>为了使得解集不包含重复的组合。有以下 2 种方案：</p><ul><li>使用 <strong>哈希表</strong> 天然的去重功能，但是编码相对复杂；</li><li>这里我们使用和第 39 题和第 15 题（三数之和）类似的思路：不重复就需要按 <strong>顺序</strong> 搜索， <strong>在搜索的过程中检测分支是否会出现重复结果</strong> 。注意：这里的顺序不仅仅指数组 <code>candidates</code>有序，还指按照一定顺序搜索结果。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119210609.png" style="zoom:80%;" /><p>由第 39 题我们知道，数组 <code>candidates</code> 有序，也是 <strong>深度优先遍历</strong> 过程中实现「剪枝」的前提。<br>将数组先排序的思路来自于这个问题：去掉一个数组中重复的元素。很容易想到的方案是：先对数组 <strong>升序</strong> 排序，重复的元素一定不是排好序以后相同的连续数组区域的第 1 个元素。也就是说，剪枝发生在：<strong>同一层数值相同的结点第 2、3 … 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果</strong>，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比第 1 个结点更多，并且是第 1 个结点的子集。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-comment">// 从根结点到叶子结点的路径</span><br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// begin：从候选数组的 begin 位置开始搜索</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span><br>            <span class="hljs-keyword">if</span>(target-candidates[begin]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span><br>            <span class="hljs-keyword">if</span>(i&gt;begin&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span><br>            <span class="hljs-built_in">dfs</span>(candidates,i+<span class="hljs-number">1</span>,path,target-candidates[i],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调试示例输出可以查阅 @<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">liweiwei1419</a> 题解。</p><h4 id="讲解小剪枝语句如何避免重复"><a href="#讲解小剪枝语句如何避免重复" class="headerlink" title="讲解小剪枝语句如何避免重复"></a>讲解小剪枝语句如何避免重复</h4><p>参考 @<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/xiang-xi-jiang-jie-ru-he-bi-mian-zhong-fu-by-allen/">Allen</a> 题解。</p><p>这个避免重复思想最重要的作用是，可以让同一层级，不出现相同的元素，但是却允许了不同层级之间的重复。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">例1:<br>          1<br>         / \<br>       <span class="hljs-number"> 2 </span> <span class="hljs-number"> 2 </span> 这种情况不会发生 <br>       /     \<br>     <span class="hljs-number"> 5 </span>      5<br>例2<br>          1<br>         /<br>       <span class="hljs-number"> 2 </span>     这种情况确是允许的<br>       /<br>     <span class="hljs-number"> 2 </span> <br></code></pre></td></tr></table></figure><p>为何会有这种神奇的效果呢？</p><p>首先 <code>candidates[i]==candidates[i-1]</code> 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例 1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例 2 的情况也会消失。 因为当第二个2出现的时候，他就和前一个 2 相同了。</p><p>那么如何保留例 2 呢？</p><p>那么就用 <code>i&gt;begin</code> 来避免这种情况，你发现例 1 中的两个 2 是处在同一个层级上的，例 2 的两个 2 是处在不同层级上的。在一个 for 循环中，所有被遍历到的数都是属于同一个层级的。我们要让一个层级中，必须出现且只出现一个 2，那么就放过第一个出现重复的 2，但不放过后面出现的 2。第一个出现的 2 的特点就是<code>i==begin</code>，第二个出现的 2 特点是<code>i&gt;begin</code>。</p><h2 id="77-组合-medium"><a href="#77-组合-medium" class="headerlink" title="77. 组合[medium]"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a>[medium]</h2><p>详细思路叙述和调试输出参考 @<a href="https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">liweiwei1419</a> 题解。</p><h3 id="解法：回溯-3"><a href="#解法：回溯-3" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>思路与 <a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 相似。</p><h4 id="思路一：根据搜索起点画出二叉树-1"><a href="#思路一：根据搜索起点画出二叉树-1" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>例如输入：<code>n = 4, k = 2</code>，可以发现如下递归结构：</p><ol><li>如果组合里有 <code>1</code> ，那么需要在 <code>[2, 3, 4]</code>里再找 1 个数；</li><li>如果组合里有 <code>2</code> ，那么需要在 <code>[3, 4]</code>里再找 1 个数。注意：这里不能再考虑 1，因为包含 1 的组合，在第 1 种情况中已经包含。</li></ol><p>依次类推（后面部分省略），以上描述体现的 <strong>递归</strong> 结构是：在以 n 结尾的候选数组里，选出若干个元素。画出递归结构如下图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121215225.png" style="zoom:80%;" /><p>说明：</p><ul><li>叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 <code>path</code>，它是一个列表，特别地， <code>path</code>是一个栈；</li><li>每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 <code>start</code>，表示在区间  <code>[begin, n]</code>里选出若干个数的组合；</li><li>可能有一些分支没有必要执行，放在优化中介绍。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 从 1 开始是题目的设定</span><br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件是：path 的长度等于 k</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历可能的搜索起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-comment">// 向路径变量里添加一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">// 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素</span><br>            <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="优化：分析搜索起点的上界进行剪枝"><a href="#优化：分析搜索起点的上界进行剪枝" class="headerlink" title="优化：分析搜索起点的上界进行剪枝"></a>优化：分析搜索起点的上界进行剪枝</h5><p>上面的代码，搜索起点遍历到 <code>n</code>，即：递归函数中有下面的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从当前搜索起点 begin 遍历到 n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt;= n; i++) &#123;<br>    path.addLast(i);<br>    dfs(n, k, i + <span class="hljs-number">1</span>, path, res);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上，如果 <code>n = 7, k = 4</code>，<strong>从 5 开始搜索就已经没有意义了</strong>，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。因此，<strong>搜索起点有上界</strong>，这个上界是多少，可以举几个例子分析。</p><p>分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。</p><p>下面的图片绿色部分是剪掉的枝叶，当 <code>n</code> 很大的时候，能少遍历很多结点，节约了时间。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121220205.png" style="zoom:80%;" /><p>容易知道：搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 <code>path</code> 的长度相关。我们举几个例子分析：</p><p>例如：<code>n = 6 ，k = 4</code>：</p><p><code>path.size() == 1</code> 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 <code>[4, 5, 6]</code>；</p><p><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 <code>[5, 6]</code>；</p><p><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 <code>[6]</code>。</p><p>可以归纳出：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">搜索起点的上界 + 接下来要选择的元素个数 - <span class="hljs-number">1</span> = <span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>其中，接下来要选择的元素个数 <code>= k - path.size()</code>，整理得到：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">搜索起点的上界 = n - (k - <span class="hljs-built_in">path</span>.size()) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>所以，剪枝过程就是：把 <code>i &lt;= n</code> 改成 <code>i &lt;= n - (k - path.size()) + 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有这里 i &lt;= n - (k - path.size()) + 1 与之前代码不同</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=n-(k-path.<span class="hljs-built_in">size</span>())+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二：按照每一个数选与不选画出二叉树-1"><a href="#思路二：按照每一个数选与不选画出二叉树-1" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>可以按照每一个数选与不选画出二叉树，二叉树最多 <code>n</code> 层。同样可以剪枝。剪枝的思路请见下图「剪枝条件 ② 的加强」。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221217.png" style="zoom:80%;" /><p>画一个表格更容易看出边界条件。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221306.png" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基础版本（无剪枝条件②的加强）的递归终止条件：if (begin==n+1)</span><br>        <span class="hljs-keyword">if</span>(begin&gt;n-k+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 不选当前考虑的数 begin，直接递归到下一层</span><br>        <span class="hljs-built_in">dfs</span>(n,k,begin+<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-comment">// 选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数</span><br>        path.<span class="hljs-built_in">push_back</span>(begin);<br>        <span class="hljs-built_in">dfs</span>(n,k<span class="hljs-number">-1</span>,begin+<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-comment">// 深度优先遍历有回头的过程，因此需要撤销选择</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="216-组合总和-III-medium"><a href="#216-组合总和-III-medium" class="headerlink" title="216. 组合总和 III[medium]"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a>[medium]</h2><h3 id="解法：回溯-4"><a href="#解法：回溯-4" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>思路与 <a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 相似。</p><h4 id="思路一：根据搜索起点画出二叉树-2"><a href="#思路一：根据搜索起点画出二叉树-2" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125214145.png" style="zoom:80%;" /><ul><li>尝试做减法，减到 0 就说明可能找到了一个符合题意的组合，但是题目对组合里元素的个数有限制，因此还需要对元素个数做判断；</li><li>如果减到负数，没有必要继续搜索下去；</li><li>由于结果集里的元素互不相同，因此<strong>下一层搜索的起点应该是上一层搜索的起点值 + 1</strong>；</li><li><strong>根据画出的递归树设计递归方法的参数</strong>。</li></ul><p>编写代码就是要在这棵递归树上搜索所有符合条件的解，使用的是深度优先遍历。需要设计递归方法，参数有：</p><ul><li>剩下的数的和是多少，这里命名为 <code>residue</code>，一维剩余元素之和，初始的时候传入 <code>n</code>；</li><li>因为题目规定，需要 <code>k</code>个数，每递归一层，需要找的数就减去 1，因此需要一个变量表示还需要搜索多少个数，仍然用 <code>k</code> 表示，到 <code>0</code>的时候搜索结束；</li><li>搜索的起点，最小是 1，最大是 9，<strong>事实上，这个最大值有一个上界</strong>。暂时忽略对它的讨论；</li><li>需要一个变量 <code>path</code>表示从根结点到叶子结点的路径。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这一步判断可以放到上一层，减少递归深度</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-i,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="剪枝优化："><a href="#剪枝优化：" class="headerlink" title="剪枝优化："></a>剪枝优化：</h5><ul><li><p>首先是对输入的特殊判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || n &lt;= <span class="hljs-number">0</span> || k &gt; n) &#123;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>n</code> 其实是有上限的，考虑最大的 <code>k</code> 个数字：<code>[9, 8, ... , (9 - k + 1)]</code>，他们的和为 <code>(19 - k) * k / 2</code>，如果比这个数还大，就不用搜索下去了。</p></li><li><p>每一轮搜索的起点值也有一个上限，起点值最多到 <code>9</code>，找一下规律：</p></li></ul><p>起点值列表： <code>[..., 7, 8, 9]</code></p><ul><li>找 3 个数，起点最多到 7；</li><li>找 2 个数，起点最多到 8。</li></ul><p>因此一般规律是：<code>起点上界 + k = 10</code>，故 <code>起点上界 = 10 - k</code>。事实上，还可以计算得到一个更小的上界，但是在这题里没有必要了，每次去计算也要消耗时间。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125215309.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">// 一开始做一些特殊判断</span><br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>||n&lt;=<span class="hljs-number">0</span>||k&gt;n)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 寻找 n 的上限：[9, 8, ... , (9 - k + 1)]，它们的和为 (19 - k) * k / 2</span><br>        <span class="hljs-comment">// 比上限还大，就不用搜索了：</span><br>        <span class="hljs-keyword">if</span>(n&gt;(<span class="hljs-number">19</span>-k)*k/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 剪枝：[start, 9] 这个区间里的数都不够 k 个，不用继续往下搜索</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">10</span>-begin&lt;k)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 规律是，起点上界 + k = 10，故起点上界 = 10 - k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=<span class="hljs-number">10</span>-k;++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span>(residue-i&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-i,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二：按照每一个数选与不选画出二叉树-2"><a href="#思路二：按照每一个数选与不选画出二叉树-2" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>对于组合来说，还可以根据一个数选和不选画树形图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">// 生成数字</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; nums;        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;++i)<br>            nums.<span class="hljs-built_in">push_back</span>(i);<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 注意begin从0开始，代表nums索引</span><br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">0</span>,nums,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(begin&gt;=nums.<span class="hljs-built_in">size</span>()||residue-nums[begin]&lt;<span class="hljs-number">0</span>||k&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(nums[begin]);<br>        <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-nums[begin],begin+<span class="hljs-number">1</span>,nums,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">dfs</span>(k,residue,begin+<span class="hljs-number">1</span>,nums,path,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78. 子集[medium]"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>[medium]</h2><h3 id="解法一：回溯"><a href="#解法一：回溯" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><h4 id="思路一：根据搜索起点画出二叉树-3"><a href="#思路一：根据搜索起点画出二叉树-3" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>每次看看有几个数能选，然后选一个：</p><ul><li>用 for 枚举出当前可选的数，比如选第一个数：有 1、2、3 可选。</li><li>选了 1，选第二个数，有 2、3 可选；如果选 2，选第二个数，只有 3 可选，如下图</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123174727.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 没有显式的递归终止</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 组合问题，状态在递归完成后要重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二：按照每一个数选与不选画出二叉树-3"><a href="#思路二：按照每一个数选与不选画出二叉树-3" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><ul><li>单看每个元素，都有两种选择：选入子集，或不选入子集。<ul><li>比如<code>[1,2,3]</code>，先考察 1，选它或不选它，都会再考察 2，选它或不选它，以此类推。</li></ul></li><li>考察当前枚举的数，基于选它，继续选下去（一个递归分支）；基于不选它，继续选下去（一个递归分支）</li><li>在递归子调用中，又面临两种选择：选或不选……</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123164029.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当前数可选，也可以不选</span><br>        <span class="hljs-comment">// 选了有，进入下一层</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[begin]);<br>        <span class="hljs-built_in">dfs</span>(nums,begin+<span class="hljs-number">1</span>,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 不选，直接进入下一层</span><br>        <span class="hljs-built_in">dfs</span>(nums,begin+<span class="hljs-number">1</span>,path,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>逐个枚举，空集的幂集只有空集，每增加一个元素，让之前幂集中的每个集合，追加这个元素，就是新增的子集。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123172351.png" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 当前数字与已经存在的子集组合成新的组合，并将其加入到结果中</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：使用位运算技巧"><a href="#解法三：使用位运算技巧" class="headerlink" title="解法三：使用位运算技巧"></a>解法三：使用位运算技巧</h3><p>数组的每个元素，可以有两个状态：</p><ul><li>不在子数组中（用 0 表示）；</li><li>在子数组中（用 1 表示）。</li></ul><p>从 0 到 2 的数组个数次幂（不包括）的整数的二进制表示就能表示所有状态的组合。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123165451.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                    cur.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="90-子集-II-medium"><a href="#90-子集-II-medium" class="headerlink" title="90. 子集 II[medium]"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a>[medium]</h2><h3 id="解法一：回溯-剪枝"><a href="#解法一：回溯-剪枝" class="headerlink" title="解法一：回溯+剪枝"></a>解法一：回溯+剪枝</h3><p>回溯思路与 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法一思路一相同。剪枝思路与 <a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>、 <a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a> 相同。</p><p>剪枝思路：</p><p>以 <code>[1, 2, 2&#39;]</code>（2’ 的 “ ‘ “ 是为了理解方便加的） 为例，如果不剪枝将会得到的非空子集为：<code>[[1],[1,2],[1,2,2&#39;],[1,2&#39;],[2],[2,2&#39;],[2&#39;]]</code>。</p><ul><li>出现重复解的为 [2] [2’] 和 [1, 2] [1, 2’]；</li><li>观察选取到重复的解的特点， 重复的解是因为有 2 个或以上个相同的元素（如 2， 2’）在同一层回溯过程中被分别选择， 作为最终解的一部分了。所以处理这种问题， 就是要在回溯过程中区分出来这种数值相同的情况（就是要区分出来 2 &#x3D;&#x3D; 2’）；</li><li>因为输入数据已经经过排序， 所以一种显而易见的做法就是在回溯时， 检查当前元素是否和上一个元素相同，即 <code>nums[i - 1] == nums[i]</code>  如果发现和上一个相同了就可以直接跳过（如<code>nums = [1, 2, 2&#39;] nums[1]==nums[2], nums[2]</code> 就直接跳过了）；</li><li>需要注意的是<code>nums[i - 1]==nums[i]</code> 的作用是在递归树的同一层上的，也就是防止<code>nums = [1, 2, 2&#39;] 出现 [1, 2]， [1, 2&#39;] </code>两个重复的解 （即： 通过 <code>nums[1] == nums[2]: continue</code> 进行的剪枝）；</li><li>而解 [1, 2, 2’] 实际中的 2, 2’ 是位于递归树的不同层级的， 也就是剪枝要从每一层的第二个元素开始， 所以还要增加一个<code>i &gt; start 或者 i != start</code>。最终的思路就是要增加一个 <code>i&gt;start &amp;&amp; nums[i - 1]==nums[i] 或 i!=start &amp;&amp; nums[i - 1]==nums[i]</code> 的剪枝。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 没有显式的递归终止</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝关键代码</span><br>            <span class="hljs-keyword">if</span>(i&gt;begin&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 组合问题，状态在递归完成后要重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：迭代-剪枝"><a href="#解法二：迭代-剪枝" class="headerlink" title="解法二：迭代+剪枝"></a>解法二：迭代+剪枝</h3><p>迭代思路与 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法二相同。</p><h4 id="剪枝思路一"><a href="#剪枝思路一" class="headerlink" title="剪枝思路一"></a>剪枝思路一</h4><p>如果有重复的数字，按照原来的迭代方式，会出现重复的数组。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123214501.png" style="zoom: 67%;" /><p>如上图第 4 行黑色的部分重复，是怎么造成的呢？第 4 行新添加的 2 要加到第 3 行的所有解中，而第 3 行的一部分解是旧解，一部分是新解。可以看到，黑色部分是由第 3 行的旧解产生的，橙色部分是由新解产生的。</p><p>而第 2 行到第 3 行，已经在旧解中加入了 2 产生了第 3 行的橙色部分，所以这里如果再在旧解中加 2 产生黑色部分就造成了重复。</p><p>所以当有重复数字的时候，只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">1</span>;<span class="hljs-comment">//保存新解的开始位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历之前的所有结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                <span class="hljs-comment">// 如果出现重复数字，就跳过所有旧解</span><br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;j&lt;start)<br>                    <span class="hljs-keyword">continue</span>;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>            <span class="hljs-comment">// 更新新解的开始位置</span><br>            start=resLen;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剪枝思路二"><a href="#剪枝思路二" class="headerlink" title="剪枝思路二"></a>剪枝思路二</h4><p>当有重复数字出现的时候不再按照之前的思路走，而是单独考虑这种情况。</p><p>当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 … 什么意思呢，看一个例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">数组 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>2 ] <br>[ ]的所有子串 [ ]<br>[<span class="hljs-number"> 1 </span>] 个的所有子串 [ ] [<span class="hljs-number"> 1 </span>] <br>然后出现了重复数字 2，那么记录重复的次数，然后遍历之前每个解即可<br>对于 [ ] 这个解：<br>加<span class="hljs-number"> 1 </span>个 2，变成 [<span class="hljs-number"> 2 </span>] <br>加<span class="hljs-number"> 2 </span>个 2，变成 [<span class="hljs-number"> 2 </span>2 ]<br>加<span class="hljs-number"> 3 </span>个 2，变成 [<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>]<br>对于 [<span class="hljs-number"> 1 </span>] 这个解：<br>加<span class="hljs-number"> 1 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2 ] <br>加<span class="hljs-number"> 2 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>]<br>加<span class="hljs-number"> 3 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>2 ]<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> dupCount=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 判断当前是否是重复数字，并且记录重复的次数</span><br>            <span class="hljs-keyword">while</span>((i+<span class="hljs-number">1</span>&lt;nums.<span class="hljs-built_in">size</span>())&amp;&amp;nums[i+<span class="hljs-number">1</span>]==nums[i])<br>            &#123;<br>                ++dupCount;<br>                ++i;<br>            &#125;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历之前几个结果的每个解</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                <span class="hljs-comment">// 每次在上次的结果中多加 1 个重复数字</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=dupCount;++k)<br>                &#123;<br>                    tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    res.<span class="hljs-built_in">push_back</span>(tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：位运算-剪枝"><a href="#解法三：位运算-剪枝" class="headerlink" title="解法三：位运算+剪枝"></a>解法三：位运算+剪枝</h3><p>位运算思路与 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法三相同。</p><p>如果有重复数字，会出现以下情况，对于 nums &#x3D; [ 1 2 2 2 3 ]。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br></code></pre></td></tr></table></figure><p>上边三个数产生的数组重复了。三个中只取其中 1 个，取哪个呢？取从重复数字的开头连续的数字。什么意思呢？就是下边的情况是保留的。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span>         ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>       ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>     ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>   ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> ]  <br></code></pre></td></tr></table></figure><p>而对于 [ 2 2 ] 来说，除了 1 1 0 0 0 可以产生，下边的几种情况，都是产生的 [ 2 2 ]</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2 <br>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>......<br></code></pre></td></tr></table></figure><p>怎么把 1 1 0 0 0 和上边的那么多种情况区分开来呢？看一下出现了重复数字，并且当前是 1 的前一个的二进位。</p><p>对于 <strong>1</strong> 1 0 0 0 ，是 1。</p><p>对于 1 <strong>0</strong> 1 0 0 , 是 0。</p><p>对于 <strong>0</strong> 1 1 0 0 ，是 0。</p><p>对于 <strong>0</strong> 1 0 1 0 ，是 0。</p><p>对于 0 0 <strong>0</strong> 1 1 ，是 0。</p><p>……</p><p>可以看到只有第一种情况对应的是 1 ，其他情况都是 0。其实除去从开头是连续的 1 的话，就是两种情况。</p><p>第一种就是，占据了开头，类似于这种 1<strong>0</strong>…1….</p><p>第二种就是，没有占据开头，类似于这种 <strong>0</strong>…1…</p><p>这两种情况，除了第一位，其他位的 1 的前边一定是 0。所以条件是看出现了重复数字，并且当前位是 1 的前一个的二进位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-type">bool</span> illegal=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-comment">// 当前位是 1</span><br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 当前是重复数字，并且前一位是 0，跳过这种情况</span><br>                    <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;nums[j]==nums[j<span class="hljs-number">-1</span>]&amp;&amp;(i&gt;&gt;(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        illegal=<span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        cur.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!illegal)<br>                res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="60-排列序列-hard"><a href="#60-排列序列-hard" class="headerlink" title="60. 排列序列[hard]"></a><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a>[hard]</h2><p>通过 <strong>计算剩余数字个数的阶乘数</strong>，一位一位选出第 <code>k</code> 个排列的数位。</p><h3 id="解法一：全排列-剪枝"><a href="#解法一：全排列-剪枝" class="headerlink" title="解法一：全排列+剪枝"></a>解法一：全排列+剪枝</h3><p>使用 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a> 的回溯搜索，依次得到全排列，输出第 k 个全排列。事实上不需要求出所有全排列，所求排列 <strong>一定在叶子结点处得到</strong>，进入每一个分支，可以根据已经选定的数的个数，进而计算还未选定的数的个数，然后计算阶乘，就知道这一个分支的 <strong>叶子结点</strong> 的个数：</p><ul><li>如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，即「剪枝」；</li><li>如果 k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126210516.png" style="zoom:67%;" /><p><strong>编码注意事项：</strong></p><ul><li>计算阶乘的时候，可以使用循环计算。注意：0!&#x3D;1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；</li><li>题目中说「给定 n 的范围是 [1,9]」，可以把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">calculateFactorial</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//记录数字是否使用过</span><br>        string path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">0</span>,used,path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; factorial;<span class="hljs-comment">//阶乘数组</span><br>    <span class="hljs-comment">// 计算阶乘数组</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculateFactorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        factorial.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            factorial.<span class="hljs-built_in">push_back</span>(factorial[i<span class="hljs-number">-1</span>]*i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,string &amp;path)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==n)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 计算还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1</span><br>        <span class="hljs-type">int</span> cnt=factorial[n<span class="hljs-number">-1</span>-index];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(cnt&lt;k)<br>            &#123;<br>                k-=cnt;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path+=<span class="hljs-built_in">to_string</span>(i);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(n,k,index+<span class="hljs-number">1</span>,used,path);<br>            <span class="hljs-comment">// 注意 1：不可以回溯（重置变量），算法设计是「一下子来到叶子结点」，没有回头的过程</span><br>            <span class="hljs-comment">// 注意 2：这里要加 return，后面的数没有必要遍历去尝试了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：有序数组（链表）模拟"><a href="#解法二：有序数组（链表）模拟" class="headerlink" title="解法二：有序数组（链表）模拟"></a>解法二：有序数组（链表）模拟</h3><p>如果 <code>n = 4</code>，<code>k = 16</code>，现在确定第 1 个数字填啥。如果 <code>k</code> &gt; 后面的数字个数的阶乘。数一数，可以跳过几个阶乘数。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214453.png" style="zoom:67%;" /><p>其实这个思路很像解法一的「剪枝」，只不过解法一减法，解法二用除法。</p><p><strong>算法流程设计</strong>：</p><ul><li>把候选数放在一个 <strong>有序列表</strong> 里，从左到右根据「剩下的数的阶乘数」确定每一位填谁，公式 k &#x2F; (后面几位的阶乘数) 的值 <strong>恰好等于候选数组的下标</strong>；</li><li>选出一个数以后，<code>k</code> 就需要减去相应跳过的阶乘数的倍数，也可直接求余；</li><li><strong>已经填好的数需要从候选列表里删除</strong>，注意保持列表的有序性（因为排列的定义是按照字典序）；</li><li>由于这里考虑的是下标，第 <code>k</code> 个数，下标为 <code>k - 1</code>，一开始的时候，<code>k--</code>。</li></ul><p>下面看一个例子：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214753.png" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 相当于在n个数字的全排列中找到下标为k - 1的那个数，因此k先减1</span><br>        --k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        factorial[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 先算出所有的阶乘值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>            factorial[i]=factorial[i<span class="hljs-number">-1</span>]*i;<br>        <span class="hljs-comment">// 这里使用数组或者链表都行</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            nums[i<span class="hljs-number">-1</span>]=i;<br>        string res;<br>        <span class="hljs-comment">// i 表示剩余的数字个数，初始化为n-1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-type">int</span> index=k/factorial[i];<br>            res+=<span class="hljs-built_in">to_string</span>(nums[index]);<br>            nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>()+index);<br>            k%=factorial[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="93-复原IP地址-medium"><a href="#93-复原IP地址-medium" class="headerlink" title="93. 复原IP地址[medium]"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原IP地址</a>[medium]</h2><h3 id="解法：回溯-剪枝-2"><a href="#解法：回溯-剪枝-2" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127211509.png" style="zoom:80%;" /><ul><li>剩余的字符个数大于能组成的合法 IP 片段，则剪枝；</li><li>每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</li><li>根据截取出来的字符串判断是否是合理的 IP 片段，如果不是，则剪枝；</li><li>由于 IP 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</li><li>每一个结点表示了求解这个问题的不同阶段，需要的状态变量有：<ul><li><code>residue</code>：记录剩余多少段还没被分割；</li><li><code>begin</code>：截取 IP 段的起始位置；</li><li><code>path</code>：记录从根结点到叶子结点的一个路径（回溯算法常规变量）；</li><li><code>res</code>：记录结果集的变量，常规变量。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(s,len,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,string &amp;path,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 首个IP片段前不需要&#x27;.&#x27;</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">4</span>)<br>            path+=<span class="hljs-string">&quot;.&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;begin+<span class="hljs-number">3</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=len)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 剩下的太多了，就剪枝</span><br>            <span class="hljs-keyword">if</span>(len-i&gt;residue*<span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 截取片段</span><br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s.begin()+begin,s.begin()+i+<span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">valid</span>(tmp))<br>            &#123;<br>                path+=tmp;<br>                <span class="hljs-built_in">dfs</span>(s,len,residue<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,path,res);<br>                <span class="hljs-comment">// 删除tmp,string.erase(index,count);</span><br>                <span class="hljs-comment">// index:要移除的首个字符，count:要移除的字符数</span><br>                path.<span class="hljs-built_in">erase</span>(path.<span class="hljs-built_in">size</span>()-(i-begin+<span class="hljs-number">1</span>),i-begin+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 删除&#x27;.&#x27;</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">4</span>)<br>            path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 s 是否是一个合法的 IP 段</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 大于 1 位的时候，不能以 0 开头</span><br>        <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">1</span>&amp;&amp;s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 将 string 转为 int</span><br>        <span class="hljs-type">int</span> num=<span class="hljs-built_in">stoi</span>(s);<br>        <span class="hljs-keyword">return</span> num&gt;=<span class="hljs-number">0</span>&amp;&amp;num&lt;=<span class="hljs-number">255</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17. 电话号码的字母组合[medium]"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>[medium]</h2><h3 id="解法一：DFS-回溯"><a href="#解法一：DFS-回溯" class="headerlink" title="解法一：DFS+回溯"></a>解法一：DFS+回溯</h3><p>建立一个字典，用来保存每个数字所代表的字符串，然后还需要一个变量 index，记录当前生成的字符串的字符个数。在递归函数中首先判断 index，如果跟 digits 中数字的个数相等了，将当前的组合加入结果 res 中，然后返回。通过 digits 中的数字到 phoneMap中取出字符串，然后遍历这个取出的字符串，将每个字符都加到当前的组合后面，并调用递归函数，并用回溯法消除一次遍历操作。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211416.jpeg" style="zoom: 50%;" /><p>对于打印”2345”这样的字符串：</p><ul><li>第一次递归就是上图中最下面的方格，然后处理完第一个字符 2 之后，将输入的字符改变成”345”并调用第二个递归函数；</li><li>第二次递归处理 3，将字符串改变成”45”后再次递归；</li><li>第三次递归处理 4，将字符串改变成”5”后继续递归</li><li>第四次递归处理5，将字符串改变成””后继续递归；</li><li>最后发现字符串为空了，将结果放到列表中并返回。</li></ul><p>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211729.jpeg" style="zoom: 80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 用map记录每个数字按键对应的所有字母</span><br>        unordered_map&lt;<span class="hljs-type">char</span>,string&gt; phoneMap&#123;&#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;;<br>        <span class="hljs-built_in">combine</span>(digits,phoneMap,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// index是生成临时结果字串的下标</span><br>    <span class="hljs-comment">// str存储临时结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(string &amp;digits,unordered_map&lt;<span class="hljs-type">char</span>,string&gt; &amp;phoneMap,<span class="hljs-type">int</span> index,string str,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==digits.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对于当前输入的第index号数字(digits[index])</span><br>        string tmp=phoneMap[digits[index]];<br>        <span class="hljs-comment">// 枚举其对应的所有字母</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:tmp)<br>        &#123;<br>            <span class="hljs-comment">// 临时结果压入一个字母</span><br>            str+=c;<br>            <span class="hljs-comment">// 以在当前位置压入该字母这一“情况”为前提，构造此“分支”的后续结果</span><br>            <span class="hljs-built_in">combine</span>(digits,phoneMap,index+<span class="hljs-number">1</span>,str,res);<br>            <span class="hljs-comment">//状态还原，例如临时结果从 &quot;ab&quot; -&gt; &quot;a&quot;，下一次循环尝试&quot;ac&quot; </span><br>            str.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>在遍历 digits 中所有的数字时，先建立一个临时的字符串数组 tmp，然后跟解法一的操作一样，通过数字到 phoneMap 中取出字符串 chars，然后遍历取出字符串中的所有字符，再遍历当前结果 res 中的每一个字符串，将字符加到后面，并加入到临时字符串数组 tmp 中。取出的字符串 str 遍历完成后，将临时字符串数组赋值给结果 res。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-type">char</span>,string&gt; phoneMap&#123;&#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;digits.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            vector&lt;string&gt; tmp;<br>            string chars=phoneMap[digits[i]];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:chars)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;str:res)<br>                    tmp.<span class="hljs-built_in">push_back</span>(str+c);<br>            res=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成-medium"><a href="#22-括号生成-medium" class="headerlink" title="22. 括号生成[medium]"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a>[medium]</h2><h3 id="解法一：DFS-回溯-1"><a href="#解法一：DFS-回溯-1" class="headerlink" title="解法一：DFS+回溯"></a>解法一：DFS+回溯</h3><p>以 <code>n = 2</code> 为例，画树形结构图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127221208.png" style="zoom:80%;" /><ul><li>当前左右括号都有大于 0 个可以使用的时候，才产生分支；</li><li>产生左分支的时候，只看当前是否还有左括号可以使用；</li><li>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；</li><li>在左边和右边剩余的括号数都等于 0 的时候结算。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;&quot;</span>,n,n,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// path 当前递归得到的结果</span><br>    <span class="hljs-comment">// left 左括号还有几个可以使用</span><br>    <span class="hljs-comment">// right 右括号还有几个可以使用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string path,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span><br>        <span class="hljs-comment">// 在递归终止的时候，直接把它添加到结果集即可</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span>&amp;&amp;right==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(left&gt;right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">dfs</span>(path+<span class="hljs-string">&quot;(&quot;</span>,left<span class="hljs-number">-1</span>,right,res);<br>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">dfs</span>(path+<span class="hljs-string">&quot;)&quot;</span>,left,right<span class="hljs-number">-1</span>,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>若严格按照「回溯法」的定义去做，全程只用一份状态变量去搜索所有可能的状态（本题中将 path 改成<strong>引用</strong>类型），则有「恢复现场」和「撤销选择」的需要，即回溯。每次都是用新的字符串的话，所用的内存会很多，中间那些变量其实都是不需要的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(path,n,n,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;path,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span>&amp;&amp;right==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&gt;right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            path+=<span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(path,left<span class="hljs-number">-1</span>,right,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;           <br>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            path+=<span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(path,left,right<span class="hljs-number">-1</span>,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>广度优先遍历，得自己编写结点类，显式使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显式使用栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        queue&lt;Node&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(<span class="hljs-string">&quot;&quot;</span>,n,n));<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            Node cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur.left==<span class="hljs-number">0</span>&amp;&amp;cur.right==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(cur.res);<br>            <span class="hljs-keyword">if</span>(cur.left&gt;<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(cur.res+<span class="hljs-string">&quot;(&quot;</span>,cur.left<span class="hljs-number">-1</span>,cur.right));<br>            <span class="hljs-keyword">if</span>(cur.right&gt;<span class="hljs-number">0</span>&amp;&amp;cur.left&lt;cur.right)<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(cur.res+<span class="hljs-string">&quot;)&quot;</span>,cur.left,cur.right<span class="hljs-number">-1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Node</span>(string str,<span class="hljs-type">int</span> _left,<span class="hljs-type">int</span> _right):<span class="hljs-built_in">res</span>(str),<span class="hljs-built_in">left</span>(_left),<span class="hljs-built_in">right</span>(_right)<br>        &#123;&#125;<br>        string res;<span class="hljs-comment">// 当前得到的字符串</span><br>        <span class="hljs-type">int</span> left;<span class="hljs-comment">// 剩余左括号数量</span><br>        <span class="hljs-type">int</span> right;<span class="hljs-comment">// 剩余右括号数量</span><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h3><p>思路参考 @<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">Yuyu</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;()&quot;</span>&#125;;<br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>dp[<span class="hljs-number">0</span>]=&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>dp[<span class="hljs-number">1</span>]=&#123;<span class="hljs-string">&quot;()&quot;</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <br>        &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) <br>            &#123;<br><span class="hljs-keyword">for</span>(string p:dp[j])<br><span class="hljs-keyword">for</span>(string q:dp[i-j<span class="hljs-number">-1</span>]) <br>                    &#123;<br>string str=<span class="hljs-string">&quot;(&quot;</span>+p+<span class="hljs-string">&quot;)&quot;</span>+q;<br>dp[i].<span class="hljs-built_in">push_back</span>(str);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串-medium"><a href="#131-分割回文串-medium" class="headerlink" title="131. 分割回文串[medium]"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a>[medium]</h2><h3 id="解法：回溯-5"><a href="#解法：回溯-5" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>递归树：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207193035.png" style="zoom:80%;" /><p>思考如何根据这棵递归树编码：</p><ol><li>每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；</li><li>产生前缀字符串的时候，判断前缀字符串是否是回文。<ul><li>如果前缀字符串是回文，则可以产生分支和结点；</li><li>如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。</li></ul></li><li>在叶子结点是空字符串的时候结算，此时<strong>从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果</strong>。<ul><li>采用一个路径变量 <code>path</code> 搜索，<code>path</code> 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;string&gt; path;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// start：起始字符的索引</span><br>    <span class="hljs-comment">// path：记录从根结点到叶子结点的路径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 判断是否回文，不是的话，剪枝</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">checkPalindrome</span>(s,start,i))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// substr(pos,len)</span><br>            string tmp=s.<span class="hljs-built_in">substr</span>(start,i-start+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 s[left...right] 是否回文</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPalindrome</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 严格小于即可</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[left++]!=s[right--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在上一步，验证回文串那里，每一次都得使用“两边夹”的方式验证子串是否是回文子串，为 O(n) 的时间复杂度。于是“用空间换时间”，利用 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a> 的思路，利用动态规划把结果先算出来，这样就可以以 O(1) 的时间复杂度直接得到一个子串是否是回文。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 预处理</span><br>        <span class="hljs-comment">// 状态：dp[i][j] 表示 s[i][j] 是否是回文</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">// 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;len;++right)<br>        &#123;<br>            <span class="hljs-comment">// 注意：left &lt;= right 取等号表示 1 个字符的时候也需要判断</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;left&lt;=right;++left)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[left]==s[right]&amp;&amp;(right-left&lt;=<span class="hljs-number">2</span>||dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>]))<br>                    dp[left][right]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;string&gt; path;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>,dp,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;dp,vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span>(!dp[start][i])<br>                <span class="hljs-keyword">continue</span>;<br>            string tmp=s.<span class="hljs-built_in">substr</span>(start,i-start+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>,dp,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题型二：Flood-Fill"><a href="#题型二：Flood-Fill" class="headerlink" title="题型二：Flood Fill"></a>题型二：Flood Fill</h1><p>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。此类问题不建议修改输入数据，设置 <code>visited</code> 数组是标准的做法。</p><h2 id="695-岛屿的最大面积-medium"><a href="#695-岛屿的最大面积-medium" class="headerlink" title="695. 岛屿的最大面积[medium]"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a>[medium]</h2><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><blockquote><p>经典的方格搜索题目，尽量用 DFS。</p></blockquote><ul><li>计算方格中每个连通岛屿的面积，然后取最大值。</li><li>如果在一片土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</li><li>为了确保每个方格不进行重复遍历，每次经过方格时，将这块方格的值置为 0。</li></ul><p>边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（解法一中采用后者，解法二中采用前者）。</p><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,<span class="hljs-built_in">area</span>(grid,i,j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 若坐标不合法，直接返回</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 若该方格不是岛屿，直接返回</span><br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">area</span>(grid,i<span class="hljs-number">-1</span>,j)+<span class="hljs-built_in">area</span>(grid,i+<span class="hljs-number">1</span>,j)+<span class="hljs-built_in">area</span>(grid,i,j<span class="hljs-number">-1</span>)+<span class="hljs-built_in">area</span>(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; s;<span class="hljs-comment">// &lt;行索引, 列索引&gt;</span><br>                    s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        <span class="hljs-keyword">auto</span> indexs=s.<span class="hljs-built_in">top</span>();<br>                        s.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row=indexs.first;<br>                        <span class="hljs-type">int</span> col=indexs.second;<br>                        <span class="hljs-comment">// 若坐标不合法，直接进入下一个循环</span><br>                        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||col&lt;<span class="hljs-number">0</span>||row&gt;=m||col&gt;=n)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 若该方格不是岛屿，进行下一个循环</span><br>                        <span class="hljs-comment">// 坐标点会重复加入到栈中，所以需要检查</span><br>                        <span class="hljs-keyword">if</span>(grid[row][col]!=<span class="hljs-number">1</span>)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>                        grid[row][col]=<span class="hljs-number">0</span>;<br>                        ++count;<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                    &#125;<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-2"><a href="#解法二：BFS-2" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用队列实现 BFS，每次从队首取出土地，并将接下来想要遍历的土地放在队尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">// &lt;行索引, 列索引&gt;</span><br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row=indexs.first;<br>                        <span class="hljs-type">int</span> col=indexs.second;<br>                        <span class="hljs-comment">// 若该方格不是岛屿，进行下一个循环</span><br>                        <span class="hljs-comment">// 坐标点会重复加入到队列中，所以需要检查</span><br>                        <span class="hljs-keyword">if</span>(grid[row][col]!=<span class="hljs-number">1</span>)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>                        grid[row][col]=<span class="hljs-number">0</span>;<br>                        ++count;<br>                        <span class="hljs-comment">// 将相邻的土地入队</span><br>                        <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[row<span class="hljs-number">-1</span>][col]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                        <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;m&amp;&amp;grid[row+<span class="hljs-number">1</span>][col]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                        <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[row][col<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                        <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[row][col+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                    &#125;<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量-medium"><a href="#200-岛屿数量-medium" class="headerlink" title="200. 岛屿数量[medium]"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>[medium]</h2><h3 id="解法一：DFS、BFS"><a href="#解法一：DFS、BFS" class="headerlink" title="解法一：DFS、BFS"></a>解法一：DFS、BFS</h3><p>思路与 <a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> 相同，可使用 DFS 以及 BFS 解决，这里只写出 DFS 代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j);<br>                    ++count;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-string">&#x27;1&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 置0，表示访问过</span><br>        grid[i][j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>需要注意的一点是，对于算法的输入而言，很多时候是介意修改输入的，除非题目就是要我们修改输入数据。因此，可以创建一个数组，来标记是否已经访问过。这里是 liuyubobobo 老师对这一类问题的解释：<a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/ru-guo-mian-shi-yu-dao-zhe-ge-wen-ti-zhe-yi-dian-z/">如果面试遇到这个问题，这一点最重要!</a>。</p><p>因此建议是：</p><ul><li>建立 <code>visited</code> 布尔数组辅助完成题目给出的任务。</li><li>实在是觉得没有必要用 <code>visited</code> 布尔数组的话，写代码之前可以问一下面试官，和面试官进行沟通。</li></ul></blockquote><p>建立 <code>visited</code> 布尔数组后代码重写为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 如果是岛屿中的一个点，并且没有被访问过，就进行深度优先遍历</span><br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j,visited);<br>                    ++count;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 从坐标为 (i, j) 的点开始进行深度优先遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-string">&#x27;1&#x27;</span>||(grid[i][j]=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;visited[i][j]))<br>            <span class="hljs-keyword">return</span>;<br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,visited);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：并查集"><a href="#解法二：并查集" class="headerlink" title="解法二：并查集"></a>解法二：并查集</h3><blockquote><p>关于连通性问题，并查集也是常用的数据结构。并查集的套路模板可以学习<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/2.4-shou-ba-shou-she-ji-shu-ju-jie-gou/unionfind-suan-fa-xiang-jie">labuladong的算法小抄</a>。</p></blockquote><p>对于本题来说，所做的就是分类的问题，把相邻的 <code>1</code> 都分成一类。</p><ul><li>首先把每个节点各作为一类，用它的行数和列数生成一个 <code>id</code> 标识该类，即函数 <code>getIndex</code> 和构造函数中所做的。</li><li>用 <code>nums</code> 来记录当前有多少个岛屿，初始化的时候每个 <code>1</code> 都认为是一个岛屿，然后开始合并。</li><li>遍历每个为 <code>1</code> 的节点，将它的右边和下边的 <code>1</code> 和当前节点合并（这里算作一个优化，不需要像解法一那样上下左右）。每进行一次合并，就将 <code>nums</code> 减 <code>1</code> 。</li><li>最后返回 <code>nums</code> 。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parents;<br>    <span class="hljs-type">int</span> nums;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols)<br>    &#123;<br>        nums=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 记录 1 的个数</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                    ++nums;<br>                <span class="hljs-comment">// 每一个类初始化为它本身</span><br>                parents.<span class="hljs-built_in">push_back</span>(i*cols+j);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 带路径优化的查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> son)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> father=parents[son];<br>        <span class="hljs-keyword">while</span>(father!=son)<br>        &#123;<br>            son=father;<br>            father=parents[son];<br>        &#125;<br>        parents[son]=father;<br>        <span class="hljs-keyword">return</span> father;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br>        <span class="hljs-type">int</span> father1=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> father2=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-comment">// 发生合并，nums--</span><br>        <span class="hljs-keyword">if</span>(father1!=father2)<br>        &#123;<br>            parents[father2]=father1;<br>            nums--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNums</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        rows=grid.<span class="hljs-built_in">size</span>();<br>        cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid,rows,cols)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将下边右边的 1 节点和当前节点合并</span><br>                    <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;grid[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                        uf.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">getIndex</span>(i,j),<span class="hljs-built_in">getIndex</span>(i+<span class="hljs-number">1</span>,j));<br>                    <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;grid[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                        uf.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">getIndex</span>(i,j),<span class="hljs-built_in">getIndex</span>(i,j+<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getNums</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="463-岛屿的周长-easy"><a href="#463-岛屿的周长-easy" class="headerlink" title="463. 岛屿的周长[easy]"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a>[easy]</h2><h3 id="解法一：直接计算"><a href="#解法一：直接计算" class="headerlink" title="解法一：直接计算"></a>解法一：直接计算</h3><p>一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201109215649.png" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> land=<span class="hljs-number">0</span>;<span class="hljs-comment">// 土地个数</span><br>        <span class="hljs-type">int</span> border=<span class="hljs-number">0</span>;<span class="hljs-comment">// 接壤边界的条数</span><br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    ++land;<br>                    <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;grid[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>)<br>                        ++border;<br>                    <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;grid[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                        ++border;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> land*<span class="hljs-number">4</span>-border*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h3><p><strong>岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量</strong>。这里的非岛屿方格，既包括水域方格，也包括网格的边界。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201106151555.jpeg" style="zoom:67%;" /><p>将这个“相邻关系”对应到 DFS 遍历中，就是：每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 题目限制只有一个岛屿，计算一个即可</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[i][j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,i,j,visited);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 从一个岛屿方格走向网格边界，周长加 1</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从一个岛屿方格走向水域方格，周长加 1</span><br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 之前访问过，直接返回0，无周长收益</span><br>        <span class="hljs-keyword">if</span>(visited[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将方格标记为&quot;已遍历&quot;</span><br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 继续往四个方向扩散，目标是遇到边界和水域，答案随着递归出栈向上返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,visited)+<span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,visited)+<span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,visited)+<span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,visited);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="547-朋友圈-medium"><a href="#547-朋友圈-medium" class="headerlink" title="547. 朋友圈[medium]"></a><a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a>[medium]</h2><h3 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>DFS 搜索，对于某个人，遍历其好友，然后再遍历其好友的好友，那么就能把属于同一个朋友圈的人都遍历一遍，同时标记出已经遍历过的人，然后累积朋友圈的个数。再去对于没有遍历到的人再找其朋友圈的人，这样就能求出个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(M,visited,i);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;M,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;M.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(M[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[j])<br>            &#123;<br>                visited[j]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(M,visited,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-3"><a href="#解法二：BFS-3" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用 BFS 来遍历朋友圈中的所有人。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])<br>            &#123;<br>                queue&lt;<span class="hljs-type">int</span>&gt; q;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-type">int</span> index=q.<span class="hljs-built_in">front</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    visited[index]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(M[index][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[j])<br>                            q.<span class="hljs-built_in">push</span>(j);<br>                    &#125;<br>                &#125;<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：并查集"><a href="#解法三：并查集" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><blockquote><p>统计图中连通块数量的题目可以使用并查集。并查集的套路模板可以学习<a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/2.4-shou-ba-shou-she-ji-shu-ju-jie-gou/unionfind-suan-fa-xiang-jie">labuladong的算法小抄</a>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">// 记录连通分量个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(M[i][j]==<span class="hljs-number">1</span>&amp;&amp;i!=j)<br>                    uf.<span class="hljs-built_in">unionTree</span>(i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getCount</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="130-被围绕的区域-medium"><a href="#130-被围绕的区域-medium" class="headerlink" title="130. 被围绕的区域[medium]"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a>[medium]</h2><h3 id="解法一：DFS-2"><a href="#解法一：DFS-2" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>题目中解释说被包围的区间不会存在于边界上，所以边界上的 O 要特殊处理，只要把边界上的 O 特殊处理了，那么剩下的 O 替换成 X 就可以了。问题转化为，如何寻找和边界联通的 O，需要考虑如下情况。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> O O <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> O <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> O O <span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure><p>这时候的 O 是不做替换的。因为和边界是连通的。为了记录这种状态，把这种情况下的 O 换成 # 作为占位符，待搜索结束之后，遇到 O 替换为 X（和边界不连通的 O）；遇到 #，替换回 O(和边界连通的 O)。</p><h4 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 从边缘O开始搜索</span><br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=board.<span class="hljs-built_in">size</span>()||j&gt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;O&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(board,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(board,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(board,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(board,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="非递归写法-1"><a href="#非递归写法-1" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 取出当前stack 顶, 不弹出.</span><br>            <span class="hljs-keyword">auto</span> indexs=s.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> row=indexs.first;<br>            <span class="hljs-type">int</span> col=indexs.second;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row<span class="hljs-number">-1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                board[row<span class="hljs-number">-1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=board.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row+<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                board[row+<span class="hljs-number">1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;              <br>            <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row][col<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                board[row][col<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;                <br>            <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row][col+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                board[row][col+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果上下左右都搜索不到,本次搜索结束，弹出stack</span><br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-4"><a href="#解法二：BFS-4" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用队列来进行 BFS。和 DFS 不同的是，DFS 中搜索上下左右，只要搜索到一个满足条件，就顺着该方向继续搜索，所以在 DFS 代码中，只要满足条件，就入 stack，然后 continue 本次搜索，进行下一次搜索，直到搜索到没有满足条件的时候出 stack。而 BFS 中，要把上下左右满足条件的都入队，所以搜索的时候就不能 continue。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">bfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> row=indexs.first;<br>            <span class="hljs-type">int</span> col=indexs.second;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row<span class="hljs-number">-1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                board[row<span class="hljs-number">-1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-comment">// 没有continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=board.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row+<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                board[row+<span class="hljs-number">1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;              <br>            <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row][col<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                board[row][col<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;                <br>            <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row][col+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                board[row][col+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;               <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：并查集-1"><a href="#解法三：并查集-1" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><p>把所有边界上的 O 看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类：</p><ul><li>和边界上的 O 在一个连通区域内的，这些 O 保留。</li><li>不和边界上的 O 在一个连通区域内的，这些 O 就是被包围的，替换。</li></ul><p>由于并查集一般用一维数组来记录，方便查找 parents，所以将二维坐标用 <code>node</code> 函数转化为一维坐标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        rows=board.<span class="hljs-built_in">size</span>();<br>        cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 用一个虚拟节点, 边界上的O的父节点都是这个虚拟节点</span><br>        <span class="hljs-type">int</span> dummyNode=rows*cols;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(rows*cols+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 遇到O进行并查集操作合并</span><br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 边界上的O,把它和dummyNode合并成一个连通区域</span><br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),dummyNode);<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">// 和上下左右合并成一个连通区域</span><br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;board[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i<span class="hljs-number">-1</span>,j));<br>                        <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;board[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i+<span class="hljs-number">1</span>,j));<br>                        <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;board[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j<span class="hljs-number">-1</span>));<br>                        <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;board[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j+<span class="hljs-number">1</span>));                       <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 和dummyNode在一个连通区域的,保留</span><br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(<span class="hljs-built_in">node</span>(i,j),dummyNode))<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>                <span class="hljs-keyword">else</span><br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-comment">// 将二维坐标转化为一维坐标</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="417-太平洋大西洋水流问题-medium"><a href="#417-太平洋大西洋水流问题-medium" class="headerlink" title="417. 太平洋大西洋水流问题[medium]"></a><a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a>[medium]</h2><h3 id="解法：DFS、BFS"><a href="#解法：DFS、BFS" class="headerlink" title="解法：DFS、BFS"></a>解法：DFS、BFS</h3><p>从边界往里面走，即从海洋开始逆流，只能走到比自己更高或者等高的地方。边界能走到的地方，就是能流入对应海洋的地方，进行标记，然后检查两个海洋都可以逆流到的区域。可使用 DFS 以及 BFS 解决，这里只写出 DFS 代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> rows=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">canReachP</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">canReachA</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//从海洋边界开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">dfs</span>(matrix,i,j,canReachP,matrix[i][j]);<br>                <span class="hljs-keyword">if</span>(i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                    <span class="hljs-built_in">dfs</span>(matrix,i,j,canReachA,matrix[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(canReachP[i][j]&amp;&amp;canReachA[i][j])<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;canReach,<span class="hljs-type">int</span> pre)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 判断坐标是否合法</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=matrix.<span class="hljs-built_in">size</span>()||j&gt;=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 已经流到过了 || 不能流动</span><br>        <span class="hljs-keyword">if</span>(canReach[i][j]||matrix[i][j]&lt;pre)<br>            <span class="hljs-keyword">return</span>;<br>        canReach[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(matrix,i<span class="hljs-number">-1</span>,j,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i+<span class="hljs-number">1</span>,j,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i,j<span class="hljs-number">-1</span>,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i,j+<span class="hljs-number">1</span>,canReach,matrix[i][j]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="733-图像渲染-easy"><a href="#733-图像渲染-easy" class="headerlink" title="733. 图像渲染[easy]"></a><a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a>[easy]</h2><p>思路与 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 相似。</p><h3 id="解法一：DFS-3"><a href="#解法一：DFS-3" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。注意：因为初始位置的颜色会被修改，所以需要保存初始位置的颜色，以便于之后的更新操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(color!=newColor)<br>            <span class="hljs-built_in">dfs</span>(image,sr,sc,newColor,color);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;image,<span class="hljs-type">int</span> sr,<span class="hljs-type">int</span> sc,<span class="hljs-type">int</span> newColor,<span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sr&lt;<span class="hljs-number">0</span>||sc&lt;<span class="hljs-number">0</span>||sr&gt;=image.<span class="hljs-built_in">size</span>()||sc&gt;=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(image[sr][sc]!=color)<br>            <span class="hljs-keyword">return</span>;<br>        image[sr][sc]=newColor;<br>        <span class="hljs-built_in">dfs</span>(image,sr<span class="hljs-number">-1</span>,sc,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr+<span class="hljs-number">1</span>,sc,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr,sc<span class="hljs-number">-1</span>,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr,sc+<span class="hljs-number">1</span>,newColor,color);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-5"><a href="#解法二：BFS-5" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。注意：因为初始位置的颜色会被修改，所以需要保存初始位置的颜色，以便于之后的更新操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(color==newColor)<br>            <span class="hljs-keyword">return</span> image;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(sr,sc));<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> r=indexs.first;<br>            <span class="hljs-type">int</span> c=indexs.second;<br>            <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||c&lt;<span class="hljs-number">0</span>||r&gt;=image.<span class="hljs-built_in">size</span>()||c&gt;=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(image[r][c]!=color)<br>                <span class="hljs-keyword">continue</span>;<br>            image[r][c]=newColor;<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r<span class="hljs-number">-1</span>,c));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r+<span class="hljs-number">1</span>,c));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r,c<span class="hljs-number">-1</span>));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r,c+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：并查集-2"><a href="#解法三：并查集-2" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><p>并查集可以用来解决动态连通性问题。从<code>(0, 0)</code>位置开始依次遍历，这时就不需要同时兼顾上下左右四个方向了，只需要看看它<strong>右边和下面</strong>的像素点颜色是不是和初始点一样都为<code>color</code>，一样就合并。最后只需要把所有和开始位置<code>(sr, sc)</code>在同一个集合的像素点的颜色改为<code>newColor</code>就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(newColor==color)<br>            <span class="hljs-keyword">return</span> image;<br>        rows=image.<span class="hljs-built_in">size</span>();<br>        cols=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(rows*cols)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(image[i][j]==color)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;rows&amp;&amp;image[i+<span class="hljs-number">1</span>][j]==color)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i+<span class="hljs-number">1</span>,j));<br>                    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;cols&amp;&amp;image[i][j+<span class="hljs-number">1</span>]==color)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j+<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(sr,sc)))<br>                    image[i][j]=newColor;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-comment">// 将二维坐标转化为一维坐标</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="79-单词搜索-medium"><a href="#79-单词搜索-medium" class="headerlink" title="79. 单词搜索[medium]"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a>[medium]</h2><h3 id="解法：DFS-回溯"><a href="#解法：DFS-回溯" class="headerlink" title="解法：DFS+回溯"></a>解法：DFS+回溯</h3><p>当前字符匹配，在标记数组<code>visited</code>中标记当前元素为已访问，然后向四个方向（上下左右）搜索下一个字符。</p><ol><li>如果四个方向中，有一个方向可以完全匹配，则立即返回<em><strong>true</strong></em>。</li><li>如果四个方向都不匹配，则在标记数组<code>visited</code>中标记当前元素为未访问，回溯到上一层继续搜索。</li></ol><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201130202158.png" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        rows=board.<span class="hljs-built_in">size</span>();<br>        cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 对每一个格子都从头开始搜索</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,i,j,<span class="hljs-number">0</span>,visited))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,string &amp;word,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span>(start==word.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> board[i][j]==word[start];<br>        <span class="hljs-comment">// 中间匹配了，再继续搜索</span><br>        <span class="hljs-keyword">if</span>(board[i][j]==word[start])<br>        &#123;<br>            <span class="hljs-comment">// 先占住这个位置，搜索不成功的话，要释放掉</span><br>            visited[i][j]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>            &#123;<br>                <span class="hljs-type">int</span> newX=i+direction[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> newY=j+direction[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inArea</span>(newX,newY)&amp;&amp;!visited[newX][newY])<br>                &#123;<br>                    <span class="hljs-comment">// 如果这一次 search word 成功的话，就返回</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,newX,newY,start+<span class="hljs-number">1</span>,visited))<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 回溯</span><br>            visited[i][j]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&lt;cols;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1254-统计封闭岛屿的数目-medium"><a href="#1254-统计封闭岛屿的数目-medium" class="headerlink" title="1254. 统计封闭岛屿的数目[medium]"></a><a href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a>[medium]</h2><h3 id="解法：DFS、BFS-1"><a href="#解法：DFS、BFS-1" class="headerlink" title="解法：DFS、BFS"></a>解法：DFS、BFS</h3><p>思路与 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 相似。区别在于这题要求封闭，因此需要代入一个变量表示是否封闭。这里只给出DFS代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> val=<span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j,val);<br>                    res+=val;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> &amp;val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 走出边界就说明该陆地所在岛屿不是封闭岛屿</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            val=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1020-飞地的数量-medium"><a href="#1020-飞地的数量-medium" class="headerlink" title="1020. 飞地的数量[medium]"></a><a href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a>[medium]</h2><h3 id="解法：DFS、BFS、并查集"><a href="#解法：DFS、BFS、并查集" class="headerlink" title="解法：DFS、BFS、并查集"></a>解法：DFS、BFS、并查集</h3><p>典型的 Flood Fill 问题，可以用 DFS、BFS 和 并查集解决。这里只给出 DFS 代码。从边界的陆地往里搜索，把和边界相接的陆地淹没，剩下的陆地就是飞地，统计个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rows=A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(A[i][j]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-built_in">dfs</span>(A,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(A[i][j]==<span class="hljs-number">1</span>)<br>                    ++count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;A,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=A.<span class="hljs-built_in">size</span>()||j&gt;=A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(A[i][j]!=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        A[i][j]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">dfs</span>(A,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(A,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(A,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(A,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题型三：最短路径问题"><a href="#题型三：最短路径问题" class="headerlink" title="题型三：最短路径问题"></a>题型三：最短路径问题</h1><p>问题的本质就是在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</p><h2 id="1091-二进制矩阵中的最短路径-medium"><a href="#1091-二进制矩阵中的最短路径-medium" class="headerlink" title="1091. 二进制矩阵中的最短路径[medium]"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a>[medium]</h2><h3 id="解法：BFS"><a href="#解法：BFS" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><blockquote><p>最短路径问题，使用 BFS 解决。</p><p>关于为什么 BFS 的结果会是最短的：BFS 按照层次来遍历，搜索到的第一个符合条件的解一定是在层次上最浅的，所以只会有长度一样的解不会有长度更短的解。</p></blockquote><p>利用队列实现 BFS，同时将访问过的点标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>||grid[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; directions=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历当前队列所有的元素</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 判断是否满足退出的条件</span><br>                <span class="hljs-keyword">if</span>(x==n<span class="hljs-number">-1</span>&amp;&amp;y==n<span class="hljs-number">-1</span>)<br>                    <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> x1=x+directions[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y1=y+directions[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 边界不合法</span><br>                    <span class="hljs-keyword">if</span>(x1&lt;<span class="hljs-number">0</span>||y1&lt;<span class="hljs-number">0</span>||x1&gt;=n||y1&gt;=n)<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 已访问或者条件不符合</span><br>                    <span class="hljs-keyword">if</span>(visited[x1][y1]||grid[x1][y1]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    visited[x1][y1]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(x1,y1));<br>                &#125;               <br>            &#125;<br>            ++res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="127-单词接龙-medium"><a href="#127-单词接龙-medium" class="headerlink" title="127. 单词接龙[medium]"></a><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a>[medium]</h2><h3 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><blockquote><p>无向图中两个顶点之间的最短路径的长度，可以通过广度优先遍历得到。</p><p>为什么 BFS 得到的路径最短？<strong>可以把起点和终点所在的路径拉直来看，两点之间线段最短</strong>。</p></blockquote><ul><li><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图；</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201204541.png" style="zoom:67%;" /></li><li><p>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，复杂度是 O(NwordLen)，这里 N 是单词列表的长度；</p></li><li><p>为此，在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，复杂度是 O(26×wordLen)，借助哈希表，找到邻居与 N 无关；</p></li><li><p>使用 BFS 进行遍历，需要的辅助数据结构是：</p><ul><li>队列；</li><li><code>visited</code> 集合。说明：可以直接在 <code>wordSet</code> (由 <code>wordList</code>放进集合中得到)里做删除。但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</li></ul></li></ul><p>思路：</p><ul><li>从起点词出发，每次变一个字母，经过 n 次变换，变成终点词，希望 n 尽量小。</li><li>需要找出邻接关系，比如<code>hit</code>它变一个字母会变成 <code>_it</code>、<code>h_t</code>、<code>hi_</code> 形式的单词，然后看这个新词是否存在于 <code>wordSet</code> ，如果存在，就找到了一个下一层的转换词。</li><li>同时，要避免重复访问，比如 <code>hot-&gt;dot-&gt;hot</code> 这样变回来，只会徒增转换的长度。因此，使用 <code>visited</code> 集合。</li><li>可能下一层的单词有多个，都要考察，哪一条转换路径先遇到终点词，它就最短。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201203647.png" style="zoom: 67%;" /><p>上图中的删除操作改为使用 <code>visited</code> 集合，理由如上所述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(),wordList.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">empty</span>()||wordSet.<span class="hljs-built_in">count</span>(endWord)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 一开始要把开始的单词移除</span><br>        wordSet.<span class="hljs-built_in">erase</span>(beginWord);<br>        <span class="hljs-comment">// 图的广度优先遍历，使用队列和表示是否访问过的 visited 哈希表</span><br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(beginWord);<br>        unordered_set&lt;string&gt; visited;<br>        visited.<span class="hljs-built_in">insert</span>(beginWord);<br>        <span class="hljs-comment">// 开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span><br>        <span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-comment">// 依次遍历当前队列中的单词</span><br>                string curWord=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 如果 curWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">changeWord</span>(curWord,endWord,q,wordSet,visited))<br>                    <span class="hljs-keyword">return</span> step+<span class="hljs-number">1</span>;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 尝试对 curWord 修改每一个字符，看看是不是能与 endWord 匹配</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">changeWord</span><span class="hljs-params">(string &amp;curWord,string &amp;endWord,queue&lt;string&gt; &amp;q,unordered_set&lt;string&gt; &amp;wordSet,unordered_set&lt;string&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;endWord.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 先保存，然后恢复</span><br>            <span class="hljs-type">char</span> old=curWord[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> j=<span class="hljs-string">&#x27;a&#x27;</span>;j&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==old)<br>                    <span class="hljs-keyword">continue</span>;<br>                curWord[i]=j;<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">count</span>(curWord)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(curWord==endWord)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(curWord)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(curWord);<br>                        <span class="hljs-comment">// 添加到队列以后，必须马上标记为已经访问</span><br>                        visited.<span class="hljs-built_in">insert</span>(curWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复</span><br>            curWord[i]=old;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：双向BFS"><a href="#解法二：双向BFS" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h3><blockquote><p>已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集，这是双向广度优先遍历的思想。</p></blockquote><ul><li>已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集。这种方式搜索的单词数量会更小一些；</li><li>更合理的做法是，<strong>每次从单词数量小的集合开始扩散</strong>；</li><li>这里 <code>beginVisited</code> 和 <code>endVisited</code>交替使用，等价于单向 BFS 里使用队列，每次扩散都要加到总的 <code>visited</code> 里。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201212031.png" style="zoom: 80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(),wordList.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">empty</span>()||wordSet.<span class="hljs-built_in">count</span>(endWord)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 已经访问过的 word 添加到 visited 哈希表里</span><br>        unordered_set&lt;string&gt; visited;<br>        <span class="hljs-comment">// 分别用左边和右边扩散的哈希表代替单向 BFS 里的队列，它们在双向 BFS 的过程中交替使用</span><br>        unordered_set&lt;string&gt; beginVisited;<br>        beginVisited.<span class="hljs-built_in">insert</span>(beginWord);<br>        unordered_set&lt;string&gt; endVisited;<br>        endVisited.<span class="hljs-built_in">insert</span>(endWord);<br>        <span class="hljs-comment">// 执行双向 BFS，左右交替扩散的步数之和为所求</span><br>        <span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!beginVisited.<span class="hljs-built_in">empty</span>()&amp;&amp;!endVisited.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 优先选择小的哈希表进行扩散，考虑到的情况更少</span><br>            <span class="hljs-keyword">if</span>(beginVisited.<span class="hljs-built_in">size</span>()&gt;endVisited.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                unordered_set&lt;string&gt; tmp=beginVisited;<br>                beginVisited=endVisited;<br>                endVisited=tmp;<br>            &#125;<br>            <span class="hljs-comment">// 逻辑到这里，保证 beginVisited 是相对较小的集合，nextLevelVisited 在扩散完成以后，会成为新的 beginVisited</span><br>            unordered_set&lt;string&gt; nextLevelVisited;<br>            <span class="hljs-keyword">for</span>(string word:beginVisited)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">changeWord</span>(word,endVisited,visited,wordSet,nextLevelVisited))<br>                    <span class="hljs-keyword">return</span> step+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 原来的 beginVisited 废弃，从 nextLevelVisited 开始新的双向 BFS</span><br>            beginVisited=nextLevelVisited;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 尝试对 word 修改每一个字符，看看是不是能落在 endVisited 中，扩展得到的新的 word 添加到 nextLevelVisited 里</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">changeWord</span><span class="hljs-params">(string &amp;word,unordered_set&lt;string&gt; &amp;endVisited,unordered_set&lt;string&gt; &amp;visited,unordered_set&lt;string&gt; &amp;wordSet,unordered_set&lt;string&gt; &amp;nextLevelVisited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">char</span> old=word[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> j=<span class="hljs-string">&#x27;a&#x27;</span>;j&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==old)<br>                    <span class="hljs-keyword">continue</span>;<br>                word[i]=j;<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">count</span>(word)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(endVisited.<span class="hljs-built_in">count</span>(word)!=<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(word)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        nextLevelVisited.<span class="hljs-built_in">insert</span>(word);<br>                        visited.<span class="hljs-built_in">insert</span>(word);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复，下次再用</span><br>            word[i]=old;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="752-打开转盘锁-medium"><a href="#752-打开转盘锁-medium" class="headerlink" title="752. 打开转盘锁[medium]"></a><a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a>[medium]</h2><p>思路与 <a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a> 相似。详细思路叙述参考 @<a href="https://leetcode-cn.com/problems/open-the-lock/solution/wo-xie-liao-yi-tao-bfs-suan-fa-kuang-jia-jian-dao-/">labuladong</a> 题解。</p><h3 id="解法一：BFS-1"><a href="#解法一：BFS-1" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>第一步，不管 <code>deadends</code> 和 <code>target</code> 的限制，穷举所有可能的密码组合。总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能。比如说从 <code>&quot;0000&quot;</code> 开始，转一次，可以穷举出 <code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code>共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点。题目要求计算最短距离，这就是典型的 BFS 。</p><p>第二步，思考一些注意事项和限制：</p><ul><li>为了避免穷举时走回头路，需要一个 <code>visited</code> 集合记录转过的数字，避免死循环。</li><li>找到 <code>target</code> 就应该结束并返回拨动的次数。</li><li>对 <code>deadends</code> 进行处理，按道理这些「死亡密码」是不能出现的，也就是说遇到这些密码的时候需要跳过，用一个哈希表记录。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录需要跳过的死亡密码</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">deads</span><span class="hljs-params">(deadends.begin(),deadends.end())</span></span>;<br>        <span class="hljs-comment">// 记录已经穷举过的密码，防止走回头路</span><br>        unordered_set&lt;string&gt; visited;<br>        queue&lt;string&gt; q;<br>        <span class="hljs-comment">// 从起点开始启动广度优先搜索</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        visited.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 将当前队列中的所有节点向周围扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                string cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(deads.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 判断是否到达终点</span><br>                <span class="hljs-keyword">if</span>(cur==target)<br>                    <span class="hljs-keyword">return</span> steps;<br>                <span class="hljs-comment">// 将一个节点的未遍历相邻节点加入队列</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    string up=<span class="hljs-built_in">plusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(up)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(up);<br>                        visited.<span class="hljs-built_in">insert</span>(up);<br>                    &#125;<br>                    string down=<span class="hljs-built_in">minusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(down)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(down);<br>                        visited.<span class="hljs-built_in">insert</span>(down);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里增加步数</span><br>            steps++;<br>        &#125;<br>        <span class="hljs-comment">// 如果穷举完都没找到目标密码，那就是找不到了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 s[j] 向上拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">plusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 s[j] 向下拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">minusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]-=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：双向BFS-1"><a href="#解法二：双向BFS-1" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h3><p><strong>双向 BFS</strong>，可以进一步提高算法的效率。传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p><p>为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 <code>O(N)</code>，但是实际上双向 BFS 确实会快一些。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207204943.jpeg" style="zoom:80%;" /><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207205104.jpeg"></p><p>图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code>target</code>；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</p><p><strong>不过，双向 BFS 也有局限，因为必须知道终点在哪里</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录需要跳过的死亡密码</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">deads</span><span class="hljs-params">(deadends.begin(),deadends.end())</span></span>;<br>        <span class="hljs-comment">// 记录已经穷举过的密码，防止走回头路</span><br>        unordered_set&lt;string&gt; visited;<br>        <span class="hljs-comment">// 用集合不用队列，可以快速判断元素是否存在</span><br>        unordered_set&lt;string&gt; begin;<br>        begin.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        unordered_set&lt;string&gt; end;<br>        end.<span class="hljs-built_in">insert</span>(target);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!begin.<span class="hljs-built_in">empty</span>()&amp;&amp;!end.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 从元素少的集合扩散</span><br>            <span class="hljs-keyword">if</span>(begin.<span class="hljs-built_in">size</span>()&gt;end.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-comment">// 交换 begin 和 end</span><br>                unordered_set&lt;string&gt; tmp=begin;<br>                begin=end;<br>                end=tmp;<br>            &#125;<br>            <span class="hljs-comment">// 哈希集合在遍历的过程中不能修改，用 nextLevel 存储扩散结果</span><br>            unordered_set&lt;string&gt; nextLevel;<br>            <span class="hljs-comment">// 将 begin 中的所有节点向周围扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;cur:begin)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(deads.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 判断是否到达终点</span><br>                <span class="hljs-keyword">if</span>(end.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> steps;<br>                visited.<span class="hljs-built_in">insert</span>(cur);<br>                <span class="hljs-comment">// 将一个节点的未遍历相邻节点加入集合</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    string up=<span class="hljs-built_in">plusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(up)==<span class="hljs-number">0</span>)<br>                        nextLevel.<span class="hljs-built_in">insert</span>(up);<br>                    string down=<span class="hljs-built_in">minusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(down)==<span class="hljs-number">0</span>)<br>                        nextLevel.<span class="hljs-built_in">insert</span>(down);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里增加步数</span><br>            steps++;<br>            <span class="hljs-comment">// 下一轮 while 就是扩散 nextLevel</span><br>            begin=nextLevel;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 s[j] 向上拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">plusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 s[j] 向下拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">minusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]-=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集</strong>。</p><p>另外的一个技巧点就是在 while 循环开始时做一个判断，总是从元素少的集合进行扩散。因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</p><h2 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279. 完全平方数[medium]"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a>[medium]</h2><h3 id="解法一：DFS-暴力递归"><a href="#解法一：DFS-暴力递归" class="headerlink" title="解法一：DFS 暴力递归"></a>解法一：DFS 暴力递归</h3><p>考虑所有的分解方案，找出最小的解，举个例子。</p><p>n&#x3D;12，先把 n 减去一个平方数，然后求剩下的数分解成平方数和所需的最小个数。</p><ul><li>把 n 减去 1, 然后求出 11 分解成平方数和所需的最小个数，记做 n1，那么当前方案总共需要 n1+1 个平方数；</li><li>把 n 减去 4, 然后求出 8 分解成平方数和所需的最小个数，记做 n2，那么当前方案总共需要 n2+1 个平方数；</li><li>把 n 减去 9, 然后求出 3 分解成平方数和所需的最小个数，记做 n3 那么当前方案总共需要 n3+1 个平方数；</li><li>下一个平方数是 16，大于 12，不能再分了。</li></ul><p>接下来只需要从 (n1 + 1)、(n2 + 1)、(n3 + 1) 三种方案中选择最小的个数,  此时就是 12 分解成平方数和所需的最小个数。至于求 11、8、3 分解成最小平方数和所需的最小个数继续用上边的方法去求，直到如果求 0 分解成最小平方数的和的个数, 返回 0 即可。</p><p>直接递归会造成许多重复的计算，因此采用 <code>memoization</code> 技术，即记忆化搜索，把过程中的解利用 <code>HashMap</code> 全部保存起来。</p><p>Cpp 代码超时！！！Java 不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(n)) <br>            <span class="hljs-keyword">return</span> map.get(n);<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=Integer.MAX_VALUE;<br>    <span class="hljs-comment">// 依次减去一个平方数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i*i&lt;=n;i++)<br>            <span class="hljs-comment">// 选最小的</span><br>            count=Math.min(count,dfs(n-i*i,map)+<span class="hljs-number">1</span>);<br>        map.put(n, count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>将解法一改写成动态规划。递归相当于先压栈压栈然后出栈出栈，动态规划可以省去压栈的过程。动态规划的转移方程就对应递归的过程，动态规划的初始条件就对应递归的出口。</p><p>使用数组 <code>dp</code> 记录最少平方和，<code>dp[i]</code> 表示成 <code>i</code> 需要的最少平方和，则 <code>dp[n]=1+min&#123; dp[n-1^2],dp[n-2^2],dp[n-3^2],dp[n-4^2],...,dp[n-k^2] &#125;</code>，其中 <code>k</code> 为满足 <code>k^2 &lt;= n</code> 的最大的 <code>k</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 默认初始化值都为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i]=i;<span class="hljs-comment">// 最坏的情况就是每次+1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=i;++j)<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-j*j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：BFS"><a href="#解法三：BFS" class="headerlink" title="解法三：BFS"></a>解法三：BFS</h3><p>相对于解法一的 DFS ，当然也可以使用 BFS 。DFS 是一直做减法，然后一直减一直减，直到减到 <code>0</code> 算作找到一个解。属于一个解一个解的寻找。BFS 的话，可以一层一层的算。第一层依次减去一个平方数得到第二层，第二层依次减去一个平方数得到第三层。直到某一层出现了 <code>0</code>，此时的层数就是要找到平方数和的最小个数。</p><p>举个例子，<code>n = 12</code>，每层的话每个节点依次减 <code>1, 4, 9...</code>。如下图，灰色表示当前层重复的节点，不需要处理。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207171739.jpeg"></p><p>如上图，当出现 <code>0</code> 的时候遍历就可以停止，此时是第 <code>3</code> 层（从 <code>0</code> 计数），所以最终答案就是 <code>3</code>。</p><p>实现的话当然离不开队列，此外需要一个 <code>set</code> 来记录重复的解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> level=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>        q.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            level++;<span class="hljs-comment">// 开始生成下一层</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 依次减 1, 4, 9... 生成下一层的节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j*j&lt;=cur;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> next=cur-j*j;<br>                    <span class="hljs-keyword">if</span>(next==<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> level;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(next)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(next);<br>                        visited.<span class="hljs-built_in">insert</span>(next);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法四：数学方法"><a href="#解法四：数学方法" class="headerlink" title="解法四：数学方法"></a>解法四：数学方法</h3><p>四平方和定理，意思是任何正整数都能表示成四个平方数的和。少于四个平方数的，像 <code>12</code> 这种，可以补一个 <code>0</code> 也可以看成四个平方数，<code>12 = 4 + 4 + 4 + 0</code>。知道了这个定理，对于题目要找的解，其实只可能是 <code>1, 2, 3, 4</code> 其中某个数。</p><p><a href="https://en.wikipedia.org/wiki/Legendre's_three-square_theorem">Legendre’s three-square theorem</a>，这个定理表明，如果正整数 <code>n</code> 被表示为三个平方数的和，那么 <code>n</code> 不等于 <code>n = 4^a*(8b+7)</code> ，<code>a</code> 和 <code>b</code>都是非负整数。</p><p>换言之，如果 <code>n = 4^a*(8b+7)</code>，那么他一定不能表示为三个平方数的和，同时也说明不能表示为一个、两个平方数的和，因为如果能表示为两个平方数的和，那么补个 <code>0</code>，就能凑成三个平方数的和了。一个、两个、三个都排除了，所以如果 <code>n = 4^a*(8b+7)</code>，那么 <code>n</code> 只能表示成四个平方数的和了。</p><p>代码的话，采取排除的方法。首先考虑答案是不是 <code>1</code>，也就是判断当前数是不是一个平方数。然后考虑答案是不是 <code>4</code>，也就是判断 <code>n</code> 是不是等于 <code>4^a*(8b+7)</code>。然后考虑答案是不是 <code>2</code>，当前数依次减去一个平方数，判断得到的差是不是平方数。以上情况都排除的话，答案就是 <code>3</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSquare</span>(n))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> temp=n;<br>        <span class="hljs-keyword">while</span>(temp%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)<br>            temp/=<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">8</span>==<span class="hljs-number">7</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSquare</span>(n-i*i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">sqrt</span>(n));<br>        <span class="hljs-keyword">return</span> a*a==n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="542-01-矩阵-medium"><a href="#542-01-矩阵-medium" class="headerlink" title="542. 01 矩阵[medium]"></a><a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a>[medium]</h2><h3 id="解法一：BFS-2"><a href="#解法一：BFS-2" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>「图 的 BFS」与 「Tree 的 BFS」的区别：</p><ul><li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li><li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过。并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问。</li></ul><p>题目给出了多个<code>1</code>，要找出每个<code>1</code>到<code>0</code>的最近距离。由于<code>1</code>到<code>0</code>的距离和<code>0</code>到<code>1</code>的距离一样的，所以可以换个思维：找出每个<code>0</code>到<code>1</code>的距离。因此，题目可以抽象成：多个起始点的BFS。即从每一个 0 位置向上下左右四个方向进行广播，同时将点距离 0 的长度更新为最短。</p><p>首先把每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ），扩散的时候可以设置 <code>int[][] dist</code> 来记录距离（即扩散的层次）并同时标志是否访问过。对于本题是可以直接修改原数组 <code>int[][] matrix</code> 来记录距离和标志是否访问的，这里要注意先把 <code>matrix</code> 数组中 <code>1</code> 的位置设置成 <code>-1</code>（设成<code>Integer.MAX_VALUE</code>，<code>m * n</code>，<code>10000</code>都行，只要是个无效的距离值来标志这个位置的 <code>1</code> 没有被访问过就行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-comment">// 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                <span class="hljs-keyword">else</span><br>                    matrix[i][j]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>            <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> newX=x+direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> newY=y+direction[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 如果四邻域的点是 -1，表示这个点是未被访问过的 1</span><br>                <span class="hljs-comment">// 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1</span><br>                <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;matrix.<span class="hljs-built_in">size</span>()&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&amp;&amp;matrix[newX][newY]==<span class="hljs-number">-1</span>)<br>                &#123;<br>                    matrix[newX][newY]=matrix[x][y]+<span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：动态规划-1"><a href="#解法二：动态规划-1" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>对于任一点 (i, j)，距离 0 的距离为：<br>$$<br>f(i, j)&#x3D;\left{\begin{array}{ll}<br>1+\min (f(i-1, j), f(i, j-1), f(i+1, j), f(i, j+1)) &amp; \text { if matrix }[\mathrm{i}][\mathrm{j}]&#x3D;&#x3D;1 \<br>0 &amp; \text { if matrix }[\mathrm{i}][\mathrm{j}]&#x3D;&#x3D;0<br>\end{array}\right.<br>$$<br>因此用 dp[i] [j] 来表示距离该位置最近的 0 的距离。dp[i] [j] 是由其上下左右四个状态来决定，无法从一个方向开始递推。</p><p>于是尝试将问题分解：</p><ul><li>距离 (i, j) 最近的 0 的位置，是在其 「左上，右上，左下，右下」4 个方向之一；</li><li>因此分别从四个角开始递推，就分别得到了位于「左上方、右上方、左下方、右下方」距离 (i, j) 的最近的 0 的距离，取 min 即可；</li><li>通过上两步思路，可以很容易的写出 4 个双重 for 循环，动态规划的解法写到这一步其实已经完全 OK 了；</li><li>但是从四个角开始的 4 次递推，有一些重复计算的地方，还可以优化成从任一组对角开始的 2 次递推，比如只写从左上角、右下角开始递推就行了，为啥可以这样呢？<ul><li>首先从左上角开始递推 dp[i] [j] 是由其 「左方」和 「左上方」的最优子状态决定的；</li><li>然后从右下角开始递推 dp[i] [j] 是由其 「右方」和 「右下方」的最优子状态决定的；</li><li>看起来第一次递推的时候，把「右上方」的最优子状态给漏掉了，其实不是的，因为第二次递推的时候「右方」的状态在第一次递推时已经包含了「右上方」的最优子状态了；</li><li>看起来第二次递推的时候，把「左下方」的最优子状态给漏掉了，其实不是的，因为第二次递推的时候「右下方」的状态在第一次递推时已经包含了「左下方」的最优子状态了。</li></ul></li></ul><p>关于动态规划为什么只考虑左上和右下就可以了。另一个通俗易懂的解释：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-number">0</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br></code></pre></td></tr></table></figure><p>如上图，假设某个位置<code>(x,y)</code>离它最近的 0 只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3&#x3D;1+2”的范围内，所有的位置都是1（或者出界，暂时不考虑出界的情况，不影响结论）。</p><p>所以这张图一定是（不考虑左下方的出界情况，不影响）:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>? ? ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>?<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>&quot;1&quot;<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>? ? ?<br>? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br></code></pre></td></tr></table></figure><p>所以来考虑它右一处标为 X 的位置，离这个位置最近的 0，一定就是它“上二”方向的 0：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>? ? ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>?<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>&quot;1&quot; X<span class="hljs-number"> 1 </span>1 ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>? ? ?<br>? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br></code></pre></td></tr></table></figure><p>所以在“考虑左上角的时候”，X 处的位置可以记录到目标 0 的信息，X 处的最短距离被正确记录了。</p><p>然后在“考虑右下角的时候”，X 处的最短信息，正好又能被中心“1”观察到，所以中心 1 间接地，记录到了目标 0 的最短距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span><br>        <span class="hljs-comment">// 设置为 INT_MAX-1 的原因是 INT_MAX 会导致溢出</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,INT_MAX<span class="hljs-number">-1</span>));<br>        <span class="hljs-comment">// 如果 (i, j) 的元素为 0，那么距离为 0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)<br>                    dist[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从左上角开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) <br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从右下角开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;m)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1162-地图分析-medium"><a href="#1162-地图分析-medium" class="headerlink" title="1162. 地图分析[medium]"></a><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">1162. 地图分析</a>[medium]</h2><h3 id="解法：BFS-1"><a href="#解法：BFS-1" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><ul><li>把所有的 <strong>陆地（<code>1</code>）</strong> 添加到队列中，进行广度优先遍历，看看多少步可以扩散完成；</li><li>「扩散完成」的意思是：没有海洋可以扩散。</li></ul><p><strong>解读题目中的「最远」和「最近」</strong></p><ul><li>题目问的是「距离陆地区域最远的海洋区域」，其实就是从陆地 <code>1</code> 开始，要扩散多少次，才能把所有的海洋给覆盖掉。「最远」应该从这个角度来理解。</li><li>而「该海洋区域到离它最近的陆地区域的距离」，「最近」是因为一定是距离这个最后才扩散到的海洋的最近的陆地才能扩散到它。</li></ul><p>题目问的是「距离陆地区域最远的海洋区域」，这和以往经验稍微有点出入。一般而言，「广度优先遍历」求的是最短路径，但仔细一想，发现其实广度优先遍历也是适用的：</p><blockquote><ul><li>求最短路径的时候，只要找到目标值，返回即可；</li><li>求最长路径的时候，<strong>所有目标值都看完以后，才返回</strong>。</li></ul></blockquote><p>这道题「广度优先遍历」的起点有多个，但完全不影响算法的正确性，可以假想一个虚拟的起点，初始的起点就是由虚拟起点扩散开来的，示意图可以参考 @<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/">前额叶没长好</a> 题解。</p><p>题目中介绍的「曼哈顿距离」，其实就是对广度优先遍历（BFS）<strong>逐层向外扩散</strong>的精准数学解释，<strong>每扩散一次，曼哈顿距离就加 1</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=grid.<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    <span class="hljs-comment">// 把陆地添加到队列中</span><br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> size=que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>||size==n*n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 方向向量</span><br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 注意：先把当前队列的长度保存下来</span><br>            <span class="hljs-type">int</span> curSize=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> newX=x+direction[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> newY=y+direction[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;n&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;n&amp;&amp;!visited[newX][newY]&amp;&amp;visited[newX][newY]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        visited[newX][newY]=<span class="hljs-literal">true</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            steps++;<br>        &#125;<br>        <span class="hljs-comment">// 注意：由于最后一步，没有可以扩散的的区域，但是 step 加了 1，故在退出循环的时候应该减 1</span><br>        <span class="hljs-keyword">return</span> steps<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="994-腐烂的橘子-medium"><a href="#994-腐烂的橘子-medium" class="headerlink" title="994. 腐烂的橘子[medium]"></a><a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a>[medium]</h2><h3 id="解法：BFS-2"><a href="#解法：BFS-2" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><p>题目要求返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。实际上就是求<strong>腐烂橘子到所有新鲜橘子的最短路径</strong>。</p><ul><li>一开始，找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点；</li><li>然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点；<br>由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历</li><li>一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 表示新鲜橘子的数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">2</span>)<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    ++cnt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">while</span>(cnt&gt;<span class="hljs-number">0</span>&amp;&amp;!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> newX=x+direction[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> newY=y+direction[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;m&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;n&amp;&amp;!visited[newX][newY]&amp;&amp;grid[newX][newY]==<span class="hljs-number">1</span>)<br>                    &#123;<br>                        cnt-=<span class="hljs-number">1</span>;<br>                        visited[newX][newY]=<span class="hljs-literal">true</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            steps++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt==<span class="hljs-number">0</span>?steps:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题型四：游戏问题"><a href="#题型四：游戏问题" class="headerlink" title="题型四：游戏问题"></a>题型四：游戏问题</h1><h2 id="51-N-皇后-hard"><a href="#51-N-皇后-hard" class="headerlink" title="51. N 皇后[hard]"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a>[hard]</h2><h3 id="解法：回溯-6"><a href="#解法：回溯-6" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p><strong>理解树形结构</strong>：</p><p>先尝试画出递归树，以 4 皇后问题为例，画出的递归树如下：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208211356.png" style="zoom:80%;" /><p>搜索的过程蕴含了 <strong>剪枝</strong> 的思想。「剪枝」的依据是：题目中给出的 「N 皇后」 的摆放规则：1、不在同一行；2、不在同一列；3、不在同一主对角线方向上；4、不在同一副对角线方向上。</p><p><strong>小技巧：记住已经摆放的皇后的位置</strong></p><p>这里记住已经摆放的位置不能像 Flood Fill 一样，简单地使用 <code>visited</code> 布尔数组。放置的规则是：一行一行考虑皇后可以放置在哪一个位置上，某一行在考虑某一列是否可以放置皇后的时候，需要根据前面已经放置的皇后的位置。</p><p>可以使用一个一维数组 <code>queen</code> 来保存所有皇后的列位置，初始化均为 -1， 那么 <code>queen[i]</code>  就是表示第 <code>i</code> 个皇后在 <code>(i, queen[i])</code> 位置。这种记录每个皇后的坐标的方法在验证冲突的时候比较简单，只要从第 0 行遍历到当前行，若跟之前的皇后的列数相同，直接返回 <code>false</code>。</p><p><strong>考虑对角线（找规律）</strong>：</p><p>为了保证至少两个皇后不同时出现在 <strong>同一对角线方向</strong>。检查策略是，只要「检测」到新摆放的「皇后」与已经摆放好的「皇后」冲突，就尝试摆放同一行的下一个位置，到行尾还不能放置皇后，就退回到上一行。</p><p>当两个点在同一条对角线上，那么二者的横坐标差的绝对值等于纵坐标差的绝对值，利用这条性质，可以快速的判断对角线冲突。</p><p><strong>编码</strong>：</p><p>使用一个 1 到 4 的排列表示一个 4×4 的棋盘，例如：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208212423.png" style="zoom:80%;" /><p>得到一个符合要求的全排列以后，生成棋盘的代码就很简单了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 记录每一列皇后放置的位置</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queens</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(queens,n,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            <span class="hljs-comment">// 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果</span><br>            vector&lt;string&gt; board=<span class="hljs-built_in">convert2board</span>(path,n);<br>            res.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-comment">// 符合条件</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(queens,n,row,j))<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(j);<br>                queens[row]=j;<span class="hljs-comment">//放置“皇后”</span><br>                <span class="hljs-built_in">dfs</span>(queens,n,row+<span class="hljs-number">1</span>,path,res);<br>                queens[row]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//还原</span><br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将路径转化为棋盘</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">convert2board</span><span class="hljs-params">(deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;string&gt; board;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:path)<br>        &#123;<br>            string row;<br>            row.<span class="hljs-built_in">append</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>);<br>            row.<span class="hljs-built_in">replace</span>(num,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Q&quot;</span>);<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br><br>    <span class="hljs-comment">// 验证是否符合条件</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-comment">// 某一行与当前行在同一列放置了“皇后”，它们在数组中的值相等</span><br>            <span class="hljs-comment">// 当两个点在同一条对角线上，二者的横坐标差的绝对值等于纵坐标差的绝对值</span><br>            <span class="hljs-keyword">if</span>(queens[i]==col||<span class="hljs-built_in">abs</span>(i-row)==<span class="hljs-built_in">abs</span>(queens[i]-col))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="用空间换时间，进行优化"><a href="#用空间换时间，进行优化" class="headerlink" title="用空间换时间，进行优化"></a>用空间换时间，进行优化</h4><p>每次都调用 <code>isValid</code> 遍历一遍前面的格子，效率是不优的。最好是用数组或哈希表去记录出现过皇后的列、主对角线、副对角线，用空间换取时间。</p><p>由于是一行一行考虑放置皇后，摆放的这些皇后肯定不在同一行，为了避免它们在同一列，需要一个长度为 N 的布尔数组 <code>cols</code>，已经放置的皇后占据的列，就需要在对应的列的位置标注为 <code>True</code>。</p><p>下面研究一下主对角线或者副对角线上的元素有什么特性。在每一个单元格里写下行和列的 <strong>下标</strong>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208213344.png" style="zoom:80%;" /><p>可以像全排列 <code>used</code> 数组那样，再为 「主对角线（Main diagonal）」 和 「副对角线（Sub diagonal）」 设置相应的 <strong>布尔数组变量</strong>，只要排定一个 「皇后」 的位置，就需要占住对应的位置。</p><p>其实已经摆放皇后的列下标、占据了哪一条主对角线、哪一条副对角线也可以使用哈希表来记录。实际上哈希表底层也是数组，使用哈希表可以不用处理已经占据位置的皇后的主对角线、副对角线的下标偏移问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; col;<span class="hljs-comment">//记录某一列是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; main;<span class="hljs-comment">//记录主对角线上的单元格是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; sub;<span class="hljs-comment">//记录了副对角线上的单元格是否放置了皇后</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            vector&lt;string&gt; board=<span class="hljs-built_in">convert2board</span>(path,n);<br>            res.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(col.<span class="hljs-built_in">count</span>(j)==<span class="hljs-number">0</span>&amp;&amp;main.<span class="hljs-built_in">count</span>(row-j)==<span class="hljs-number">0</span>&amp;&amp;sub.<span class="hljs-built_in">count</span>(row+j)==<span class="hljs-number">0</span>)<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(j);<span class="hljs-comment">// 放置皇后</span><br>                col.<span class="hljs-built_in">insert</span>(j);<span class="hljs-comment">//记录放了皇后的列</span><br>                main.<span class="hljs-built_in">insert</span>(row-j);<span class="hljs-comment">//记录放了皇后的主对角线</span><br>                sub.<span class="hljs-built_in">insert</span>(row+j);<span class="hljs-comment">//记录放了皇后的副对角线</span><br>                <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,path,res);<br>                sub.<span class="hljs-built_in">erase</span>(row+j);<span class="hljs-comment">//删除对应的记录</span><br>                main.<span class="hljs-built_in">erase</span>(row-j);<br>                col.<span class="hljs-built_in">erase</span>(j);<br>                path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//撤销该点的皇后</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将路径转化为棋盘</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">convert2board</span><span class="hljs-params">(deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;string&gt; board;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:path)<br>        &#123;<br>            string row;<br>            row.<span class="hljs-built_in">append</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>);<br>            row.<span class="hljs-built_in">replace</span>(num,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Q&quot;</span>);<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="52-N皇后-II-hard"><a href="#52-N皇后-II-hard" class="headerlink" title="52. N皇后 II[hard]"></a><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a>[hard]</h2><h3 id="解法一：回溯-1"><a href="#解法一：回溯-1" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><p>思路与 <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 相同，稍加修改即可。区别在于，51 题需要得到所有可能的解，这道题只需要得到可能的解的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; col;<span class="hljs-comment">//记录某一列是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; main;<span class="hljs-comment">//记录主对角线上的单元格是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; sub;<span class="hljs-comment">//记录了副对角线上的单元格是否放置了皇后</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> &amp;count)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            ++count;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(col.<span class="hljs-built_in">count</span>(j)==<span class="hljs-number">0</span>&amp;&amp;main.<span class="hljs-built_in">count</span>(row-j)==<span class="hljs-number">0</span>&amp;&amp;sub.<span class="hljs-built_in">count</span>(row+j)==<span class="hljs-number">0</span>)<br>            &#123;<br>                col.<span class="hljs-built_in">insert</span>(j);<span class="hljs-comment">//记录放了皇后的列</span><br>                main.<span class="hljs-built_in">insert</span>(row-j);<span class="hljs-comment">//记录放了皇后的主对角线</span><br>                sub.<span class="hljs-built_in">insert</span>(row+j);<span class="hljs-comment">//记录放了皇后的副对角线</span><br>                <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,count);<br>                sub.<span class="hljs-built_in">erase</span>(row+j);<span class="hljs-comment">//删除对应的记录</span><br>                main.<span class="hljs-built_in">erase</span>(row-j);<br>                col.<span class="hljs-built_in">erase</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：DFS-位运算剪枝"><a href="#解法二：DFS-位运算剪枝" class="headerlink" title="解法二：DFS+位运算剪枝"></a>解法二：DFS+位运算剪枝</h3><p>具体思路参考 @<a href="https://leetcode-cn.com/problems/n-queens-ii/solution/dfs-wei-yun-suan-jian-zhi-by-makeex/">makee</a> 题解。</p><ol><li>使用常规深度优先一层层搜索。</li><li>使用三个整形分别标记每一层哪些格子可以放置皇后，这三个整形分别代表列、左斜下、右斜下<code>（_col, ld, rd_）</code>，二进制位为 1 代表不能放置，0 代表可以放置。</li><li>核心两个位运算：<ul><li><code>x &amp; -x</code> 代表除最后一位 1 保留，其它位全部为 0；</li><li><code>x &amp; (x - 1)</code> 代表将最后一位 1 变成 0。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">int</span> ld,<span class="hljs-type">int</span> rd,<span class="hljs-type">int</span> &amp;count)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row&gt;=n) <br>        &#123; <br>            ++count; <br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        <span class="hljs-comment">// 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历</span><br>        <span class="hljs-type">int</span> bits=~(col|ld|rd)&amp;((<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(bits&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> pick=bits&amp;-bits; <span class="hljs-comment">// 注: x &amp; -x</span><br>            <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,col|pick,(ld|pick)&lt;&lt;<span class="hljs-number">1</span>,(rd|pick)&gt;&gt;<span class="hljs-number">1</span>,count);<br>            bits&amp;=bits<span class="hljs-number">-1</span>; <span class="hljs-comment">// 注: x &amp; (x - 1)</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="37-解数独-hard"><a href="#37-解数独-hard" class="headerlink" title="37. 解数独[hard]"></a><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a>[hard]</h2><p>思路与 <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 相似。</p><h3 id="解法一：回溯-2"><a href="#解法一：回溯-2" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><p>详细思路参考 @<a href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/3.1-hui-su-suan-fa-dfs-suan-fa-pian/sudoku">labuladong的算法小抄</a> 回溯算法最佳实践：解数独。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 找到一个可行解，触发 base case</span><br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">9</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 穷举到最后一列的话就换到下一行重新开始</span><br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">9</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtrack</span>(board,i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果有预设数字，不用穷举</span><br>        <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtrack</span>(board,i,j+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 对 board[i][j] 进行穷举尝试</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;1&#x27;</span>;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>;++ch)<br>        &#123;<br>            <span class="hljs-comment">// 如果遇到不合法的数字，就跳过</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board,i,j,ch))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 做选择</span><br>            board[i][j]=ch;<br>            <span class="hljs-comment">// 继续穷举下一个</span><br>            <span class="hljs-comment">// 如果找到一个可行解，立即结束</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board,i,j+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 撤销选择</span><br>            board[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 穷举完 1~9，依然没有找到可行解，此路不通</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 board[i][j] 是否可以填入 n</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c,<span class="hljs-type">char</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 判断行是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[r][i]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 判断列是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[i][c]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 判断 3 x 3 方框是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[(r/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+i/<span class="hljs-number">3</span>][(c/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+i%<span class="hljs-number">3</span>]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：回溯-状态压缩（使用bitset）"><a href="#解法二：回溯-状态压缩（使用bitset）" class="headerlink" title="解法二：回溯+状态压缩（使用bitset）"></a>解法二：回溯+状态压缩（使用bitset）</h3><p>详细思路参考 @<a href="https://leetcode-cn.com/problems/sudoku-solver/solution/37-by-ikaruga/">Ikaruga</a> 题解。</p><p><strong>状态压缩</strong></p><ul><li>使用 <code>bitset&lt;9&gt;</code> 来压缩存储每一行、每一列、每一个 <code>3x3</code> 宫格中 <code>1-9</code> 是否出现；</li><li>这样每一个格子就可以计算出所有不能填的数字，然后得到所有<strong>能填的数字</strong> <code>getPossibleStatus()</code>；</li><li>填入数字和回溯时，只需要更新存储信息；</li><li>每个格子在使用时，会根据存储信息重新计算<strong>能填的数字</strong>。</li></ul><p>回溯</p><ul><li>每次都使用 <code>getNext()</code> 选择<strong>能填的数字</strong>最少的格子开始填，这样填错的概率最小，回溯次数也会变少；</li><li>使用 <code>fillNum()</code> 在填入和回溯时负责更新存储信息；</li><li>一旦全部填写成功，一路返回 true ，结束递归。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201214170159.png" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        rows=vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">9</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;());<br>        cols=vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">9</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;());<br>        cells=vector&lt;vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;&gt;(<span class="hljs-number">3</span>,vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">3</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;()));<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)<br>            &#123;<br>                <span class="hljs-comment">// 记录有待填入数字的数目</span><br>                cnt+=(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>);<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 初始化存储状态</span><br>                <span class="hljs-type">int</span> n=board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>;<br>                rows[i]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>                cols[j]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>                cells[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(board,cnt);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;bitset&lt;9&gt;&gt; rows;<br>    vector&lt;bitset&lt;9&gt;&gt; cols;<br>    vector&lt;vector&lt;bitset&lt;9&gt;&gt;&gt; cells;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件</span><br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 找出可能性最小的位置（其实就是包含已知信息最多的位置，这样选择的次数是最少的，有点类似贪心的思想）</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; next=<span class="hljs-built_in">getNext</span>(board);<br>        <span class="hljs-comment">// 找出这个坐标(i,j)可以填入的数字</span><br>        bitset&lt;9&gt; bits=<span class="hljs-built_in">getPossibleStatus</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;bits.<span class="hljs-built_in">size</span>();++n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!bits.<span class="hljs-built_in">test</span>(n))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 更新存储状态</span><br>            <span class="hljs-built_in">fillNum</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>],n,<span class="hljs-literal">true</span>);<br>            board[next[<span class="hljs-number">0</span>]][next[<span class="hljs-number">1</span>]]=n+<span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,cnt<span class="hljs-number">-1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            board[next[<span class="hljs-number">0</span>]][next[<span class="hljs-number">1</span>]]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            <span class="hljs-comment">// 撤销上一步的存储状态</span><br>            <span class="hljs-built_in">fillNum</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>],n,<span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 选择可能性最少的数字开始填</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> minCnt=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                bitset&lt;9&gt; cur=<span class="hljs-built_in">getPossibleStatus</span>(i,j);<br>                <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">count</span>()&gt;=minCnt)<br>                    <span class="hljs-keyword">continue</span>;<br>                ret=&#123;i,j&#125;;<br>                minCnt=cur.<span class="hljs-built_in">count</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function">bitset&lt;9&gt; <span class="hljs-title">getPossibleStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> ~(rows[x]|cols[y]|cells[x/<span class="hljs-number">3</span>][y/<span class="hljs-number">3</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillNum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n,<span class="hljs-type">bool</span> fillFlag)</span></span><br><span class="hljs-function">    </span>&#123;<br>        rows[x][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        cols[y][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        cells[x/<span class="hljs-number">3</span>][y/<span class="hljs-number">3</span>][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Sort</title>
    <link href="/2020/11/03/Leetcode%20Notes%E2%80%94%E2%80%94Sort/"/>
    <url>/2020/11/03/Leetcode%20Notes%E2%80%94%E2%80%94Sort/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>排序算法</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="75-颜色分类-medium"><a href="#75-颜色分类-medium" class="headerlink" title="75. 颜色分类[medium]"></a><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a>[medium]</h1><h2 id="解法一：计数排序"><a href="#解法一：计数排序" class="headerlink" title="解法一：计数排序"></a>解法一：计数排序</h2><p>使用计数排序两趟扫描，首先，迭代计算出 0、1 和 2 元素的个数，然后按照 0、1、2 的排序，重写当前数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count0=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count1=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count2=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>                ++count0;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)<br>                ++count1;<br>            <span class="hljs-keyword">else</span><br>                ++count2;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;count0)<br>                nums[i]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i&lt;count0+count1)<br>                nums[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                nums[i]=<span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：快速排序-partition"><a href="#解法二：快速排序-partition" class="headerlink" title="解法二：快速排序 partition"></a>解法二：快速排序 partition</h2><p>经典的荷兰国旗问题。参见<a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E8%8D%B7%E5%85%B0%E5%9B%BD%E6%97%97%E9%97%AE%E9%A2%98">牛客左神算法课笔记——算法入门</a>。</p><p>另外，还有不同的写法，主要是循环不变量的定义不同，参考 @<a href="https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/">liweiwei1419</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> zero=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 0 的右界</span><br>        <span class="hljs-type">int</span> two=nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 2 的左界</span><br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index&lt;two)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[index]==<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">swap</span>(nums[++zero],nums[index++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[index]==<span class="hljs-number">1</span>)<br>                ++index;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-built_in">swap</span>(nums[--two],nums[index]);           <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="215-数组中的第K个最大元素-medium"><a href="#215-数组中的第K个最大元素-medium" class="headerlink" title="215. 数组中的第K个最大元素[medium]"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>[medium]</h1><blockquote><p>经典的 TopK 问题，思路与 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#29-%E6%9C%80%E5%B0%8F%E7%9A%84-K-%E4%B8%AA%E6%95%B0">剑指offer-29.最小的 K 个数</a> 相同。</p></blockquote><p>思路的不同写法可以参考 @<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">liweiwei1419</a> 题解。</p><h2 id="解法一：排序"><a href="#解法一：排序" class="headerlink" title="解法一：排序"></a>解法一：排序</h2><p>升序排序后，返回索引为 <code>len - k</code> 的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[len-k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：快排变形"><a href="#解法二：快排变形" class="headerlink" title="解法二：快排变形"></a>解法二：快排变形</h2><p>借助 partition 操作定位到最终排定以后索引为 <code>len - k</code> 的那个元素。partition 操作总能排定一个元素，还能够知道这个元素它最终所在的位置，这样每经过一次 partition 操作就能缩小搜索的范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=len<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 转换一下，第 k 大元素的索引是 len - k</span><br>        <span class="hljs-type">int</span> target=len-k;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">partition</span>(nums,left,right);<br>            <span class="hljs-keyword">if</span>(index==target)<br>                <span class="hljs-keyword">return</span> nums[index];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index&lt;target)<br>                left=index+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>    <br>                right=index<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// partition 操作 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 在区间随机选择一个元素作为标定点</span><br>        <span class="hljs-type">int</span> randIndex=<span class="hljs-built_in">rand</span>()%(right-left+<span class="hljs-number">1</span>)+left;<br>        <span class="hljs-comment">// 将标定点 pivot 放到末尾</span><br>        <span class="hljs-built_in">swap</span>(nums[randIndex],nums[right]);<br>        <span class="hljs-type">int</span> less=left<span class="hljs-number">-1</span>;<span class="hljs-comment">// &lt; 区的右界</span><br>        <span class="hljs-type">int</span> more=right; <span class="hljs-comment">// &gt; 区的左界</span><br>        <span class="hljs-type">int</span> index=left;<br>        <span class="hljs-keyword">while</span>(index&lt;more)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[index]&lt;nums[right])<br>                <span class="hljs-built_in">swap</span>(nums[++less],nums[index++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[index]&gt;nums[right])<br>                <span class="hljs-built_in">swap</span>(nums[--more],nums[index]);    <br>            <span class="hljs-keyword">else</span><br>                ++index;      <br>        &#125;<br>        <span class="hljs-comment">// 处理末尾的标定点</span><br>        <span class="hljs-built_in">swap</span>(nums[more],nums[right]);<br>        <span class="hljs-keyword">return</span> less+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：堆"><a href="#解法三：堆" class="headerlink" title="解法三：堆"></a>解法三：堆</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>把 <code>len</code>个元素都放入一个大根堆中，然后再 <code>pop()</code> 出 <code>k - 1</code>个元素，因为前 <code>k - 1</code>大的元素都被弹出了，此时最大堆的堆顶元素就是数组中的第 <code>k</code>个最大元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            pq.<span class="hljs-built_in">push</span>(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k<span class="hljs-number">-1</span>;++i)<br>            pq.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>只用 <code>k</code> 个容量的优先队列，而不用全部 <code>len</code> 个容量。维护一个容量为 <code>k</code> 的小根堆。使用剩下的<code>n-k</code>个元素与堆顶元素比较：</p><ul><li>如果元素比堆顶元素大，则删除堆顶元素，然后插入该元素。</li><li>否则，不更新堆。</li></ul><p>最后剩下的 <code>k</code> 个元素即为最大的 <code>k</code> 个元素，堆顶是第 <code>k</code> 大元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            pq.<span class="hljs-built_in">push</span>(nums[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;pq.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="347-前-K-个高频元素-medium"><a href="#347-前-K-个高频元素-medium" class="headerlink" title="347. 前 K 个高频元素[medium]"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>[medium]</h1><p>TopK 问题的变形，需要建立数字和出现次数之间的映射关系。</p><h2 id="解法一：快排变形"><a href="#解法一：快排变形" class="headerlink" title="解法一：快排变形"></a>解法一：快排变形</h2><p>与 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a> 解法二思路相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 随机数种子</span><br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// &lt;数字，次数&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            ++m[num];<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; values;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv:m)<br>            values.<span class="hljs-built_in">push_back</span>(kv);<br>        <span class="hljs-built_in">findKth</span>(values,<span class="hljs-number">0</span>,values.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// values 按数字出现频率升序排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            res.<span class="hljs-built_in">push_back</span>(values[values.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-i].first);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findKth</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; &amp;values,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 转换一下，第 k 大的索引为 right-left+1-k</span><br>        <span class="hljs-type">int</span> target=right-left+<span class="hljs-number">1</span>-k;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">partition</span>(values,left,right);<br>            <span class="hljs-keyword">if</span>(index==target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index&lt;target)<br>                left=index+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>    <br>                right=index<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// partition 操作 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; &amp;values,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 在区间随机选择一个元素作为标定点</span><br>        <span class="hljs-type">int</span> randIndex=<span class="hljs-built_in">rand</span>()%(right-left+<span class="hljs-number">1</span>)+left;<br>        <span class="hljs-comment">// 将标定点 pivot 放到末尾</span><br>        <span class="hljs-built_in">swap</span>(values[randIndex],values[right]);<br>        <span class="hljs-type">int</span> pivot=values[right].second;<br>        <span class="hljs-type">int</span> less=left<span class="hljs-number">-1</span>;<span class="hljs-comment">// &lt; 区的右界</span><br>        <span class="hljs-type">int</span> more=right; <span class="hljs-comment">// &gt; 区的左界</span><br>        <span class="hljs-type">int</span> index=left;<br>        <span class="hljs-keyword">while</span>(index&lt;more)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(values[index].second&lt;pivot)<br>                <span class="hljs-built_in">swap</span>(values[++less],values[index++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(values[index].second&gt;pivot)<br>                <span class="hljs-built_in">swap</span>(values[--more],values[index]);    <br>            <span class="hljs-keyword">else</span><br>                ++index;      <br>        &#125;<br>        <span class="hljs-comment">// 处理末尾的标定点</span><br>        <span class="hljs-built_in">swap</span>(values[more],values[right]);<br>        <span class="hljs-keyword">return</span> less+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：堆"><a href="#解法二：堆" class="headerlink" title="解法二：堆"></a>解法二：堆</h2><p>与 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a> 解法三思路二相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            ++m[num];<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,CmpByValue&gt; pq;<span class="hljs-comment">//小根堆</span><br>        <span class="hljs-comment">// 遍历map，用小根堆保存频率最大的 k 个元素</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv:m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pq.<span class="hljs-built_in">size</span>()&lt;k)<br>                pq.<span class="hljs-built_in">push</span>(kv);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(kv.second&gt;pq.<span class="hljs-built_in">top</span>().second)<br>            &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(kv);<br>            &#125;               <br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 取出小根堆中的元素</span><br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(pq.<span class="hljs-built_in">top</span>().first);<br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CmpByValue</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second; <br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：桶排序"><a href="#解法三：桶排序" class="headerlink" title="解法三：桶排序"></a>解法三：桶排序</h2><p>在建立好数字和其出现次数的映射后，按照其出现次数将数字放到对应的位置中去，这样可以从桶的后面向前面遍历，最先得到的就是出现次数最多的数字，找到 k 个后返回即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            ++m[num];<br>        <span class="hljs-comment">// 桶排序，bucket 的大小为 nums.size()+1 是因为没有数字出现次数为 0，0 是空着的，保证不会越界</span><br>        <span class="hljs-comment">// 比如数组长度为 1，那么那个值一定出现 1 次，假设桶的长度也是 1，那么索引最大到 0，访问索引 1 越界</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">bucket</span>(nums.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>);<span class="hljs-comment">// &lt;次数，数字&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv:m)<br>            bucket[kv.second].<span class="hljs-built_in">push_back</span>(kv.first);<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bucket.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;bucket[i].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(bucket[i][j]);<br>                <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==k)<br>                    <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="451-根据字符出现频率排序-medium"><a href="#451-根据字符出现频率排序-medium" class="headerlink" title="451. 根据字符出现频率排序[medium]"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a>[medium]</h1><h2 id="解法一：自定义排序"><a href="#解法一：自定义排序" class="headerlink" title="解法一：自定义排序"></a>解法一：自定义排序</h2><p>使用 STL 自带的 sort 来做，关键就在于重写 comparator，由于需要使用外部变量，lambda 表达式中括号中放入 ＆，然后将频率大的返回，注意要处理频率相等的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:s)<br>            ++m[c];<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>(),[&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;b)&#123;<span class="hljs-keyword">return</span> m[a]&gt;m[b]||(m[a]==m[b]&amp;&amp;a&lt;b);&#125;);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：优先级队列"><a href="#解法二：优先级队列" class="headerlink" title="解法二：优先级队列"></a>解法二：优先级队列</h2><p>利用优先级队列自动排序的特点，把个数和字符组成 pair 放到优先队列里排好序后，再取出来组成结果 res。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:s)<br>            ++m[c];<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt;&gt; pq;<span class="hljs-comment">// &lt;次数，字符&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv:m)<br>            pq.<span class="hljs-built_in">push</span>(&#123;kv.second,kv.first&#125;);<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t=pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 添加 t.first 个字符（t.second）</span><br>            res.<span class="hljs-built_in">append</span>(t.first,t.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：桶排序-1"><a href="#解法三：桶排序-1" class="headerlink" title="解法三：桶排序"></a>解法三：桶排序</h2><p>思路与 <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a> 解法三相同。</p><p>将每个字符根据其出现次数放入数组中对应位置，然后从后往前遍历数组所有位置，将不为空的位置的字符串加入结果 res。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:s)<br>            ++m[c];<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">bucket</span><span class="hljs-params">(s.size()+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;kv:m)<br>            bucket[kv.second].<span class="hljs-built_in">append</span>(kv.second,kv.first);<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bucket.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!bucket[i].<span class="hljs-built_in">empty</span>())<br>                res.<span class="hljs-built_in">append</span>(bucket[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Greedy</title>
    <link href="/2020/10/29/Leetcode%20Notes%E2%80%94%E2%80%94Greedy/"/>
    <url>/2020/10/29/Leetcode%20Notes%E2%80%94%E2%80%94Greedy/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>贪心算法</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="贪心算法方法论"><a href="#贪心算法方法论" class="headerlink" title="贪心算法方法论"></a>贪心算法方法论</h1><p><strong>贪心算法</strong>（greedy algorithm），是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p><p>贪心算法在有<strong>最优子结构</strong>的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p><p>贪心算法与<strong>动态规划</strong>的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码..…对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。</p><p><strong>贪心算法流程：</strong></p><ol><li>创建数学模型来描述问题；</li><li>把求解的问题分成若干个<strong>子问题</strong>；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><p><strong>贪心算法与回溯算法、动态规划的关系：</strong></p><p>回溯算法，动态规划和贪心算法其实是循序渐进的。回溯算法即是暴力的<strong>枚举</strong>，每一步对所有可能都进行计算，计算到达终点即返回，每一步返回后都要把状态回归到之前的状态。回溯算法的痛点是他有很多重复的计算，解决的办法是引入备忘录，备忘录记录了每一步的结果，这其实就是子问题的最优解，动态规划由此产生。所以使用动态规划时必须要满足<strong>无后效性</strong>，子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。如果一个问题没有<strong>重叠子问题</strong>，那就只能使用回溯算法，比如 N 皇后问题。</p><h1 id="455-分发饼干-easy"><a href="#455-分发饼干-easy" class="headerlink" title="455. 分发饼干[easy]"></a><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a>[easy]</h1><h2 id="解法：贪心算法"><a href="#解法：贪心算法" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：</p><ol><li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li><li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li></ol><p>在以上的解法中，只在每次分配饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p><p>代码思路：</p><ul><li>对 <code>g</code> 和 <code>s</code>升序排序。</li><li>初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向 <code>g</code> 和 <code>s</code>初始位置。</li><li>对比 <code>g[i]</code> 和 <code>s[j]</code>，<ul><li><code>g[i] &lt;= s[j]</code>：饼干满足胃口，把能满足的孩子数量加 1，并移动指针 <code>++i</code>，<code>++j</code>。</li><li><code>g[i] &gt; s[j]</code>：无法满足胃口，<code>j</code>右移，继续查看下一块饼干是否可以满足胃口。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(g[i]&lt;=s[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>                ++count;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="435-无重叠区间-medium"><a href="#435-无重叠区间-medium" class="headerlink" title="435. 无重叠区间[medium]"></a><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a>[medium]</h1><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>&#x3D;&#x3D;TODO&#x3D;&#x3D;</p><h2 id="解法二：贪心算法"><a href="#解法二：贪心算法" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><p>先计算有多少个区间不会重叠，即典型的会议室安排问题，那么剩下的就是至少需要去除的区间个数。</p><p>贪心策略：</p><ol><li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li><li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li><li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li></ol><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210735.gif" style="zoom:67%;" /><p>代码思路：</p><ul><li>对区间集合 intvs 按照结束时间升序排序。</li><li>筛选开始时间大于等于 x 的区间，计数 count++。</li><li>返回结果为总的区间数量减去不相交的区间数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;      <br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 按 end 升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-comment">// 至少有一个区间不相交</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 排序后，第一个区间就是 x</span><br>        <span class="hljs-type">int</span> end=intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;intervals.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]&gt;=end)<br>            &#123;<br>                <span class="hljs-comment">// 找到下一个选择的区间了</span><br>                count++;<br>                end=intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>()-count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="452-用最少数量的箭引爆气球-medium"><a href="#452-用最少数量的箭引爆气球-medium" class="headerlink" title="452. 用最少数量的箭引爆气球[medium]"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a>[medium]</h1><h2 id="解法：贪心算法-1"><a href="#解法：贪心算法-1" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>与 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a> 基本相同，也是计算不重叠的区间个数，区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。因从采用和 435 解法二相同的贪心策略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> end=points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;points.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>]&gt;end)<br>            &#123;<br>                count++;<br>                end=points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="406-根据身高重建队列-medium"><a href="#406-根据身高重建队列-medium" class="headerlink" title="406. 根据身高重建队列[medium]"></a><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a>[medium]</h1><h2 id="解法：贪心算法-2"><a href="#解法：贪心算法-2" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：</p><ul><li>先排身高更高的，这是要防止后排入人员影响先排入人员位置。</li><li>每次排入新人员<code>[h,k]</code>时，已处于队列的人身高都<code>&gt;=h</code>，所以新排入位置就是<code>people[k]</code>。</li><li>详细解释可以参考<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/">官方解答</a>。</li></ul><p>代码思路：</p><p>先将<code>people</code>按照<strong>身高降序排序</strong>，又由于每次插入的位置是<code>k</code>，所以<strong>相同身高需要按<code>k</code>升序排序</strong>，否则插入位置会越界。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[7,1]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[4,4]</span><br>再一个一个插入。<br><span class="hljs-selector-attr">[7,0]</span><br><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[4,4]</span>, <span class="hljs-selector-attr">[7,1]</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),compare);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:people)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>()+e[<span class="hljs-number">1</span>],e);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于需要频繁使用<code>insert()</code>操作，可以使用<code>list</code>加速，注意<code>list</code>的迭代器不支持随机访问，需要使用<code>advance()</code>找到相应插入位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),compare);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:people)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> pos=tmp.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-built_in">advance</span>(pos,e[<span class="hljs-number">1</span>]);<br>            tmp.<span class="hljs-built_in">insert</span>(pos,e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="605-种花问题-easy"><a href="#605-种花问题-easy" class="headerlink" title="605. 种花问题[easy]"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a>[easy]</h1><h2 id="解法：贪心算法-3"><a href="#解法：贪心算法-3" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>从左到右扫描数组，如果数组中有一个 <code>0</code>，并且这个<code>0</code>的左右两侧都是 <code>0</code>，那么就可以在这个位置种花，即将这个位置的<code>0</code>修改成 <code>1</code>，并将计数器 <code>count</code> 增加 <code>1</code>。对于数组的第一个和最后一个位置，只需要考虑一侧是否为 0。在扫描结束之后，将 <code>count</code> 与 <code>n</code> 进行比较。如果 <code>count &gt;= n</code>，返回 <code>True</code>，否则返回 <code>False</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> pre=i==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:flowerbed[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-type">int</span> next=i==flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:flowerbed[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">0</span>&amp;&amp;next==<span class="hljs-number">0</span>)<br>                &#123;<br>                    flowerbed[i]=<span class="hljs-number">1</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化：当 <code>count</code> 的值已经达到 <code>n</code>时，可以提前退出循环返回<code>True</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> pre=i==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:flowerbed[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-type">int</span> next=i==flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:flowerbed[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">0</span>&amp;&amp;next==<span class="hljs-number">0</span>)<br>                &#123;<br>                    flowerbed[i]=<span class="hljs-number">1</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&gt;=n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二：前后补零"><a href="#思路二：前后补零" class="headerlink" title="思路二：前后补零"></a>思路二：前后补零</h3><p>为了避免首位和尾位的特殊情况，可在首位和尾位都填上一个 0，这样就可以一视同仁了，只需寻找到有多少个 0 的左右两边都是 0 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        flowerbed.<span class="hljs-built_in">insert</span>(flowerbed.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>        flowerbed.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>&amp;&amp;flowerbed[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flowerbed[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)<br>            &#123;<br>                flowerbed[i]=<span class="hljs-number">1</span>;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&gt;=n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="392-判断子序列-easy"><a href="#392-判断子序列-easy" class="headerlink" title="392. 判断子序列[easy]"></a><a href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a>[easy]</h1><h2 id="解法一：贪心算法-双指针"><a href="#解法一：贪心算法-双指针" class="headerlink" title="解法一：贪心算法+双指针"></a>解法一：贪心算法+双指针</h2><p>贪心策略：</p><p>每次贪心地匹配靠前的字符。</p><p>假定当前需要匹配字符 c，而字符 c 在 t 中的位置 x1 和 x2 出现（x1 &lt; x2），那么贪心取 x1 是最优解，因为 x2 后面能取到的字符，x1 也都能取到，并且通过 x1 与 x2 之间的可选字符，更有希望能匹配成功。</p><p>代码思路：</p><p>初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;t.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==t[j])<br>                ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==s.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p><strong>后续挑战：</strong></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果有大量输入的 S，称作<span class="hljs-built_in">S1</span>, <span class="hljs-built_in">S2</span>, ... , Sk 其中 k &gt;= <span class="hljs-number">10</span>亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？<br></code></pre></td></tr></table></figure><p>如果有大量输入的 S，需要依次检查它们是否为 T 的子序列，这时候处理每一个子串都需要扫描一遍 T 是很费时的。</p><p>在这种情况下，需要在匹配前对 T 做预处理，可以利用一个二维数组记录匹配到某一点时，待匹配的字符在 T 中<strong>下一次</strong>出现的位置。这里的字符是<code>&#39;a&#39; ~ &#39;z&#39;</code>，所以这个数组的大小是 <code>dp[n][26]</code>，n 为 T 的长度。对于要匹配的短字符串，遍历每一个字符，不断地寻找该字符在长字符串中的位置，然后将位置更新，寻找下一个字符，相当于在长字符串上“跳跃”。比如下面匹配 “ada” 的例子，只需要“跳跃”三次。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210813.jpeg" style="zoom:67%;" /><p>如果下一个位置为 <code>-1</code>，表示长字符串再没有该字符了，返回 <code>false</code> 即可。如果能正常遍历完毕，则返回<code>true</code> 。</p><p>需要注意的一点：对于 “abc” 在 “ahbgdc” 上匹配的时候，由于长字符串第一个 a 的下一个出现 a 的位置为 -1（不出现），会导致访问越界。所以在生成数组时在长字符串前插入一个空字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// 预处理</span><br>        t=<span class="hljs-string">&quot; &quot;</span>+t;<br>        <span class="hljs-type">int</span> len=t.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c=<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++c)<br>        &#123;<br>            <span class="hljs-type">int</span> nextPos=<span class="hljs-number">-1</span>;<span class="hljs-comment">// 表示接下来再不会出现该字符</span><br>            <span class="hljs-comment">// 为了获得下一个字符的位置，要从后往前</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>            &#123;<br>                dp[i][c-<span class="hljs-string">&#x27;a&#x27;</span>]=nextPos;<br>                <span class="hljs-keyword">if</span>(t[i]==c)<br>                    nextPos=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 匹配</span><br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:s)<br>        &#123;<br>            <span class="hljs-comment">// 跳跃遍历</span><br>            index=dp[index][c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(index==<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="134-加油站-medium"><a href="#134-加油站-medium" class="headerlink" title="134. 加油站[medium]"></a><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a>[medium]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>题目可以理解为下边的图：每个节点表示添加的油量，每条边表示消耗的油量。只能顺时针方向走。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210827.jpeg" style="zoom:80%;" /><p>分别从每个点出发，看是否能回到出发点。由于是个圆，得到下一个点的时候需要取余数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=gas.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 考虑从每一个点出发</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j=i;<br>            <span class="hljs-type">int</span> remain=gas[i];<br>            <span class="hljs-comment">// 当前剩余的油能否到达下一个点</span><br>            <span class="hljs-keyword">while</span>(remain-cost[j]&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 减去花费的加上新的点的补给</span><br>                remain=remain-cost[j]+gas[(j+<span class="hljs-number">1</span>)%len];<br>                j=(j+<span class="hljs-number">1</span>)%len;<br>                <span class="hljs-comment">// j 回到了 i</span><br>                <span class="hljs-keyword">if</span>(j==i)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 任何点都不可以</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p><h2 id="解法二：贪心算法-1"><a href="#解法二：贪心算法-1" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><p>首先要知道能走完整个环的前提是<code>gas</code>的总量要大于<code>cost</code>的总量，这样才会有起点的存在。假设开始设置起点 <code>start=0</code>，从这里出发，遍历所有节点，<code>curTank</code>记录当前节点油箱内剩余油量，如果<code>curTank&gt;=0</code>，则继续前进。当到达某一站点时，如果<code>curTank&lt;0</code>，则说明从起点到这个点中间的任何一个点都不能作为起点，将<code>curTank</code>置 0 ，<code>start</code>置为下一个节点，继续遍历。当遍历完整个环时，当前保存的起点即为所求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalTank=<span class="hljs-number">0</span>;<span class="hljs-comment">// 总油量</span><br>        <span class="hljs-type">int</span> curTank=<span class="hljs-number">0</span>;<span class="hljs-comment">// 当前油量</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<span class="hljs-comment">// 起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;gas.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            totalTank+=gas[i]-cost[i];<br>            curTank+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(curTank&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                start=i+<span class="hljs-number">1</span>;<br>                curTank=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalTank&gt;=<span class="hljs-number">0</span>?start:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>参考 @<a href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/">神奇的Z</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=gas.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> totalTank=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minTotal=INT_MAX;<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            totalTank+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(totalTank&lt;minTotal)<br>            &#123;<br>                minTotal=totalTank;<br>                minIndex=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalTank&gt;=<span class="hljs-number">0</span>?(minIndex+<span class="hljs-number">1</span>)%len:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="665-非递减数列-easy"><a href="#665-非递减数列-easy" class="headerlink" title="665. 非递减数列[easy]"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a>[easy]</h1><h2 id="解法：贪心算法-4"><a href="#解法：贪心算法-4" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>在出现 <code>nums[i]&gt;nums[i+1]</code> 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 <code>i+1</code> 之前的数组成为非递减数组，并且<strong>不影响后续的操作</strong> 。</p><ul><li><p>当数组长度小于 3 时，最多需要调整一次就能满足条件。</p></li><li><p>当数组长度大于等于 3 时，出现前一个元素 y 大于后一个元素 z 时，如果 y 的前元素 x 不存在，让 y&#x3D;z 即可；若 x 存在，会有以下情况，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>    y   z<br><span class="hljs-attribute">1</span>    <span class="hljs-number">3</span>   <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">3</span>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>    <span class="hljs-number">3</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>要满足条件，需要如下调整：</p><ul><li>当 x&lt;z,让 y&#x3D;z</li><li>当 x&gt;z,让 z&#x3D;y</li><li>当 x&#x3D;z,让 y&#x3D;z</li></ul><p>综合以上可以得到：当 x 存在且 x&gt;z，就让 z&#x3D;y，否则让 y&#x3D;z。</p></li><li><p>当变更超过 2 次就不再满足条件。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                count++;<br>                <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i<span class="hljs-number">-1</span>]&gt;nums[i+<span class="hljs-number">1</span>])<br>                    nums[i+<span class="hljs-number">1</span>]=nums[i];<br>                <span class="hljs-keyword">else</span><br>                    nums[i]=nums[i+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="763-划分字母区间-medium"><a href="#763-划分字母区间-medium" class="headerlink" title="763. 划分字母区间[medium]"></a><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a>[medium]</h1><h2 id="解法：贪心算法-双指针"><a href="#解法：贪心算法-双指针" class="headerlink" title="解法：贪心算法+双指针"></a>解法：贪心算法+双指针</h2><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。由于只包含小写字母，因此可以用数组代替哈希表。</p><p>在得到每个字母最后一次出现的下标位置之后，使用贪心算法将字符串划分为尽可能多的片段：</p><ul><li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 <code>start</code> 和结束下标<code>end</code>，初始时 <code>start=end=0</code>。</li><li>对于每个访问到的字母，得到当前字母的最后一次出现的下标位置 <code>maxPos</code> ，则当前片段的结束下标一定不会小于 <code>maxPos</code> ，更新 <code>end</code>。</li><li>当访问到下标 <code>end</code> 时，当前片段访问结束，进行切割，保存当前片段长度，<code>start</code> 从 <code>end+1</code> 开始继续寻找下一个片段。</li><li>重复上述过程，直到遍历完字符串。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201031162549.png" style="zoom:50%;" /><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxPos</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 存放字母与它的最远位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();++i)<br>            maxPos[S[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=i;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<span class="hljs-comment">// 待切割的起始位置</span><br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<span class="hljs-comment">// 已扫描的字符中最远的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            end=<span class="hljs-built_in">max</span>(end,maxPos[S[i]-<span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-comment">// 正好扫描到「已扫描的字符的最远位置」，到达切割点</span><br>            <span class="hljs-keyword">if</span>(i==end)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(end-start+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 更新下一个待切割的字符串的起始位置</span><br>                start=end+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="621-任务调度器-medium"><a href="#621-任务调度器-medium" class="headerlink" title="621. 任务调度器[medium]"></a><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a>[medium]</h1><h2 id="解法：贪心算法-5"><a href="#解法：贪心算法-5" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：每次先安排出现次数多的任务。</p><h3 id="思路一：排序"><a href="#思路一：排序" class="headerlink" title="思路一：排序"></a>思路一：排序</h3><p>规定 <code>n + 1</code> 个任务为一轮，这样同一轮中一个任务最多只能被安排一次。在每一轮中，将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 <code>n + 1</code> 个任务依次执行。如果任务的种类 <code>t</code> 少于 <code>n + 1</code> 个，就只选择全部的 <code>t</code> 种任务，其余的时间空闲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(times[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(times[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">26</span>&amp;&amp;times[i]&gt;<span class="hljs-number">0</span>)<br>                    --times[i];<br>                ++count;<br>            &#125;<br>            <span class="hljs-comment">// 每轮过后重新排序</span><br>            <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二：优先级队列"><a href="#思路二：优先级队列" class="headerlink" title="思路二：优先级队列"></a>思路二：优先级队列</h3><p>在选择每一轮的任务时，用优先队列来代替排序。在一开始，把所有的任务加入到优先队列中。在每一轮，从优先队列中选择最多 <code>n + 1</code> 个任务，把它们的数量减去 <code>1</code>，再放回堆中（如果数量不为 <code>0</code>），直到堆为空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:times)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(num);<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">top</span>()&gt;<span class="hljs-number">1</span>)<br>                        tmp.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>()<span class="hljs-number">-1</span>);<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                ++count;<br>                <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">empty</span>())<br>                    <span class="hljs-keyword">break</span>; <br>            &#125;<br>            <span class="hljs-comment">// 每轮过后重新维护堆</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;t:tmp)<br>                q.<span class="hljs-built_in">push</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路三：桶思想"><a href="#思路三：桶思想" class="headerlink" title="思路三：桶思想"></a>思路三：桶思想</h3><p>参考桶思想，详细说明各种情况。建立大小为 <code>n + 1</code> 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 n&#x3D;2，A 任务个数 6 个，建立 6 个桶子，每个容量为 3：</p><p>可以把一个桶子看作一轮任务</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094432.png" style="zoom:80%;" /><ol><li><p>从最简单的情况看起，现在就算没有其他任务，完成任务 A 所需的时间应该是（6-1）*3+1&#x3D;16，因为最后一个桶子，不存在等待时间；</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094454.png" style="zoom:80%;" /></li><li><p>接下来添加些其他任务：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093606.png" style="zoom:80%;" /><p>可以看到 C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；<br>而 B 和 A 数量相同，这会导致最后一个桶子中，需要多执行一次B任务，现在需要的时间是（6-1)*3+2&#x3D;17。</p><p><strong>前面两种情况，总结起来：总排队时间 &#x3D; (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong>。</p></li><li><p>当冷却时间短，任务种类很多时：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093836.png" style="zoom:80%;" /><p>比如上图，刚好排满了任务，此时所需时间还是 17，如果现在还要执行两次任务 F，该怎么安排呢？</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093904.png" style="zoom:80%;" /><p>此时可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">插入前：ABC | <span class="hljs-type">ABC</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> |<span class="hljs-type">AB</span><br>插入后：ABCF | <span class="hljs-type">ABCF</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> |<span class="hljs-type">AB</span><br></code></pre></td></tr></table></figure><p>在第一个、第二个桶子里插入了任务 F，不难发现无论再继续插入多少任务，都可以类似处理，而且新插入元素肯定满足冷却要求。继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。<br><strong>也就是说，执行任务所需的时间，就是任务的数量</strong>。</p></li></ol><p>这样剩下就很好处理了，只需要算两个数：</p><ul><li>记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X，计算 NUM1&#x3D;(N-1)*(n+1)+x。</li><li>NUM2&#x3D;tasks.size()。</li></ul><p>输出其中较大值即可。因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是NUM2&gt;&#x3D;NUM1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;times.<span class="hljs-built_in">size</span>()&amp;&amp;times[i]==times[<span class="hljs-number">0</span>])<br>            ++i;<br>        <span class="hljs-type">int</span> tasksNum=tasks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tasksNum,(times[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>)*(n+<span class="hljs-number">1</span>)+i);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="55-跳跃游戏-medium"><a href="#55-跳跃游戏-medium" class="headerlink" title="55. 跳跃游戏[medium]"></a><a href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>[medium]</h1><h2 id="解法：贪心算法-6"><a href="#解法：贪心算法-6" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>对于数组中的任意一个位置 y，如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度 <code>x+nums[x]≥y</code>，那么位置 y 也可以到达。换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p><p>这样一来，可以依次遍历数组中的每一个位置，并实时维护最远可以到达的位置。对于当前遍历到的位置 x，如果它在最远可以到达的位置的范围内，那么就可以从起点通过若干次跳跃到达该位置，因此可以用 <code>x+nums[x]</code> 更新最远可以到达的位置。</p><p>在遍历的过程中，如果当前位置大于最远可以到达的位置，那么该位置不可达，直接返回 <code>false</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxRight=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;maxRight)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            maxRight=<span class="hljs-built_in">max</span>(maxRight,i+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="45-跳跃游戏-II-hard"><a href="#45-跳跃游戏-II-hard" class="headerlink" title="45. 跳跃游戏 II[hard]"></a><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>[hard]</h1><h2 id="解法：贪心算法-7"><a href="#解法：贪心算法-7" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><h3 id="思路一：反向查找出发位置"><a href="#思路一：反向查找出发位置" class="headerlink" title="思路一：反向查找出发位置"></a>思路一：反向查找出发位置</h3><p>目标是到达数组的最后一个位置，因此可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。如果有多个位置通过跳跃都能够到达最后一个位置，那么「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，可以从左到右遍历数组，选择第一个满足要求的位置。找到最后一步跳跃前所在的位置之后，继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。</p><p>代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> position=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-comment">//要找的位置</span><br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 是否到了第 0 个位置</span><br>        <span class="hljs-keyword">while</span>(position!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;position;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i+nums[i]&gt;=position)<br>                &#123;<br>                    position=i;<span class="hljs-comment">//更新要找的位置</span><br>                    steps++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，在最坏的情况下，例如数组中的所有元素都是 1，<code>position</code> 需要遍历数组中的每个位置，对于 <code>position</code> 的每个值都有一次循环。空间复杂度 O(1)。</p><h3 id="思路二：正向查找可到达的最大位置"><a href="#思路二：正向查找可到达的最大位置" class="headerlink" title="思路二：正向查找可到达的最大位置"></a>思路二：正向查找可到达的最大位置</h3><p>贪心策略：每次找到可到达的最远位置。</p><p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p><p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102162656.png" style="zoom:67%;" /><p>在具体的实现中，维护当前能够到达的最大下标位置，记为边界。从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</p><p>在遍历数组时，不访问最后一个元素，这是因为在访问最后一个元素之前，边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，会增加一次「不必要的跳跃次数」，因此不必访问最后一个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxPos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 找能跳的最远的</span><br>            maxPos=<span class="hljs-built_in">max</span>(maxPos,i+nums[i]);<br>            <span class="hljs-keyword">if</span>(i==end)<br>            &#123;<br>                <span class="hljs-comment">// 遇到边界，就更新边界，并且步数加一</span><br>                end=maxPos;<br>                steps++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h1 id="135-分发糖果-hard"><a href="#135-分发糖果-hard" class="headerlink" title="135. 分发糖果[hard]"></a><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a>[hard]</h1><h2 id="解法一：暴力法-1"><a href="#解法一：暴力法-1" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>使用数组 candies 记录给学生的糖果数。首先给每个学生 1 个糖果。然后开始从左到右扫描数组。对每一个学生，如果当前的评分 ratings[i] 比前一名学生的评分 ratings[i−1] 高，且 candies[i]&lt;&#x3D;candies[i−1] ，那么更新 candies[i]&#x3D;candies[i−1]+1。这样，这两名学生之间的糖果分配目前是正确的。同样的，检查当前学生的评分 ratings[i] 是否比 ratings[i+1] 高，如果成立，同样更新 candies[i]&#x3D;candies[i+1]+1 。继续对 ratings 数组重复此步骤。如果在某次遍历中，candies 数组不再变化，意味着已经得到了最后的糖果分布，此时可以停止遍历。为了记录是否到达最终状态，用 flag 记录每次遍历是否有糖果数目变化，如果有，则为 True ，否则为 False 。最终，把 candies 数组中所有糖果数目加起来，得到要求数目最少的糖果数。</p><p>cpp 超时！！！java 不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        Arrays.fill(candies, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (flag) <br>        &#123;<br>            flag=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ratings.length;i++) &#123;<br>                <span class="hljs-keyword">if</span>(i!=ratings.length-<span class="hljs-number">1</span>&amp;&amp;ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>]&amp;&amp;candies[i]&lt;=candies[i+<span class="hljs-number">1</span>]) <br>                &#123;<br>                    candies[i]=candies[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>&amp;&amp;ratings[i]&gt;ratings[i-<span class="hljs-number">1</span>]&amp;&amp;candies[i]&lt;=candies[i-<span class="hljs-number">1</span>]) <br>                &#123;<br>                    candies[i]=candies[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> candy:candies)<br>            sum+=candy;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(n)。</p><h2 id="解法二：贪心算法-2"><a href="#解法二：贪心算法-2" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><h3 id="思路一：用两个数组"><a href="#思路一：用两个数组" class="headerlink" title="思路一：用两个数组"></a>思路一：用两个数组</h3><p>数组 left2right 用来存储每名学生只与左边邻居有关的所需糖果数。也就是假设规则为：如果一名学生评分比他左边学生高，那么他应该比他左边学生得到更多糖果。类似的，right2left 数组用来保存只与右边邻居有关的所需糖果数。也就是假设规则为：如果一名学生评分比他右边学生高，那么他应该比他右边学生得到更多糖果。</p><p>首先，在 left2right 和 right2left 中，给每个学生 1 个糖果。然后，从左向右遍历整个数组，只要当前学生评分比他左邻居高，就在 left2right 数组中更新当前学生的糖果数 left2right[i]&#x3D;left2right[i−1]+1，这是因为在每次更新前，当前学生的糖果数一定小于等于他左邻居的糖果数。然后用同样的方法从右到左更新 right2left 数组。</p><p>对于数组中第 i 个学生，为了满足题中条件，需要给他 max(left2right[i],right2left[i]) 个糖果。最后再将这些糖果数相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left2right</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right2left</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 更新与左边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])<br>                left2right[i]=left2right[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新与右边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                right2left[i]=right2left[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            <span class="hljs-comment">// 取最大值才满足条件</span><br>            sum+=<span class="hljs-built_in">max</span>(left2right[i],right2left[i]);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h3 id="思路二：用一个数组"><a href="#思路二：用一个数组" class="headerlink" title="思路二：用一个数组"></a>思路二：用一个数组</h3><p>本质上与思路一相同。思路一中用两个数组分别记录每一个学生与他左邻居和右邻居的关系，实际只用一个数组也可以，记录当前学生被分配的糖果数。从左向右遍历时与思路一相同，从右向左遍历时，同时更新需要分配的糖果数与已分配糖果数的最大值。最后再将这些糖果数相加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 更新与左边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])<br>                candies[i]=candies[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-comment">// 取最大值才满足条件</span><br>                candies[i]=<span class="hljs-built_in">max</span>(candies[i],candies[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            sum+=candies[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h3 id="思路三：不需要数组"><a href="#思路三：不需要数组" class="headerlink" title="思路三：不需要数组"></a>思路三：不需要数组</h3><p>首先给第一个同学一个糖果，那么对于接下来的一个同学就有三种情况：</p><ul><li>接下来的同学的 rating 等于前一个同学，那么给接下来的同学一个糖果就行。</li><li>接下来的同学的 rating 大于前一个同学，那么给接下来的同学的糖果数要比前一个同学糖果数加 1。</li><li>接下来的同学的 rating 小于前一个同学，那么此时不知道应该给这个同学多少个糖果，需要看后面的情况。</li></ul><p>对于第三种情况，不确定要给几个，因为要是只给 1 个的话，那么有可能接下来还有 rating 更小的同学，总不能一个都不给吧。也不能直接给前一个同学的糖果数减 1，有可能给多了，因为如果后面再没人了的话，其实只要给一个就行了。还有就是，如果后面好几个 rating 越来越小的同学，那么前一个同学的糖果数可能还得追加，以保证最后面的同学至少能有 1 个糖果。来一个例子吧，四个同学，他们的 rating 如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>先给第一个 rating 为 1 的同学一个糖果，然后从第二个同学开始遍历，第二个同学 rating 为3，比 1 大，所以多给一个糖果，第二个同学得到两个糖果。下面第三个同学，他的 rating 为 2，比前一个同学的 rating 小，如果此时给 1 个糖果的话，那么 rating 更小的第四个同学就得不到糖果了，所以要给第四个同学 1 个糖果，而给第三个同学 2 个糖果，此时要给第二个同学追加 1 个糖果，使其能够比第三个同学的糖果数多至少一个。那么就需要统计出有多少个连着的同学的 rating 变小，用变量 cnt 来记录，找出了最后一个减小的同学，那么就可以往前推，每往前一个加一个糖果，这就是个等差数列，可以直接利用求和公式算出这些 rating 减小的同学的糖果之和。然后还要看第一个开始减小的同学的前一个同学需不需要追加糖果，只要比较 cnt 和 pre 的大小，pre 是之前同学得到的最大糖果数，二者做差加 1 就是需要追加的糖果数，加到结果 res 中即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ratings.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">1</span>;<span class="hljs-comment">// 连续递减序列的最大值</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 连续递减序列的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ratings.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//当前是在上坡或者平坡</span><br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;=ratings[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                <span class="hljs-comment">// 之前出现过了下坡</span><br>                <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// previous - count - count - 1 - ... - 1</span><br>                    res+=cnt*(cnt+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(cnt&gt;=pre)<br>                        <span class="hljs-comment">// 连续递减序列的最大值应该为 count，将加少了的补上</span><br>                        res+=cnt-pre+<span class="hljs-number">1</span>;<br>                    cnt=<span class="hljs-number">0</span>;<br>                    pre=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// ratings[i] &lt;= ratings[i - 1]</span><br>                pre=(ratings[i]==ratings[i<span class="hljs-number">-1</span>])?<span class="hljs-number">1</span>:pre+<span class="hljs-number">1</span>;<br>                res+=pre;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 统计连续递减序列的长度</span><br>                ++cnt;<br>        &#125;<br>        <span class="hljs-comment">// 判断是否有下坡</span><br>        <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            res+=cnt*(cnt+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(cnt&gt;=pre)<br>                res+=cnt-pre+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Greedy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——HashMap</title>
    <link href="/2020/10/26/Leetcode%20Notes%E2%80%94%E2%80%94HashMap/"/>
    <url>/2020/10/26/Leetcode%20Notes%E2%80%94%E2%80%94HashMap/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>哈希表</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1. 两数之和[easy]"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a>[easy]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;nums.<span class="hljs-built_in">size</span>();++j)<br>            <span class="hljs-keyword">if</span>(nums[i]+nums[j]==target)<br>                <span class="hljs-keyword">return</span> &#123;i,j&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p><h2 id="解法二：哈希表-两次扫描"><a href="#解法二：哈希表-两次扫描" class="headerlink" title="解法二：哈希表+两次扫描"></a>解法二：哈希表+两次扫描</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<span class="hljs-comment">// &lt;值, 索引&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-comment">// 向map中添加元素 </span><br>            m[nums[i]]=i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//如果 m 中存在对应的键值，且不为 i</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target-nums[i])!=<span class="hljs-number">0</span>&amp;&amp;m[target-nums[i]]!=i)<br>                <span class="hljs-keyword">return</span> &#123;i,m[target-nums[i]]&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h2 id="解法三：哈希表-一次扫描"><a href="#解法三：哈希表-一次扫描" class="headerlink" title="解法三：哈希表+一次扫描"></a>解法三：哈希表+一次扫描</h2><p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<span class="hljs-comment">// &lt;值, 索引&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target-nums[i])!=<span class="hljs-number">0</span>)<br>                <span class="hljs-comment">//  m[target-nums[i]]为已经加入 map 的元素的索引，小于本轮循环中的 i，放在前面</span><br>                <span class="hljs-keyword">return</span> &#123;m[target-nums[i]],i&#125;;<br>            <span class="hljs-comment">//向map中添加元素</span><br>            m[nums[i]]=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h1 id="217-存在重复元素-easy"><a href="#217-存在重复元素-easy" class="headerlink" title="217. 存在重复元素[easy]"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a>[easy]</h1><h2 id="解法一：暴力法-1"><a href="#解法一：暴力法-1" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>使用两层循环，第一层循环遍历数组，第二层遍历第一层循环遍历到的元素后面的元素，两者比较，如果相等，则返回 true；否则，继续遍历。如果遍历完数组，也没有重复的数字，则返回 false。</p><p>代码超时！！！</p><p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p><h2 id="解法二：排序"><a href="#解法二：排序" class="headerlink" title="解法二：排序"></a>解法二：排序</h2><p>对数组进行排序，如果存在重复元素，排序后它们应该相邻。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><h2 id="解法三：哈希表"><a href="#解法三：哈希表" class="headerlink" title="解法三：哈希表"></a>解法三：哈希表</h2><p>使用<code>Set</code>保存第一次出现的数字，在遍历数组过程中，如果<code>Set</code>中已经有该数字，则返回 true。如果遍历完数组，也没有重复的数字，则返回 false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(nums[i])!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>简洁的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(nums.begin(),nums.end())</span></span>;<br>        <span class="hljs-comment">// 如果原数组的大小 != set的大小，则说明存在重复元素</span><br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>()!=nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h1 id="219-存在重复元素-II-easy"><a href="#219-存在重复元素-II-easy" class="headerlink" title="219. 存在重复元素 II[easy]"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">219. 存在重复元素 II</a>[easy]</h1><h2 id="解法一：hashmap"><a href="#解法一：hashmap" class="headerlink" title="解法一：hashmap"></a>解法一：hashmap</h2><p>利用 hashmap 存储数组值和索引，遍历数组，当 hashmap 中已该元素且索引差不超过 k 时返回 true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(nums[i])!=<span class="hljs-number">0</span>&amp;&amp;i-m[nums[i]]&lt;=k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            m[nums[i]]=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h2 id="解法二：滑动窗口-hashset"><a href="#解法二：滑动窗口-hashset" class="headerlink" title="解法二：滑动窗口+hashset"></a>解法二：滑动窗口+hashset</h2><p>维护一个 hashset，里面始终最多包含 k 个元素，当出现重复值时则说明在 k 距离内存在重复元素。每次遍历一个元素则将其加入 hashset 中，如果 hashset 的大小大于 k，则移除最前面的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(nums[i])!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;k)<br>                s.<span class="hljs-built_in">erase</span>(nums[i-k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(min(n,k))。</p><h1 id="220-存在重复元素-III-medium"><a href="#220-存在重复元素-III-medium" class="headerlink" title="220. 存在重复元素 III[medium]"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a>[medium]</h1><h2 id="解法一：暴力法-2"><a href="#解法一：暴力法-2" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>枚举所有长度小于等于 <code>k + 1</code> 的“下标对<code>（）</code>”，只要发现 <code>nums[i] - nums[j]</code> 的绝对值小于 <code>t</code> ，就返回 <code>true</code>。</p><p>以下代码超时！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsNearbyAlmostDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> a;<br>        <span class="hljs-type">long</span> b;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; len &amp;&amp; j &lt;= i + k; j++) &#123;<br>                a = nums[i];<br>                b = nums[j];<br>                <span class="hljs-keyword">if</span> (Math.abs(a - b) &lt;= t) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N^2)，空间复杂度 O(1)。</p><h2 id="解法二：滑动窗口-set"><a href="#解法二：滑动窗口-set" class="headerlink" title="解法二：滑动窗口+set"></a>解法二：滑动窗口+set</h2><p>以空间换时间，这里的空间还需要有比较大小的功能，比较容易想到的数据结构是二叉搜索树。这里采用<code>set</code>来维护滑动窗口，因为<code>set</code>底层是用红黑树实现的。</p><p>题目意思翻译一下：在数组 <code>nums[i]</code> 中，在任意有效区间 <code>[i, i + k]</code> 里是否存在两个数的绝对值小于等于 <code>t</code>，即 |nums[i] - nums[j] | &lt;&#x3D; t。等价于 nums[i] - nums[j] &lt;&#x3D; t 并且 nums[i] - nums[j] &gt;&#x3D; -t，整理得：nums[i] &lt;&#x3D; t + nums[j] 并且 nums[i] &gt;&#x3D; nums[j] - t。</p><p>于是算法可以在遍历的时候，把遍历到的数存到<code>set</code>中，边遍历边查找。</p><p>根据刚才得到式子 nums[i] &gt;&#x3D; nums[j] - t，假设当前遍历到的数是 nums[j]，nums[i] 就是 nums[j] - t 的天花板数（lower_bound），这个数同时还要小于等于 t + nums[j]。根据这一点写滑动窗口的代码。用 long 防止数值溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-comment">// 滑动窗口结合查找表，此时滑动窗口即为查找表本身（控制查找表的大小即可控制窗口大小）</span><br>        set&lt;<span class="hljs-type">long</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 边添加边查找</span><br>            <span class="hljs-comment">// 查找表中是否有大于等于 nums[i] - t 且小于等于 nums[i] + t 的值</span><br>            <span class="hljs-keyword">auto</span> it=s.<span class="hljs-built_in">lower_bound</span>((<span class="hljs-type">long</span>)nums[i]-(<span class="hljs-type">long</span>)t);<br>            <span class="hljs-keyword">if</span>(it!=s.<span class="hljs-built_in">end</span>()&amp;&amp;*it&lt;=(<span class="hljs-type">long</span>)nums[i]+(<span class="hljs-type">long</span>)t)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 添加后，控制查找表（窗口）大小，移除窗口最左边元素</span><br>            s.<span class="hljs-built_in">insert</span>((<span class="hljs-type">long</span>)nums[i]);<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&gt;k)<br>                s.<span class="hljs-built_in">erase</span>((<span class="hljs-type">long</span>)nums[i-k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlog(min(n,k))，空间复杂度 O(min(n,k))。</p><h2 id="解法三：桶排序"><a href="#解法三：桶排序" class="headerlink" title="解法三：桶排序"></a>解法三：桶排序</h2><p>使用桶排序的思想。首先还是滑动窗口的思想，一个窗口一个窗口考虑。不同之处在于，把窗口内的数字存在不同编号的桶中。每个桶内存的数字范围是 <code>t + 1</code>个数，这样做的好处是，桶内任意两个数之间的差一定是小于等于 <code>t</code> 的。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">t = 2, 每个桶内的数字范围如下<br>编号          <span class="hljs-string">...</span>     -2            -1             0           1      <span class="hljs-string">...</span>      <br>                  <span class="hljs-params">-------</span>        <span class="hljs-params">-------</span>       <span class="hljs-params">-------</span>     <span class="hljs-params">-------</span>     <br>桶内数字范围      | -6 ~ -4  |    | -3 ~ -1 |   | 0 ~ 2 |   | 3 ~ 5 |  <br>                  <span class="hljs-params">-------</span>        <span class="hljs-params">-------</span>       <span class="hljs-params">-------</span>     <span class="hljs-params">-------</span>   <br></code></pre></td></tr></table></figure><p>有了上边的桶，再结合滑动窗口就简单多了，举个例子。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">k = 3,  t = 2, 窗口内<span class="hljs-number"> 3 </span>个数用上边的桶存储, 当前考虑 x<br>2<span class="hljs-number"> 6 </span>3 x 5<br>^   ^<br>桶中的情况<br>    <span class="hljs-number"> 0 </span>           <span class="hljs-number"> 1 </span>             2<br>  -------        -------       -------    <br>|    <span class="hljs-number"> 2 </span> |      | <span class="hljs-number"> 3 </span>   |     |  <span class="hljs-number"> 6 </span>  |   <br>  -------        -------       -------     <br></code></pre></td></tr></table></figure><p>接下来我们只需要算出来 <code>x</code>在哪个桶中。如果 <code>x</code> 所在桶已经有数字了,那就说明存在和 <code>x</code> 相差小于等于<code>t</code>的数。如果 <code>x</code> 所在桶没有数字，因为与 <code>x</code>所在桶不相邻的桶中的数字与 <code>x</code> 的差一定大于 <code>t</code>，所以只需要考虑与 <code>x</code>所在桶相邻的两个桶中的数字与 <code>x</code>的差是否小于等于 <code>t</code>。如果没有找到和 <code>x</code> 相差小于等于 <code>t</code>的数, 那么窗口右移，从桶中将窗口中第一个数删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;       <br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()||t&lt;<span class="hljs-number">0</span>||k&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        unordered_map&lt;<span class="hljs-type">long</span>,<span class="hljs-type">long</span>&gt; m;<br>        <span class="hljs-type">long</span> bucketSize=(<span class="hljs-type">long</span>)t+<span class="hljs-number">1</span>; <span class="hljs-comment">// 一个桶里边数字范围的个数是 t + 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 得到当前数的桶编号</span><br>            <span class="hljs-type">long</span> id=<span class="hljs-built_in">getBuckerId</span>(nums[i],bucketSize);<br>            <span class="hljs-comment">// 如果桶内已经有元素，则这两个数字肯定符合条件</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(id)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 检查与相邻桶内元素是否满足条件</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(id+<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">abs</span>(nums[i]-m[id+<span class="hljs-number">1</span>])&lt;=t)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(id<span class="hljs-number">-1</span>)!=<span class="hljs-number">0</span>&amp;&amp;<span class="hljs-built_in">abs</span>(nums[i]-m[id<span class="hljs-number">-1</span>])&lt;=t)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            m[id]=nums[i];<br>            <span class="hljs-comment">// 删除窗口中第一个数字</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">size</span>()&gt;k)<br>                m.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getBuckerId</span>(nums[i-k],bucketSize));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 求出一个数所在桶的编号</span><br>    <span class="hljs-comment">// -3 / 5 = 0 但是需要 -3 / 5 = -1</span><br>    <span class="hljs-comment">// num 加 1, 把负数移动到从 0 开始, 这样算出来标号最小是 0, 已经用过了, 所以要再减 1</span><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getBuckerId</span><span class="hljs-params">(<span class="hljs-type">long</span> value,<span class="hljs-type">long</span> bucketSize)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> value&gt;=<span class="hljs-number">0</span>?value/bucketSize:(value+<span class="hljs-number">1</span>)/bucketSize<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(min(n, k))。</p><h1 id="594-最长和谐子序列-easy"><a href="#594-最长和谐子序列-easy" class="headerlink" title="594. 最长和谐子序列[easy]"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a>[easy]</h1><h2 id="解法一：暴力法-3"><a href="#解法一：暴力法-3" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>枚举数组中的每一个元素，对于当前枚举的元素 <code>x</code>，它可以和 <code>x + 1</code> 组成和谐子序列。再遍历一遍整个数组，找出等于 <code>x</code> 或 <code>x + 1</code> 的元素个数，就可以得到以 <code>x</code> 为最小值的和谐子序列的长度。</p><p>cpp代码超时，java不超时！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findLHS</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] == nums[i])<br>                    count++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j]== nums[i]+<span class="hljs-number">1</span>) &#123;<br>                    count++;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)<br>                res = Math.max(count, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N^2)，空间复杂度 O(1)。</p><h2 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>用一个 HashMap 来存储每个数出现的次数。先遍历一遍数组，得到哈希映射，随后遍历哈希映射，设当前遍历到的键值对为 <code>(x, value)</code>，那么就查询 <code>x + 1</code> 在哈希映射中对应的值，就得到了 <code>x</code> 和 <code>x + 1</code> 出现的次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            m[num]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> kv:m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(kv.first+<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)<br>                res=<span class="hljs-built_in">max</span>(res,m[kv.first]+m[kv.first+<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h3 id="思路二：单次扫描"><a href="#思路二：单次扫描" class="headerlink" title="思路二：单次扫描"></a>思路二：单次扫描</h3><p>扫描一次数组，当扫描到元素<code>x</code>时，首先将<code>x</code>加入哈希映射，随后获取哈希映射中 <code>x - 1, x, x + 1</code>三者出现的次数 <code>u, v, w</code>，那么 <code>u + v</code> 即为 <code>x - 1, x</code>组成的和谐子序列的长度，<code>v + w</code> 即为 <code>x, x + 1</code>组成的和谐子序列的长度。假设数组中最长的和谐子序列的最后一个元素在数组中的位置为 <code>i</code>，那么在扫描到 <code>nums[i]</code>时，<code>u + v</code> 和 <code>v + w</code>中一定有一个就是答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            m[num]++;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num+<span class="hljs-number">1</span>))<br>                res=<span class="hljs-built_in">max</span>(res,m[num]+m[num+<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num<span class="hljs-number">-1</span>))<br>                res=<span class="hljs-built_in">max</span>(res,m[num]+m[num<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h1 id="128-最长连续序列-hard"><a href="#128-最长连续序列-hard" class="headerlink" title="128. 最长连续序列[hard]"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a>[hard]</h1><h2 id="解法一：排序"><a href="#解法一：排序" class="headerlink" title="解法一：排序"></a>解法一：排序</h2><p>先将数组排序，然后遍历数组，比较相邻的两项，如果相同，则跳过，继续遍历下一项。如果 当前项+1 等于下一项，说明遇到连续项，count++。否则，说明连续情况发生中断，将  count 重置为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>,count=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 相同就跳过本次循环</span><br>            <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>]==nums[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 发现连续项 count++</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>]==nums[i]+<span class="hljs-number">1</span>)<br>                count++;<br>            <span class="hljs-comment">// 否则，count重置1</span><br>            <span class="hljs-keyword">else</span><br>                count=<span class="hljs-number">1</span>;<br>            res=<span class="hljs-built_in">max</span>(res,count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><h2 id="解法二：hashset"><a href="#解法二：hashset" class="headerlink" title="解法二：hashset"></a>解法二：hashset</h2><p>查找 hashset 中的元素的时间复杂度是 O(1)，且 hashset 能给数组去掉重复元素。将数组元素存入 hashset 中。遍历数组 nums，</p><ul><li>如果当前项 - 1 存在于 hashset 中，说明当前项不是连续序列的起点，跳过，继续遍历。</li><li>如果当前项没有”左邻居”，它就是连续序列的起点，则不断在 hashset 中查看 cur+1 是否存在，存在，则 count++。当 cur 不再有”右邻居”了，就算出了一段连续序列的长度。</li></ul><p>用 long 防止数值溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        unordered_set&lt;<span class="hljs-type">long</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            <span class="hljs-comment">// 如果有比自己小一点的，那自己不查，让小的去查</span><br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>((<span class="hljs-type">long</span>)num<span class="hljs-number">-1</span>)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">long</span> cur=num;<br>            <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// cur 有右邻居 cur+1</span><br>            <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">count</span>(cur+<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)<br>            &#123;<br>                cur++;<span class="hljs-comment">// 更新cur</span><br>                count++;<br>            &#125;<br>            <span class="hljs-comment">// cur不再有右邻居，检查 count 是否最大</span><br>            res=<span class="hljs-built_in">max</span>(res,count);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，虽 <code>for</code> 内有 <code>while</code>，但每个元素最多被查<code>2</code>次。空间复杂度 O(n)。</p><h2 id="解法三：hashmap-动态规划"><a href="#解法三：hashmap-动态规划" class="headerlink" title="解法三：hashmap+动态规划"></a>解法三：hashmap+动态规划</h2><p>用哈希表存储每个端点值对应连续区间的长度</p><ul><li>若数已在哈希表中：跳过不做处理</li><li>若是新数加入：<ul><li>取出其左右相邻数已有的连续区间长度 left 和 right；</li><li>计算当前数的区间长度为：<code>cur = left + right + 1</code>；</li><li>根据 cur 更新最大长度 max 的值；</li><li>更新区间两端点的长度值。</li></ul></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210920.png" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">long</span>,<span class="hljs-type">long</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            <span class="hljs-comment">// 重复的数字不考察，跳过</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num)==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 获取左邻居所在序列的长度 </span><br>                <span class="hljs-type">int</span> left=m.<span class="hljs-built_in">count</span>((<span class="hljs-type">long</span>)num<span class="hljs-number">-1</span>)?m[num<span class="hljs-number">-1</span>]:<span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 获取右邻居所在序列的长度</span><br>                <span class="hljs-type">int</span> right=m.<span class="hljs-built_in">count</span>((<span class="hljs-type">long</span>)num+<span class="hljs-number">1</span>)?m[num+<span class="hljs-number">1</span>]:<span class="hljs-number">0</span>;<br>                <span class="hljs-comment">// 新序列的长度</span><br>                <span class="hljs-type">int</span> cur=left+<span class="hljs-number">1</span>+right;<br>                <span class="hljs-comment">// 将自己存入 map</span><br>                m[num]=cur;<br>                <span class="hljs-comment">// 和 max 比较，试图刷新 max</span><br>                res=<span class="hljs-built_in">max</span>(res,cur);<br>                <span class="hljs-comment">// 只需更新新序列两端的值，因为两端的值可能继续延伸，而中间值对最大长度没有影响</span><br>                <span class="hljs-comment">// 更新新序列的左端数字的 value</span><br>                m[num-left]=cur;<br>                <span class="hljs-comment">// 更新新序列的右端数字的 value</span><br>                m[num+right]=cur;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p><h2 id="解法四：并查集"><a href="#解法四：并查集" class="headerlink" title="解法四：并查集"></a>解法四：并查集</h2><ul><li>将连续的数字作为一个集合，初始时所有元素都各自为集合。</li><li>遍历数组，扫描到一个数字，只要将它和它的下一个数字（假如存在）合并到一个集合即可。同时更新这个集合的元素个数。</li><li>遍历 sizeMap，更新最大的集合。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">long</span>,<span class="hljs-type">long</span>&gt; findMap; <span class="hljs-comment">//&lt;son,father&gt;</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; sizeMap; <span class="hljs-comment">//&lt;father,size&gt;</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(vector&lt;<span class="hljs-type">int</span>&gt; nums)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            findMap[num]=(<span class="hljs-type">long</span>)num;<br>            sizeMap[num]=<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 带路径优化的查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> son)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> father=findMap[son];<br>        <span class="hljs-keyword">while</span>(father!=son)<br>        &#123;<br>            son=father;<br>            father=findMap[son];<br>        &#125;<br>        findMap[son]=father;<br>        <span class="hljs-keyword">return</span> father;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br>        <span class="hljs-type">int</span> father1=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> father2=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(father1!=father2)<br>        &#123;<br>            <span class="hljs-type">int</span> size1=sizeMap[father1];<br>            <span class="hljs-type">int</span> size2=sizeMap[father2];<br>            <span class="hljs-comment">// 按秩合并，将深度小的合并到深度大的上去</span><br>            <span class="hljs-keyword">if</span>(size1&lt;size2)<br>            &#123;<br>                findMap[father1]=father2;<br>                sizeMap[father2]=size1+size2;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                findMap[father2]=father1;<br>                sizeMap[father1]=size1+size2;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(nums)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:nums)&#123;<br>            <span class="hljs-keyword">if</span>(uf.findMap.<span class="hljs-built_in">count</span>((<span class="hljs-type">long</span>)num+<span class="hljs-number">1</span>)!=<span class="hljs-number">0</span>)<br>                uf.<span class="hljs-built_in">merge</span>(num,num+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:uf.sizeMap)<br>            res = <span class="hljs-built_in">max</span>(res,elem.second);<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Sliding Window</title>
    <link href="/2020/10/13/Leetcode%20Notes%E2%80%94%E2%80%94Sliding%20Window/"/>
    <url>/2020/10/13/Leetcode%20Notes%E2%80%94%E2%80%94Sliding%20Window/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>滑动窗口</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解，<a href="https://www.geekxh.com/">小浩算法</a> 题解，<a href="https://github.com/grandyang/leetcode">grandyang</a> 题解。</p><span id="more"></span><h1 id="滑动窗口介绍"><a href="#滑动窗口介绍" class="headerlink" title="滑动窗口介绍"></a>滑动窗口介绍</h1><p>对于大部分滑动窗口类型的题目，一般是<strong>考察字符串的匹配</strong>。比较标准的题目，会给出一个模式串 B，以及一个目标串 A。然后提出问题，找到 <strong>A 中符合对 B 一些限定规则的子串或者对 A 一些限定规则的结果，最终再将搜索出的子串完成题意中要求的组合或者其他</strong>。</p><p>比如：</p><ul><li>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</li><li>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。</li><li>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</li></ul><p>都是属于这一类的标准题型。而对于这一类题目，常用的解题思路，<strong>是去维护一个可变长度的滑动窗口</strong>。无论是使用<strong>双指针</strong>，还是使用<strong>双端队列</strong>，又或者用<strong>游标</strong>等其他奇技淫巧，目的都是一样的。</p><h1 id="3-无重复字符的最长子串-medium"><a href="#3-无重复字符的最长子串-medium" class="headerlink" title="3. 无重复字符的最长子串[medium]"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a>[medium]</h1><h2 id="解法：滑动窗口"><a href="#解法：滑动窗口" class="headerlink" title="解法：滑动窗口"></a>解法：滑动窗口</h2><p>只需要维护一个窗口在输入字符串中进行移动。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201013121511.jpg" style="zoom: 80%;" /><p>当下一个元素在窗口没有出现过时，扩大窗口：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201013121556.jpg" style="zoom:80%;" /><p>当下一个元素在窗口中出现过时，缩小窗口，将<strong>出现过的元素以及其左边的元素</strong>统统移出：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201013121706.jpg" style="zoom:80%;" /><p>在整个过程中，<strong>记录下窗口出现过的最大值</strong>即可。而唯一要做的，只需要<strong>尽可能扩大窗口</strong>。</p><p>那代码中通过什么来维护这样的一个窗口呢？anyway~ 不管是队列，双指针，甚至通过 map 来做，都可以。</p><h3 id="双指针做法"><a href="#双指针做法" class="headerlink" title="双指针做法"></a>双指针做法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; lookup;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;len&amp;&amp;j&lt;len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(lookup.<span class="hljs-built_in">count</span>(s[j])==<span class="hljs-number">0</span>)<br>            &#123;<br>                lookup.<span class="hljs-built_in">insert</span>(s[j]);<br>                j++;<br>                res=<span class="hljs-built_in">max</span>(res,j-i);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                lookup.<span class="hljs-built_in">erase</span>(s[i]);<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最坏情况下，双指针做法每一个字符都可能会访问两次，right一次，left一次，时间复杂度达到了 O(2N)。假设字符串为“abcdc”，对于 abc 都访问了 2 次。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201013122443.jpg" style="zoom:80%;" /><h3 id="利用-hashmap-进行优化"><a href="#利用-hashmap-进行优化" class="headerlink" title="利用 hashmap 进行优化"></a>利用 hashmap 进行优化</h3><p>可以定义<strong>字符到索引的映射</strong>，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复。而不是简单通过一个集合来判断字符是否存在。这样的话，当找到重复的字符时，更新 left ,<strong>可以立即跳过该窗口</strong>，而不需要对之前的元素进行再次访问。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201013122943.jpg" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; lookup;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;      <br>        <span class="hljs-keyword">while</span>(right&lt;len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(lookup.<span class="hljs-built_in">count</span>(s[right])!=<span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// max 保证 left 不会左移</span><br>                left=<span class="hljs-built_in">max</span>(lookup[s[right]],left);<br>            res=<span class="hljs-built_in">max</span>(res,right-left+<span class="hljs-number">1</span>);<br>            lookup[s[right]]=right+<span class="hljs-number">1</span>;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用固定大小数组替代-hashmap-进一步优化"><a href="#用固定大小数组替代-hashmap-进一步优化" class="headerlink" title="用固定大小数组替代 hashmap 进一步优化"></a>用固定大小数组替代 hashmap 进一步优化</h3><p>使用一个 128 位的数组（ASCII 码表里的<strong>字符</strong>总共有 128 个）来替代 hashmap，以进行优化。字符的 ASCII 码值作为数组的下标，数组存储该字符所在字符串的位置。因为已知了待访问数据的下标，可以<strong>直接寻址</strong>，所以极大的缩短了查询时间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-number">128</span>)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;      <br>        <span class="hljs-keyword">while</span>(right&lt;len)<br>        &#123;<br>            left=<span class="hljs-built_in">max</span>(lookup[s[right]],left);<br>            res=<span class="hljs-built_in">max</span>(res,right-left+<span class="hljs-number">1</span>);<br>            lookup[s[right]]=right+<span class="hljs-number">1</span>;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="30-串联所有单词的子串-hard"><a href="#30-串联所有单词的子串-hard" class="headerlink" title="30. 串联所有单词的子串[hard]"></a><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a>[hard]</h1><h2 id="解法一：哈希表-固定长度的滑动窗口"><a href="#解法一：哈希表-固定长度的滑动窗口" class="headerlink" title="解法一：哈希表 + 固定长度的滑动窗口"></a>解法一：哈希表 + 固定长度的滑动窗口</h2><p>使用一个固定长度（单词长度 * 单词个数）的滑动窗口在<code>s</code>上滑动，判断每个子串是否符合，符合就把下标保存起来，最后返回。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201014211306.jpeg" style="zoom:67%;" /><p>怎么判断子串是否符合？由于子串包含的单词顺序并不需要固定，如果是两个单词 A，B，只需要判断子串是否是 AB 或者 BA 即可。如果更多单词呢？</p><p>策略是利用两个 HashMap 来解决，先把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（给出的单词可能有重复的）。然后扫描子串的单词，如果当前扫描的单词未出现过，即不在 HashMap 中，则当前子串不符合要求，直接判断下一个字串；如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是要找的，接着判断下一个子串。如果不大于，那么接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是要找的其中一个。看下具体的例子。</p><p>把 words 存到一个 HashMap 中。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201014212456.jpeg" style="zoom:67%;" /><p>然后遍历子串的每个单词。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201014212522.jpeg" style="zoom:67%;" /><p>第一个单词在 HashMap1 中，把 foo 存到 HashMap2 中。并且比较此时 foo 的 value 和 HashMap1 中 foo 的 value，1 &lt; 2，所以继续扫描。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201014212619.jpeg" style="zoom:67%;" /><p>第二个单词也在 HashMap1 中，把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 2 ，比较此时 foo 的 value 和 HashMap1 中 foo 的 value，2 &lt;&#x3D; 2，所以继续扫描下一个单词。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201014212703.jpeg" style="zoom:67%;" /><p>第三个单词也在 HashMap1 中，把 foo 存到 HashMap2 中，因为之前已经存过了，所以更新它的 value 为 3，比较此时 foo 的 value 和 HashMap1 中 foo 的 value，3 &gt; 2，表明该字符串不符合。然后判断下个子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||words.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> wordLength=words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> totalWordsLength=wordLength*words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;totalWordsLength)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// HashMap1 存所有单词</span><br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; wordMap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;word:words)<br>            wordMap[word]++;<br>        <span class="hljs-comment">// 遍历所有子串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>()-totalWordsLength+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> start=i;<br>            <span class="hljs-type">int</span> end=i+totalWordsLength;<br>            <span class="hljs-comment">// HashMap2 存当前扫描的字符串含有的单词</span><br>            unordered_map&lt;string,<span class="hljs-type">int</span>&gt; tmpMap;<br>            <span class="hljs-comment">// 判断该子串是否符合</span><br>            <span class="hljs-keyword">while</span>(start&lt;end)<br>            &#123;<br>                <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s.begin()+start,s.begin()+start+wordLength)</span></span>;<br>                <span class="hljs-comment">// 判断该单词是否在 HashMap1 中</span><br>                <span class="hljs-keyword">if</span>(wordMap.<span class="hljs-built_in">count</span>(tmp)==<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                tmpMap[tmp]++;<br>                <span class="hljs-comment">// 判断当前单词的 value 和 HashMap1 中该单词的 value</span><br>                <span class="hljs-keyword">if</span>(tmpMap[tmp]&gt;wordMap[tmp])<br>                    <span class="hljs-keyword">break</span>;<br>                start+=wordLength;<br>            &#125;<br>            <span class="hljs-comment">// 判断是不是所有的单词都符合条件</span><br>            <span class="hljs-keyword">if</span>(start==end)<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：假设 s 的长度是 n，words 里有 m 个单词，那么时间复杂度就是 O(n * m)。</li><li>空间复杂度：两个 HashMap，假设 words 里有 m 个单词，就是 O(m)。</li></ul><h2 id="解法二：哈希表-动态长度的滑动窗口"><a href="#解法二：哈希表-动态长度的滑动窗口" class="headerlink" title="解法二：哈希表 + 动态长度的滑动窗口"></a>解法二：哈希表 + 动态长度的滑动窗口</h2><p>解法二不再是一个字符一个字符的遍历，而是一个词一个词的遍历，比如根据题目中的例子：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201016153032.png"></p><p>字符串 s 的长度 n 为 18，words 数组中有两个单词 (wordNum&#x3D;2)，每个单词的长度 wordLength 均为3，那么遍历的顺序为 :</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0，3，6，9</span>，<span class="hljs-number">12</span>，<span class="hljs-number">15</span>，<br>然后偏移一个字符 <br><span class="hljs-number">1，4，7，10</span>，<span class="hljs-number">13</span>，<span class="hljs-number">16</span>，<br>然后再偏移一个字符 <br><span class="hljs-number">2，5，8，11</span>，<span class="hljs-number">14</span>，<span class="hljs-number">17</span>，<br></code></pre></td></tr></table></figure><p>这样就可以把所有情况都遍历到。</p><p>还是先用一个 HashMap (wordMap)来记录 words 里的所有词，然后从 0 开始遍历，用 left 来记录左边界的位置，count 表示当前已经匹配的单词的个数。然后一个单词一个单词的遍历，</p><ul><li><p>如果当前遍历的单词 tmp 在 wordMap 中存在，那么将其加入另一个 HashMap (tmpMap) 中，</p><ul><li><p>如果在 tmpMap 中个数小于等于 wordMap 中的个数，那么 count 自增 1；</p></li><li><p>如果大于了，则需要做一些处理，比如下面这种情况：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">s = <span class="hljs-keyword">barfoofoo,</span><br><span class="hljs-keyword"></span>words = &#123;<span class="hljs-keyword">bar, </span>foo, abc&#125;,<br>(给 words 中新加了一个 abc ，目的是为了遍历到 <span class="hljs-keyword">barfoo </span>不会停止)<br></code></pre></td></tr></table></figure><p>当遍历到第二个 foo 的时候, tmpMap [foo]&#x3D;2, 而此时 wordMap[foo]&#x3D;1，这时候已经不连续了，所以要移动左边界 left 的位置，先把第一个词 tmpFirst&#x3D;bar 取出来，然后将 tmpMap[tmpFirst] 自减1，如果此时 tmpMap[tmpFirst]&lt;wordMap[tmpFirst] 了，说明一个匹配没了，那么对应的 count 也要自减1，然后左边界加上个 wordLength ，这样就可以了。</p></li><li><p>如果某个时刻 count 和 wordNum 相等了，说明成功匹配了一个位置，将当前左边界 left 存入结果 res 中，此时去掉最左边的一个词，同时 count 自减 1，左边界右移 wordLength ，继续匹配。</p></li></ul></li><li><p>如果匹配到一个不在 wordMap 中的词，说明跟前面已经断开了，重置 tmpMap ，count 为 0，左边界 left 移到 右边界，即 j+wordLength。比如这种情况，</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201016153043.jpg" style="zoom:67%;" /><p>判断 i &#x3D; 0 的子串的时候，出现了 the ，并不在所给的单词中，所以此时 i &#x3D; 3，i &#x3D; 6 的子串都不需要判断了。直接判断 i &#x3D; 9 的情况就可以了。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSubstring</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||words.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> wordLength=words[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> wordNum=words.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; wordMap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;word:words)<br>            wordMap[word]++;<br>        <span class="hljs-comment">// 遍历所有子串组合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;wordLength;++i)<br>        &#123;<br>            unordered_map&lt;string,<span class="hljs-type">int</span>&gt; tmpMap;<br>            <span class="hljs-type">int</span> left=i,count=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;s.<span class="hljs-built_in">size</span>()-wordLength+<span class="hljs-number">1</span>;j+=wordLength)<br>            &#123;<br>                string tmp=s.<span class="hljs-built_in">substr</span>(j,wordLength);<br>                <span class="hljs-comment">// 一个有效的单词，积累结果</span><br>                <span class="hljs-keyword">if</span>(wordMap.<span class="hljs-built_in">count</span>(tmp)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    tmpMap[tmp]++;<br>                    <span class="hljs-keyword">if</span>(tmpMap[tmp]&lt;=wordMap[tmp])<br>                        count++;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">// 次数太大了，移动滑动窗口的左边界（右边界不动）</span><br>                        <span class="hljs-keyword">while</span>(tmpMap[tmp]&gt;wordMap[tmp])<br>                        &#123;<br>                            string tmpFirst=s.<span class="hljs-built_in">substr</span>(left,wordLength);<br>                            tmpMap[tmpFirst]--;<br>                            <span class="hljs-keyword">if</span>(tmpMap[tmpFirst]&lt;wordMap[tmpFirst])<br>                                count--;<br>                            left+=wordLength;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">// 得到一个匹配结果</span><br>                    <span class="hljs-keyword">if</span>(count==wordNum)<br>                    &#123;<br>                        res.<span class="hljs-built_in">push_back</span>(left);<br> <span class="hljs-comment">// 前进一个单词</span><br>                        tmpMap[s.<span class="hljs-built_in">substr</span>(left,wordLength)]--;<br>                        count--;<br>                        left+=wordLength;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 不是一个有效的单词，重置所有变量，并且移动滑动窗口的左边界到右边界</span><br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    tmpMap.<span class="hljs-built_in">clear</span>();<br>                    count=<span class="hljs-number">0</span>;<br>                    left=j+wordLength;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：判断子串是否符合，本质上也就是判断每个单词符不符合，假设 s 的长度是 n，那么就会大约有 n 个子串，也就是会有 n 个单词。而对于每个单词，只有刚开始判断符不符合的时候访问一次，还有就是把它移除的时候访问一次，所以每个单词最多访问 2 次，所以时间复杂度是 O(n)。</li><li>空间复杂度：两个 HashMap，假设 words 里有 m 个单词，就是 O(m)。</li></ul><h1 id="76-最小覆盖子串-hard"><a href="#76-最小覆盖子串-hard" class="headerlink" title="76. 最小覆盖子串[hard]"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a>[hard]</h1><h2 id="解法：滑动窗口-1"><a href="#解法：滑动窗口-1" class="headerlink" title="解法：滑动窗口"></a>解法：滑动窗口</h2><h3 id="利用-hashmap"><a href="#利用-hashmap" class="headerlink" title="利用 hashmap"></a>利用 hashmap</h3><p>先统计 T 串中字母的个数，然后开始遍历 S 串，对于 S 中的每个遍历到的字母，都在 HashMap 中的映射值减 1，如果减 1 后的映射值仍大于等于 0，说明当前遍历到的字母是 T 串中的字母，使用一个计数器 cnt，使其自增 1。当 cnt 和 T 串字母个数相等时，说明此时的窗口已经包含了 T 串中的所有字母，此时更新一个 minLen 和结果 res，这里的 minLen 是一个全局变量，用来记录出现过的包含 T 串所有字母的最短的子串的长度，结果 res 就是这个最短的子串。然后开始收缩左边界，由于遍历的时候，对映射值减了 1，所以此时去除字母的时候，就要把减去的 1 加回来，此时如果加 1 后的值大于 0 了，说明此时少了一个 T 中的字母，那么 cnt 值就要减 1 了，然后移动左边界 left。你可能会疑问，对于不在 T 串中的字母的映射值也这么加呀减呀的，真的没问题吗？其实没啥事，因为对于不在 T 串中的字母，减 1 后，变 -1，cnt 不会增加，之后收缩左边界的时候，映射值加 1 后为 0，cnt 也不会减少，所以并没有什么影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; letterMap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:t)<br>            letterMap[c]++;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minLength=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;s.<span class="hljs-built_in">size</span>();++right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(--letterMap[s[right]]&gt;=<span class="hljs-number">0</span>)<br>                count++;<br>            <span class="hljs-keyword">while</span>(count==t.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&lt;minLength)<br>                &#123;<br>                    minLength=right-left+<span class="hljs-number">1</span>;<br>                    res=s.<span class="hljs-built_in">substr</span>(left,minLength);<br>                &#125;  <br>                <span class="hljs-keyword">if</span>(++letterMap[s[left]]&gt;<span class="hljs-number">0</span>)<br>                    count--;<br>                ++left;<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="用固定大小数组替代-hashmap-进行优化"><a href="#用固定大小数组替代-hashmap-进行优化" class="headerlink" title="用固定大小数组替代 hashmap 进行优化"></a>用固定大小数组替代 hashmap 进行优化</h3><p>这道题也可以不用 HashMap，直接用 int 数组来代替，因为 ASCII 只有256个字符，所以用大小为 256 的 int 数组即可代替 HashMap，但由于一般输入字母串的字符只有 128 个，所以也可以只用 128，其余部分思路完全相同，虽然只改了一个数据结构，但是运行速度提高了。</p><p>此外，还可以进一步的优化，没有必要每次都计算子串，只要有了起始位置和长度，就能唯一的确定一个子串。这里使用一个全局变量 minLeft 来记录最终结果子串的起始位置，初始化为 -1，最终配合上 minLen，就可以得到最终结果了。注意在返回的时候要检测一下若 minLeft 仍为初始值 -1，需返回空串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">letterMap</span><span class="hljs-params">(<span class="hljs-number">128</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:t)<br>            letterMap[c]++;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minLeft=<span class="hljs-number">-1</span>,minLength=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;s.<span class="hljs-built_in">size</span>();++right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(--letterMap[s[right]]&gt;=<span class="hljs-number">0</span>)<br>                count++;<br>            <span class="hljs-keyword">while</span>(count==t.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&lt;minLength)<br>                &#123;<br>                    minLength=right-left+<span class="hljs-number">1</span>;<br>                    minLeft=left;<br>                &#125;  <br>                <span class="hljs-keyword">if</span>(++letterMap[s[left]]&gt;<span class="hljs-number">0</span>)<br>                    count--;<br>                ++left;<br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> minLeft==<span class="hljs-number">-1</span>?<span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(minLeft,minLength);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="438-找到字符串中所有字母异位词-medium"><a href="#438-找到字符串中所有字母异位词-medium" class="headerlink" title="438. 找到字符串中所有字母异位词[medium]"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a>[medium]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>统计字符串<code>p</code>中字符出现的次数，然后从<code>s</code>的开头开始，每次找<code>p</code>字符串长度个字符，来验证字符个数是否相同，如果不相同出现了直接 break，如果一直都相同了，则将起始位置加入结果<code>res</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||p.<span class="hljs-built_in">empty</span>()||s.<span class="hljs-built_in">size</span>()&lt;p.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();++i)<br>            ++cnt[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>()-p.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(cnt)</span></span>;<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;i+p.<span class="hljs-built_in">size</span>();++j)<br>            &#123;                <br>                <span class="hljs-keyword">if</span>(--tmp[s[j]-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(mn)，<code>m</code>表示<code>s</code>的长度，<code>n</code>表示<code>p</code>的长度。</p><h2 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>使用两个哈希表，一个记录<code>p</code>中每个字母出现的次数，一个记录滑动窗口中字母的出现次数。如果两个哈希表相等，则将起始位置加入结果<code>res</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||p.<span class="hljs-built_in">empty</span>()||s.<span class="hljs-built_in">size</span>()&lt;p.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pcnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">scnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++pcnt[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++scnt[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pcnt==scnt)<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;s.<span class="hljs-built_in">size</span>()-p.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 移动固定长度（p.size()）的滑动窗口</span><br>            ++scnt[s[i+p.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            --scnt[s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(pcnt==scnt)<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(m - n)，<code>m</code>表示<code>s</code>的长度，<code>n</code>表示<code>p</code>的长度。</p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路与 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a> 相似。</p><p>首先统计字符串 p 的字符个数，然后用两个变量 left 和 right 表示滑动窗口的左右边界，用变量 cnt 表示字符串 p 中需要匹配的字符个数，然后开始循环，如果右边界的字符已经在哈希表中了，说明该字符在 p 中有出现，则 cnt 自减 1，然后哈希表中该字符个数自减 1，右边界自加 1，如果此时 cnt 减为 0 了，说明 p 中的字符都匹配上了，那么将此时左边界加入结果 res 中。如果此时 right 和 left 的差为 p 的长度，说明此时应该去掉最左边的一个字符，如果该字符在哈希表中的个数大于等于 0，说明该字符是 p 中的字符，为啥呢，因为上面有让每个字符自减 1，如果不是 p 中的字符，那么在哈希表中个数应该为 0，自减 1 后就为 -1，所以这样就知道该字符是否属于p，如果去掉了属于 p 的一个字符，cnt 自增 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()||p.<span class="hljs-built_in">empty</span>()||s.<span class="hljs-built_in">size</span>()&lt;p.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pcnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();++i)<br>            ++pcnt[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt=p.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(right&lt;s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pcnt[s[right++]-<span class="hljs-string">&#x27;a&#x27;</span>]--&gt;<span class="hljs-number">0</span>)<br>                --cnt;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(left);<br>            <span class="hljs-keyword">if</span>(right-left==p.<span class="hljs-built_in">size</span>()&amp;&amp;pcnt[s[left++]-<span class="hljs-string">&#x27;a&#x27;</span>]++&gt;=<span class="hljs-number">0</span>)<br>                ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(m)，<code>m</code>表示<code>s</code>的长度。</p><h1 id="567-字符串的排列-medium"><a href="#567-字符串的排列-medium" class="headerlink" title="567. 字符串的排列[medium]"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a>[medium]</h1><h2 id="解法一：哈希表-1"><a href="#解法一：哈希表-1" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>思路与 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 解法一相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;s2.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();++i)<br>            ++cnt[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s2.<span class="hljs-built_in">size</span>()-s1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tmp</span><span class="hljs-params">(cnt)</span></span>;<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;i+s1.<span class="hljs-built_in">size</span>();++j)<br>            &#123;                <br>                <span class="hljs-keyword">if</span>(--tmp[s2[j]-<span class="hljs-string">&#x27;a&#x27;</span>]&lt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：滑动窗口-1"><a href="#解法二：滑动窗口-1" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h2><h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><p>思路与 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 解法二思路一相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;s2.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt1</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt2</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++cnt1[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            ++cnt2[s2[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt1==cnt2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;s2.<span class="hljs-built_in">size</span>()-s1.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            ++cnt2[s2[i+s1.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            --cnt2[s2[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(cnt1==cnt2)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h3><p>思路与 <a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a> 解法二思路二相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;s2.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt1</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();++i)<br>            ++cnt1[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt=s1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(right&lt;s2.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt1[s2[right++]-<span class="hljs-string">&#x27;a&#x27;</span>]--&gt;<span class="hljs-number">0</span>)<br>                --cnt;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(right-left==s1.<span class="hljs-built_in">size</span>()&amp;&amp;cnt1[s2[left++]-<span class="hljs-string">&#x27;a&#x27;</span>]++&gt;=<span class="hljs-number">0</span>)<br>                ++cnt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>用哈希表记录窗口中各个字符出现次数的差值：</p><ul><li>正数表示还应该出现几次</li><li>0 表示正好</li><li>负数表示多出现了几次</li></ul><p>统计 s1 中字符的出现次数，然后遍历 s2 中的字符，对于每个遍历到的字符，在哈希表中对应的字符次数减 1，如果次数小于 0 了，说明该字符在 s1 中不曾出现，或是出现的次数超过了s1 中的对应的字符出现次数，那么此时移动滑动窗口的左边界，对于移除的字符串，哈希表中对应的次数要加 1，如果此时次数不为 0，说明该字符不在 s1 中，继续向右移，直到更新后的次数为 0 停止，此时到达的字符是在 s1中的。如果次数大于等于 0 了，看此时窗口大小是否为 s1 的长度，若二者相等，由于此时窗口中的字符都是在 s1 中存在的字符，而且对应的次数都为 0 了，说明窗口中的字符串和 s1 互为全排列，返回 true 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">size</span>()&gt;s2.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt1</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s1.<span class="hljs-built_in">size</span>();++i)<br>            ++cnt1[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;s2.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">char</span> c=s2[right++]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>            --cnt1[c];<span class="hljs-comment">// 入窗</span><br>            <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;cnt1[c]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 出窗</span><br>               ++cnt1[s2[left++]-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(right-left==s1.<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="632-最小区间-hard"><a href="#632-最小区间-hard" class="headerlink" title="632. 最小区间[hard]"></a><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a>[hard]</h1><h2 id="解法一：优先级队列"><a href="#解法一：优先级队列" class="headerlink" title="解法一：优先级队列"></a>解法一：优先级队列</h2><p>思路与 <a href="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard">23.合并 K 个升序链表</a> 解法一相似。</p><p>使用优先级队列（小根堆）维护 k 个指针指向的元素中的最小值，同时维护堆中元素的最大值。初始时，k 个指针都指向下标 0，最大元素即为所有列表的下标 0 位置的元素中的最大值。每次从堆中取出最小值，根据最大值和最小值计算当前区间，如果当前区间小于最小区间则用当前区间更新最小区间，然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值。如果一个列表的指针超出该列表的下标范围，则说明该列表中的所有元素都被遍历过，堆中不会再有该列表中的元素，因此退出循环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// pair&lt;value,pair&lt;i,j&gt;&gt;</span><br>    <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; PII;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">smallestRange</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间的左右端点</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=INT_MAX;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(length)</span></span>;<br>        priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; pq;<span class="hljs-comment">//小根堆</span><br>        <span class="hljs-comment">// 堆中最小值、最大值</span><br>        <span class="hljs-type">int</span> minValue=<span class="hljs-number">0</span>,maxValue=INT_MIN;<br>        <span class="hljs-comment">// 把初始 length 个元素放入堆中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;++i)<br>        &#123;<br>            pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nums[i][<span class="hljs-number">0</span>],<span class="hljs-built_in">make_pair</span>(i,<span class="hljs-number">0</span>)));<br>            maxValue=<span class="hljs-built_in">max</span>(maxValue,nums[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            PII tmp=pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            minValue=tmp.first;<br>            <span class="hljs-type">int</span> i=tmp.second.first;<br>            <span class="hljs-type">int</span> j=tmp.second.second;<br>            <span class="hljs-comment">// 更新区间长度</span><br>            <span class="hljs-keyword">if</span>(maxValue-minValue&lt;right-left)<br>            &#123;<br>                left=minValue;<br>                right=maxValue;<br>            &#125;<br>            <span class="hljs-comment">// 为堆中填充下一个元素</span><br>            <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;nums[i].<span class="hljs-built_in">size</span>())<br>            &#123;<br>                pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nums[i][j+<span class="hljs-number">1</span>],<span class="hljs-built_in">make_pair</span>(i,j+<span class="hljs-number">1</span>)));<br>                maxValue=<span class="hljs-built_in">max</span>(maxValue,nums[i][j+<span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;                <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;left,right&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(nklogk)，其中 n 是所有列表的平均长度，k 是列表数量。所有的指针移动的总次数最多是 nk 次，每次从堆中取出元素和添加元素都需要更新堆，时间复杂度是 O(logk)，因此总时间复杂度是 O(nklogk)。</li><li>空间复杂度 O(k)，其中 k 是列表数量。空间复杂度取决于堆的大小，堆中维护 k 个元素。</li></ul><h2 id="解法二：哈希表-滑动窗口"><a href="#解法二：哈希表-滑动窗口" class="headerlink" title="解法二：哈希表+滑动窗口"></a>解法二：哈希表+滑动窗口</h2><p>首先将每个数组合并成一个大数组统一处理，但是需要保留其原属数组的序号，所以大数组中存 pair 对，同时保存数字和原数组的序号。然后重新按照数字大小进行排序，这样问题实际上就转换成了求一个最小窗口，使其能够同时包括所有数组中的至少一个数字。与题目 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a> 相似。</p><p>使用两个指针 left 和 right 来确定滑动窗口的范围，还要用一个 HashMap 来建立每个数组与其数组中数字出现的个数之间的映射，变量 cnt 表示当前窗口中的数字覆盖了几个数组，diff 为窗口的大小，让 right 向右滑动，然后判断如果 right 指向的数字所在数组还没有被覆盖到，cnt 自增1，然后 HashMap 中对应的数组出现次数自增1，然后循环判断如果 cnt 此时为k (数组的个数)且 left 不大于 right，那么用当前窗口的范围来更新结果，然后此时想缩小窗口，通过将 left 向右移，移动之前需要减小 HashMap 中的映射值，因为去除了数字，如果此时映射值为 0 了，说明有个数组无法覆盖到了，cnt 就要自减1。这样遍历后就能得到最小的范围了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">smallestRange</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; mergeNums;<span class="hljs-comment">// (number, group)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:nums[i])<br>                mergeNums.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(num,i));<br>        <span class="hljs-comment">// 默认对 first 升序，当 first 相同时对 second 升序</span><br>        <span class="hljs-built_in">sort</span>(mergeNums.<span class="hljs-built_in">begin</span>(),mergeNums.<span class="hljs-built_in">end</span>());<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> diff=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;mergeNums.<span class="hljs-built_in">size</span>();++right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m[mergeNums[right].second]==<span class="hljs-number">0</span>)<br>                ++cnt;<br>            ++m[mergeNums[right].second];<br>            <span class="hljs-comment">// 收缩窗口</span><br>            <span class="hljs-keyword">while</span>(cnt==nums.<span class="hljs-built_in">size</span>()&amp;&amp;left&lt;=right)<br>            &#123;<br>                <span class="hljs-comment">// 更新区间长度</span><br>                <span class="hljs-keyword">if</span>(mergeNums[right].first-mergeNums[left].first&lt;diff)<br>                &#123;<br>                    diff=mergeNums[right].first-mergeNums[left].first;<br>                    res=&#123;mergeNums[left].first,mergeNums[right].first&#125;;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(--m[mergeNums[left].second]==<span class="hljs-number">0</span>)<br>                    --cnt;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nk)，空间复杂度 O(nk)。</p><h1 id="209-长度最小的子数组-medium"><a href="#209-长度最小的子数组-medium" class="headerlink" title="209. 长度最小的子数组[medium]"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>[medium]</h1><h2 id="解法一：暴力解法"><a href="#解法一：暴力解法" class="headerlink" title="解法一：暴力解法"></a>解法一：暴力解法</h2><p>使用两个 for 循环遍历数组，外循环固定一个元素，内循环从该元素开始累加，当和大于等于 s 的时候终止内循环，顺便记录下最小长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minLength=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;nums.<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                sum+=nums[j];<br>                <span class="hljs-keyword">if</span>(sum&gt;=s)<br>                &#123;<br>                    minLength=<span class="hljs-built_in">min</span>(minLength,j-i+<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength==INT_MAX?<span class="hljs-number">0</span>:minLength;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p><h2 id="解法二：滑动窗口-2"><a href="#解法二：滑动窗口-2" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h2><p>使用两个指针，<code>left</code>代表滑动窗口左边，<code>right</code>代表滑动窗口右边。</p><ul><li>当窗口内元素和不大于<code>s</code>，则<code>right++</code>，扩大窗口；</li><li>当窗口内元素和大于等于<code>s</code>，则<code>left++</code>，缩小窗口，同时记录窗口的最小长度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minLength=INT_MAX;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            sum+=nums[right];<br>            <span class="hljs-keyword">while</span>(sum&gt;=s)<br>            &#123;<br>                minLength=<span class="hljs-built_in">min</span>(minLength,right-left+<span class="hljs-number">1</span>);<br>                sum-=nums[left];<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength==INT_MAX?<span class="hljs-number">0</span>:minLength;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h2 id="解法三：前缀和-二分查找"><a href="#解法三：前缀和-二分查找" class="headerlink" title="解法三：前缀和+二分查找"></a>解法三：前缀和+二分查找</h2><p>申请一个临时数组 sums，其中 <code>sums[i]</code> 表示的是原数组 nums 前 <code>i</code>个元素的和，题中说了 “给定一个含有 n 个 正整数 的数组”，既然是正整数，那么相加的和会越来越大，也就是 sums数组中的元素是递增的。只需要找到 <code>sums[k]-sums[j]&gt;=s</code>，那么 <code>k-j</code>就是满足的连续子数组，<strong>但不一定是最小的</strong>，所以要继续找，直到找到最小的为止。怎么找呢，可以使用两个 for 循环来枚举，但这又和第一种暴力求解一样了，所以可以换种思路，求 <code>sums[k]-sums[j]&gt;=s</code> 可以求 <code>sums[j]+s&lt;=sums[k]</code>，那这样就好办了，因为数组 sums 中的元素是递增的，也就是排序的，只需要求出<code>sum[j]+s</code>的值，然后使用二分查找即可找到这个 <code>k</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sums</span><span class="hljs-params">(length+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 为了方便计算，令 size = length + 1 </span><br>        <span class="hljs-comment">// sums[0] = 0 意味着前 0 个元素的前缀和为 0</span><br>        <span class="hljs-comment">// sums[1] = A[0] 前 1 个元素的前缀和为 A[0]</span><br>        <span class="hljs-comment">// 以此类推</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=length;++i)<br>            sums[i]=sums[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> minLength=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=length;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> target=s+sums[i];<br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">binarySearch</span>(sums,i,length,target);<br>            <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>)<br>                minLength=<span class="hljs-built_in">min</span>(minLength,index-i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength==INT_MAX?<span class="hljs-number">0</span>:minLength;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 寻求刚好大于等于 target 的 sums 的下标，也就是大于等于 target 所有 sums 中最小的那个，即 lower_bound</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(sums[mid]&lt;target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-comment">// 后处理</span><br>        <span class="hljs-keyword">return</span> sums[left]&gt;=target?left:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(n)，需要额外创建数组 sums 存储前缀和。</p><h2 id="解法四：滑动窗口-二分查找"><a href="#解法四：滑动窗口-二分查找" class="headerlink" title="解法四：滑动窗口+二分查找"></a>解法四：滑动窗口+二分查找</h2><p>解法二往窗口中添加元素来判断是否满足。其实可以逆向思维，先固定一个窗口大小比如 len，然后遍历数组，查看在数组中 len 个元素长度的和是否有满足的，如果没有满足的就扩大窗口的大小继续查找，如果有满足的就记录下窗口的大小 len，因为这个 len 不一定是最小的，需要缩小窗口的大小再继续找……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> minLength=<span class="hljs-number">0</span>;<span class="hljs-comment">// 最小窗口长度</span><br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 找到就记录此时窗口大小，并且缩小窗口的大小，继续查找</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">windowExist</span>(nums,mid,s))<br>            &#123;<br>                minLength=mid;<br>                right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 没找到就扩大窗口的大小，继续查找</span><br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minLength;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// size：窗口的大小</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">windowExist</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            sum+=nums[i];<br>            <span class="hljs-comment">// 限制窗口最大为 size</span><br>            <span class="hljs-keyword">if</span>(i&gt;=size)<br>                sum-=nums[i-size];<br>            <span class="hljs-keyword">if</span>(sum&gt;=s)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><h1 id="239-滑动窗口最大值-hard"><a href="#239-滑动窗口最大值-hard" class="headerlink" title="239. 滑动窗口最大值[hard]"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a>[hard]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>遍历每个滑动窗口，找到每个窗口的最大值。一共有<code>N - k + 1</code>滑动窗口，每个有<code>k</code>个元素，于是算法的时间复杂度为 O(nk)，表现较差。</p><p>注意以下 cpp 代码超时！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()-k+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> maxNum=INT_MIN;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;i+k;++j)<br>                maxNum=<span class="hljs-built_in">max</span>(maxNum,nums[j]);<br>            res.<span class="hljs-built_in">push_back</span>(maxNum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：优先队列"><a href="#解法二：优先队列" class="headerlink" title="解法二：优先队列"></a>解法二：优先队列</h2><p>解法一中每次循环寻找最大的值，其实这样的最大值可以用优先队列来维护，这样得到最大值是 <code>O(1)</code>。</p><p>优先队列中存储的是 pair 对，由数字和其所在位置组成，这样就可以知道每个数字的位置而不用再进行搜索。在遍历每个数字时，进行 while 循环，假如优先队列中最大的数字此时不在窗口中了，就要移除，判断方法就是将队首元素的 pair 对中的 second（位置坐标）跟 i-k 对比，小于等于就移除。然后将当前数字和其位置组成 pair 对加入优先队列中。此时看若 i &gt;&#x3D; k-1，说明窗口大小正好是 k，就将最大值加入结果 res 中即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">// &lt;nums[i], i&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()&amp;&amp;q.<span class="hljs-built_in">top</span>().second&lt;=i-k)<br>                q.<span class="hljs-built_in">pop</span>();<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nums[i],i));<br>            <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>().first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(nlogk)，空间复杂度 O(k)。</p><h2 id="解法三：双端队列实现单调队列"><a href="#解法三：双端队列实现单调队列" class="headerlink" title="解法三：双端队列实现单调队列"></a>解法三：双端队列实现单调队列</h2><p>使用双向队列 deque 来维护一个单调队列。可以参考 <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-dui-lie">labuladong的算法小抄</a>。</p><p>遍历数组，将数存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 <code>[L,R]</code>中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。示例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br><br>解释过程中队列中都是具体的值，方便理解，具体见代码。<br>初始状态：<span class="hljs-attribute">L</span>=R=0,队列:&#123;&#125;<br><span class="hljs-attribute">i</span>=0,nums[0]=1。队列为空,直接加入。队列：&#123;1&#125;<br><span class="hljs-attribute">i</span>=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：&#123;3&#125;<br><span class="hljs-attribute">i</span>=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：&#123;3,-1&#125;。此时窗口已经形成，<span class="hljs-attribute">L</span>=0,R=2，result=[3]<br><span class="hljs-attribute">i</span>=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：&#123;3,-1,-3&#125;。队首3对应的下标为1，<span class="hljs-attribute">L</span>=1,R=3，有效。result=[3,3]<br><span class="hljs-attribute">i</span>=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：&#123;5&#125;。此时<span class="hljs-attribute">L</span>=2,R=4，有效。result=[3,3,5]<br><span class="hljs-attribute">i</span>=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：&#123;5,3&#125;。此时<span class="hljs-attribute">L</span>=3,R=5，有效。result=[3,3,5,5]<br><span class="hljs-attribute">i</span>=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：&#123;6&#125;。此时<span class="hljs-attribute">L</span>=4,R=6，有效。result=[3,3,5,5,6]<br><span class="hljs-attribute">i</span>=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：&#123;7&#125;。此时<span class="hljs-attribute">L</span>=5,R=7，有效。result=[3,3,5,5,6,7]<br></code></pre></td></tr></table></figure><ul><li>通过示例发现发现 <code>R=i</code>，<code>L=R-k</code>。由于队列中的值是从大到小排序的，所以每次窗口变动时，只需要判断队首的值是否还在窗口中就行了。</li><li>解释一下为什么队列中要存放数组下标的值而不是直接存储数值，因为要判断队首的值是否在窗口范围内，由数组下标取值很方便，而由值取数组下标不是很方便。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-comment">// 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序</span><br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-comment">// 遍历nums数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span><br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[dq.<span class="hljs-built_in">back</span>()]&lt;nums[i])<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-comment">// 添加当前值对应的数组下标</span><br>            dq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">// 判断当前队列中队首的值是否有效</span><br>            <span class="hljs-keyword">if</span>(dq.<span class="hljs-built_in">front</span>()&lt;=i-k)<br>                dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-comment">// 当窗口长度为k时 保存当前窗口中最大值</span><br>            <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>)<br>                res.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n)，每个元素被处理两次（其索引被添加到双向队列中和被双向队列删除）。 </li><li>空间复杂度 O(k)。</li></ul><h2 id="解法四：动态规划"><a href="#解法四：动态规划" class="headerlink" title="解法四：动态规划"></a>解法四：动态规划</h2><p>将输入数组分割成有<code>k</code>个元素的块。若 <code>n % k != 0</code>，则最后一块的元素个数可能更少。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201023155658.png" style="zoom:50%;" /><p>开头元素为 <code>i</code> ，结尾元素为 <code>j</code> 的当前滑动窗口可能在一个块内，也可能在两个块中。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201023155724.png" style="zoom:50%;" /><p>情况 <code>1</code> 比较简单。 建立数组 <code>left</code>， 其中 <code>left[j]</code> 是从块的开始到下标 <code>j</code> 最大的元素，方向 <code>左-&gt;右</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201023155747.png" style="zoom:50%;" /><p>为了处理更复杂的情况 <code>2</code>，需要数组 <code>right</code>，其中 <code>right[j]</code>是从块的结尾到下标 <code>j</code> 最大的元素，方向 <code>右-&gt;左</code>。 <code>right</code>数组和 <code>left</code>除了方向不同以外基本一致。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201023160151.png" style="zoom:50%;" /><p>两数组一起可以提供两个块内元素的全部信息。考虑从下标 <code>i</code> 到下标 <code>j</code>的滑动窗口。 根据定义，<code>right[i]</code> 是左侧块内的最大元素，<code>left[j]</code>是右侧块内的最大元素。因此滑动窗口中的最大元素为 <code>max(right[i], left[j])</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201023160447.png" style="zoom:50%;" /><p>因此算法过程为：</p><ul><li>从左到右遍历数组，建立数组 <code>left</code>。</li><li>从右到左遍历数组，建立数组 <code>right</code>。</li><li>建立输出数组 <code>max(right[i], left[i + k - 1])</code>，其中 <code>i</code>取值范围为 <code>(0, n - k + 1)</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(length,<span class="hljs-number">0</span>)</span></span>;<br>        left[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 左 -&gt; 右</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;length;++j)<br>        &#123;<br>            <span class="hljs-comment">// 块的左边界</span><br>            <span class="hljs-keyword">if</span>(j%k==<span class="hljs-number">0</span>)<br>                left[j]=nums[j];<br>            <span class="hljs-keyword">else</span><br>                left[j]=<span class="hljs-built_in">max</span>(left[j<span class="hljs-number">-1</span>],nums[j]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(length,<span class="hljs-number">0</span>)</span></span>;<br>        right[length<span class="hljs-number">-1</span>]=nums[length<span class="hljs-number">-1</span>];<br>        <span class="hljs-comment">// 右 -&gt; 左</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-comment">// 块的右边界</span><br>            <span class="hljs-keyword">if</span>((i+<span class="hljs-number">1</span>)%k==<span class="hljs-number">0</span>)<br>                right[i]=nums[i];<br>            <span class="hljs-keyword">else</span><br>                right[i]=<span class="hljs-built_in">max</span>(right[i+<span class="hljs-number">1</span>],nums[i]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(length-k+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length-k+<span class="hljs-number">1</span>;++i)<br>            <span class="hljs-comment">// i 表示滑动窗口的左边界</span><br>            res[i]=<span class="hljs-built_in">max</span>(right[i],left[i+k<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(n)。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sliding Window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Two Pointers</title>
    <link href="/2020/09/29/Leetcode%20Notes%E2%80%94%E2%80%94Two%20Pointers/"/>
    <url>/2020/09/29/Leetcode%20Notes%E2%80%94%E2%80%94Two%20Pointers/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>双指针</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p><span id="more"></span><h1 id="11-盛最多水的容器-medium"><a href="#11-盛最多水的容器-medium" class="headerlink" title="11. 盛最多水的容器[medium]"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a>[medium]</h1><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p><strong>算法流程：</strong> </p><p>设置双指针<code>i,j</code>分别位于容器壁两端，根据规则移动指针，并且更新面积最大值 <code>res</code>，直到 <code>i == j</code> 时返回 <code>res</code>。</p><p><strong>指针移动规则：</strong> </p><p>每次选定围成水槽两板高度<code>h[i],h[j]</code>中的短板，向中间收窄 1 格。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-type">int</span> area=(j-i)*<span class="hljs-built_in">min</span>(height[i],height[j]);<br>            res=<span class="hljs-built_in">max</span>(res,area);<br>            <span class="hljs-keyword">if</span>(height[i]&lt;height[j])<br>                i++;<br>            <span class="hljs-keyword">else</span><br>                j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><p><strong>双指针解法的正确性:</strong></p><p>用一句话概括双指针解法的要点：指针每一次移动，都意味着排除掉了一个柱子。</p><p>如下图所示，在一开始，考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d&#x3D;8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h&#x3D;3。水的面积就是 3×8&#x3D;24。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101701.jpeg" style="zoom:67%;" /><p>如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：</p><ul><li>当前柱子是最两侧的柱子，水的宽度 d 为最大，其他的组合，水的宽度都比这个小。</li><li>左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。</li><li>如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101708.jpeg" style="zoom:67%;" /><p>由此可见，如果固定左边的柱子，移动右边的柱子，那么水的高度一定不会增加，且宽度一定减少，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是可以排除掉左边的柱子了。</p><p>这个排除掉左边柱子的操作，就是双指针代码里的 <code>i++</code>。<code>i</code> 和 <code>j</code> 两个指针中间的区域都是还未排除掉的区域。随着不断的排除，<code>i</code> 和 <code>j</code> 都会往中间移动。当 <code>i</code> 和 <code>j</code>相遇，算法就结束了。</p><p><strong>图解双指针解法的原理：</strong></p><p>下面用更直观的方法来看看”排除掉一根柱子”，”指针移动”代表着什么。</p><p>在这道题中，假设一共有 n 根柱子，编号 0,1,…,n−1，高度分别为 H_0, H_1 ,…,H_n−1。要寻找的是两根柱子 i, j，它们需要满足的约束条件是：</p><ul><li>i、j 都是合法的柱子下标，即 0≤i&lt;n,0≤j&lt;n；</li><li>i 在 j 的左边，即 i&lt;j。</li></ul><p>而我们希望从中找到容纳水面积最大的柱子 (i, j)。以 n&#x3D;8 为例，这时候全部的搜索空间是：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101724.jpeg" style="zoom:67%;" /><p>由于 i、j 的约束条件的限制，搜索空间是白色的倒三角部分。可以看到，搜索空间的大小是 O(n^2) 数量级的。如果用暴力解法求解，一次只检查一个单元格，那么时间复杂度一定是 O(n^2)。要想得到 O(n) 的解法，就需要能够一次排除多个单元格。那么看看双指针解法是如何削减搜索空间的：</p><p>一开始，检查右上方单元格 (0,7)，即考虑最左边的 0 号柱子和最右边的 7 号柱子，计算它们之间容纳水的面积。然后比较一下两根柱子的高度，关注其中较短的一根。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101733.jpeg" style="zoom:67%;" /><p>假设左边的 0 号柱子较短。根据刚才的推理，0 号柱子目前的水面高度已经到了上限。由于 7 号柱子已经是离 0 号柱子最远的了，水的宽度也最大，如果换其他的柱子和 0 号柱子配对，水的宽度只会更小，高度也不会增加，容纳水的面积只会更小。也就是说，0 号柱子和 6,5,…,1 号柱子的配对都可以排除掉了。记录了(0,7) 这组柱子的结果之后，就可以排除 0 号柱子了。这相当于 i&#x3D;0 的情况全部被排除，即 <code>i++</code>；对应于搜索空间，就是削减了一行的搜索空间。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101746.jpeg" style="zoom:67%;" /><p>排除掉了搜索空间中的一行之后，再看剩余的搜索空间，仍然是倒三角形状。检查右上方的单元格 (1,7)，即考虑 1 号柱子和 7 号柱子，计算它们之间容纳水的面积。然后，比较两根柱子的高度。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101758.jpeg" style="zoom:67%;" /><p>假设此时 7 号柱子较短。同理， 7 号柱子已经是离 1 号柱子最远的了，如果换其他的柱子和 1 号柱子配对，水的宽度变小，高度也不会增加，容纳水的面积只会更小。也就是说，7 号柱子和 2,3,…,6 号柱子的配对都可以排除掉了。记录了 (1,7) 这组柱子的结果之后，就可以排除 7 号柱子了。这相当于 j&#x3D;7 的情况全部被排除，即 <code>j--</code>；对应于搜索空间，就是削减了一列的搜索空间。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101815.jpeg" style="zoom:67%;" /><p>可以看到，无论柱子 i 和 j 哪根更长，都可以排除掉一行或者一列的搜索空间。经过 n 步以后，就能排除所有的搜索空间，检查完所有的可能性。搜索空间的减小过程如下面动图所示。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101648.gif" style="zoom:67%;" /><h1 id="125-验证回文串-easy"><a href="#125-验证回文串-easy" class="headerlink" title="125. 验证回文串[easy]"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a>[easy]</h1><h2 id="解法：双指针-1"><a href="#解法：双指针-1" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>使用双指针。初始时，左右指针分别指向 str 的两侧，随后不断地将这两个指针相向移动，每次移动一步，并判断这两个指针指向的字符是否相同。当这两个指针相遇时，就说明 str 是回文串。</p><blockquote><p>几个内置函数：</p><ul><li>islower(char c) 是否为小写字母</li><li>isupper(char c) 是否为大写字母</li><li>isdigit(char c) 是否为数字</li><li>isalpha(char c) 是否为字母</li><li>isalnum(char c) 是否为字母或者数字</li><li>toupper(char c) 字母小转大</li><li>tolower(char c) 字母大转小</li></ul></blockquote><h3 id="筛选-判断"><a href="#筛选-判断" class="headerlink" title="筛选 + 判断"></a>筛选 + 判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string str;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalnum</span>(c))<br>                str+=<span class="hljs-built_in">tolower</span>(c);<br>        &#125;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[i]!=str[j])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(|s|)，其中 |s| 是字符串 s 的长度，空间复杂度 O(|s|)。</p><h3 id="在原字符串上直接判断"><a href="#在原字符串上直接判断" class="headerlink" title="在原字符串上直接判断"></a>在原字符串上直接判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;!<span class="hljs-built_in">isalnum</span>(s[i]))<br>                i++;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;!<span class="hljs-built_in">isalnum</span>(s[j]))<br>                j--;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">tolower</span>(s[i])!=<span class="hljs-built_in">tolower</span>(s[j]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(|s|)，其中 |s| 是字符串 s 的长度，空间复杂度 O(1)。</p><h1 id="680-验证回文字符串-Ⅱ-easy"><a href="#680-验证回文字符串-Ⅱ-easy" class="headerlink" title="680. 验证回文字符串 Ⅱ[easy]"></a><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">680. 验证回文字符串 Ⅱ</a>[easy]</h1><h2 id="解法：双指针-2"><a href="#解法：双指针-2" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p><p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p><p>在判断删除完之后的字符串是否为回文字符串时，不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p><p>在试着删除字符时，既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]!=s[j])<br>                <span class="hljs-comment">// 分两种情况，一是右边减一，二是左边加一</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPalindrome</span>(s,i,j<span class="hljs-number">-1</span>)||<span class="hljs-built_in">isPalindrome</span>(s,i+<span class="hljs-number">1</span>,j);<br>            i++;<br>            j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i++]!=s[j--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="917-仅仅反转字母-easy"><a href="#917-仅仅反转字母-easy" class="headerlink" title="917. 仅仅反转字母[easy]"></a><a href="https://leetcode-cn.com/problems/reverse-only-letters/">917. 仅仅反转字母</a>[easy]</h1><h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p>将 <code>s</code>中的所有字母单独存入栈中，所以出栈等价于对字母反序操作。然后，遍历 <code>s</code> 的所有字符，如果是字母就选择栈顶元素输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; letters;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:S)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(c))<br>                letters.<span class="hljs-built_in">push</span>(c);<br>        &#125;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:S)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(c))<br>            &#123;<br>                res+=letters.<span class="hljs-built_in">top</span>();<br>                letters.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                res+=c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>遇到非字母，i++&#x2F;j–，遇到字母 swap。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseOnlyLetters</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=S.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isalpha</span>(S[i]))<br>                i++;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isalpha</span>(S[j]))<br>                j--;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(S[i])&amp;&amp;<span class="hljs-built_in">isalpha</span>(S[j]))<br>                <span class="hljs-built_in">swap</span>(S[i++],S[j--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> S;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><h1 id="345-反转字符串中的元音字母-easy"><a href="#345-反转字符串中的元音字母-easy" class="headerlink" title="345. 反转字符串中的元音字母[easy]"></a><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/">345. 反转字符串中的元音字母</a>[easy]</h1><h2 id="解法：双指针-3"><a href="#解法：双指针-3" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-comment">// 从左边查找元音字母</span><br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;!<span class="hljs-built_in">isVowel</span>(s[i]))<br>                i++;<br>            <span class="hljs-comment">// 从右边查找元音字母</span><br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;!<span class="hljs-built_in">isVowel</span>(s[j]))<br>                j--;<br>            <span class="hljs-built_in">swap</span>(s[i++],s[j--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isVowel</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> c==<span class="hljs-string">&#x27;a&#x27;</span>||c==<span class="hljs-string">&#x27;e&#x27;</span>||c==<span class="hljs-string">&#x27;i&#x27;</span>||c==<span class="hljs-string">&#x27;o&#x27;</span>||c==<span class="hljs-string">&#x27;u&#x27;</span>||<br>               c==<span class="hljs-string">&#x27;A&#x27;</span>||c==<span class="hljs-string">&#x27;E&#x27;</span>||c==<span class="hljs-string">&#x27;I&#x27;</span>||c==<span class="hljs-string">&#x27;O&#x27;</span>||c==<span class="hljs-string">&#x27;U&#x27;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为了快速判断一个字符是不是元音字符，可以将全部元音字符添加到 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; vowelSet&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;u&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>&#125;;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;vowelSet.<span class="hljs-built_in">count</span>(s[i])==<span class="hljs-number">0</span>)<br>                i++;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;vowelSet.<span class="hljs-built_in">count</span>(s[j])==<span class="hljs-number">0</span>)<br>                j--;<br>            <span class="hljs-built_in">swap</span>(s[i++],s[j--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="925-长按键入-easy"><a href="#925-长按键入-easy" class="headerlink" title="925. 长按键入[easy]"></a><a href="https://leetcode-cn.com/problems/long-pressed-name/">925. 长按键入</a>[easy]</h1><h2 id="解法：双指针-4"><a href="#解法：双指针-4" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLongPressedName</span><span class="hljs-params">(string name, string typed)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;typed.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&lt;name.<span class="hljs-built_in">size</span>()&amp;&amp;name[i]==typed[j])<br>                ++i;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!j||typed[j]!=typed[j<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==name.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="986-区间列表的交集-medium"><a href="#986-区间列表的交集-medium" class="headerlink" title="986. 区间列表的交集[medium]"></a><a href="https://leetcode-cn.com/problems/interval-list-intersections/">986. 区间列表的交集</a>[medium]</h1><h2 id="解法：双指针-5"><a href="#解法：双指针-5" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>题目说，给定的两个区间列表都是排好序的，因此用两个指针，分别考察A、B数组的子区间。根据子区间的左右边界，求出一个交集区间。移动指针直至遍历完A、B数组，得到由交集区间组成的数组。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200930101630.png" style="zoom: 50%;" /><p><strong>怎么求交集区间：</strong></p><ul><li>注意上图的绿色箭头，交集区间的 start 取的是 A、B 子区间中较大的左界。</li><li>注意上图的红色箭头，交集区间的 end 取的是 A、B 子区间中较小的右界。</li><li>只要 start &lt;&#x3D; end，就形成了一个交集区间。</li></ul><p><strong>双指针移动的时机是什么：</strong></p><ul><li>求完一个交集区间后，较早结束的子区间不可能再和别的子区间重叠了，它的指针要移动。</li><li>较长的子区间还有可能和别人重叠，它的指针暂时不动。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">intervalIntersection</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; B) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;A.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;B.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> start=<span class="hljs-built_in">max</span>(A[i][<span class="hljs-number">0</span>],B[j][<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">int</span> end=<span class="hljs-built_in">min</span>(A[i][<span class="hljs-number">1</span>],B[j][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span>(start&lt;=end)<br>                res.<span class="hljs-built_in">push_back</span>(&#123;start,end&#125;);<br>            <span class="hljs-keyword">if</span>(A[i][<span class="hljs-number">1</span>]&lt;B[j][<span class="hljs-number">1</span>])<br>                ++i;<br>            <span class="hljs-keyword">else</span><br>                ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="167-两数之和-II-输入有序数组-easy"><a href="#167-两数之和-II-输入有序数组-easy" class="headerlink" title="167. 两数之和 II - 输入有序数组[easy]"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>借助哈希表，不考虑数组是否有序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<span class="hljs-comment">// &lt;值，索引&gt;</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> anotherNum=target-numbers[i];<span class="hljs-comment">// 另一个数</span><br>            <span class="hljs-comment">// 存在等于target - numbers[i]的数且不是同一个数</span><br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(anotherNum)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// mp[anotherNum]+1 为另一个数的索引，该索引先插入 hashMap中，则其索引比较小，所以先放到结果中</span><br>                <span class="hljs-keyword">return</span> &#123;mp[anotherNum]+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>&#125;;<br>            <span class="hljs-comment">// 否则，插入记录到哈希表</span><br>            <span class="hljs-keyword">else</span><br>                mp[numbers[i]]=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><p>遍历一遍数组，根据当前遍历的数字，利用数组的有序性质，可以使用二分查找查找当前数字后面，是否存在另一个数字使得两数之和等于 target。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> anotherNum=target-numbers[i];<br>            <span class="hljs-type">int</span> index=<span class="hljs-built_in">binarySearch</span>(numbers,i+<span class="hljs-number">1</span>,numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,anotherNum);<br>            <span class="hljs-comment">// 查找成功</span><br>            <span class="hljs-keyword">if</span>(index!=<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> &#123;i+<span class="hljs-number">1</span>,index+<span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 二分查找，如果查找成功，则返回索引值；否则，返回 -1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(numbers[mid]&lt;target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(numbers[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(NlogN)，空间复杂度 O(1)。</p><h2 id="解法三：双指针"><a href="#解法三：双指针" class="headerlink" title="解法三：双指针"></a>解法三：双指针</h2><p>初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。</p><p>使用双指针的实质是<strong>缩减搜索空间</strong>，其原理与 <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a> 相似。具体可以查看 @<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/yi-zhang-tu-gao-su-ni-on-de-shuang-zhi-zhen-jie-fa/">nettee</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=numbers[i]+numbers[j];<br>            <span class="hljs-keyword">if</span>(sum==target)<br>                <span class="hljs-keyword">return</span> &#123;i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>&#125;;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)<br>                ++i;<br>            <span class="hljs-keyword">else</span><br>                --j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><h1 id="633-平方数之和-medium"><a href="#633-平方数之和-medium" class="headerlink" title="633. 平方数之和[medium]"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a>[medium]</h1><p>本题可以看成是在元素为 0~c 的有序数组中查找两个数，使得这两个数的平方和为 c，如果能找到，则返回 true，表示 c 是两个整数的平方和。思路和 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。</p><h2 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h2><p>思路和 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> 解法二类似。首先枚举 <code>a</code>，随后通过二分查找的方法找出是否存在 <code>b</code>，满足 <code>b^2 = c - a^2</code>。二分查找的范围为 <code>[0, c - a^2]</code>。用 long 防止数据溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> a=<span class="hljs-number">0</span>;a*a&lt;=c;++a)<br>        &#123;<br>            <span class="hljs-type">int</span> b=c-a*a;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">binarySearch</span>(<span class="hljs-number">0</span>,b,b))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-type">long</span> left,<span class="hljs-type">long</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">long</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mid*mid&lt;target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left*left!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(sqrt(c)logc)，空间复杂度  O(1)。</p><h2 id="解法二：双指针-1"><a href="#解法二：双指针-1" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>思路和 <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> 解法三类似。本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 <code>j</code>，左指针固定为 0，为了使 <code>0^2 + j^2</code> 的值尽可能接近 <code>c</code>，可以将<code>j</code>取为<code>sqrt(c)</code>。用 long 防止数据溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">long</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> j=(<span class="hljs-type">long</span>)<span class="hljs-built_in">sqrt</span>(c);<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">long</span> powSum=i*i+j*j;<br>            <span class="hljs-keyword">if</span>(powSum==c)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(powSum&lt;c)<br>                i++;<br>            <span class="hljs-keyword">else</span><br>                j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(sqrt(c))，空间复杂度 O(1)。</p><h2 id="解法三：费马平方和定理"><a href="#解法三：费马平方和定理" class="headerlink" title="解法三：费马平方和定理"></a>解法三：费马平方和定理</h2><blockquote><p>费马平方和定理：</p><p>一个非负整数 c 能够表示为两个整数的平方和，当且仅当 c 的所有形如 4k+3 的质因子的幂次均为偶数。</p></blockquote><p>证明方法可以见 <a href="http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html">这里</a>。</p><p>因此对 c 进行质因数分解，再判断形如 4k+3 的质因子的幂次是否均为偶数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= c; i++) <br>        &#123;<br>            <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 求c的质因子</span><br>            <span class="hljs-keyword">if</span>(c%i==<span class="hljs-number">0</span>) <br>            &#123;<br>                <span class="hljs-keyword">while</span>(c%i==<span class="hljs-number">0</span>) <br>                &#123;<br>                    <span class="hljs-comment">// 质因子的幂次</span><br>                    count++;<br>                    c/=i;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">4</span>==<span class="hljs-number">3</span>&amp;&amp;count%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c%<span class="hljs-number">4</span>!=<span class="hljs-number">3</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(sqrt(c))，空间复杂度 O(1)。</p><h1 id="15-三数之和-medium"><a href="#15-三数之和-medium" class="headerlink" title="15. 三数之和[medium]"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a>[medium]</h1><h2 id="解法：排序-双指针"><a href="#解法：排序-双指针" class="headerlink" title="解法：排序+双指针"></a>解法：排序+双指针</h2><p>本题的难点在于如何去除重复解。</p><p><strong>算法流程：</strong></p><ul><li><p>特判，对于数组长度 n，如果数组长度小于 3，返回。</p></li><li><p>对数组进行排序。</p></li><li><p>遍历排序后数组：</p><ul><li><p>若 nums[i]&gt;0：因为已经排序好，所以后面不可能有三个数加和等于 0，直接返回结果。</p></li><li><p>对于重复元素：跳过，避免出现重复解。</p></li><li><p>令左指针 L&#x3D;i+1，右指针 R&#x3D;n-1，当 L&lt;R 时，执行循环：</p><ul><li><p>当 nums[i]+nums[L]+nums[R]&#x3D;&#x3D;0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,R 移到下一位置，寻找新的解。</p></li><li><p>若和大于 0，说明 nums[R] 太大，R 左移。</p></li><li><p>若和小于 0，说明 nums[L] 太小，L 右移。</p></li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(length&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length<span class="hljs-number">-2</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> res;<br>            <span class="hljs-comment">// 注意这边别忘记！！！</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=length<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)<br>            &#123;<br>                <span class="hljs-type">int</span> sum=nums[i]+nums[left]+nums[right];<br>                <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">0</span>)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);<br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left+<span class="hljs-number">1</span>]==nums[left])<br>                        ++left;<br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right<span class="hljs-number">-1</span>]==nums[right])<br>                        --right;<br>                    ++left;<br>                    --right;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)<br>                    --right;<br>                <span class="hljs-keyword">else</span>    <br>                    ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)，数组排序 O(NlogN)，遍历数组 O(N)，双指针遍历 O(N)，总体  O(NlogN)+O(N)∗O(N)，即 O(N^2)。</li><li>空间复杂度：O(logN)，额外的排序的空间复杂度为 O(logN)。</li></ul><h1 id="16-最接近的三数之和-medium"><a href="#16-最接近的三数之和-medium" class="headerlink" title="16. 最接近的三数之和[medium]"></a><a href="https://leetcode-cn.com/problems/3sum-closest/">16. 最接近的三数之和</a>[medium]</h1><h2 id="解法：排序-双指针-1"><a href="#解法：排序-双指针-1" class="headerlink" title="解法：排序+双指针"></a>解法：排序+双指针</h2><ul><li>首先进行数组排序</li><li>在数组 nums 中，进行遍历，每遍历一个值利用其下标 i，形成一个固定值 nums[i]。</li><li>再使用左指针指向 <code>left = i + 1</code> 处，右指针指向 <code>right = nums.size() - 1</code> 处，也就是结尾处。</li><li>根据 根据 <code>sum = nums[i] + nums[left] + nums[right]</code>的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 res。</li><li>同时判断 sum 与 target 的大小关系，因为数组有序，如果 <code>sum &gt; target</code> 则 <code>--right</code>，如果 如果 <code>sum &lt; target</code> 则 <code>++left</code>，如果 <code>sum == target</code> 则说明距离为 0 直接返回结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)<br>            &#123;<br>                <span class="hljs-type">int</span> sum=nums[i]+nums[left]+nums[right];<br>                <span class="hljs-keyword">if</span>(sum==target)<br>                    <span class="hljs-keyword">return</span> sum;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target-sum)&lt;<span class="hljs-built_in">abs</span>(target-res))<br>                    res=sum;<br>                <span class="hljs-keyword">if</span>(sum&gt;target)<br>                     --right;<br>                <span class="hljs-keyword">else</span><br>                    ++left; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>双指针法的优化</strong></p><p>利用 <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a> 中去重的思路对本题元素重复的问题进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res=nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 解决nums[i]重复</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> left=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)<br>            &#123;<br>                <span class="hljs-type">int</span> sum=nums[i]+nums[left]+nums[right];<br>                <span class="hljs-keyword">if</span>(sum==target)<br>                    <span class="hljs-keyword">return</span> sum;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target-sum)&lt;<span class="hljs-built_in">abs</span>(target-res))<br>                    res=sum;<br>                <span class="hljs-keyword">if</span>(sum&gt;target)<br>                &#123;<br>                    <span class="hljs-comment">// 解决nums[right]重复</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[right<span class="hljs-number">-1</span>]==nums[right])<br>                        --right;<br>                     --right;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                &#123;<br>                    <span class="hljs-comment">// 解决nums[left]重复</span><br>                    <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;nums[left+<span class="hljs-number">1</span>]==nums[left])<br>                        ++left;<br>                    ++left;<br>                &#125;   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)，数组排序 O(NlogN)，遍历数组 O(N)，双指针遍历 O(N)，总体  O(NlogN)+O(N)∗O(N)，即 O(N^2)。</li><li>空间复杂度：O(logN)，额外的排序的空间复杂度为 O(logN)。</li></ul><h1 id="88-合并两个有序数组-easy"><a href="#88-合并两个有序数组-easy" class="headerlink" title="88. 合并两个有序数组[easy]"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a>[easy]</h1><h2 id="解法一：合并数组后排序"><a href="#解法一：合并数组后排序" class="headerlink" title="解法一：合并数组后排序"></a>解法一：合并数组后排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-built_in">copy</span>(nums2.<span class="hljs-built_in">begin</span>(),nums2.<span class="hljs-built_in">end</span>(),nums1.<span class="hljs-built_in">begin</span>()+m);<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());            <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O((n + m)log(n + m)，空间复杂度 O(1)。</p><h2 id="解法二：双指针（从前往后）"><a href="#解法二：双指针（从前往后）" class="headerlink" title="解法二：双指针（从前往后）"></a>解法二：双指针（从前往后）</h2><p>将指针<code>p1</code>置为<code>nums1</code>的开头，<code>p2</code>为<code>nums2</code>的开头，在每一步将最小值放入输出数组中。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725150214.png" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;   <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(nums1.begin(),nums1.begin()+m)</span></span>;<br>    <span class="hljs-type">int</span> p1=<span class="hljs-number">0</span>,p2=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(p1&lt;m &amp;&amp; p2&lt;n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[p1]&lt;=nums2[p2])<br>            nums1[p++]=a[p1++];<br>        <span class="hljs-keyword">else</span><br>            nums1[p++]=nums2[p2++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(p1&lt;m)<br>        nums1[p++]=a[p1++];<br>    <span class="hljs-keyword">while</span>(p2&lt;n)<br>        nums1[p++]=nums2[p2++];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n + m)，空间复杂度 O(m)。由于 nums1 是用于输出的数组，需要将 nums1 中的前 m 个元素放在其他地方，也就需要 O(m)的空间复杂度。</p><h2 id="解法三：双指针（从后往前）"><a href="#解法三：双指针（从后往前）" class="headerlink" title="解法三：双指针（从后往前）"></a>解法三：双指针（从后往前）</h2><p>方法二已经取得了最优的时间复杂度O(n + m)，但需要使用额外空间。这是由于在从头改变<code>nums1</code>的值时，需要把<code>nums1</code>中的元素存放在其他位置。从结尾开始改写 <code>nums1</code> 的值不需要额外空间。指针 <code>p</code> 用于追踪添加元素的位置。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725150229.png" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123; <br>    <span class="hljs-type">int</span> p1=m<span class="hljs-number">-1</span>,p2=n<span class="hljs-number">-1</span>,p=m+n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(p1&gt;=<span class="hljs-number">0</span> &amp;&amp; p2&gt;=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(nums1[p1]&gt;=nums2[p2])<br>            nums1[p--]=nums1[p1--];<br>        <span class="hljs-keyword">else</span><br>            nums1[p--]=nums2[p2--];<br>    &#125;<br>    <span class="hljs-comment">//while(p1&gt;=0)</span><br>        <span class="hljs-comment">//nums1[p--]=nums1[p1--];</span><br>    <span class="hljs-keyword">while</span>(p2&gt;=<span class="hljs-number">0</span>)<br>        nums1[p--]=nums2[p2--];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n + m)，空间复杂度 O(1)。</p><h1 id="977-有序数组的平方-easy"><a href="#977-有序数组的平方-easy" class="headerlink" title="977. 有序数组的平方[easy]"></a><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>[easy]</h1><h2 id="解法一：平方后排序"><a href="#解法一：平方后排序" class="headerlink" title="解法一：平方后排序"></a>解法一：平方后排序</h2><p>创建一个新的数组，它每个元素是给定数组对应位置元素的平方，然后排序这个数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:A)<br>            res.<span class="hljs-built_in">push_back</span>(num*num);<br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(NlogN))。</p><h2 id="解法二：双指针-2"><a href="#解法二：双指针-2" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>因为数组 <code>A</code> 有序， 所以可以说数组中的负数已经按照平方值降序排好了，数组中的非负数已经按照平方值升序排好了。因此使用两个指针分别读取数组的非负部分与负数部分 —— 指针 <code>i</code> 反向读取负数部分，指针 <code>j</code> 正向读取非负数部分。在用两个指针分别读取两个递增的数组（按元素的平方排序）时，合并这两个有序数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;length&amp;&amp;A[j]&lt;<span class="hljs-number">0</span>)<br>            j++;<br>        <span class="hljs-type">int</span> i=j<span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(length)</span></span>;<br>        <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(A[i]*A[i]&lt;A[j]*A[j])<br>            &#123;<br>                res[p++]=A[i]*A[i];<br>                i--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res[p++]=A[j]*A[j];<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            res[p++]=A[i]*A[i];<br>            i--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;length)<br>        &#123;<br>            res[p++]=A[j]*A[j];<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)。</p><h1 id="26-删除排序数组中的重复项-easy"><a href="#26-删除排序数组中的重复项-easy" class="headerlink" title="26. 删除排序数组中的重复项[easy]"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a>[easy]</h1><h2 id="解法：双指针-6"><a href="#解法：双指针-6" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>数组是有序的，那么重复的元素一定会相邻。要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。考虑用 2 个指针，前指针<code>p</code>，后指针 <code>q</code>，</p><ul><li><p>比较<code>p</code>和 <code>q</code> 位置的元素是否相等：</p><ul><li>如果相等，<code>q</code>后移 1 位。</li><li>如果不相等，将<code>q</code>位置的元素复制到<code>p+1</code>位置上，<code>p</code>后移一位，<code>q</code>后移 1 位。</li></ul></li><li><p>重复上述过程，直到<code>q</code>等于数组长度。</p></li><li><p>返回<code>p+1</code>，即为新数组长度。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> q=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(q&lt;nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[q]!=nums[p])<br>            &#123;<br>                nums[p+<span class="hljs-number">1</span>]=nums[q];<br>                p++;<br>            &#125;<br>            q++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h1 id="27-移除元素-easy"><a href="#27-移除元素-easy" class="headerlink" title="27. 移除元素[easy]"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a>[easy]</h1><h2 id="解法：双指针-7"><a href="#解法：双指针-7" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>使用两个指针<code>i</code>和<code>j</code>，其中<code>i</code>是慢指针，<code>j</code>是快指针。</p><h3 id="拷贝覆盖"><a href="#拷贝覆盖" class="headerlink" title="拷贝覆盖"></a>拷贝覆盖</h3><p>当<code>nums[j]</code>与给定的值相等时，递增<code>j</code>以跳过该元素。只要<code>nums[j]!=val</code>，就复制<code>nums[j]</code>到<code>nums[i]</code>并同时递增两个索引。重复这一过程，直到<code>j</code>到达数组的末尾，该数组的新长度为<code>i</code>。</p><p>这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[j]!=val)<br>            &#123;<br>                nums[i]=nums[j];<br>                i++;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="交换移除"><a href="#交换移除" class="headerlink" title="交换移除"></a>交换移除</h3><p>当遇到<code>nums[i]=val</code> 时，可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。被交换的最后一个元素可能是想要移除的值，但是在下一次迭代中，仍然会检查这个元素。</p><p>这种思路在移除元素较少时更适合使用，最极端的情况是没有元素需要移除，遍历一遍结束即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]==val)<br>            &#123;<br>                nums[i]=nums[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-comment">// 数组长度 -1</span><br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                i++;               <br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h1 id="524-通过删除字母匹配到字典里最长单词-medium"><a href="#524-通过删除字母匹配到字典里最长单词-medium" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词[medium]"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/">524. 通过删除字母匹配到字典里最长单词</a>[medium]</h1><h2 id="解法：双指针-8"><a href="#解法：双指针-8" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>使用双指针来判断一个字符串是否为另一个字符串的子序列。利用两个指针<code>i</code>和<code>j</code>，一个指向<code>s</code>字符串，一个指向<code>target</code>字符串，每一次查找过程中,<code>i</code>依次后移，若<code>i,j</code>对应的两个字符相等，则<code>j</code>后移，如果<code>j</code>可以移到<code>target.length()</code>，那么说明<code>target</code>中的字符<code>s</code>中都有，即<code>s</code>删除一些字符后，可以得到<code>target</code>字符串。最后一步就是比较当前的结果与找到的<code>target</code>字符串，按照题目的需求来决定是否改变结果字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; d)</span> </span>&#123;<br>        string res=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;d.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> l1=res.<span class="hljs-built_in">length</span>();<br>            <span class="hljs-type">int</span> l2=d[i].<span class="hljs-built_in">length</span>();<br>            <span class="hljs-comment">// 若字符串更短或者一样长且字母顺序较大的直接舍去</span><br>            <span class="hljs-keyword">if</span>(l1&gt;l2||(l1==l2&amp;&amp;res.<span class="hljs-built_in">compare</span>(d[i])&lt;<span class="hljs-number">0</span>))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSubStr</span>(s,d[i]))<br>                res=d[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStr</span><span class="hljs-params">(string s,string target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">length</span>()&amp;&amp;j&lt;target.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==target[j])<br>                j++;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j==target.<span class="hljs-built_in">length</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Two Pointers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Binary Search</title>
    <link href="/2020/09/10/Leetcode%20Notes%E2%80%94%E2%80%94Binary%20Search/"/>
    <url>/2020/09/10/Leetcode%20Notes%E2%80%94%E2%80%94Binary%20Search/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>二分查找</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。思路、核心思想等搬运自 @<a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">liweiwei1419</a> 提供的方法论。</p><span id="more"></span><h1 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h1><ul><li>分析题意，挖掘题目中隐含的 <strong>单调性</strong>；</li><li><code>while(left &lt; right)</code>退出循环的时候有 <code>left == right</code> 成立，因此无需考虑返回 <code>left</code> 还是 <code>right</code>；</li><li>始终思考下一轮搜索区间是什么，如果是 <code>[mid, right]</code> 就对应 <code>left = mid</code> ，如果是 <code>[left, mid - 1]</code> 就对应 <code>right = mid - 1</code>，是保留 <code>mid</code>还是 +1、-1 就在这样的思考中完成；</li><li><strong>从一个元素什么时候不是解开始考虑下一轮搜索区间是什么</strong> ，把区间分为 2 个部分（一个部分肯定不存在目标元素，另一个部分有可能存在目标元素），问题会变得简单很多，这是一条 <strong>非常有用</strong> 的经验；</li><li>每一轮区间被划分成 2 部分，理解 <strong>区间划分</strong> 决定中间数取法（ <strong>无需记忆，需要练习 + 理解</strong> ），在调试的过程中理解 <strong>区间和中间数划分的配对关系</strong>：<ul><li>划分 <code>[left, mid]</code> 与 <code>[mid + 1, right]</code> ， <code>mid</code>被分到左边，对应 <code>int mid = left + (right - left) / 2</code>；</li><li>划分 <code>[left, mid - 1]</code> 与 <code>[mid, right]</code>， <code>mid</code> 被分到右边，对应 <code>int mid = left + (right - left + 1) / 2</code>。</li></ul></li></ul><blockquote><p>至于为什么划分是这种对应关系，原因在于区间只有 2 个数的时候，如果中间数的取法不对，<strong>一旦进入的分支不能使得区间缩小</strong>，会出现 <strong>死循环</strong>。暂时不理解问题不大，需要在练习中进行调试；</p></blockquote><ul><li>退出循环的时候有 <code>left == right</code> 成立，此时如果能确定问题一定有解，返回 <code>left</code>即可，如果不能确定，需要单独判断一次。</li></ul><h1 id="二分查找的核心思想"><a href="#二分查找的核心思想" class="headerlink" title="二分查找的核心思想"></a>二分查找的核心思想</h1><p>二分查找的核心思想是「减而治之」，即「不断缩小问题规模」。</p><p><strong>二分查找的两种思路（请特别留意第 2 种思路，掌握它能思路清晰地解决「力扣」上的所有二分查找问题）</strong></p><h2 id="思路-1：在循环体内部查找元素"><a href="#思路-1：在循环体内部查找元素" class="headerlink" title="思路 1：在循环体内部查找元素"></a>思路 1：在循环体内部查找元素</h2><ul><li><code>while(left &lt;= right)</code>这种写法表示在循环体内部直接查找元素；</li><li>退出循环的时候 <code>left</code> 和 <code>right</code> 不重合，区间 <code>[left, right]</code>是空区间。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115632.gif" style="zoom: 67%;" /><h2 id="思路-2：在循环体内部排除元素（重点）"><a href="#思路-2：在循环体内部排除元素（重点）" class="headerlink" title="思路 2：在循环体内部排除元素（重点）"></a>思路 2：在循环体内部排除元素（重点）</h2><ul><li><code>while(left &lt; right)</code>这种写法表示在循环体内部排除元素；</li><li>退出循环的时候 <code>left</code> 和 <code>right</code> 重合，区间 <code>[left, right]</code> 只剩下成 1 个元素，这个元素 <strong>有可能</strong> 就是我们要找的元素。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115611.gif"  style="zoom: 67%;" /><p>第 2 种思路可以归纳为「左右边界向中间走，两边夹」，这种思路在解决复杂问题的时候，可以使得思考的过程变得简单。</p><h1 id="为什么总是写不对「二分查找」"><a href="#为什么总是写不对「二分查找」" class="headerlink" title="为什么总是写不对「二分查找」"></a>为什么总是写不对「二分查找」</h1><p>二分查找不难，更多时候在考察是否细心。弄不清楚边界条件，有可能是在背模板，没有搞清楚二分查找的思想和里面非常细节的地方。</p><ul><li><p>经验是把区间定义成为：左闭右闭区间，两个变量向中间走，定义的左右边界理应是无差别的，<strong>定义成左闭右开，反而增加了解决问题的的复杂程度</strong>，因为还要去考虑右边界是否能够取到，即使定义成左闭右开区间 <code>[left, right)</code> 也一定对应一个等价的左闭右闭区间 <code>[left, right - 1]</code>；</p><blockquote><p>友情提示：这里所说的二分查找的左闭右闭区间的具体定义如下：<strong>在区间 [left, right] 里可能存在目标元素</strong>，在二分搜索的过程中需要保持这个定义。而「滑动窗口」问题，习惯性定义成左闭右开 [left, right)，这是因为滑动窗口问题的特点是，右指针先向右移动，左指针再向右移动，右指针主动，左指针被动，因此地位是不一样的，滑动窗口问题定义成左闭右开的好处有 2 点。第一，初始化的时候 left &#x3D; 0 和 right &#x3D; 0 这是相对自然的，第二，滑动窗口的长度为 right - left 不用加 1。</p></blockquote></li><li><p>明确 <code>int = left + (right - left) / 2</code> 这里除以 2 是下取整（想一想上取整可以吗，什么时候需要上取整，为什么是除以 2 ，其它整数行不行）；</p></li><li><p>明确 <code>while(left &lt;= right)</code> 和 <code>while(left &lt; right)</code>这两种写法在思路上有本质差别，里面的逻辑该怎么写，应该做到彻底理解；</p></li><li><p>始终在思考下一轮搜索区间是什么，这一点对应上面所说的：「始终将区间认为是 <strong>左闭右闭</strong> 区间」，这样就能帮助我们搞清楚边界是不是能取到，等于、+1 、−1 之类的细节；</p></li><li><p>思考清楚每一行代码背后的语义是什么，保证语义上清晰，也是写对代码，减少 bug 的一个非常有效的方法；</p></li><li><p>不能忽视一个很重要的方法是 <strong>调试</strong>。它不是什么很高超的技巧，就是把变量的值打印出来看一下，相信就能解决为什么写出的代码会造成死循环的问题，并得出解决方案。</p></li></ul><p>写对二分查找算法是基于我们的思考，并且认真对待遇到的二分查找问题，<strong>通过挖掘单调性，使得问题规模不断缩小</strong> 。</p><h1 id="二分查找的三种题型"><a href="#二分查找的三种题型" class="headerlink" title="二分查找的三种题型"></a>二分查找的三种题型</h1><h2 id="在一个数组里查找一个数，简称为「二分下标」"><a href="#在一个数组里查找一个数，简称为「二分下标」" class="headerlink" title="在一个数组里查找一个数，简称为「二分下标」"></a>在一个数组里查找一个数，简称为「二分下标」</h2><p>一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。</p><h2 id="查找一个有范围的整数，简称为「二分答案」"><a href="#查找一个有范围的整数，简称为「二分答案」" class="headerlink" title="查找一个有范围的整数，简称为「二分答案」"></a>查找一个有范围的整数，简称为「二分答案」</h2><p>如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p><h2 id="复杂的二分查找问题，「最大值最小化」"><a href="#复杂的二分查找问题，「最大值最小化」" class="headerlink" title="复杂的二分查找问题，「最大值最小化」"></a>复杂的二分查找问题，「最大值最小化」</h2><p>通过一个变量与另一个变量的相关关系，进而确定目标变量的值，统称为「复杂问题」，通常这一类问题的判别函数需要遍历整个数组。</p><p>目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。这一类问题可以统称为「 <strong>最大值极小化</strong> 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题。</p><p>解题的思路是这样的：</p><ul><li>分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；</li><li>分析出<strong>单调性</strong>，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果；</li><li>这一类问题的题目条件一定会给出<strong>连续、正整数</strong>这样的关键字，如果没有，问题场景也一定蕴含了这两个关键信息。</li></ul><h1 id="题型一：在数组中查找符合条件的元素的下标"><a href="#题型一：在数组中查找符合条件的元素的下标" class="headerlink" title="题型一：在数组中查找符合条件的元素的下标"></a>题型一：在数组中查找符合条件的元素的下标</h1><h2 id="35-搜索插入位置-easy"><a href="#35-搜索插入位置-easy" class="headerlink" title="35. 搜索插入位置[easy]"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a>[easy]</h2><h3 id="解法一：暴力循环搜索"><a href="#解法一：暴力循环搜索" class="headerlink" title="解法一：暴力循环搜索"></a>解法一：暴力循环搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=target)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>插入位置的下标是 <strong>大于等于</strong> <code>target</code> 的第 1 个元素的位置。因此，<strong>严格小于 <code>target</code> 的元素一定不是解</strong>，在循环体中将左右边界 <code>left</code> 和 <code>right</code> 逐渐向中间靠拢，最后 <code>left</code> 和 <code>right</code>相遇，则找到了插入元素的位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 nums.size()</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 小于 target 的元素一定不是解</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索的区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是 [left, mid]</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(logN)，N 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的。</li><li>空间复杂度：O(1)，使用到常数个临时变量。</li></ul><h2 id="704-二分查找-easy"><a href="#704-二分查找-easy" class="headerlink" title="704. 二分查找[easy]"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>[easy]</h2><h3 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><h4 id="while-left-lt-right-写法"><a href="#while-left-lt-right-写法" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束条件 left==right，此时 nums[left]还没看</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="while-left-lt-right-写法-1"><a href="#while-left-lt-right-写法-1" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束条件[right,left]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置-medium"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-medium" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置[medium]"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>[medium]</h2><h3 id="解法：二分查找-1"><a href="#解法：二分查找-1" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p><strong>查找 target 出现的第 1 个位置</strong></p><ul><li>如果当前看到的元素恰好等于<code>target</code>，那么当前元素有可能是 <code>target</code> 出现的第 1 个位置，因为我们要找第 1 个位置，此时应该向左边继续查找。</li><li>如果当前看到的元素严格大于<code>target</code>，那么当前元素一定不是要找的 <code>target</code> 出现的第 1 个位置，第 1 个位置肯定出现在 <code>mid</code> 的 <strong>左边</strong> ，因此就需要在 <code>[left, mid]</code>区间里继续查找。</li><li>如果当前看到的元素严格小于<code>target</code>，那么当前元素一定不是要找的<code>target</code>出现的第 1 个位置，第 1 个位置肯定出现在 <code>mid</code> 的 <strong>右边</strong> ，因此就需要在 <code>[mid + 1, right]</code>区间里继续查找。</li></ul><p><strong>查找 target 出现的最后 1 个位置</strong></p><p>与上述相似。</p><h4 id="while-left-lt-right-写法-2"><a href="#while-left-lt-right-写法-2" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> first=<span class="hljs-built_in">findFirstPosition</span>(nums,target);<br>        <span class="hljs-keyword">if</span>(first==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> last=<span class="hljs-built_in">findLastPosition</span>(nums,target);<br>        <span class="hljs-keyword">return</span> &#123;first,last&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirstPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                 <span class="hljs-comment">// 下一轮搜索区间是 [left, mid]</span><br>                right=mid;<br>            <span class="hljs-comment">// 小于一定不是解</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// nums[mid] &gt; target，下一轮搜索区间是 [left, mid - 1]</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断未搜索的元素</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLastPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 如果采用下取整会陷入死循环，因此采用上取整</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid, right]</span><br>                left=mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// nums[mid] &gt; target，下一轮搜索区间是 [left, mid - 1]</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不用判断未搜索元素是因为主调函数中先搜索 first，如果 first 未找到则 last 不可能找到</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="while-left-lt-right-写法-3"><a href="#while-left-lt-right-写法-3" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> first=<span class="hljs-built_in">findFirstPosition</span>(nums,target);<br>         <span class="hljs-comment">// 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置</span><br>        <span class="hljs-keyword">if</span>(first==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> last=<span class="hljs-built_in">findLastPosition</span>(nums,target);<br>        <span class="hljs-keyword">return</span> &#123;first,last&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirstPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// ①不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 此时 nums[mid] &gt; target，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置</span><br>        <span class="hljs-comment">// 因此还需要特别做一次判断</span><br>        <span class="hljs-keyword">if</span>(left!=nums.<span class="hljs-built_in">size</span>()&amp;&amp;nums[left]==target)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLastPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>   <br>                <span class="hljs-comment">// 此时 nums[mid] &gt; target，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>寻找第 1 次出现的位置解释：</strong></p><p><code>nums[mid] == target</code> 的时候，在 <code>[left, mid - 1]</code> 区间里找，有没有可能 <code>nums[mid]</code> 就是第 1 次出现的位置，有可能，但不要紧，退出循环的时候 <code>right</code> 指针在左，<code>left</code> 在右。<strong>如果数组里存在 <code>target</code>，那么 <code>left</code> 一定位于 <code>target</code>出现的第 1 个位置</strong>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115555.png" style="zoom:67%;" /><p>还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：</p><ul><li><p>target 很大，还是上面的例子</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115547.png" style="zoom:67%;" /></li><li><p>target 很小，还是上面的例子</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115541.png" style="zoom:67%;" /></li></ul><p>以上特殊例子，解释了为什么在 <code>while (left &lt;= right)</code> 退出循环以后，需要单独判断 <code>left</code> 是否越界，以及判断 <code>nums[left]</code>是不是目标元素的原因。</p><p><strong>寻找最后 1 次出现的位置解释：</strong></p><p>为什么返回 <code>right</code> 解释如下图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115530.png" style="zoom:67%;" /><p>这里注意：无需讨论不存在的情况。这是因为先执行了 <code>findFirstPosition()</code>方法，这个方法如果返回 -1，显然知道数组里不存在目标元素，可以直接返回 <code>[-1, -1]</code>。</p><h2 id="153-寻找旋转排序数组中的最小值-medium"><a href="#153-寻找旋转排序数组中的最小值-medium" class="headerlink" title="153. 寻找旋转排序数组中的最小值[medium]"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a>[medium]</h2><h3 id="解法一：暴力法遍历数组"><a href="#解法一：暴力法遍历数组" class="headerlink" title="解法一：暴力法遍历数组"></a>解法一：暴力法遍历数组</h3><p>遍历找最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num&lt;minNum)<br>                minNum=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>通过数组旋转后的特点找到最小值，即最小值比它前面的元素小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h3 id="解法二：二分查找-1"><a href="#解法二：二分查找-1" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>思路：看看当前搜索区间的 <strong>右边界</strong> 和「中间数」，是不是可以缩小搜索区间的范围。</p><ul><li><p>当中间数比右边界表示的数大的时候，中间数就一定不是目标数（旋转排序数组的最小值）。</p><p>例 ：<code>[7, 8, 9, 10, 11, 12, 1, 2, 3]</code></p><p>「中间数」 11 比右边界 3 大，因此中间数左边的数（包括中间数）都不是「旋转排序数组」的最小值，把左边界设置中间数位置 + 1，即 <code>left = mid + 1</code>。</p></li><li><p>当中间数比右边界表示的数小的时候，中间数就可能是目标数（旋转排序数组的最小值）。</p><p>例 ：<code>[7, 8, 1, 2, 3]</code></p><p>「中间数」 1 比右边界 3 小，说明，中间数到右边界是递增的，那么中间数右边的（不包括中间数）一定不是「旋转排序数组」的最小值，可以把它们排除，但中间数有可能是整个数组中的最小值，就如本例，因此把右边界设置为 <code>right = mid</code>。</p></li></ul><p>为什么比较  <code>mid</code> 和 <code>right</code> 查看 @<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">armeria</a> 题解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                <span class="hljs-comment">// 中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid </span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                <span class="hljs-comment">// 中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束，left == right</span><br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logn)，空间复杂度 O(1)。</p><h3 id="解法三：分治法"><a href="#解法三：分治法" class="headerlink" title="解法三：分治法"></a>解法三：分治法</h3><p>将原问题划分成若干与原问题同结构且规模更小的子问题，等到这些子问题解决了以后，原问题也得到了解决，思路基本与二分查找相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-comment">// 这一步是关键</span><br>        <span class="hljs-keyword">if</span>(nums[left]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>            <span class="hljs-comment">// 左边是顺序数组，[left + 1, mid] 这个区间里的元素可以不看</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            <span class="hljs-comment">// 右边是顺序数组，[mid + 1 , right] 这个区间里的元素可以不看</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,mid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logn)，空间复杂度 O(logn)。</p><h2 id="154-寻找旋转排序数组中的最小值-II-hard"><a href="#154-寻找旋转排序数组中的最小值-II-hard" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II[hard]"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a>[hard]</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 的延伸题目，数组中可能存在重复的元素。</p><h3 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h3><p>和 153 题思路一样，还是比较中间数和右边界，与 153 题相比，多了一种可能性。</p><ul><li><p>当中间数与右边界表示的数相等的时候：</p><p>例 1：<code>[0, 1, 1, 1, 1, 1, 1]</code>，例2 ：<code>[1, 1, 1, 1, 0, 1, 1]</code></p><p>目标值可能在中间数的左边，也可能在中间数的右边，那么该怎么办呢？很简单，此时看到的是右边界，就只把右边界排除掉就好了。正是因为右边界和中间数相等，去掉了右边界，中间数还在，就让中间数在后面的循环中被发现。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                right=mid;<br>            <span class="hljs-keyword">else</span> <br>                right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logn)，空间复杂度 O(1)。</p><h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件，区间里只有 1 个元素的时候，返回这个元素</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-keyword">if</span>(nums[left]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-comment">// 分治：设置分治的界限</span><br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,mid);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,right<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logn)，空间复杂度 O(logn)。</p><h2 id="33-搜索旋转排序数组-medium"><a href="#33-搜索旋转排序数组-medium" class="headerlink" title="33. 搜索旋转排序数组[medium]"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>[medium]</h2><h3 id="解法一：将-「旋转数组查找目标值」-转化成-「有序数组查找目标值」"><a href="#解法一：将-「旋转数组查找目标值」-转化成-「有序数组查找目标值」" class="headerlink" title="解法一：将 「旋转数组查找目标值」 转化成 「有序数组查找目标值」"></a>解法一：将 「旋转数组查找目标值」 转化成 「有序数组查找目标值」</h3><ul><li>使用 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 的方法找出最小值的索引，将数组分成两个有序数组。</li><li>根据 <code>nums[0]</code> 与 <code>target</code> 的关系判断 <code>target</code> 在左段还是右段，再对升序数组进行二分查找。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-built_in">findMin</span>(nums,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(minIndex==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>,target);<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;target)<br>            <span class="hljs-comment">// 目标值在右段</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,minIndex,length<span class="hljs-number">-1</span>,target);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 目标值在左段</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,minIndex<span class="hljs-number">-1</span>,target);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 153.寻找旋转排序数组中的最小值 稍作修改，改成返回最小值索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 有序数组查找目标值（704. 二分查找）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：直接对旋转数组进行二分查找"><a href="#解法二：直接对旋转数组进行二分查找" class="headerlink" title="解法二：直接对旋转数组进行二分查找"></a>解法二：直接对旋转数组进行二分查找</h3><p>将待搜索区间从中间一分为二，**<code>mid</code> 一定会落在其中一个有序区间里**。即中间元素把待搜索区间分成了两部分，两部分具有的性质是至少有一部分是有序的。</p><h4 id="while-left-lt-right-写法-4"><a href="#while-left-lt-right-写法-4" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><h5 id="讨论中间元素和右边界的关系"><a href="#讨论中间元素和右边界的关系" class="headerlink" title="讨论中间元素和右边界的关系"></a>讨论中间元素和右边界的关系</h5><p>因为不存在重复元素，所以它们的关系不是大于就是小于。</p><ol><li><p>情况 1：<code>nums[mid] &lt; nums[right]</code>，当中间元素的数值严格小于右边界的数值时候</p><ul><li><p>此时区间 <code>[mid, right]</code> 一定是有序的。</p></li><li><p><code>target</code> 要么在有序区间 <code>[mid, right]</code> 里，要么在另一个区间 <code>[left, mid - 1]</code> 里。</p><ul><li><code>target</code> 落在有序区间 <code>[mid, right]</code>，即：<code>nums[mid] &lt;= target &lt;= nums[right]</code>，此时设置 <code>left = mid</code>；</li><li>落在另一个区间 <code>[left, mid - 1]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>right = mid - 1</code>。</li></ul><p><strong>关键</strong>：把比较好些的判断（<code>target</code> 落在有序的那部分）放在 <code>if</code> 的开头考虑，把剩下的情况放在 <code>else</code> 里面。</p></li></ul></li><li><p>情况 2：<code>nums[mid] &gt; nums[right]</code>，当中间元素的数值严格大于右边界的数值时候</p><ul><li>此时区间 <code>[left, mid]</code> 内的元素一定是有序的。</li><li><code>target</code> 要么在有序区间 <code>[left, mid]</code> 里，要么在另一个区间 <code>[mid + 1, right]</code> 里。</li><li><code>target</code>落在有序区间 <code>[left, mid]</code> ，即：<code>nums[left] &lt;= target &lt;= nums[mid]</code>，此时设置 <code>right = mid</code>；</li><li>落在另一个区间 <code>[mid + 1, right]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>left = mid + 1</code>。</li></ul></li><li><p>此时发现：情况 1 分支左右边界的收缩情况是：<code>left = mid</code> 与 <code>right = mid - 1</code>，情况 2 分支左右边的收缩情况是：<code>left = mid + 1</code> 与 <code>right = mid</code>，为了让二者一致，在情况 1 里强行只认为 <code>[mid+1, right]</code> 有序。这样左右边界的收缩情况就和情况 2 一样了。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 右半部分有序</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 后处理，有可能区间内不存在目标元素，因此还需做一次判断</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="讨论中间元素和左边界的关系"><a href="#讨论中间元素和左边界的关系" class="headerlink" title="讨论中间元素和左边界的关系"></a>讨论中间元素和左边界的关系</h5><p>与上述讨论思路相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 右半部分有序</span><br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 后处理</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="while-left-lt-right-写法-5"><a href="#while-left-lt-right-写法-5" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><p>这种写法可以避免收缩情况不统一。</p><h5 id="讨论中间元素和左边界的关系-1"><a href="#讨论中间元素和左边界的关系-1" class="headerlink" title="讨论中间元素和左边界的关系"></a>讨论中间元素和左边界的关系</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-comment">// 这里是 &gt;= 而不是 &gt; 是为了最后只剩下两个数的时候，则么和逻辑匹配</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[left])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="讨论中间元素和右边界的关系-1"><a href="#讨论中间元素和右边界的关系-1" class="headerlink" title="讨论中间元素和右边界的关系"></a>讨论中间元素和右边界的关系</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-comment">// 这里是 &lt;</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="81-搜索旋转排序数组-II-medium"><a href="#81-搜索旋转排序数组-II-medium" class="headerlink" title="81. 搜索旋转排序数组 II[medium]"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a>[medium]</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 的延伸题目，数组中可能存在重复的元素。</p><h3 id="解法：二分查找-2"><a href="#解法：二分查找-2" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>和 33 题思路一样，还是讨论中间元素和左边界（或者有边界）的关系，只不过当中间元素等于边界的情况下，无法判断有序性，仅可排除掉边界，与 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 思想一致。</p><h4 id="while-left-lt-right-写法-6"><a href="#while-left-lt-right-写法-6" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><p>这里仅讨论中间元素和左边界关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">// 落在前有序数组里</span><br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">// 让分支和上面分支一样</span><br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 要排除掉左边界之前，先看一看左边界可以不可以排除</span><br>                <span class="hljs-keyword">if</span>(nums[left]==target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span><br>                    left++;<br>            &#125;              <br>        &#125;<br>        <span class="hljs-comment">// 后处理</span><br>        <span class="hljs-keyword">if</span>(nums[left]==target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="while-left-lt-right-写法-7"><a href="#while-left-lt-right-写法-7" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><p>这里仅讨论中间元素和左边界关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==nums[left])<br>                left++;<br>            <span class="hljs-comment">//前半部分有序</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">//target在前半部分</span><br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//后半部分有序</span><br>                <span class="hljs-comment">//target在后半部分</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="162-寻找峰值-medium"><a href="#162-寻找峰值-medium" class="headerlink" title="162. 寻找峰值[medium]"></a><a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a>[medium]</h2><h3 id="解法：二分查找-3"><a href="#解法：二分查找-3" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><blockquote><p>寻找局部极大极小值问题。</p></blockquote><p>在题目描述中出现了 <code>nums[-1] = nums[n] = -∞</code>，这就代表着 <strong>只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值</strong>。比较 <code>nums[m]</code> 与  <code>nums[m+1]</code> 的值，如果 <code>nums[m]</code> 较大，则左侧存在峰值，<code>right=mid</code> ，如果 <code>nums[m+1]</code>  较大，则右侧存在峰值，<code>left=mid+1</code> 。</p><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,left,mid);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,mid+<span class="hljs-number">1</span>,right); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(logN)。</p><h4 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(1)。</p><h2 id="852-山脉数组的峰顶索引-easy"><a href="#852-山脉数组的峰顶索引-easy" class="headerlink" title="852. 山脉数组的峰顶索引[easy]"></a><a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a>[easy]</h2><h3 id="解法：二分查找-4"><a href="#解法：二分查找-4" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>与 <a href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a> 思路相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1095-山脉数组中查找目标值-hard"><a href="#1095-山脉数组中查找目标值-hard" class="headerlink" title="1095. 山脉数组中查找目标值[hard]"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/">1095. 山脉数组中查找目标值</a>[hard]</h2><h3 id="解法：二分查找-5"><a href="#解法：二分查找-5" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>“山脉数组”可以分为两部分，一部分是前升序数组 ，另一部分是后降序数组。因此可以分为 3 步：</p><ol><li>找到山顶元素 <code>mountaintop</code> 所在的索引；</li><li>在前有序且升序数组中找 <code>target</code> 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；</li><li>如果步骤 2 找不到，就在后有序且降序数组中找 <code>target</code> 所在的索引。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the MountainArray&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * class MountainArray &#123;</span><br><span class="hljs-comment"> *   public:</span><br><span class="hljs-comment"> *     int get(int index);</span><br><span class="hljs-comment"> *     int length();</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=mountainArr.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> mountaintop=<span class="hljs-built_in">findMountainTop</span>(mountainArr,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> res=<span class="hljs-built_in">findFromFrontSortedArr</span>(mountainArr,<span class="hljs-number">0</span>,mountaintop,target);<br>        <span class="hljs-keyword">if</span>(res!=<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFromBackSortedArr</span>(mountainArr,mountaintop<br>        +<span class="hljs-number">1</span>,length<span class="hljs-number">-1</span>,target);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 返回山顶元素（162. 寻找峰值）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMountainTop</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;mountainArr.<span class="hljs-built_in">get</span>(mid+<span class="hljs-number">1</span>))<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 在前有序且升序数组中找 target 所在的索引（704. 二分查找）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFromFrontSortedArr</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 后处理：因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span><br>        <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(left)!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 在后有序且降序数组中找 target 所在的索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFromBackSortedArr</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(left)!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4. 寻找两个正序数组的中位数[hard]"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a>[hard]</h2><h3 id="解法一：合并数组"><a href="#解法一：合并数组" class="headerlink" title="解法一：合并数组"></a>解法一：合并数组</h3><p>先将两个有序数组合并，然后根据数组长度是奇数还是偶数，返回中位数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> length2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(length1+length2)</span></span>;<br>        <span class="hljs-comment">// 合并两个有序数组</span><br>        <span class="hljs-type">int</span> p1=<span class="hljs-number">0</span>,p2=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;length1&amp;&amp;p2&lt;length2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[p1]&lt;=nums2[p2])<br>                nums[p++]=nums1[p1++];<br>            <span class="hljs-keyword">else</span><br>                nums[p++]=nums2[p2++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p1&lt;length1)<br>            nums[p++]=nums1[p1++];<br>        <span class="hljs-keyword">while</span>(p2&lt;length2)<br>            nums[p++]=nums2[p2++];<br>        <span class="hljs-comment">// 返回中位数</span><br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(length%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (nums[length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+nums[length/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> nums[length/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(m+n)，空间复杂度 O(m+n)。</p><h3 id="解法二：直接取中位数"><a href="#解法二：直接取中位数" class="headerlink" title="解法二：直接取中位数"></a>解法二：直接取中位数</h3><p>不需要将两个数组真的合并，只需要找到中位数在哪里。</p><p>首先是怎么将奇数和偶数的情况合并一下。用 <code>len</code> 表示合并后数组的长度，如果是奇数，需要知道第 <code>(len+1)/2</code>个数就可以了，如果遍历的话需要遍历 <code>len/2+1</code> 次。如果是偶数，需要知道第 <code>len/2</code>和 <code>len/2+1</code> 个数，也是需要遍历 <code>len/2+1</code> 次。所以遍历的话，奇数和偶数都是 <code>len/2+1</code> 次。</p><p>返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以用两个变量 <code>left</code> 和 <code>right</code>， <code>right</code>保存当前循环的结果，在每次循环前将 <code>right</code>的值赋给 <code>left</code> 。这样在最后一次循环的时候， <code>left</code> 将得到 <code>right</code>的值，也就是上一次循环的结果，接下来 <code>right</code>更新为最后一次的结果。</p><p>循环中该怎么写，什么时候 <code>A</code> 数组后移，什么时候 <code>B</code> 数组后移。用 <code>aStart</code> 和 <code>bStart</code> 分别表示当前指向 <code>A</code> 数组和 <code>B</code> 数组的位置。如果 <code>aStart</code> 还没有到最后并且此时 <code>A</code> 位置的数字小于<code>B</code>位置的数组，那么就可以后移了。也就是<code>aStart&lt;len1&amp;&amp;A[aStart]&lt;=B[bStart]</code>。但如果 <code>B</code> 数组此刻已经没有数字了，继续取数字 <code>B[bStart]</code>，则会越界，所以判断下 <code>bStart</code> 是否大于数组长度了，这样 <code>||</code>后边的就不会执行了，也就不会导致错误了，所以增加为 <code>aStart&lt;len1&amp;&amp;(bStart&gt;=len2||A[aStart]&lt;=B[bStart]) </code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len=len1+len2;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> aStart=<span class="hljs-number">0</span>,bStart=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len/<span class="hljs-number">2</span>;++i)<br>        &#123;<br>            left=right;<br>            <span class="hljs-keyword">if</span>(aStart&lt;len1&amp;&amp;(bStart&gt;=len2||nums1[aStart]&lt;=nums2[bStart]))<br>                right=nums1[aStart++];<br>            <span class="hljs-keyword">else</span><br>                right=nums2[bStart++];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (left+right)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(m+n)，空间复杂度 O(1)。</p><h3 id="解法三：查找第-K-小的数"><a href="#解法三：查找第-K-小的数" class="headerlink" title="解法三：查找第 K 小的数"></a>解法三：查找第 K 小的数</h3><p>上面的思路无法达到时间复杂度要求，看到 <code>log</code>需要使用二分才能达到，这里先用另一种思路，题目求中位数其实是求第 <code>k</code> 小数的一种特殊情况，而求第 <code>k</code>小数有一种算法。</p><p>解法二中，一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，完全可以一半儿一半儿的排除。假设要找第 <code>k</code> 小数，可以每次循环排除掉<code>k/2</code>个数。看下边一个例子。</p><p>假设要找第 7 小的数字。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918144041.png"></p><p>比较两个数组的第<code>k/2</code>个数字，如果<code>k</code>是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前<code>k/2</code>个数字都不是第<code>k</code>小数字，所以可以排除。也就是 1,2,3 这三个数字不可能是第 7 小的数字，可以把它排除掉。将 1,3,4,9 和 4,5,6,7,8,9,10 两个数组作为新的数组进行比较。</p><p>更一般的情况 <code>A[1]</code> ，<code>A[2]</code> ，<code>A[3]</code>，<code>A[k/2]</code> … ，<code>B[1]</code>，<code>B[2]</code>，<code>B[3]</code>，<code>B[k/2]</code> … ，如果 <code>A[k/2]</code>&lt;<code>B[k/2]</code>，那么<code>A[1]</code>，<code>A[2]</code>，<code>A[3]</code>，<code>A[k/2]</code>都不可能是第<code>k</code>小的数字。<code>A</code> 数组中比 <code>A[k/2]</code> 小的数有 <code>k/2-1</code> 个，<code>B</code> 数组中，比<code>B[k/2]</code> 小的数有 <code>k/2-1</code> 个，现在<code>A[k/2]</code>&lt;<code>B[k/2]</code>，假设<code>B[k/2]</code> 前边的数字都比<code>A[k/2]</code> 小，也只有<code>k/2-1+k/2-1=k-2</code> 个，所以 <code>B[k/2]</code>  最多是第<code>k-1</code>小的数。而比 <code>A[k/2]</code> 小的数更不可能是第<code>k</code>小的数了，所以可以把它们排除。</p><p>橙色的部分表示已经去掉的数字。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145512.png"></p><p>由于已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，只需要找第 7 - 3 &#x3D; 4 小的数字就可以了，也就是 k &#x3D; 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以可以把小的那个数组中的 1,3 排除掉了。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145603.png"></p><p>由于又排除掉 2 个数字，所以现在找第 4 - 2 &#x3D; 2 小的数字就可以了。此时比较两个数组中的第 k &#x2F; 2 &#x3D; 1 个数，4 &#x3D;&#x3D; 4，怎么办呢？由于两个数相等，所以无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145708.png"></p><p>由于又去掉 1 个数字，此时要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p><p>所以第 7 小的数字是 4。</p><p>每次都是取<code>k/2</code>的数进行比较，有时候可能会遇到数组长度小于<code>k/2</code>的时候。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111608.png"></p><p>此时 k &#x2F; 2 等于 3，而上边的数组长度是 2，此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111602.png"></p><p>由于 2 个元素被排除，所以此时 k &#x3D; 5，又由于上边的数组已经空了，只需要返回下边的数组的第 5 个数字就可以了。</p><p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对算法并没有影响，而且在算法进行中，<code>k</code>的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p><p>所以采用递归的思路，为了防止数组长度小于<code>k/2</code>，所以每次比较<code>min(k/2,len(数组))</code>对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且<code>k</code>要减去排除的数字的个数。递归出口就是当 <code>k=1</code> 或者其中一个数字长度是 <code>0</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=(len1+len2+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> right=(len1+len2+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">getKth</span>(nums1,<span class="hljs-number">0</span>,len1<span class="hljs-number">-1</span>,nums2,<span class="hljs-number">0</span>,len2<span class="hljs-number">-1</span>,left)+<span class="hljs-built_in">getKth</span>(nums1,<span class="hljs-number">0</span>,len1<span class="hljs-number">-1</span>,nums2,<span class="hljs-number">0</span>,len2<span class="hljs-number">-1</span>,right))/<span class="hljs-number">2.0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1,<span class="hljs-type">int</span> start1,<span class="hljs-type">int</span> end1,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2,<span class="hljs-type">int</span> start2,<span class="hljs-type">int</span> end2,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1=end1-start1+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> len2=end2-start2+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span><br>        <span class="hljs-keyword">if</span>(len1&gt;len2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums2,start2,end2,nums1,start1,end1,k);<br>        <span class="hljs-comment">// 两种 base case</span><br>        <span class="hljs-keyword">if</span>(len1==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> nums2[start2+k<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[start1],nums2[start2]);<br>        <span class="hljs-type">int</span> i=start1+<span class="hljs-built_in">min</span>(len1,k/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=start2+<span class="hljs-built_in">min</span>(len2,k/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(nums1[i]&lt;nums2[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums1,i+<span class="hljs-number">1</span>,end1,nums2,start2,end2,k-(i-start1+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums1,start1,end1,nums2,j+<span class="hljs-number">1</span>,end2,k-(j-start2+<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每进行一次循环，就减少 k&#x2F;2 个元素，所以时间复杂度是 O(log(k)，而 k&#x3D;(m+n)&#x2F;2，所以最终的复杂是 O(log(m+n)。</li><li>空间复杂度：虽然用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)。</li></ul><h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><blockquote><p>中位数（中值），代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。</p></blockquote><p>所以只需要对数组进行切分。</p><p>一个长度为 m 的数组，有 0 到 m 总共 m + 1 个位置可以切。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111554.png" style="zoom:67%;" /><p>把数组 A 和数组 B 分别在 i 和 j 进行切割。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111547.png" style="zoom:67%;" /><p>将 i 的左边和 j 的左边组合成「左半部分」，将 i 的右边和 j 的右边组合成「右半部分」。</p><ul><li><p>当 A 数组和 B 数组的总长度是偶数时，如果能够保证</p><ul><li><p>左半部分的长度等于右半部分</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">i + j = m - i  + <span class="hljs-built_in">n</span> - j  , 也就是 j = ( m + <span class="hljs-built_in">n</span> ) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure></li><li><p>左半部分最大的值小于等于右半部分最小的值 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">max ( A<span class="hljs-comment">[i-1]</span> , B<span class="hljs-comment">[j-1]</span> ) &lt;= min ( A<span class="hljs-comment">[i]</span> , B<span class="hljs-comment">[j]</span> )<br></code></pre></td></tr></table></figure></li></ul><p>那么，中位数就可以表示如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">(左半部分最大值 + 右半部分最小值)/ <span class="hljs-number">2</span>。<br>( max (<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i-1]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j-1]</span>) + min (<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j]</span>) ) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>当 A 数组和 B 数组的总长度是奇数时，如果能够保证</p><ul><li><p>左半部分的长度比右半部分大 1</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> + j = m - i  + n - j  + <span class="hljs-number">1</span> , 也就是 j = ( m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure></li><li><p>左半部分最大的值小于等于右半部分最小的值 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">max ( A<span class="hljs-comment">[i-1]</span> , B<span class="hljs-comment">[j-1]</span> ) &lt;= min ( A<span class="hljs-comment">[i]</span> , B<span class="hljs-comment">[j]</span> )<br></code></pre></td></tr></table></figure></li></ul><p>那么，中位数就是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">左半部分最大值，也就是左半部比右半部分多出的那一个数。<br>max ( <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i-1]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j-1]</span> )<br></code></pre></td></tr></table></figure></li></ul><p>上边的第一个条件可以合并为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">j</span> = ( m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure><p>因为如果 m+n 是偶数，由于取的是 int 值，所以加 1 也不会影响结果。当然，由于 0&lt;&#x3D;i&lt;&#x3D;m ，为了保证 0&lt;&#x3D;j&lt;&#x3D;n，必须保证 m&lt;&#x3D;n。<br>$$<br>m≤n,i&lt;m,j&#x3D;(m+n+1)&#x2F;2−i≥(m+m+1)&#x2F;2−i&gt;(m+m+1)&#x2F;2−m&#x3D;0<br>$$</p><p>$$<br>m≤n,i&gt;0,j&#x3D;(m+n+1)&#x2F;2−i≤(n+n+1)&#x2F;2−i&lt;(n+n+1)&#x2F;2&#x3D;n<br>$$</p><p>最后一步由于是 int 间的运算，所以 1&#x2F;2&#x3D;0。</p><p>对于第二个条件，奇数和偶数的情况是一样的，进一步分析。为了保证 <code>max(A[i-1],B[j-1]) &lt;= min(A[i],B[j])</code>，因为 A 数组和 B 数组是有序的，所以 <code>A[i-1] &lt;= A[i], B[i-1] &lt;= B[i]</code> 这是天然的，所以只需要保证 <code>B[j-1] &lt;= A[i] 和 A[i-1] &lt;= B[j]</code> ，分两种情况讨论：</p><ul><li><p><code>B[j-1] &gt; A[i]</code>，并且为了不越界，要保证 <code> j != 0 , i != m</code></p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111538.png" style="zoom:67%;" /><p>此时需要增加 <code>i</code> ，为了数量的平衡还要减少 <code>j</code> ，幸运的是 <code>j = ( m + n + 1) / 2 - i</code>，<code>i</code>增大，<code>j</code> 自然会减少。</p></li><li><p><code>A[i-1] &gt; B[j]</code> ，并且为了不越界，要保证 <code>i != 0 , j != n</code></p><p>此时和上边的情况相反，需要减少 <code>i</code> ，增大<code>j</code> 。</p></li><li><p>当 <code>i=0</code> , 或者<code>j=0</code>，也就是切在了最前边</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111529.png" style="zoom:67%;" /><p>此时左半部分当 <code>i=0</code> 时 最大的值就是 <code>B[j-1]</code>；当 <code>j=0</code> 时，最大的值就是 <code>A[i-1]</code> 。右半部分最小值和之前一样。</p></li><li><p>当 <code>i=m</code> 或者 <code>j=n</code>，也就是切在了最后边。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111520.png" style="zoom:67%;" /><p>此时左半部分最大值和之前一样。右半部分当<code>i=m</code>时，最小值就是 <code>B[j]</code>；当<code>j=n</code>时，最小值就是 <code>A[i]</code>。</p></li></ul><p>所有的思路都理清了，最后一个问题，增加<code>i</code>的方式。当然用二分了。初始化<code>i</code>为中间的值，然后减半找中间的，减半找中间的，减半找中间的直到答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 保证 m &lt;= n</span><br>        <span class="hljs-keyword">if</span>(m&gt;n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2,nums1);<br>        <span class="hljs-type">int</span> iMin=<span class="hljs-number">0</span>,iMax=m;<br>        <span class="hljs-keyword">while</span>(iMin&lt;=iMax)<br>        &#123;<br>            <span class="hljs-type">int</span> i=iMin+(iMax-iMin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> j=(m+n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>-i;<br>            <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>&amp;&amp;i!=m&amp;&amp;nums2[j<span class="hljs-number">-1</span>]&gt;nums1[i])<br>                <span class="hljs-comment">// i 需要增大</span><br>                iMin=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>&amp;&amp;j!=n&amp;&amp;nums1[i<span class="hljs-number">-1</span>]&gt;nums2[j])<br>                <span class="hljs-comment">// i 需要减小</span><br>                iMax=i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 达到要求，并且将边界条件列出来单独考虑</span><br>                <span class="hljs-type">int</span> maxLeft=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>                    maxLeft=nums2[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    maxLeft=nums1[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span><br>                    maxLeft=<span class="hljs-built_in">max</span>(nums1[i<span class="hljs-number">-1</span>],nums2[j<span class="hljs-number">-1</span>]);<br>                <span class="hljs-keyword">if</span>((m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-comment">// 奇数的话不需要考虑右半部分</span><br>                    <span class="hljs-keyword">return</span> maxLeft;<br>                <span class="hljs-type">int</span> minRight=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(i==m)<br>                    minRight=nums2[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n)<br>                    minRight=nums1[i];<br>                <span class="hljs-keyword">else</span><br>                    minRight=<span class="hljs-built_in">min</span>(nums1[i],nums2[j]);<br>                <span class="hljs-comment">//如果是偶数的话返回结果</span><br>                <span class="hljs-keyword">return</span> (maxLeft+minRight)/<span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：对较短的数组进行了二分查找，时间复杂度是 O(log(min(m,n))。</li><li>空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O(1)。</li></ul><h2 id="658-找到-K-个最接近的元素-medium"><a href="#658-找到-K-个最接近的元素-medium" class="headerlink" title="658. 找到 K 个最接近的元素[medium]"></a><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a>[medium]</h2><h3 id="解法一：排除法（双指针）"><a href="#解法一：排除法（双指针）" class="headerlink" title="解法一：排除法（双指针）"></a>解法一：排除法（双指针）</h3><p>使用排除法删去元素，因为是有序数组，且返回的是连续升序子数组，所以每一次删除的元素一定是位于边界，可以使用双指针对撞的方式确定保留区间，即「最优区间」。</p><p>将 <code>x-arr[left]</code> 与 <code>arr[right]-x</code> 进行比较：</p><ul><li>如果 <code>x-arr[left]</code> 比较小，则将右边界删除，即 <code>right--</code>；</li><li>如果两者相等，因为优先选择数值较小的数，所以将右边界删除，<code>right--</code>；</li><li>如果 <code>arr[right]-x</code> 比较小，则将左边界删除，即 <code>left++</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findClosestElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=length<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> removeNums=length-k;<br>        <span class="hljs-keyword">while</span>(removeNums--&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x-arr[left]&lt;=arr[right]-x)<br>                right--;<br>            <span class="hljs-keyword">else</span><br>                left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>()+left,arr.<span class="hljs-built_in">begin</span>()+left+k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(1)。</p><h3 id="解法二：二分查找最优区间的左边界"><a href="#解法二：二分查找最优区间的左边界" class="headerlink" title="解法二：二分查找最优区间的左边界"></a>解法二：二分查找最优区间的左边界</h3><p>「最优区间的左边界」的下标的搜索区间为 <code>[0, size - k]</code>，从这个区间的任意一个位置（二分法为当前候选区间的中位数）开始，定位一个长度为 <code>(k + 1)</code> 的区间，根据这个区间是否包含 <code>x</code> 开展讨论。<code>left </code>、<code>right </code>是候选区间的左右边界的下标，根据上面的分析，初始时，<code>left = 0</code>，<code>right = size - k</code>。</p><p><strong>情况 1</strong>：如果区间不包含 <code>x</code>：</p><ul><li><p>区间的右端点在 <code>x</code>的左边，即 <code>x</code> 比 <code>arr</code>中最大的元素还要大，由于要去掉 1 个元素，显然去掉左端点，因此「最优区间的左边界」的下标至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>，<strong>因为区间不可能再往左边走了</strong>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111427.png" style="zoom:67%;" /><p>说明：极端情况是此时中位数位于索引 <code>size - k</code>，区间不能右移。</p></li><li><p>区间的左端点在 <code>x</code> 的左边，即 <code>x</code> 比 <code>arr</code> 中最小的元素还要小，当前的区间左端点的下标至多是 <code>mid</code>，此时 <code>right = mid</code>，<strong>因为区间不可能再往右偏了</strong>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111421.png" style="zoom:67%;" /><p>说明：极端情况是此时 <code>mid</code> 位于索引 <code>0</code>，区间不能左移。</p></li></ul><p><strong>情况 2</strong>：如果区间包含 <code>x</code>，尝试删掉一个元素，以便让区间发生移动，缩小搜索范围：</p><p>易知，需要比较长度为 <code>k + 1</code> 的区间的左右端点的数值与 <code>x</code> 的差值的绝对值。此时这个区间的左边界的下标是 <code>mid</code>，右边界的下标是 <code>mid + k</code>。根据解法一（排除法）的结论，分类讨论如下：</p><ul><li><p>如果右边界与 <code>x</code> 的差值的绝对值较小，左边界收缩，可以肯定的是「最优区间的左边界」的下标 <code>left</code> 至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111416.png" style="zoom:67%;" /><p>说明：「右边界与 <code>x</code> 的差值绝对值较小」同样适用于「情况 1.1」，因此它们二者可以合并。</p></li><li><p>如果左边界与 <code>x</code> 的差值的绝对值较小，右边界收缩，此时区间不移动，注意：此时有可能收缩以后的区间就是待求的区间，也有可能整个区间向左移动，这件事情叫做，<code>right = mid</code>，不能排除 <code>mid</code>（下一轮搜索区间是 <code>[left, mid]</code>）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111507.png" style="zoom:67%;" /><p>说明 1：这一点比较难想，但实际上也可以不想，根据「情况 2.1」的结论，左区间收缩的反面即是右区间不收缩，因此，这一分支的逻辑一定是 <code>right = mid</code>。</p><p>说明 2：「左边界与 <code>x</code> 的差的绝对值较小」同样适用于 「情况 1.2」，因此它们二者可以合并。</p></li><li><p>如果左、右边界与 <code>x</code> 的差的绝对值相等，删除右边界，结论同「情况 2.2」，也有 <code>right = mid</code>，可以合并到 「情况 2.2」。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findClosestElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=length-k;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 尝试从长度为 k + 1 的连续子区间删除一个元素，从而定位左区间端点的边界值</span><br>            <span class="hljs-keyword">if</span>(x-arr[mid]&gt;arr[mid+k]-x)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>()+left,arr.<span class="hljs-built_in">begin</span>()+left+k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(log N + K)，空间复杂度 O(1)。</p><h2 id="744-寻找比目标字母大的最小字母-easy"><a href="#744-寻找比目标字母大的最小字母-easy" class="headerlink" title="744. 寻找比目标字母大的最小字母[easy]"></a><a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a>[easy]</h2><h3 id="解法一：线性扫描"><a href="#解法一：线性扫描" class="headerlink" title="解法一：线性扫描"></a>解法一：线性扫描</h3><p>由于 <code>letters</code> 已经有序，当从左往右扫描找到比目标字母大则该字母就是答案。否则(<code>letters</code> 不为空)答案将是 <code>letters[0]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, <span class="hljs-type">char</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter:letters)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(letter&gt;target)<br>                <span class="hljs-keyword">return</span> letter;<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(n)，空间复杂度 O(1)。</p><h3 id="解法二：二分查找-2"><a href="#解法二：二分查找-2" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>想要在有序数组中查找比目标字母大的最小字母，可以使用二分查找：找到最右边的位置将 <code>target</code> 插入 <code>letters</code> 中，以便它保持排序。如果插入位置是最后一个位置 <code>letters.size</code>，则返回 <code>letters[0]</code>。用模运算统一起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, <span class="hljs-type">char</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=letters.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(letters[mid]&lt;=target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[left%letters.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(logN)，空间复杂度 O(1)。</p><h2 id="278-第一个错误的版本-easy"><a href="#278-第一个错误的版本-easy" class="headerlink" title="278. 第一个错误的版本[easy]"></a><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a>[easy]</h2><h3 id="解法：二分查找-6"><a href="#解法：二分查找-6" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The API isBadVersion is defined for you.</span><br><span class="hljs-comment">// bool isBadVersion(int version);</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isBadVersion</span>(mid))<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="题型二：在一个有范围的区间里搜索一个整数"><a href="#题型二：在一个有范围的区间里搜索一个整数" class="headerlink" title="题型二：在一个有范围的区间里搜索一个整数"></a>题型二：在一个有范围的区间里搜索一个整数</h1><h2 id="69-x-的平方根-easy"><a href="#69-x-的平方根-easy" class="headerlink" title="69. x 的平方根[easy]"></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a>[easy]</h2><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><p><code>i</code>从 0 开始递增，计算<code>i</code>的平方并与<code>x</code>比较大小，直到<code>i</code>平方大于<code>x</code>为止。此时，<code>i - 1</code>为所求值（注意，如果<code>i</code>是 int 类型，在某些测试用例下，<code>i</code>平方会溢出，因此采用 long 类型）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i*i&lt;=x)<br>            ++i;<br>        <span class="hljs-keyword">return</span> --i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：二分查找-3"><a href="#解法二：二分查找-3" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>对于一个非负数 <code>n</code>，它的平方根不会大于 <code>n/2+1</code>，因此可在 <code>[0,n/2+1]</code> 范围内进行二分查找。</p><p><code>while(left &lt;= right)</code>写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left=<span class="hljs-number">0</span>,right=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">long</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> square=mid*mid;<br>            <span class="hljs-keyword">if</span>(square==x)<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(square&gt;x)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// while 循环里没有找到符合的 mid ，此时 right&lt;left，返回 right 相当于取整</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>while(left &lt; right)</code>写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left=<span class="hljs-number">0</span>,right=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 注意：这里取右中位数，如果取左中位数，代码会进入死循环</span><br>            <span class="hljs-type">long</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> square=mid*mid;<br>            <span class="hljs-keyword">if</span>(square&gt;x)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-comment">// 因为一定存在，因此无需后处理</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(log N)，空间复杂度 O(1)。</p><h3 id="解法三：牛顿迭代法"><a href="#解法三：牛顿迭代法" class="headerlink" title="解法三：牛顿迭代法"></a>解法三：牛顿迭代法</h3><blockquote><p>牛顿法：在迭代过程中，<strong>以直线代替曲线</strong>，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 <em>x</em> 轴的交点，重复这个过程直到收敛。</p></blockquote><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111405.gif" style="zoom:67%;" /><p>可以参考知乎问答<a href="https://www.zhihu.com/question/20690553">《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》</a>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111959.png" style="zoom:67%;" /><p>求根号 a 的近似值：首先随便猜一个近似值 <em>x</em>，然后不断令 x 等于 x 和 a&#x2F;x 的平均数，迭代几次后 x 的值就相当精确了。</p><p>例如，想求根号 2 等于多少。假如猜测的结果为 4，虽然错的离谱，但可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">( <span class="hljs-number">4</span> + <span class="hljs-number">2</span><span class="hljs-regexp">/ 4 ) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">2.25</span><br>( <span class="hljs-number">2.25</span> + <span class="hljs-number">2</span><span class="hljs-regexp">/ 2.25 ) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.56944</span>..<br>( <span class="hljs-number">1.56944</span>..+ <span class="hljs-number">2</span><span class="hljs-regexp">/1.56944..) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.42189</span>..<br>( <span class="hljs-number">1.42189</span>..+ <span class="hljs-number">2</span><span class="hljs-regexp">/1.42189..) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.41423</span>..<br>….<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> res=x;<br>        <span class="hljs-keyword">while</span>(res*res&gt;x)<br>            res=(res+x/res)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="287-寻找重复数-medium"><a href="#287-寻找重复数-medium" class="headerlink" title="287. 寻找重复数[medium]"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a>[medium]</h2><p>思路注意题目的限制：</p><ol><li>不能更改原数组（假设数组是只读的）。</li><li>只能使用额外的 <code>O(1)</code> 的空间。</li></ol><blockquote><p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。</p></blockquote><h3 id="解法一：用二分法查找一个有范围的整数"><a href="#解法一：用二分法查找一个有范围的整数" class="headerlink" title="解法一：用二分法查找一个有范围的整数"></a>解法一：用二分法查找一个有范围的整数</h3><p>详细思路解释参考 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">liweiwei1419</a> 题解。</p><p>二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>），然后统计原始数组中<strong>小于等于</strong>这个中间数的元素的个数 <code>cnt</code>，如果 <code>cnt</code> <strong>严格大于</strong> <code>mid</code>，（注意加了着重号的部分「小于等于」、「严格大于」）。根据抽屉原理，重复元素就在区间 <code>[left, mid]</code> 里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(num&lt;=mid)<br>                    cnt++;<br>            &#125;<br>            <span class="hljs-comment">// 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，</span><br>            <span class="hljs-comment">// 此时重复元素一定出现在 [1, 4] 区间里</span><br>            <span class="hljs-keyword">if</span>(cnt&gt;mid)<br>                <span class="hljs-comment">// 重复的元素一定出现在 [left, mid] 区间里</span><br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span><br>                <span class="hljs-comment">// [mid + 1, right]</span><br>                <span class="hljs-comment">// 注意：此时需要调整中位数的取法为上取整</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//循环结束条件即left=right，区间只剩下一个元素，即重复值</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(NlogN)，二分法的时间复杂度为 O(logN)，在二分法的内部，执行了一次 for 循环，时间复杂度为 O(N)，故时间复杂度为 O(NlogN)。</li><li>空间复杂度：O(1)，使用了一个 cnt 变量，因此空间复杂度为 O(1)。</li></ul><h3 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h3><p><strong>数组形式的链表</strong></p><p>题目设定的问题是 <code>n+1</code> 个元素都在 <code>[1,n]</code> 这个范围内。可以将这个题目给的特殊的数组当作一个链表来看，数组的下标就是指向元素的指针，把数组的元素也看作指针。如 0 是指针，**指向 <code>nums[0]</code>，而 <code>nums[0]</code> 也是指针，指向 <code>nums[nums[0]]</code>**。</p><p>这样就可以有以下操作：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> point = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    point = nums[point]; <span class="hljs-comment">// 等同于 next = next-&gt;next; </span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>链表中的环</strong></p><p>假设有这样一个样例：[1,2,3,4,5,6,7,8,9,5]。如果按照上面的循环下去就会得到这样一个路径: 1 2 3 4  [5 6 7 8 9] [5 6 7 8 9] [5 6 7 8 9] . . .这样就有了一个环，也就是5 6 7 8 9。point 会一直在环中循环的前进。于是就可以使用双指针寻找环形链表的入环节点，即题目 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>，参见<a href="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-medium">题解</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            fast=nums[nums[fast]];<br>            slow=nums[slow];<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>            &#123;<br>                fast=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(fast!=slow)<br>                &#123;<br>                    fast=nums[fast];<br>                    slow=nums[slow];<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="374-猜数字大小-easy"><a href="#374-猜数字大小-easy" class="headerlink" title="374. 猜数字大小[easy]"></a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a>[easy]</h2><h3 id="解法：二分查找-7"><a href="#解法：二分查找-7" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><h4 id="while-left-lt-right-写法-8"><a href="#while-left-lt-right-写法-8" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Forward declaration of guess API.</span><br><span class="hljs-comment"> * @param  num   your guess</span><br><span class="hljs-comment"> * @return      -1 if num is lower than the guess number</span><br><span class="hljs-comment"> *      1 if num is higher than the guess number</span><br><span class="hljs-comment"> *               otherwise return 0</span><br><span class="hljs-comment"> * int guess(int num);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guessNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">-1</span>)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="while-left-lt-right-写法-9"><a href="#while-left-lt-right-写法-9" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guessNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数，如果取左中位数，代码会进入死循环</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">-1</span>)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-comment">// 最后剩下的数一定是所求，无需后处理</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1300-转变数组后最接近目标值的数组和-medium"><a href="#1300-转变数组后最接近目标值的数组和-medium" class="headerlink" title="1300. 转变数组后最接近目标值的数组和[medium]"></a><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">1300. 转变数组后最接近目标值的数组和</a>[medium]</h2><h3 id="解法：二分查找-8"><a href="#解法：二分查找-8" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><ul><li><p>这道题比较麻烦的是求和以后可能不等于 target ，所以让求「最接近的方案」。而这个烦人的根源是 value 的取值一定得是整数。正是因为题目说 value 是整数，并且「答案不一定是 arr 中的数字」，因此依然可以使用二分查找法确定这个整数值。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173054.png" style="zoom:67%;" /></li><li><p>做题的时候，会发现判别条件很不好写，因为「怎么衡量接近」，度量这个「最接近」的量不好选。因此需要考虑别的方案；</p></li><li><p>最接近的情况是：选定了一个 value 求和以后，恰恰好等于 target。不过更有可能出现的情况是：value 选得小了，「接近程度」变大，而 value 选得大了，「接近程度」变小，反过来也是有可能的。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173116.png" style="zoom:67%;" /></li><li><p>解决方案是：<strong>把边界的上下方的可能的 <code>value</code> 值（一共就两个）都拿出来进行一次比较即可</strong>。</p></li></ul><h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a><strong>写法一</strong></h4><p>如果选择一个阈值 <code>value</code> ，使得它对应的 <code>sum</code> 是第 1 个大于等于 <code>target</code> 的，那么目标值可能在 <code>value</code> 也可能在 <code>value - 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            right=<span class="hljs-built_in">max</span>(num,right);<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-built_in">calculateSum</span>(arr,mid);<br>            <span class="hljs-comment">// 计算第 1 个使得转变后数组的和大于等于 target 的阈值</span><br>            <span class="hljs-keyword">if</span>(sum&gt;target)<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;              <br>        &#125;<br>        <span class="hljs-comment">// 比较阈值线分别定在 left - 1 和 left 的时候与 target 的接近程度</span><br>        <span class="hljs-type">int</span> sum1=<span class="hljs-built_in">calculateSum</span>(arr,left<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> sum2=<span class="hljs-built_in">calculateSum</span>(arr,left);<br>        <span class="hljs-keyword">if</span>(target-sum1&lt;=sum2-target)<br>            <span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            sum+=<span class="hljs-built_in">min</span>(num,value);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a><strong>写法二</strong></h4><p>如果选择一个阈值 <code>value</code> ，使得它对应的 <code>sum</code> 是最后 1 个小于等于 <code>target</code> 的阈值，那么目标值可能在 <code>value</code> 也可能在 <code>value + 1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            right=<span class="hljs-built_in">max</span>(num,right);<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-built_in">calculateSum</span>(arr,mid);<br>            <span class="hljs-comment">// 计算最后 1 个使得转变以后数组的和小于等于 target 的阈值</span><br>            <span class="hljs-keyword">if</span>(sum&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;              <br>        &#125;<br>        <span class="hljs-comment">// 比较阈值线分别定在 left 和 left + 1 的时候与 target 的接近程度</span><br>        <span class="hljs-type">int</span> sum1=<span class="hljs-built_in">calculateSum</span>(arr,left);<br>        <span class="hljs-type">int</span> sum2=<span class="hljs-built_in">calculateSum</span>(arr,left+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 注意：这里必须加绝对值，因为有可能出现 sum1 == sum2 &lt; target 的情况</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target-sum1)&lt;=<span class="hljs-built_in">abs</span>(sum2-target))<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> left+<span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            sum+=<span class="hljs-built_in">min</span>(num,value);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(NlogN)，N 是输入数组的长度，二分的时间复杂度是 O(logN)，每一次 <code>calculateSum</code>的时间复杂度是 O(N)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="题型三：复杂的二分查找问题（最大值最小化）"><a href="#题型三：复杂的二分查找问题（最大值最小化）" class="headerlink" title="题型三：复杂的二分查找问题（最大值最小化）"></a>题型三：复杂的二分查找问题（最大值最小化）</h1><h2 id="410-分割数组的最大值-hard"><a href="#410-分割数组的最大值-hard" class="headerlink" title="410. 分割数组的最大值[hard]"></a><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a>[hard]</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>&#x3D;&#x3D;#todo&#x3D;&#x3D;（留着以后填坑）</p><h3 id="解法二：二分查找-贪心"><a href="#解法二：二分查找-贪心" class="headerlink" title="解法二：二分查找+贪心"></a>解法二：二分查找+贪心</h3><p>注意题目中给出的这 3 个条件：</p><ul><li>数组中的元素均是「非负整数」；</li><li>子数组的特点是：「非空」且「连续」；</li><li>恰好分成 m 个非空「非空连续子数组」。</li></ul><p>题目中还给出了一个概念：「连续子数组各自和的最大值」，用一个变量 <code>maxIntervalSum</code> 表示。不难知道：</p><ul><li>每一个「非空连续子数组」如果包含的元素个数越多，那么<code>maxIntervalSum</code> 就可能越大（非负整数保证）；</li><li>一个<code>maxIntervalSum</code> 的数值就唯一对应了一个分出的「非空连续子数组」的组数 <strong><code>M</code></strong> ，它们是函数关系（一一对应），<code>maxIntervalSum</code>是自变量，**<code>M</code>**是因变量，可以写成：M &#x3D; function(maxIntervalSum)</li></ul><p>如何找到一个<code>maxIntervalSum</code>，使得它对应的**<code>M</code><strong>恰好等于题目给出的</strong><code>m</code>**。容易分析出，这个函数是一个单调递减的函数：</p><ul><li>如果 <code>maxIntervalSum</code> 越小，分出的「非空连续子数组」的组数**<code>M</code>**就越大；</li><li>如果 <code>maxIntervalSum</code>  越大，分出的「非空连续子数组」的组数**<code>M</code>**就越小。</li></ul><p>因此这个函数是单调不增的函数。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200928111521.png" style="zoom:67%;" /><p>原因就在于上面强调的题目中给出的 2 个条件：非负整数和非空连续子数组，**由于这种单调性，可以使用二分查找，找到与 <code>m</code> 对应的 <code>maxIntervalSum</code>**。</p><p><strong>重点理解：</strong></p><ol><li><strong>大于的时候舍弃，小于等于的时候保留，这样左右向中间逼近能找到 <code>M</code> 的最小值</strong>；</li><li>理解贪心算法的应用，在从左向右划分组的时候，尽量让一个组有更多的元素，直至超过了设定的临界值。</li></ol><p><strong>代码细节：</strong></p><ul><li>**只要连续加起来的数值超过了 <code>maxIntervalSum</code>**，就新产生一个新的连续子数组；</li><li><code>maxIntervalSum</code>的最小值是这个数组中的最大值，这是因为<code>max(nums)</code>一定会被分到其中一组；</li><li><code>maxIntervalSum</code>的最大值是这个数组中所有元素的和，极端情况就是题目中给出**<code>m=1</code>**的时候。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算「子数组各自的和的最大值」的上下界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:nums)<br>        &#123;<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-comment">// 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m</span><br>        <span class="hljs-type">int</span> left=maxNum;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> splits=<span class="hljs-built_in">split</span>(nums,mid);<br>            <span class="hljs-keyword">if</span>(splits&gt;m)<br>                <span class="hljs-comment">// 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是上一轮的反面区间 [left, mid]</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * @param nums 原始数组</span><br><span class="hljs-comment">     * @param maxIntervalSum 子数组各自的和的最大值</span><br><span class="hljs-comment">     * @return 满足不超过「子数组各自的和的最大值」的分割数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">split</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> maxIntervalSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 至少是一个分割</span><br>        <span class="hljs-type">int</span> splits=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 当前区间的和</span><br>        <span class="hljs-type">int</span> curIntervalSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:nums)<br>        &#123;<br>            <span class="hljs-comment">// 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶</span><br>            <span class="hljs-keyword">if</span>(curIntervalSum+num&gt;maxIntervalSum)<br>            &#123;<br>                curIntervalSum=<span class="hljs-number">0</span>;<br>                splits++;<br>            &#125;<br>            curIntervalSum+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> splits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(Nlog∑nums)，N 表示输入数组的长度，∑nums 表示输入数组的和，代码在 [max(nums),∑nums] 区间里使用二分查找找到目标元素，而每一次判断分支需要遍历一遍数组，时间复杂度为 O(N)；</li><li>空间复杂度：O(1) ，只使用到常数个临时变量。</li></ul><h2 id="1011-在-D-天内送达包裹的能力-medium"><a href="#1011-在-D-天内送达包裹的能力-medium" class="headerlink" title="1011. 在 D 天内送达包裹的能力[medium]"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a>[medium]</h2><h3 id="解法：二分查找-贪心"><a href="#解法：二分查找-贪心" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>思路与 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> D)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:weights)<br>        &#123;<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-type">int</span> left=maxNum;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> days=<span class="hljs-built_in">day</span>(weights,mid);<br>            <span class="hljs-keyword">if</span>(days&gt;D)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights,<span class="hljs-type">int</span> maxIntervalSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> days=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> curIntervalSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:weights)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(curIntervalSum+num&gt;maxIntervalSum)<br>            &#123;<br>                curIntervalSum=<span class="hljs-number">0</span>;<br>                days++;<br>            &#125;<br>            curIntervalSum+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="875-爱吃香蕉的珂珂-medium"><a href="#875-爱吃香蕉的珂珂-medium" class="headerlink" title="875. 爱吃香蕉的珂珂[medium]"></a><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a>[medium]</h2><h3 id="解法：二分查找-贪心-1"><a href="#解法：二分查找-贪心-1" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p><ul><li>珂珂吃香蕉的速度越小，耗时越多。反之，速度越大，耗时越少，这是这个问题的<strong>单调性</strong>；</li><li>搜索的是速度。因为题目限制了珂珂一个小时之内只能选择一堆香蕉吃，因此速度最大值就是这几堆香蕉中，数量最多的那一堆。速度的最小值是 1，其实还可以再分析一下下界是多少，由于二分搜索的时间复杂度很低，严格的分析不是很有必要；</li><li>还是因为珂珂一个小时之内只能选择一堆香蕉吃，因此：<strong>每堆香蕉吃完的耗时 &#x3D; 这堆香蕉的数量 &#x2F; 珂珂一小时吃香蕉的数量</strong>，这里的 &#x2F; 在不能整除的时候，需要<strong>上取整</strong>。</li><li><strong>注意</strong>：当目前的速度恰好使得珂珂在规定的时间内吃完香蕉的时候，还应该去尝试更小的速度是不是还可以保证在规定的时间内吃完香蕉。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> H)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:piles)<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>        <span class="hljs-comment">// 速度最小的时候，耗时最长</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 速度最大的时候，耗时最短</span><br>        <span class="hljs-type">int</span> right=maxNum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> hours=<span class="hljs-built_in">hour</span>(piles,mid);<br>            <span class="hljs-comment">// 耗时太多，说明速度太慢了，下一轮搜索区间在 [mid + 1, right]</span><br>            <span class="hljs-keyword">if</span>(hours&gt;H)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果返回的小时数严格大于 H，就不符合题意</span><br><span class="hljs-comment">     * @param piles</span><br><span class="hljs-comment">     * @param speed</span><br><span class="hljs-comment">     * @return 需要的小时数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hour</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> speed)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> hours=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:piles)<br>            <span class="hljs-comment">// 上取整</span><br>            hours+=(num+speed<span class="hljs-number">-1</span>)/speed;<br>        <span class="hljs-keyword">return</span> hours;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>关于上取整：</strong></p><p>写成 <code>hours += num / speed</code> 是下取整，为了把下取整改成上取整（根据题目要求需要上取整）。</p><p>因此，需要在分子加上「分母的值 - 1」，这样就可以改变默认 <code>/</code> 下取整的行为。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(Nlogmax(piles))，N 表示数组 piles 的长度。在 [1,max(piles)] 里使用二分查找定位最小速度，而每一次执行判别函数的时间复杂度是 O(N)。</li><li>空间复杂度：O(1)，算法只使用了常数个临时变量。</li></ul><h2 id="LCP-12-小张刷题计划-medium"><a href="#LCP-12-小张刷题计划-medium" class="headerlink" title="LCP 12. 小张刷题计划[medium]"></a><a href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/">LCP 12. 小张刷题计划</a>[medium]</h2><h3 id="解法：二分查找-贪心-2"><a href="#解法：二分查找-贪心-2" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似，区别就只在于这个问题的场景，提示使用贪心算法，贪心的点是「每一天把耗时最多的问题交给小杨去做」。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; time, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取一天最多耗时是多少</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:time)<br>            sum+=num;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<span class="hljs-comment">//T</span><br>            <span class="hljs-comment">// 计算需要的天数</span><br>            <span class="hljs-type">int</span> days=<span class="hljs-built_in">day</span>(time,mid);<br>            <span class="hljs-keyword">if</span>(days&gt;m)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; time,<span class="hljs-type">int</span> maxTime)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> days=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> curMax=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curTime=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:time)<br>        &#123;<br>            curMax=<span class="hljs-built_in">max</span>(curMax,num);<br>            <span class="hljs-comment">// 每一天把耗时最多的问题交给小杨去做，这是贪心的思想，即 -curMax</span><br>            <span class="hljs-comment">// 当耗时超过 maxTime 时就重新换一天</span><br>            <span class="hljs-keyword">if</span>(curTime+num-curMax&gt;maxTime)<br>            &#123;<br>                curMax=num;<br>                curTime=<span class="hljs-number">0</span>;<br>                days++;<br>            &#125;<br>            curTime+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1482-制作-m-束花所需的最少天数-medium"><a href="#1482-制作-m-束花所需的最少天数-medium" class="headerlink" title="1482. 制作 m 束花所需的最少天数[medium]"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a>[medium]</h2><h3 id="解法：二分查找-贪心-3"><a href="#解法：二分查找-贪心-3" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bloomDay, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> flowerSum=bloomDay.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 总花数小于制作花束需要的花的数量</span><br>        <span class="hljs-keyword">if</span>(m*k&gt;flowerSum)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 计算最大等待天数</span><br>        <span class="hljs-type">int</span> maxDays=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day:bloomDay)<br>            maxDays=<span class="hljs-built_in">max</span>(maxDays,day);<br>        <span class="hljs-comment">// 二分等待天数 waitDays</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=maxDays;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 制作的花束的数量</span><br>            <span class="hljs-type">int</span> bouquetNum=<span class="hljs-built_in">bouquet</span>(bloomDay,mid,k);<br>            <span class="hljs-comment">// 制作的花束数量太少，需要等待更多天</span><br>            <span class="hljs-keyword">if</span>(bouquetNum&lt;m)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 可以制作多少束花</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bouquet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bloomDay,<span class="hljs-type">int</span> Waitdays,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> bouquetNum=<span class="hljs-number">0</span>;<span class="hljs-comment">//花束数量</span><br>        <span class="hljs-type">int</span> flowerNum=<span class="hljs-number">0</span>;<span class="hljs-comment">//花数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day:bloomDay)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(day&lt;=Waitdays)<br>            &#123;<br>                flowerNum++;<br>                <span class="hljs-comment">//相邻的花的数量达到了制作花束的要求</span><br>                <span class="hljs-keyword">if</span>(flowerNum==k)<br>                &#123;<br>                    bouquetNum++;<br>                    flowerNum=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 因为花需要相邻，因此置 0</span><br>            <span class="hljs-keyword">else</span><br>                flowerNum=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bouquetNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="1552-两球之间的磁力-medium"><a href="#1552-两球之间的磁力-medium" class="headerlink" title="1552. 两球之间的磁力[medium]"></a><a href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a>[medium]</h2><h3 id="解法：二分查找-贪心-4"><a href="#解法：二分查找-贪心-4" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p><p>首先要找到二分搜索的边界，根据题意，要返回的是最小磁力，所以第一步要找到最小磁力的最小可能取值和最大可能取值。</p><ul><li>对于最小可能取值，是给定数组中距离最近的两个位置之间的磁力，所以对数组进行排序，并遍历数组找到相邻两个位置的最小距离。在这里直接初始化为 0，并不会增加多少次二分查找。</li><li>对于最大可能取值，一共有 m 个球，所以有 m - 1 个间隔，最大的可能取值便是最平均的取值，所以根据给定数组最大值与最小值之差与间隔数的比值计算出平均距离，就是给定的最大可能取值。</li></ul><p>确定好了边界后，每次二分搜索时需要判断当前计算值是否满足条件，这里引入 ball 函数，计算当前最小磁力时能放置的球数。计算过程使用贪心算法，遍历数组，若找到两位置之间距离大于等于最小磁力，则计数值加 1。在计算出能放置的球数 m 后，进行二分搜索边界的缩减。当球数小于 m 时，说明此时的最小磁力太大，放置不了 m 个球，因此需要减小，即将右边界左移，看稍小的数值是否满足条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; position, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// 排序以便计算初始左右边界</span><br>        <span class="hljs-built_in">sort</span>(position.<span class="hljs-built_in">begin</span>(),position.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始右边界</span><br>        <span class="hljs-type">int</span> right=(position.<span class="hljs-built_in">back</span>()-position.<span class="hljs-built_in">front</span>())/(m<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 对最小磁力进行二分搜索</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 计算当前最小磁力下能放置的球数</span><br>            <span class="hljs-type">int</span> balls=<span class="hljs-built_in">ball</span>(position,mid);<br>            <span class="hljs-comment">// 当前磁力无法放置 m 个球，需要减小磁力，右边界左移</span><br>            <span class="hljs-keyword">if</span>(balls&lt;m)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 返回当前最小磁力能放置的球数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ball</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; position,<span class="hljs-type">int</span> minDistance)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> balls=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始为 1 个球</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;position.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(position[j]-position[i]&gt;=minDistance)<br>            &#123;<br>                balls++;<br>                i=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> balls;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binary Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Array and Matrix</title>
    <link href="/2020/08/30/Leetcode%20Notes%E2%80%94%E2%80%94Array%20and%20Matrix/"/>
    <url>/2020/08/30/Leetcode%20Notes%E2%80%94%E2%80%94Array%20and%20Matrix/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>数组与矩阵</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a href="https://leetcode.wang/">wind-liang</a> 题解、<a href="https://github.com/chenBright/leetcode">chenBright</a> 题解。</p><span id="more"></span><h1 id="283-移动零-easy"><a href="#283-移动零-easy" class="headerlink" title="283. 移动零[easy]"></a><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a>[easy]</h1><h2 id="解法一：双指针（交换）——一次遍历"><a href="#解法一：双指针（交换）——一次遍历" class="headerlink" title="解法一：双指针（交换）——一次遍历"></a>解法一：双指针（交换）——一次遍历</h2><p>参考快速排序的思想，快速排序首先要确定一个待分割的元素做中间点<code>x</code>，然后把所有小于等于<code>x</code>的元素放到<code>x</code>的左边，大于<code>x</code>的元素放到其右边。<br>这里可以用<code>0</code>当做这个中间点，把不等于<code>0</code>（注意题目没说不能有负数）的放到中间点的左边，等于<code>0</code>的放到其右边。这里的中间点就是<code>0</code>本身，所以实现比快速排序简单，使用两个指针<code>i</code>和<code>j</code>，只要<code>nums[i]!=0</code>，就交换<code>nums[i]</code>和<code>nums[j]</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200830112035.gif" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[j++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法二：双指针（不交换）——两次遍历"><a href="#解法二：双指针（不交换）——两次遍历" class="headerlink" title="解法二：双指针（不交换）——两次遍历"></a>解法二：双指针（不交换）——两次遍历</h2><p>其实可以不需要交换，只要将非<code>0</code>元素移动到数组前面，再在后面补<code>0</code>即可。</p><p>创建两个指针<code>i</code>和<code>j</code>，第一次遍历的时候指针<code>j</code>用来记录当前有多少非<code>0</code>元素。即遍历的时候每遇到一个非<code>0</code>元素就将其往数组左边挪，第一次遍历完后，<code>j</code>指针的下标就指向了最后一个非<code>0</code>元素下标。第二次遍历的时候，起始位置就从<code>j</code>开始到结束，将剩下的这段区域内的元素全部置为<code>0</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200830105505.gif" style="zoom:67%;" /><p>该实现的最坏情况是：存在大量的<code>0</code>元素，例如<code>[0 0 0 ... 0 1]</code>。最后需要补<code>n - 1</code>个<code>0</code>。但是基于交换的实现，只需要交换一次即可，不需要其他操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//将非0元素移动到数组前面</span><br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)<br>                nums[j++]=nums[i];<br>        &#125;<br>        <span class="hljs-comment">//在数组后面补0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=j;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>            nums[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="566-重塑矩阵-easy"><a href="#566-重塑矩阵-easy" class="headerlink" title="566. 重塑矩阵[easy]"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a>[easy]</h1><h2 id="解法一：借助队列"><a href="#解法一：借助队列" class="headerlink" title="解法一：借助队列"></a>解法一：借助队列</h2><p>借助队列来放置按行提取的元素。然后，取出以串行顺序形成的队列元素，并再次按行逐行排列所得到的所需矩阵中的元素。如果原始矩阵中的元素数量不等于所得矩阵中的元素数量，则不可能形成所得矩阵，直接返回原始矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||r*c!=nums.<span class="hljs-built_in">size</span>()*nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> nums;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> row:nums)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> col:row)<br>                q.<span class="hljs-built_in">push</span>(col);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;++j)<br>            &#123;<br>                tmp.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">front</span>());<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;            <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m*n)。遍历 m∗n 元素两次。m 和 n 分别表示给定矩阵的行数和列数。</li><li>空间复杂度：O(m*n）。形成的队列大小为 m∗n 。</li></ul><h2 id="解法二：不用额外空间"><a href="#解法二：不用额外空间" class="headerlink" title="解法二：不用额外空间"></a>解法二：不用额外空间</h2><h3 id="逐行顺序迭代"><a href="#逐行顺序迭代" class="headerlink" title="逐行顺序迭代"></a>逐行顺序迭代</h3><p>不使用队列，而是在逐行顺序迭代给定矩阵的同时，直接将数字放在结果矩阵中。在将数字放入结果数组时，固定一个特定的行，并继续增加列数，直到到达 c 指示的所需列的末尾。此时，通过递增来更新行索引，并将列索引重置为从 0 开始。因此，可以节省队列消耗的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||r*c!=nums.<span class="hljs-built_in">size</span>()*nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> nums;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> rows=<span class="hljs-number">0</span>,cols=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                res[rows][cols]=nums[i][j];<br>                cols++;<br>                <span class="hljs-keyword">if</span>(cols==c)<br>                &#123;<br>                    rows++;<br>                    cols=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="除法和取模"><a href="#除法和取模" class="headerlink" title="除法和取模"></a>除法和取模</h3><p>在上面的写法中，需要跟踪何时到达结果矩阵的列的末尾，并且需要通过每次检查当前索引来更新当前行和列号以放置提取的元素。实际可以利用数学运算来帮助解决，而不是在每一步都进行限制性检查。</p><p>二维数组在内存中存储时表示为一维数组，二维数组<code>nums[m][n]</code>在存储元素<code>nums[i][j]</code>时实际索引到<code>nums[n*i+j]</code>。而我们需要以相反的顺序处理。因此设置一个变量<code>count</code>来统计已放置的元素个数，<code>res[count/c][count%c]</code>即为当前元素应放置的位置，<code>c</code>为<code>reshape</code>后的列数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||r*c!=nums.<span class="hljs-built_in">size</span>()*nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> nums;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                res[count/c][count%c]=nums[i][j];<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(m*n)。遍历 m∗n 个元素。m 和 n 分别表示给定矩阵的行数和列数。</li><li>空间复杂度：O(1)。</li></ul><h1 id="485-最大连续1的个数-easy"><a href="#485-最大连续1的个数-easy" class="headerlink" title="485. 最大连续1的个数[easy]"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续1的个数</a>[easy]</h1><h2 id="解法一：数组遍历"><a href="#解法一：数组遍历" class="headerlink" title="解法一：数组遍历"></a>解法一：数组遍历</h2><p>遍历数组，记录连续 1 的个数，比较是否是当前最大个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxCount=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">1</span>)<br>                <span class="hljs-comment">//记录连续1的个数</span><br>                count++;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//更新最大连续1个数</span><br>                maxCount=<span class="hljs-built_in">max</span>(count,maxCount);<br>                <span class="hljs-comment">//归零，寻找下一个连续序列</span><br>                count=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后一次连续序列在循环中无法比较，所以在循环外进行比较</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(count,maxCount);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：滑动窗口"><a href="#解法二：滑动窗口" class="headerlink" title="解法二：滑动窗口"></a>解法二：滑动窗口</h2><blockquote><p>当输出或比较的结果在原数据结构中是连续排列的时候，可以使用滑动窗口算法求解。</p></blockquote><p>将两个指针比作一个窗口，通过移动指针的位置改变窗口的大小，观察窗口中的元素是否符合题意。</p><ul><li>初始窗口中只有数组开头一个元素。</li><li>当窗口中所有元素为 1 时，右指针向右移，扩大窗口。</li><li>当窗口中存在 0 时，计算连续序列长度，左指针指向右指针。</li></ul><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120144.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxCount=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right&lt;nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-comment">//当窗口中所有元素为1时，右指针向右移，扩大窗口</span><br>            <span class="hljs-keyword">if</span>(nums[right++]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">//当窗口中存在0时，计算连续序列长度，左指针指向右指针</span><br>                maxCount=<span class="hljs-built_in">max</span>(maxCount,right-left<span class="hljs-number">-1</span>);<br>                left=right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后一次连续序列在循环中无法比较，所以在循环外进行比较</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxCount,right-left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="74-搜索二维矩阵-medium"><a href="#74-搜索二维矩阵-medium" class="headerlink" title="74. 搜索二维矩阵[medium]"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a>[medium]</h1><h2 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h2><p>输入的 <code>m x n</code> 矩阵可以视为长度为 <code>m x n</code>的有序数组，即可将二维矩阵的搜索转化为一维数组的二分查找问题。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200903152003.png" style="zoom:67%;" /><blockquote><p>该虚数组的索引与二维矩阵中的行和列的转化规则为： <code>row = idx / n</code> 、 <code>col = idx % n</code> 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//二分查找</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=m*n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> midElem=matrix[mid/n][mid%n];<br>            <span class="hljs-keyword">if</span>(target==midElem)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;midElem)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : 标准的二分查找，时间复杂度为 O(log(mn))，即 O(logm + logn)。</li><li>空间复杂度 : O(1)。</li></ul><h2 id="解法二：从右上角向左下角查找"><a href="#解法二：从右上角向左下角查找" class="headerlink" title="解法二：从右上角向左下角查找"></a>解法二：从右上角向左下角查找</h2><p>从右上角向左下角查找：</p><ol><li>如果<code>matrix[row][col] == target</code>，则查找成功。</li><li>如果<code>matrix[row][col] &gt; target</code>，则继续向左查找，即列左移<code>col--</code>。</li><li>如果<code>matrix[row][col] &lt; target</code>，则继续向下查找，即行下移<code>row++</code>。</li></ol><p>如果结束都没有查找成功，则查找失败。</p><p>也可以从左下角向右上角查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> row=<span class="hljs-number">0</span>,col=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(row&lt;m&amp;&amp;col&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==matrix[row][col])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;matrix[row][col])<br>                <span class="hljs-comment">//向左查找</span><br>                col--;<br>            <span class="hljs-keyword">else</span>  <br>                <span class="hljs-comment">//向下查找</span><br>                row++;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : O(m+n)。</li><li>空间复杂度 : O(1)。</li></ul><h1 id="240-搜索二维矩阵-II-medium"><a href="#240-搜索二维矩阵-II-medium" class="headerlink" title="240. 搜索二维矩阵 II[medium]"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a>[medium]</h1><h2 id="解法一：二分查找-1"><a href="#解法一：二分查找-1" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h2><h3 id="逐行查找"><a href="#逐行查找" class="headerlink" title="逐行查找"></a>逐行查找</h3><p>一行一行的进行二分查找，结合有序的性质，一些情况可以提前结束。</p><ul><li>某一行的第一个元素大于了<code>target</code>，当前行和后边的所有行都不用考虑了，直接返回<code>false</code>。</li><li>某一行的最后一个元素小于了<code>target</code>，当前行就不用考虑了，换下一行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//逐行二分查找</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//第一种情况</span><br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>]&gt;target)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">//第二种情况</span><br>            <span class="hljs-keyword">if</span>(matrix[i][matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>]&lt;target)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">binarySearch</span>(matrix[i],target))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> end=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(start&lt;=end)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=start+(end-start)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                start=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                end=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : O(mlog(n))。</li><li>空间复杂度 : O(1)。</li></ul><h3 id="以对角线上的元素为起点，对行和列进行二分查找"><a href="#以对角线上的元素为起点，对行和列进行二分查找" class="headerlink" title="以对角线上的元素为起点，对行和列进行二分查找"></a>以对角线上的元素为起点，对行和列进行二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> row=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> shortDim=<span class="hljs-built_in">min</span>(row,col); <span class="hljs-comment">//找出最短的边</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;shortDim;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">binarySearch</span>(matrix,target,i,<span class="hljs-literal">true</span>)||<span class="hljs-built_in">binarySearch</span>(matrix,target,i,<span class="hljs-literal">false</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//vertical为true，表示对列进行搜索，则index为列的索引，start、mid、end为行索引</span><br>    <span class="hljs-comment">//vertical为false，表示对行进行搜索，则index为行的索引，start、mid、end为列索引</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> index,<span class="hljs-type">bool</span> vertical)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> start=index;<br>        <span class="hljs-type">int</span> end=vertical?matrix.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>:matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(start&lt;=end)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=start+(end-start)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(vertical)<br>            &#123;<br>                 <span class="hljs-comment">//对列进行二分查找</span><br>                <span class="hljs-keyword">if</span>(matrix[mid][index]==target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[mid][index]&gt;target)<br>                    end=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    start=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//对行进行二分查找</span><br>                <span class="hljs-keyword">if</span>(matrix[index][mid]==target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[index][mid]&gt;target)<br>                    end=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    start=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : O(log(n!))。</li><li>空间复杂度 : O(1)。</li></ul><h3 id="对数组分块进行二分查找"><a href="#对数组分块进行二分查找" class="headerlink" title="对数组分块进行二分查找"></a>对数组分块进行二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(matrix,target,<span class="hljs-number">0</span>,matrix.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> lowRow,<span class="hljs-type">int</span> highRow,<span class="hljs-type">int</span> lowCol,<span class="hljs-type">int</span> highCol)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(lowRow&gt;highRow||lowCol&gt;highCol)<br>            <span class="hljs-comment">//区域为空</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;matrix[lowRow][lowCol]||target&gt;matrix[highRow][highCol])<br>            <span class="hljs-comment">//target 比数组中最小的数还小或者比最大的数还大</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> midCol=lowCol+(highCol-lowCol)/<span class="hljs-number">2</span>;<span class="hljs-comment">// 找到中间的列</span><br>        <span class="hljs-type">int</span> row=lowRow;<br>        <span class="hljs-comment">//查找中间列中第一个比target大的数。</span><br>        <span class="hljs-comment">//此时以row行、midCol列为届，将数组为成4部分，</span><br>        <span class="hljs-comment">//其中，左上角部分的数字肯定比target小，右下角部分的数字肯定比target 大。</span><br>        <span class="hljs-comment">//只有左下角和右上角部分的数字未确定，则递归在这两部分数组中查找。</span><br>        <span class="hljs-keyword">while</span>(row&lt;=highRow&amp;&amp;matrix[row][midCol]&lt;=target)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[row][midCol]==target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            row++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(matrix,target,row,highRow,lowCol,midCol<span class="hljs-number">-1</span>)||<span class="hljs-built_in">search</span>(matrix,target,lowRow,row<span class="hljs-number">-1</span>,midCol+<span class="hljs-number">1</span>,highCol);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : O(nlogn)。</li><li>空间复杂度 : O(1)。</li></ul><h2 id="解法二：从右上角向左下角查找-1"><a href="#解法二：从右上角向左下角查找-1" class="headerlink" title="解法二：从右上角向左下角查找"></a>解法二：从右上角向左下角查找</h2><p>思路与 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a> 解法二相同，也可以从左下角向右上角查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> row=<span class="hljs-number">0</span>,col=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(row&lt;m&amp;&amp;col&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==matrix[row][col])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;matrix[row][col])<br>                col--;<br>            <span class="hljs-keyword">else</span>  <br>                row++;<br>        &#125; <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度 : O(m+n)。</li><li>空间复杂度 : O(1)。</li></ul><h1 id="378-有序矩阵中第K小的元素-medium"><a href="#378-有序矩阵中第K小的元素-medium" class="headerlink" title="378. 有序矩阵中第K小的元素[medium]"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第K小的元素</a>[medium]</h1><h2 id="解法一：直接排序"><a href="#解法一：直接排序" class="headerlink" title="解法一：直接排序"></a>解法一：直接排序</h2><p>将这个二维数组另存为一维数组，并对该一维数组进行排序。最后这个一维数组中的第 k 个数即为答案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> row:matrix)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:row)<br>                res.<span class="hljs-built_in">push_back</span>(elem);<br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res[k<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n^2logn)，对 n^2 个数排序。</li><li>空间复杂度：O(n^2)，一维数组需要存储这 n^2 个数。</li></ul><h2 id="解法二：归并排序"><a href="#解法二：归并排序" class="headerlink" title="解法二：归并排序"></a>解法二：归并排序</h2><p>矩阵的每一行均为一个有序数组。问题即转化为从这 n 个有序数组中找第 k 小的数，可以利用归并排序的做法，归并到第 k 个数即可停止。一般归并排序是两个数组归并，而本题是 n 个数组归并，所以需要用小根堆维护，以优化时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;,vector&lt;pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;&gt;,compare&gt; que;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>            que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(matrix[i][<span class="hljs-number">0</span>],<span class="hljs-built_in">make_pair</span>(i,<span class="hljs-number">0</span>)));<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">while</span>(k--)<br>        &#123;<br>            <span class="hljs-type">int</span> elem=que.<span class="hljs-built_in">top</span>().first;<br>            <span class="hljs-type">int</span> i=que.<span class="hljs-built_in">top</span>().second.first;<br>            <span class="hljs-type">int</span> j=que.<span class="hljs-built_in">top</span>().second.second;<br>            res=elem;<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(j!=n<span class="hljs-number">-1</span>)<br>                que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(matrix[i][j+<span class="hljs-number">1</span>],<span class="hljs-built_in">make_pair</span>(i,j+<span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; &amp;a,<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; &amp;b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//小根堆为&gt;</span><br>            <span class="hljs-keyword">return</span> a.first&gt;b.first;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(klogn)，归并 k 次，每次堆中插入和弹出的操作时间复杂度均为 logn。</li><li>空间复杂度：O(n)，堆的大小始终为 n。</li></ul><h2 id="解法三：二分查找"><a href="#解法三：二分查找" class="headerlink" title="解法三：二分查找"></a>解法三：二分查找</h2><ol><li>找出二维矩阵中最小的数 left，最大的数 right，那么第 k 小的数必定在 left~right 之间；</li><li>mid&#x3D;(left+right) &#x2F; 2；在二维矩阵中寻找小于等于 mid 的元素个数 count；<ul><li>若这个count 小于 k，表明第 k 小的数在右半部分且不包含 mid，即 left&#x3D;mid+1, right&#x3D;right，又保证了第 k 小的数在 left~right 之间。</li><li>若这个count 大于 k，表明第 k 小的数在左半部分且可能包含 mid，即 left&#x3D;left, right&#x3D;mid，又保证了第 k 小的数在 left~right 之间。</li></ul></li><li>因为每次循环中都保证了第 k 小的数在 left~right 之间，当 left&#x3D;&#x3D;right 时，第 k 小的数即被找出，等于 left。</li></ol><p>注意：这里的 left、mid、right 是数值，不是索引位置。</p><p>取 mid&#x3D;8 时寻找小于等于 mid 的元素个数示意图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115744.png" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],right=matrix[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//找二维矩阵中&lt;=mid的元素总个数</span><br>            <span class="hljs-type">int</span> count=<span class="hljs-built_in">findNotBiggerThanMid</span>(matrix,mid,n);<br>            <span class="hljs-keyword">if</span>(count&lt;k)<br>                <span class="hljs-comment">//第k小的数在右半部分，且不包含mid</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//第k小的数在左半部分，可能包含mid</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNotBiggerThanMid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix,<span class="hljs-type">int</span> mid,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>         <span class="hljs-comment">//以列为单位找，找到每一列最后一个&lt;=mid的数即知道每一列有多少个数&lt;=mid</span><br>        <span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&lt;n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]&lt;=mid)<br>            &#123;<br>                <span class="hljs-comment">//第j列有i+1个元素&lt;=mid</span><br>                count+=i+<span class="hljs-number">1</span>;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">//第j列目前的数大于mid，需要继续在当前列往上找</span><br>                i--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(nlog(r−l))，二分查找进行次数为 O(log(r−l))，每次操作时间复杂度为 O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="645-错误的集合-easy"><a href="#645-错误的集合-easy" class="headerlink" title="645. 错误的集合[easy]"></a><a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a>[easy]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>单独检查 1 到 n 的所有数字。在检查每个数字时都遍历整个 nums 数组，检查当前数字在 nums 中是否出现了两次，或者一次都没有出现。使用 dup 和 missing 记录重复数字和缺失数字。一旦找到这两个数字，就提前结束查找过程。</p><p>C++超时，Java不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] findErrorNums(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-type">int</span> dup=-<span class="hljs-number">1</span>,missing=-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.length;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;nums.length;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[j]==i)<br>                    count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count==<span class="hljs-number">2</span>)<br>                dup=i;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)<br>                missing=i;<br>            <span class="hljs-keyword">if</span>(dup&gt;<span class="hljs-number">0</span>&amp;&amp;missing&gt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;dup,missing&#125;;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n^2)。在最坏的情况下，需要在 1 到 n 的每个数字上遍历一次 nums。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法二：使用map"><a href="#解法二：使用map" class="headerlink" title="解法二：使用map"></a>解法二：使用map</h2><p>使用哈希表统计数组中元素出现的次数，再检查 1 到 n 的每个数字在哈希表中出现次数，即可找出缺失数字和重复数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> dup=<span class="hljs-number">-1</span>,missing=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums)<br>            mp[n]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp[i]==<span class="hljs-number">2</span>)<br>                dup=i;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mp[i]==<span class="hljs-number">0</span>)<br>                missing=i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;dup,missing&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。遍历 nums 需要时间 O(n)，在 map 中检查每个数字需要时间 O(n)。</li><li>空间复杂度：O(n)，map 需要存储数组元素。</li></ul><h2 id="解法三：利用数组索引"><a href="#解法三：利用数组索引" class="headerlink" title="解法三：利用数组索引"></a>解法三：利用数组索引</h2><p>通过不断交换数组元素，让每个元素<code>nums[i]</code>放在索引位置<code>nums[i]-1</code>上，数组变成<code>[1,2,3,4,5...n]</code>。然后通过判断<code>nums[i]!=i+1</code>找到重复元素和缺失元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(nums[i]!=nums[nums[i]<span class="hljs-number">-1</span>])<br>                <span class="hljs-built_in">swap</span>(nums[i],nums[nums[i]<span class="hljs-number">-1</span>]);<br>        &#125; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=i+<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> &#123;nums[i],i+<span class="hljs-number">1</span>&#125;;<br>        &#125;          <br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法四：异或"><a href="#解法四：异或" class="headerlink" title="解法四：异或"></a>解法四：异或</h2><p>需要一个 [1, 2, …n] 的数组作为辅助，假设重复元素为 dup，丢失元素为 mis。将原数组和辅助数组所有元素进行异或，可知其中等于 dup 的有3个，mis有1个（在辅助数组中），其余元素各有2个。在异或运算过程中，成对出现的都会抵消为 0。最后的结果就是 dup^mis。接下来问题就转化为如何将 dup 和 mis 分开，参考 <a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#2%EF%BC%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%89%E4%B8%80%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A5%87%E6%95%B0%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BB%96%E6%95%B0%E9%83%BD%E5%87%BA%E7%8E%B0%E4%BA%86%E5%81%B6%E6%95%B0%E6%AC%A1%EF%BC%8C%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E8%BF%99%E4%B8%80%E4%B8%AA%E6%95%B0">算法笔记</a> 中题目“一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数”思路即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>,xor0=<span class="hljs-number">0</span>,xor1=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//和原数组异或</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums)<br>            eor^=n;<br>        <span class="hljs-comment">//和辅助数组异或</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();++i)<br>            eor^=i;<br>        <span class="hljs-comment">//提取出最右的1</span><br>        <span class="hljs-type">int</span> rightOne=eor&amp;(~eor+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((n&amp;rightOne)!=<span class="hljs-number">0</span>)<br>                xor1^=n;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&amp;rightOne)!=<span class="hljs-number">0</span>)<br>                xor1^=i;<br>        &#125;<br>        xor0=eor^xor1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums)<br>        &#123;<br>            <span class="hljs-comment">//判断哪个是重复数</span><br>            <span class="hljs-keyword">if</span>(n==xor0)<br>                <span class="hljs-keyword">return</span> &#123;xor0,xor1&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;xor1,xor0&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="697-数组的度-easy"><a href="#697-数组的度-easy" class="headerlink" title="697. 数组的度[easy]"></a><a href="https://leetcode-cn.com/problems/degree-of-an-array/">697. 数组的度</a>[easy]</h1><h2 id="解法：利用哈希表"><a href="#解法：利用哈希表" class="headerlink" title="解法：利用哈希表"></a>解法：利用哈希表</h2><ul><li>具有度数 d 的数组必须有一些元素 x 出现 d 次。如果某些子数组具有相同的度数，那么某些元素 x （出现 d 次）。最短的子数组是将从 x 的第一次出现到最后一次出现的数组。</li><li>对于给定数组中的每个元素， left 是它第一次出现的索引； right 是它最后一次出现的索引。例如，当 nums &#x3D; [1,2,3,2,5] 时，left[2] &#x3D; 1 和 right[2] &#x3D; 3。</li><li>然后，对于出现次数最多的每个元素 x，right[x] - left[x] + 1 将是候选答案，取这些候选的最小值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// count 统计元素出现次数</span><br>        <span class="hljs-comment">// first 记录元素第一次出现的索引</span><br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; count,first;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,degree=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 元素首次出现</span><br>            <span class="hljs-keyword">if</span>(first.<span class="hljs-built_in">count</span>(nums[i])==<span class="hljs-number">0</span>)<br>                first[nums[i]]=i;<br>            count[nums[i]]++;<br>            <span class="hljs-keyword">if</span>(count[nums[i]]&gt;degree)<br>            &#123;<br>                degree=count[nums[i]];<br>                res=i-first[nums[i]]+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 出现重复的 degree 的元素，更新候选的最小值</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(count[nums[i]]==degree)<br>                res=<span class="hljs-built_in">min</span>(res,i-first[nums[i]]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。其中 N 是 nums 的长度。</li><li>空间复杂度：O(N)，first，count 使用的空间。</li></ul><h1 id="766-托普利茨矩阵-easy"><a href="#766-托普利茨矩阵-easy" class="headerlink" title="766. 托普利茨矩阵[easy]"></a><a href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a>[easy]</h1><h2 id="解法一：对角线法"><a href="#解法一：对角线法" class="headerlink" title="解法一：对角线法"></a>解法一：对角线法</h2><p>首先需要知道怎么判断 <code>(r1, c1</code> 和 <code>(r2, c2)</code> 这两个点属于一条对角线。通过观察可以发现，在满足 <code>r1 - c1 == r2 - c2</code>的情况下，这两个点属于同一条对角线。</p><p>利用哈希表存储每条对角线上遇到的第一个元素的值，如果之后遇到的任何一个值不等于之前存储的值，那么这个矩阵就不是托普利茨矩阵，否则就是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isToeplitzMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; groups;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;matrix.<span class="hljs-built_in">size</span>();++r)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;c&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(groups.<span class="hljs-built_in">count</span>(r-c)==<span class="hljs-number">0</span>)<br>                    groups[r-c]=matrix[r][c];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[r][c]!=groups[r-c])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: O(M*N)，即矩阵大小。</li><li>空间复杂度: O(M+N)。</li></ul><h2 id="解法二：检查左上邻居"><a href="#解法二：检查左上邻居" class="headerlink" title="解法二：检查左上邻居"></a>解法二：检查左上邻居</h2><p>对于每条对角线上的元素，按顺序有 a1,a2,a3,…ak。如果所有对角线上的元素都满足 a1&#x3D;a2, a2 &#x3D; a3, a{k-1} &#x3D; ak，那么这个矩阵就是托普利茨矩阵。对于对角线上的元素来说，如果当前元素不是第一个出现的元素，那么它前面的元素一定在当前元素的左上角，因此只需要检查只需要检查 <code>matrix[r-1][c-1] == matrix[r][c]</code>就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isToeplitzMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;r&lt;matrix.<span class="hljs-built_in">size</span>();++r)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;c&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++c)<br>                <span class="hljs-keyword">if</span>(matrix[r][c]!=matrix[r<span class="hljs-number">-1</span>][c<span class="hljs-number">-1</span>])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度: O(M*N)。</li><li>空间复杂度: O(1)。</li></ul><h1 id="349-两个数组的交集-easy"><a href="#349-两个数组的交集-easy" class="headerlink" title="349. 两个数组的交集[easy]"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a>[easy]</h1><h2 id="解法：set"><a href="#解法：set" class="headerlink" title="解法：set"></a>解法：set</h2><p>需要注意数的唯一性，因此需要在加入结果后将 set 中相应数据删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums1)<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(num)!=<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(num);<br>                s.<span class="hljs-built_in">erase</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="350-两个数组的交集-II-easy"><a href="#350-两个数组的交集-II-easy" class="headerlink" title="350. 两个数组的交集 II[easy]"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a>[easy]</h1><h2 id="解法一：排序-双指针"><a href="#解法一：排序-双指针" class="headerlink" title="解法一：排序+双指针"></a>解法一：排序+双指针</h2><p>如果两个数组是有序的，则可以使用双指针的方法得到两个数组的交集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(),nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;nums1.<span class="hljs-built_in">size</span>()&amp;&amp;right&lt;nums2.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[left]&lt;nums2[right])<br>                ++left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[left]&gt;nums2[right])<br>                ++right;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(nums1[left]);<br>                ++left;<br>                ++right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(mlogm+nlogn)，空间复杂度 O(1)。</p><h2 id="解法二：哈希计数"><a href="#解法二：哈希计数" class="headerlink" title="解法二：哈希计数"></a>解法二：哈希计数</h2><p>将较小的数组哈希计数，随后在另一个数组中根据哈希来寻找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums1)<br>            ++mp[num];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(num)!=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(mp[num]==<span class="hljs-number">0</span>)<br>                    mp.<span class="hljs-built_in">erase</span>(num);<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    --mp[num];<br>                    res.<span class="hljs-built_in">push_back</span>(num);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(m+n)，空间复杂度 O(min(m, n))。</p><blockquote><p>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中。那么就无法高效地对 nums2 进行排序，因此推荐使用哈希计数而不是排序+双指针。在哈希计数中，nums2 只关系到查询操作，因此每次读取 nums2 中的一部分数据，并进行处理即可。</p></blockquote><h1 id="1502-判断能否形成等差数列-easy"><a href="#1502-判断能否形成等差数列-easy" class="headerlink" title="1502. 判断能否形成等差数列[easy]"></a><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/">1502. 判断能否形成等差数列</a>[easy]</h1><h2 id="解法一：排序-模拟"><a href="#解法一：排序-模拟" class="headerlink" title="解法一：排序+模拟"></a>解法一：排序+模拟</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canMakeArithmeticProgression</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[i]-arr[i<span class="hljs-number">-1</span>]!=arr[i+<span class="hljs-number">1</span>]-arr[i])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(NlogN)，空间复杂度 O(1)。</p><h2 id="解法二：两次遍历"><a href="#解法二：两次遍历" class="headerlink" title="解法二：两次遍历"></a>解法二：两次遍历</h2><p>第一次遍历：</p><ul><li>得出最大值，最小值</li><li>把每个元素都添加到集合</li><li>遍历结束后，计算最大值和最小值的差，然后用这个差除以 n-1，就可以得到等差（如有）</li></ul><p>第二次遍历：</p><ul><li>从最小值开始，每次加上上面求出的等差，判断和是否全在集合中</li><li>如果发现有任意不在集合的就返回 False，全在返回 True</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canMakeArithmeticProgression</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxValue=INT_MIN;<br>        <span class="hljs-type">int</span> minValue=INT_MAX;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:arr)<br>        &#123;<br>            s.<span class="hljs-built_in">insert</span>(num);<br>            maxValue=<span class="hljs-built_in">max</span>(num,maxValue);<br>            minValue=<span class="hljs-built_in">min</span>(num,minValue);<br>        &#125;<br>        <span class="hljs-type">int</span> len=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> diff=(maxValue-minValue)/(len<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(diff==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> num=minValue+i*diff;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(num)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度 O(N)。</p><h1 id="48-旋转图像-medium"><a href="#48-旋转图像-medium" class="headerlink" title="48. 旋转图像[medium]"></a><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a>[medium]</h1><blockquote><p>思路参考 <a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#2%EF%BC%89%E6%97%8B%E8%BD%AC%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9F%A9%E9%98%B5">2020牛客左神算法课笔记——算法入门——矩阵打印和查找问题、2）旋转正方形矩阵</a>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> tR=<span class="hljs-number">0</span>,tC=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dR=matrix.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,dC=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(tR&lt;dR)<br>            <span class="hljs-built_in">rotateEdge</span>(matrix,tR++,tC++,dR--,dC--);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotateEdge</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; m,<span class="hljs-type">int</span> tR,<span class="hljs-type">int</span> tC,<span class="hljs-type">int</span> dR,<span class="hljs-type">int</span> dC)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> times=dR-tR;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;times;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> tmp=m[tR][tC+i];<br>            m[tR][tC+i]=m[dR-i][tC];<br>            m[dR-i][tC]=m[dR][dC-i];<br>            m[dR][dC-i]=m[tR+i][dC];<br>            m[tR+i][dC]=tmp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array and Matrix</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Linked List</title>
    <link href="/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/"/>
    <url>/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>链表</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a href="https://leetcode.wang/">wind-liang</a> 题解、<a href="https://github.com/chenBright/leetcode">chenBright</a> 题解。</p><span id="more"></span><h1 id="160-相交链表-easy"><a href="#160-相交链表-easy" class="headerlink" title="160. 相交链表[easy]"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>[easy]</h1><h2 id="解法一：借助unordered-set记录链表的结点"><a href="#解法一：借助unordered-set记录链表的结点" class="headerlink" title="解法一：借助unordered_set记录链表的结点"></a>解法一：借助unordered_set记录链表的结点</h2><p>使用<code>unordered_set</code>记录一个链表的结点，然后遍历另一个链表，查找该链表的结点是否在<code>unordered_set</code>中，第一个在<code>unordered_set</code>中的结点即为第一个共同结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;ListNode*&gt; s;<br>        <span class="hljs-keyword">while</span>(headA!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">insert</span>(headA);<br>            headA=headA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(headB!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(headB)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> headB;<br>            headB=headB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(M+N)。</li><li>空间复杂度：O(M)。</li></ul><h2 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h2><p>如果链表相交，则链表公共节点都在尾部。</p><ol><li>先计算两个链表长度。</li><li>让长链表指针先走多出的长度，然后两个链表同时走，如果相遇则为相交节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span>||headB==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* curA=headA;<br>        ListNode* curB=headB;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            curA=curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n--;<br>            curB=curB-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// n：链表1长度减去链表2长度的值</span><br>        curA=(n&gt;<span class="hljs-number">0</span>)?headA:headB;<span class="hljs-comment">// 谁长，谁的头变成curA</span><br>        curB=(curA==headA)?headB:headA;<span class="hljs-comment">// 谁短，谁的头变成curB</span><br>        n=<span class="hljs-built_in">abs</span>(n);<br>        <span class="hljs-keyword">while</span>(n--)<br>            curA=curA-&gt;next;<br>        <span class="hljs-keyword">while</span>(curA!=curB)<br>        &#123;<br>            curA=curA-&gt;next;<br>            curB=curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(M+N)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法三：拼接链表"><a href="#解法三：拼接链表" class="headerlink" title="解法三：拼接链表"></a>解法三：拼接链表</h2><p>利用拼接两链表消除长度差：设长-短链表为 C，短-长链表为 D （分别代表长链表在前和短链表在前的拼接链表），则当 C 走到长短链表交接处时，D 走在长链表中，且与长链表头距离为长度差;</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。当 pA&#x3D;&#x3D;pB 时跳出，返回即可。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818171256.png" style="zoom: 50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span>||headB==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *pA=headA,*pB=headB;<br>        <span class="hljs-keyword">while</span>(pA!=pB)<br>        &#123;<br>            pA=pA==<span class="hljs-literal">nullptr</span>?headB:pA-&gt;next;<br>            pB=pB==<span class="hljs-literal">nullptr</span>?headA:pB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(M+N)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206. 反转链表[easy]"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>[easy]</h1><h2 id="解法一：利用外部空间"><a href="#解法一：利用外部空间" class="headerlink" title="解法一：利用外部空间"></a>解法一：利用外部空间</h2><p>申请一个容器，比如栈。然后不断遍历链表，将链表中的元素添加到容器中，达到逆序的效果。最后，同时遍历链表和容器，将链表中的值改为容器中的值。</p><h2 id="解法二：双指针迭代"><a href="#解法二：双指针迭代" class="headerlink" title="解法二：双指针迭代"></a>解法二：双指针迭代</h2><p>申请两个指针，第一个 pre，最初指向 null 。第二个指针 cur 指向 head，然后不断遍历 cur。每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。注意将 cur 的 next 指针指向 pre 前要先保存 cur 的下一个结点。迭代结束后(cur 变成 null )，pre 就是最后一个节点了。直接返回 pre，即新的头结点。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120318.gif"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//申请节点，pre和 cur，pre指向null</span><br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//保存当前节点的下一个节点</span><br>            ListNode* next=cur-&gt;next;<br>            <span class="hljs-comment">//将当前节点指向pre</span><br>            cur-&gt;next=pre;<br>            <span class="hljs-comment">//pre和cur节点都前进一位</span><br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法三：递归"><a href="#解法三：递归" class="headerlink" title="解法三：递归"></a>解法三：递归</h2><p>递归的两个条件：</p><ol><li><p>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null</p></li><li><p>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span><br></code></pre></td></tr></table></figure><p>其实就是 head 的下一个节点指向 head。递归函数中每次返回的 cur 其实是最后一个节点，在递归函数内部，改变的是当前节点的指向。</p></li></ol><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120406.gif"></p><p>更详细的递归调用执行过程查看 @<a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">wang_ni_ma</a> 题解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//递归终止条件是当前为空，或者下一个节点为空</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//cur是最后一个节点</span><br>        ListNode* cur=<span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        <span class="hljs-comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时cur就是5</span><br><span class="hljs-comment">//而head是4，head的下一个是5，下下一个是空</span><br><span class="hljs-comment">//所以head.next.next 就是5-&gt;4</span><br>        head-&gt;next-&gt;next=head;<br>        <span class="hljs-comment">//防止链表循环，需要将head.next设置为空</span><br>        head-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//每层递归函数都返回cur，也就是最后一个节点</span><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</li></ul><h1 id="21-合并两个有序链表-easy"><a href="#21-合并两个有序链表-easy" class="headerlink" title="21. 合并两个有序链表[easy]"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>[easy]</h1><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><ul><li>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束。</li><li>返回值：每一层调用都返回排序好的链表头。</li><li>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140217.png" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140314.png"  style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140328.png"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>        &#123;<br>            l1-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            l2-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度。</li><li>空间复杂度：O(n+m)，递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。</li></ul><h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><blockquote><p><strong>dummy</strong>哑结点的作用：</p><p>创建哑节点作为结果链表的开头，返回结果是这个节点的下一个位置。目的是：在未遍历之前，我们不知道构建的结果中，开头元素到底是 l1 还是 l2, 为了让代码整齐，创建哑节点。</p></blockquote><p>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位，同时将结果链表向后移一位。</p><p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。所以只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//合并后l1和l2最多只有一个还未被合并完，直接将链表末尾指向未合并完的链表即可</span><br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n+m) ，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</li><li>空间复杂度：O(1) 。只需要常数的空间存放若干变量。</li></ul><h1 id="23-合并K个升序链表-hard"><a href="#23-合并K个升序链表-hard" class="headerlink" title="23. 合并K个升序链表[hard]"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a>[hard]</h1><h2 id="解法一：K指针：K个指针分别指向K条链表"><a href="#解法一：K指针：K个指针分别指向K条链表" class="headerlink" title="解法一：K指针：K个指针分别指向K条链表"></a>解法一：K指针：K个指针分别指向K条链表</h2><h3 id="暴力求min：比较-K-个指针求最小值"><a href="#暴力求min：比较-K-个指针求最小值" class="headerlink" title="暴力求min：比较 K 个指针求最小值"></a>暴力求min：比较 K 个指针求最小值</h3><p>一列一列的比较，将最小的一个存到结果链表里。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115220.jpeg" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">bool</span> isBreak=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记是否遍历完所有链表</span><br>            <span class="hljs-type">int</span> minValue=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.<span class="hljs-built_in">size</span>();++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                     <span class="hljs-comment">//找出最小下标</span><br>                    <span class="hljs-keyword">if</span>(lists[i]-&gt;val&lt;minValue)<br>                    &#123;<br>                        minIndex=i;<br>                        minValue=lists[i]-&gt;val;<br>                    &#125;<br>                    <span class="hljs-comment">//存在一个链表不为空，标记改成false</span><br>                    isBreak=<span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isBreak)<br>                <span class="hljs-keyword">break</span>;<br>            tail-&gt;next=lists[minIndex];<br>            tail=tail-&gt;next;<br>            <span class="hljs-comment">//链表后移一个元素</span><br>            lists[minIndex]=lists[minIndex]-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N*K)，其中 N 为节点总数，每次 O(K) 比较 K 个指针。</li><li>空间复杂度：O(1)。</li></ul><h3 id="使用优先级队列进行优化"><a href="#使用优先级队列进行优化" class="headerlink" title="使用优先级队列进行优化"></a>使用优先级队列进行优化</h3><p>将链表的头结点放入到小根堆中，每次从小根堆中取出最小值的结点，插入到结果链表中。同时，将取出的结点的下一个结点放入到小根堆中，直到链表为空。循环以上过程，直到小根堆为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">//建立队列</span><br>        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,compare&gt; q;<span class="hljs-comment">//小根堆</span><br>        <span class="hljs-keyword">for</span>(ListNode* node:lists)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">nullptr</span>)<br>                q.<span class="hljs-built_in">push</span>(node);<br>        &#125;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//出队列</span><br>            ListNode* tmp=q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            tail-&gt;next=tmp;<br>            <span class="hljs-comment">//如果下一个节点不为空就入队</span><br>            tail=tail-&gt;next;<br>            <span class="hljs-keyword">if</span>(tmp-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>                q.<span class="hljs-built_in">push</span>(tmp-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//定义优先队列的比较器</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a,ListNode* b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//小根堆为&gt;</span><br>            <span class="hljs-keyword">return</span> a-&gt;val&gt;b-&gt;val;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N*logK)，其中 N 为节点总数，每个节点入队出队都需要 log(K)。</li><li>空间复杂度：O(K)。</li></ul><h2 id="解法二：合并两个有序链表"><a href="#解法二：合并两个有序链表" class="headerlink" title="解法二：合并两个有序链表"></a>解法二：合并两个有序链表</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> 提供了合并两个有序链表的思路，这里只采用迭代的写法。</p><h3 id="逐一合并两条链表"><a href="#逐一合并两条链表" class="headerlink" title="逐一合并两条链表"></a>逐一合并两条链表</h3><p>用一个变量 <code>res</code> 来维护合并的链表，第 i 次循环把第 i 个链表和 <code>res</code> 合并，答案保存到 <code>res</code> 中。即第 0 个和第 1 个链表合并，新生成的再和第 2 个链表合并，新生成的再和第 3 个链表合并…直到全部合并完。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* res=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(ListNode* list:lists)<br>            res=<span class="hljs-built_in">mergeTwoLists</span>(res,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N*K)，N 为链表节点总数。</li><li>空间复杂度：O(1)。</li></ul><h3 id="分治合并"><a href="#分治合并" class="headerlink" title="分治合并"></a>分治合并</h3><p>对上述方法进行优化，用分治的方法进行合并。</p><ul><li>k 个链表两两配对，进行第一轮合并，结束后 k 个链表被合并成 k&#x2F;2 个链表。</li><li>k&#x2F;2个链表依然两两配对，进行第二轮合并，结束后 k&#x2F;2 个链表被合并成 k&#x2F;4 个链表。</li><li>重复上述过程，进行 log(k) 次合并，完成总体合并工作。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115801.png" style="zoom:67%;" /><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists,<span class="hljs-number">0</span>,lists.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==end)<br>            <span class="hljs-keyword">return</span> lists[start];<br>        <span class="hljs-type">int</span> mid=start+(end-start)/<span class="hljs-number">2</span>;<br>        ListNode* left=<span class="hljs-built_in">merge</span>(lists,start,mid);<br>        ListNode* right=<span class="hljs-built_in">merge</span>(lists,mid+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> k=lists.<span class="hljs-built_in">size</span>();<br>         <span class="hljs-comment">//非递归归并排序的归并思路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> interval=<span class="hljs-number">1</span>;interval&lt;k;interval*=<span class="hljs-number">2</span>)<span class="hljs-comment">//间隔</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+interval&lt;k;i+=interval*<span class="hljs-number">2</span>)<br>                lists[i]=<span class="hljs-built_in">mergeTwoLists</span>(lists[i],lists[i+interval]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><p>K 条链表的总结点数是 N，平均每条链表有 N&#x2F;K 个节点，因此合并两条链表的时间复杂度是 O(N&#x2F;K)。从 K 条链表开始两两合并成 1 条链表，因此每条链表都会被合并 logK 次，因此 K 条链表会被合并 K∗logK 次，因此总共的时间复杂度是 K∗logK∗N&#x2F;K 即 O(N*logK)。</p><h1 id="83-删除排序链表中的重复元素-easy"><a href="#83-删除排序链表中的重复元素-easy" class="headerlink" title="83. 删除排序链表中的重复元素[easy]"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a>[easy]</h1><h2 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><p>将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。如果不相等则 cur 移动到下一个位置继续循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;val)<br>                cur-&gt;next=cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。</li><li>空间复杂度：O(1)，没有使用额外的空间。</li></ul><h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>递归套路解决链表问题：</p><ul><li>找终止条件：当 head 指向链表只剩一个元素的时候，自然是不可能重复的，因此 return。</li><li>想想应该返回什么值：应该返回的自然是已经去重的链表的头节点。</li><li>每一步要做什么：宏观上考虑，此时 head.next 已经指向一个去重的链表了，而根据第二步，应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的 head 和 head.next 是否相等，如果相等则说明重了，返回 head.next，否则返回 head。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(head-&gt;val==head-&gt;next-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            head-&gt;next=<span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)， n 是列表中的结点数。</li><li>空间复杂度：O(n)，递归栈空间。</li></ul><h1 id="82-删除排序链表中的重复元素-II-medium"><a href="#82-删除排序链表中的重复元素-II-medium" class="headerlink" title="82. 删除排序链表中的重复元素 II[medium]"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>[medium]</h1><h2 id="解法一：快慢指针迭代"><a href="#解法一：快慢指针迭代" class="headerlink" title="解法一：快慢指针迭代"></a>解法一：快慢指针迭代</h2><p>快慢指针,用快指针跳过那些有重复数组,慢指针负责和快指针拼接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* slow=dummy;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;val==fast-&gt;next-&gt;val)<br>                fast=fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow-&gt;next==fast)<br>                slow=slow-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                slow-&gt;next=fast-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：递归-1"><a href="#解法二：递归-1" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//如果头结点和后边的节点相等</span><br>        <span class="hljs-keyword">if</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;head-&gt;val==head-&gt;next-&gt;val)<br>        &#123; <br>            <span class="hljs-comment">//跳过所有重复数字</span><br>            <span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;head-&gt;val==head-&gt;next-&gt;val)<br>                head=head-&gt;next;<br>            <span class="hljs-comment">//将所有重复数字去掉后，进入递归</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>        &#125;<br>        <span class="hljs-comment">//头结点和后边的节点不相等</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//保留头结点，后边的所有节点进入递归</span><br>            head-&gt;next=<span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>            <span class="hljs-comment">//返回头结点</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第N个节点-medium"><a href="#19-删除链表的倒数第N个节点-medium" class="headerlink" title="19. 删除链表的倒数第N个节点[medium]"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a>[medium]</h1><h2 id="解法一：两次遍历"><a href="#解法一：两次遍历" class="headerlink" title="解法一：两次遍历"></a>解法一：两次遍历</h2><p>删除链表的倒数第 N 个节点可以转换为删除链表从开头数起的 L-n+1 个节点，其中 L 是链表的长度。</p><p>首先添加一个哑结点作为辅助，该结点位于链表头部。哑结点用来简化某些极端情况，例如链表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，找出链表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个节点。然后把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* cur=head;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        length-=n;<br>        cur=dummy;<br>        <span class="hljs-keyword">while</span>(length--&gt;<span class="hljs-number">0</span>)<br>            cur=cur-&gt;next;<br>        cur-&gt;next=cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(L)，对链表进行两次遍历，首先计算长度 L，其次找到第 (L - n) 个结点。 操作执行了 2L−n 步。</li><li>空间复杂度：O(1)，常量级的额外空间。</li></ul><h2 id="解法二：快慢指针一次遍历"><a href="#解法二：快慢指针一次遍历" class="headerlink" title="解法二：快慢指针一次遍历"></a>解法二：快慢指针一次遍历</h2><p>设置快慢指针，快指针先走 n+1(因为哑结点的关系需要+1) 步，此时快慢指针之间间隔的节点个数为 n。然后同时移动快慢指针保持这个恒定的间隔，直到快指针指向 null。此时慢指针将指向倒数第 n-1 个节点，修改慢指针的 next 指针指向该结点的下下个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* fast=dummy;<br>        ListNode* slow=dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;++i)<br>            fast=fast-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        slow-&gt;next=slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(L)，操作执行次数仍为 2L-n。</li><li>空间复杂度：O(1)，常量级的额外空间。</li></ul><h1 id="24-两两交换链表中的节点-medium"><a href="#24-两两交换链表中的节点-medium" class="headerlink" title="24. 两两交换链表中的节点[medium]"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>[medium]</h1><h2 id="解法一：迭代-1"><a href="#解法一：迭代-1" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152400.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* pre=dummy;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            pre-&gt;next=cur-&gt;next;<br>            cur-&gt;next=pre-&gt;next-&gt;next;<br>            pre-&gt;next-&gt;next=cur;<br>            pre=cur;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li><li>空间复杂度：O(1)。</li></ul><h2 id="解法二：递归-2"><a href="#解法二：递归-2" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，应该关注一级调用小单元的情况，也就是单个 f(x)。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152410.png" style="zoom: 50%;" /><p>其中应该关心的主要有三点：</p><ol><li>返回值；</li><li>调用单元做了什么；</li><li>终止条件。</li></ol><p>在本题中：</p><ol><li>返回值：交换完成的子链表；</li><li>调用单元：设需要交换的两个点为 head 和 n，head 连接后面交换完成的子链表，n 连接 head，完成交换；</li><li>终止条件：head 为空指针或者 n 为空指针，也就是当前无节点或者只有一个节点，无法进行交换。</li></ol><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152419.png" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152425.png" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152432.png" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* n=head-&gt;next;<br>        head-&gt;next=<span class="hljs-built_in">swapPairs</span>(n-&gt;next);<br>        n-&gt;next=head;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li><li>空间复杂度：O(N)，递归过程使用的堆栈空间。</li></ul><h1 id="2-两数相加-medium"><a href="#2-两数相加-medium" class="headerlink" title="2. 两数相加[medium]"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>[medium]</h1><h2 id="解法一：模拟加法"><a href="#解法一：模拟加法" class="headerlink" title="解法一：模拟加法"></a>解法一：模拟加法</h2><p>使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值。如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1（即循环的第三个条件 carry!&#x3D;0）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828140817.png" style="zoom: 80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur=dummy;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>||l2!=<span class="hljs-literal">nullptr</span>||carry!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=carry;<br>            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                sum+=l1-&gt;val;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                sum+=l2-&gt;val;<br>                l2=l2-&gt;next;<br>            &#125;<br>            cur-&gt;next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>            carry=sum/<span class="hljs-number">10</span>;<span class="hljs-comment">//更新进位的值</span><br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：递归-3"><a href="#解法二：递归-3" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>写递归的时候注意递归函数的两个条件，递归出口条件，以及函数内要做什么。</p><ol><li>递归出口条件：链表 l1 和链表 l2 都为空，且无进位时。</li><li>将两个链表的值相加，再赋给结果链表节点。</li></ol><p>这里需要注意第二个条件，因为进位标志需要通告下一层递归函数，所以需要有一个单独的变量作为记录，因此设置为全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* cur=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>&amp;&amp;l2==<span class="hljs-literal">nullptr</span>&amp;&amp;sum==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            sum+=l1-&gt;val;<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            sum+=l2-&gt;val;<br>            l2=l2-&gt;next;<br>        &#125;<br>        cur-&gt;val=sum%<span class="hljs-number">10</span>;<br>        sum/=<span class="hljs-number">10</span>;<br>        cur-&gt;next=<span class="hljs-built_in">addTwoNumbers</span>(l1,l2);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="445-两数相加-II-medium"><a href="#445-两数相加-II-medium" class="headerlink" title="445. 两数相加 II[medium]"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a>[medium]</h1><h2 id="解法一：栈-头插法"><a href="#解法一：栈-头插法" class="headerlink" title="解法一：栈+头插法"></a>解法一：栈+头插法</h2><p>因为链表中数位的顺序与做加法的顺序是相反的，所以使用栈来逆序处理所有数位。把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。记录结果链表时使用头插法使链表逆序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk1;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk2;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>            l2=l2-&gt;next;<br>        &#125;<br>        ListNode* head=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span>(!stk1.<span class="hljs-built_in">empty</span>()||!stk2.<span class="hljs-built_in">empty</span>()||carry!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=carry;<br>            <span class="hljs-keyword">if</span>(stk1.<span class="hljs-built_in">empty</span>())<br>                sum+=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sum+=stk1.<span class="hljs-built_in">top</span>();<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(stk2.<span class="hljs-built_in">empty</span>())<br>                sum+=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sum+=stk2.<span class="hljs-built_in">top</span>();<br>                stk2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ListNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>            carry=sum/<span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//头插法</span><br>            node-&gt;next=head;<br>            head=node;           <br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(max(m,n))，其中 m 与 n 分别为两个链表的长度。需要遍历每个链表。</li><li>空间复杂度：O(m+n)，把链表内容放入栈中所用的空间。</li></ul><h2 id="解法二：递归-4"><a href="#解法二：递归-4" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>先递归计算后面的位，再根据计算结果计算当前的位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> length1=<span class="hljs-built_in">getlength</span>(l1);<br>        <span class="hljs-type">int</span> length2=<span class="hljs-built_in">getlength</span>(l2);<br>        ListNode* res=<span class="hljs-built_in">nextnode</span>(l1,l2,length1,length2);<br>        <span class="hljs-keyword">if</span> (carry&gt;<span class="hljs-number">0</span>) <br>        &#123;<br>            ListNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            node-&gt;next=res;<br>            res=node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            cnt++;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>     <span class="hljs-function">ListNode* <span class="hljs-title">nextnode</span><span class="hljs-params">(ListNode* l1,ListNode* l2,<span class="hljs-type">int</span> length1,<span class="hljs-type">int</span> length2)</span>    </span><br><span class="hljs-function">     </span>&#123;<br>        <span class="hljs-keyword">if</span>(length1==<span class="hljs-number">0</span>||length2==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *p;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(length1==length2) <br>        &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1-&gt;next,l2-&gt;next,--length1,--length2);<br>            sum=carry+l1-&gt;val+l2-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (length1&gt;length2) &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1-&gt;next,l2,--length1,length2);<br>            sum=carry+l1-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1,l2-&gt;next,length1,--length2);<br>            sum=carry+l2-&gt;val;<br>        &#125;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>        node-&gt;next=p;<br>        carry=sum/<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="876-链表的中间结点-easy"><a href="#876-链表的中间结点-easy" class="headerlink" title="876. 链表的中间结点[easy]"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a>[easy]</h1><h2 id="解法一：常规做法"><a href="#解法一：常规做法" class="headerlink" title="解法一：常规做法"></a>解法一：常规做法</h2><p>寻找链表中点的常规做法是两步走：</p><ul><li>先遍历一遍链表，计算链表的长度 n；</li><li>再遍历一遍链表，找到第 n&#x2F;2 个元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur=head;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        cur=head;<br>        <span class="hljs-keyword">while</span>(k&lt;length/<span class="hljs-number">2</span>)<br>        &#123;<br>            k++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：快慢指针-1"><a href="#解法二：快慢指针-1" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h2><p>使用慢指针<code>slow</code>和快指针<code>fast</code>两个指针同时遍历链表。快指针一次前进两个结点，速度是慢指针的两倍。这样，当快指针到达链表尾部时，慢指针正好到达链表的中部。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826113000.gif" style="zoom:67%;" /><p>不过，这个方法并没有减少时间复杂度的量级 —— 时间复杂度仍然是 O(n)，不过能减少一次遍历。</p><p>两个注意点：</p><ul><li>循环的条件是 <code>fast!=null &amp;&amp; fast.next!=null</code>，防止出现空指针异常。</li><li>注意链表结点为奇数个和偶数个的时候，链表中点的含义不一样。不过这种写法正好能满足题意，可以在纸上画一画最后 slow 指针落在什么位置。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 链表元素为奇数个时，slow 指向链表的中点</span><br>    <span class="hljs-comment">// 链表元素为偶数个时，slow 指向链表两个中点的右边一个</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="234-回文链表-easy"><a href="#234-回文链表-easy" class="headerlink" title="234. 回文链表[easy]"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a>[easy]</h1><h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p>使用栈保存结点，再从链表头开始，一一与栈中的值对比。</p><p>因为回文链表前后两部分逆序，不需要保存整个链表的值，只需要保存中间节点之前的节点即可。然后从中间结点的后继结点开始遍历链表的后半部分，将遍历的结点与栈弹出的结点相比较。可以使用快慢指针，找到中间节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;ListNode*&gt; s;<br>        ListNode* fast=head;<span class="hljs-comment">//快指针</span><br>        ListNode* slow=head;<span class="hljs-comment">//慢指针</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(slow);<span class="hljs-comment">// 将前一半的结点压入栈中</span><br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// slow 指向第 n / 2 + 1 个结点。</span><br>        <span class="hljs-comment">// 链表结点个数为偶数，fast 指向 NULL，此时 slow 刚刚好指向链表后一半的第一个结点</span><br>        <span class="hljs-comment">// 链表结点个数为奇数，fast-&gt;next 指向 NULL，此时 slow 刚刚好指向链表的中间结点</span><br>        ListNode* right=fast==<span class="hljs-literal">nullptr</span>?slow:slow-&gt;next;<br>        <span class="hljs-comment">// 链表后半部分和栈中元素逐一对比</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()-&gt;val!=right-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            s.<span class="hljs-built_in">pop</span>();<br>            right=right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h2 id="解法二：递归-5"><a href="#解法二：递归-5" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>如果使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。</p><p>currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。之所以起作用的原因是递归处理节点的顺序是相反的。由于递归，从本质上，我们同时在正向和逆向迭代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer=head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursivelyCheck</span>(head);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode* frontPointer;     <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* currentNode)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(currentNode!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">recursivelyCheck</span>(currentNode-&gt;next))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(currentNode-&gt;val!=frontPointer-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            frontPointer=frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h2 id="解法三：双指针-反转"><a href="#解法三：双指针-反转" class="headerlink" title="解法三：双指针+反转"></a>解法三：双指针+反转</h2><p>利用两个指针，快指针每次走两步，慢指针每次走一步。当快指针走完的时候，慢指针来到前半部分链表的尾节点（若链表有奇数个节点，则为中间节点）。然后将单链表右半部分反转。然后利用 p1 和 p2 指针分别从链表头和尾出发，向中间推进，一一比较。为了不破坏原始数据结构，最后再将单链表恢复到原状态，即将右半部分逆序回来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//找到前半部分链表的尾节点</span><br>        ListNode* firstHalfEnd=<span class="hljs-built_in">endOfFirstHalf</span>(head);<br>        <span class="hljs-comment">//反转右半部分</span><br>        ListNode* secondHalfStart=<span class="hljs-built_in">reverseList</span>(firstHalfEnd-&gt;next);<br>        <span class="hljs-comment">//判断是否回文</span><br>        ListNode* p1=head;<br>        ListNode* p2=secondHalfStart;<br>        <span class="hljs-keyword">while</span>(p2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;val!=p2-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p1=p1-&gt;next;<br>            p2=p2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//恢复链表</span><br>        firstHalfEnd-&gt;next=<span class="hljs-built_in">reverseList</span>(secondHalfStart);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="725-分隔链表-medium"><a href="#725-分隔链表-medium" class="headerlink" title="725. 分隔链表[medium]"></a><a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a>[medium]</h1><h2 id="解法：拆分链表"><a href="#解法：拆分链表" class="headerlink" title="解法：拆分链表"></a>解法：拆分链表</h2><p>如果链表有 N 个结点，则分隔的链表中每个部分中都有 N&#x2F;k 个结点，且前 N%k 部分有一个额外的结点。</p><p>先求出链表的长度，然后求出分隔的链表平均长度，以及余数，然后余数依次给排在前面的平均长度+1即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* root, <span class="hljs-type">int</span> k)</span>    </span>&#123;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        ListNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> size=length/k;<br>        <span class="hljs-type">int</span> mod=length%k;<br>        <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-literal">nullptr</span>)</span></span>;<br>        cur=root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;i&lt;k;++i)<br>        &#123;<br>            res[i]=cur;<br>            <span class="hljs-comment">//给前面的长度+1</span><br>            <span class="hljs-type">int</span> cursize=size+(mod--&gt;<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cursize<span class="hljs-number">-1</span>;++j)<br>                cur=cur-&gt;next;<br>            <span class="hljs-comment">//断链</span><br>            ListNode* next=cur-&gt;next;<br>            cur-&gt;next=<span class="hljs-literal">nullptr</span>;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="328-奇偶链表-medium"><a href="#328-奇偶链表-medium" class="headerlink" title="328. 奇偶链表[medium]"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a>[medium]</h1><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>将奇节点放在一个链表里，偶节点放在另一个链表里。然后把偶链表接在奇链表的尾部。</p><p>利用 odd 表示奇链表的当前节点，初始化为 head，even 表示偶链表的当前节点，初始化为第二个节点，即 head.next，evenHead 是偶链表的头结点，初始化为第二个节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826110823.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *odd=head,*even=head-&gt;next,*evenHead=even;<br>        <span class="hljs-comment">//while退出判断条件可以画一下图，奇数个节点even=null,偶数个节点even-&gt;next=null</span><br>        <span class="hljs-keyword">while</span>(even!=<span class="hljs-literal">nullptr</span>&amp;&amp;even-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            odd-&gt;next=even-&gt;next;<span class="hljs-comment">//相当于odd.next=odd.next.next(跳过一个偶数节点)</span><br>            odd=odd-&gt;next;<span class="hljs-comment">//odd向前前进一位</span><br>            even-&gt;next=odd-&gt;next;<br>            even=even-&gt;next;<span class="hljs-comment">//even向前前进一位</span><br>        &#125;<br>        <span class="hljs-comment">//把偶链表头指针拼接到奇链表的最后</span><br>        odd-&gt;next=evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度： O(n)。总共有 n 个节点，每个遍历一次。</li><li>空间复杂度： O(1)。只需要 4 个指针。</li></ul><h1 id="141-环形链表-easy"><a href="#141-环形链表-easy" class="headerlink" title="141. 环形链表[easy]"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>使用哈希表记录遍历过的结点。如果链表存在环，则在遍历到环的入口时，在哈希表中可以找到该结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//只要某个节点在set中出现过，说明遍历到重复元素了</span><br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(head)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st.<span class="hljs-built_in">insert</span>(head);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，访问每个元素最多一次，添加一个结点到哈希表中只需要花费 O(1) 的时间。</li><li>空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</li></ul><h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>准备两个指针，初始都指向头节点。快指针每次走两步，慢指针每次走一步。如果快指针走到 null，则表示不是环形链表；否则，快指针在环形链表中会”追上”慢指针，即<code>fast == slow</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)，只使用了慢指针和快指针。</li></ul><h1 id="142-环形链表-II-medium"><a href="#142-环形链表-II-medium" class="headerlink" title="142. 环形链表 II[medium]"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>[medium]</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a> 的升级版，在判断是否有环的基础上，需要找到链表的入环节点。</p><h2 id="解法一：哈希表-1"><a href="#解法一：哈希表-1" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>遍历链表，并且把遍历过的节点用 <code>HashSet</code> 存起来，如果遍历过程中又遇到了之前的节点，说明这个节点就是要找的入口点。如果到达了 <code>null</code> 就说明没有环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(head)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            st.<span class="hljs-built_in">insert</span>(head);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)，最坏情况下，单链表的所有结点都在存入 set。</li></ul><h2 id="解法二：双指针-1"><a href="#解法二：双指针-1" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>准备快慢指针，初始都指向头节点，快指针每次走两步，慢指针每次走一步。如果快指针走到 null，则表示不是环形链表；否则，快指针在环形链表中会”追上”慢指针，即<code>fast == slow</code>。当快慢指针相遇时，快指针回到链表头节点，每次走一步，慢指针停在相遇的位置，每次走一步。当快慢指针再次相遇的时候，则相遇结点为入环结点。</p><p>证明方法查看<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/">官方题解</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>            &#123;<br>                fast=head;<br>                <span class="hljs-keyword">while</span>(fast!=slow)<br>                &#123;<br>                    fast=fast-&gt;next;<br>                    slow=slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)，只使用了慢指针和快指针。</li></ul><h1 id="147-对链表进行插入排序-medium"><a href="#147-对链表进行插入排序-medium" class="headerlink" title="147. 对链表进行插入排序[medium]"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a>[medium]</h1><h2 id="解法：模拟数组插入排序"><a href="#解法：模拟数组插入排序" class="headerlink" title="解法：模拟数组插入排序"></a>解法：模拟数组插入排序</h2><p>直接对链表进行插入排序，利用指针<code>prev</code>表示当前已排好序的尾节点，初始化为<code>head</code>。利用指针<code>cur</code>表示当前需要插入的节点，初始化为<code>head-&gt;next</code>。将<code>cur-&gt;val</code>与<code>prev-&gt;val</code>进行比较。</p><ul><li>如果<code>cur-&gt;val &lt; prev-&gt;val </code>则表示<code>cur</code>需要插入到<code>prev</code>之前的位置，这时从哑结点<code>dummy</code>开始寻找小于插入节点值的最后一个节点（从哑结点开始寻找便于处理插入到<code>head</code>前的情况），将<code>cur</code>插入最后一个节点后面。(数组的插入排序是将插入元素与排好序的尾元素比较后，往前一一比较的，但是链表只能从前往后查找)。</li><li>如果<code>cur-&gt;val &gt;= prev-&gt;val </code>则表示插入节点值大于排好序的所有节点值，这时直接检查下一个节点即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* prev=head;<span class="hljs-comment">//排好序的尾节点</span><br>        ListNode* cur=head-&gt;next;<span class="hljs-comment">//当前要插入的节点</span><br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val&lt;prev-&gt;val)<br>            &#123;<br>                ListNode* tmp=dummy;<br>                <span class="hljs-comment">//从头找到一个位置来插入cur，这里是tmp-&gt;next需要注意一下，比如1-3插入2，tmp-&gt;next停在3上，tmp是指在1上</span><br>                <span class="hljs-keyword">while</span>(tmp-&gt;next-&gt;val&lt;cur-&gt;val)<br>                    tmp=tmp-&gt;next;<br>                <span class="hljs-comment">// 因为实际操作还是在一个完整的链表上进行的</span><br>                <span class="hljs-comment">//（1）所以每次要断链取出一个：把要取出的cur断开，把cur-&gt;next接在prev上</span><br>                prev-&gt;next=cur-&gt;next;<br>                <span class="hljs-comment">//（2）把取出的节点插入到链表上</span><br>                cur-&gt;next=tmp-&gt;next;<br>                tmp-&gt;next=cur;<br>                <span class="hljs-comment">//prev-&gt;next为下一次要插入的节点</span><br>                cur=prev-&gt;next;<br>            &#125;<br>            <span class="hljs-comment">//直接检查下个节点</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev=cur;<br>                cur=cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="148-排序链表-medium"><a href="#148-排序链表-medium" class="headerlink" title="148. 排序链表[medium]"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>[medium]</h1><p>题目要求在 <code>O(nlogn)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序。先不管空间复杂度，则根据时间复杂度要求可以想到堆排序、归并排序和快速排序，而稳定的又只有归并排序。</p><h2 id="解法一：归并排序（递归法）"><a href="#解法一：归并排序（递归法）" class="headerlink" title="解法一：归并排序（递归法）"></a>解法一：归并排序（递归法）</h2><p>通过递归实现链表归并排序，有以下两个环节：</p><ul><li>分割 cut 环节：找到当前链表中点，并从中点将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）。<ul><li>题目 <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a> 通过快慢指针寻找链表中间节点，但是当有两个中间节点时，返回的是第二个中间结点。而本题最好返回第一个，这样可以把链表平均分开。需要修改一下代码，增加一个 pre 指针，让它一直指向 slow 的前一个即可。</li><li>找到中点后，执行 <code>midNode.next=null</code> 将链表切断。</li><li>递归分割时，输入当前链表左端点 <code>head</code> 和中心节点 <code>midNode</code> 的下一个节点 <code>rightHead</code>(因为链表是从 <code>midNode</code> 切断的)。</li><li>当分割成只剩一个节点时结束分割，即 base case。</li></ul></li><li>合并 merge 环节：将两个有序链表合并，转化为一个排序链表，为题目 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112455.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//找到链表中间节点并断开链表 &amp; 递归下探</span><br>        ListNode* midNode=<span class="hljs-built_in">middleNode</span>(head);<br>        ListNode* rightHead=midNode-&gt;next;<br>        midNode-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* left=<span class="hljs-built_in">sortList</span>(head);<br>        ListNode* right=<span class="hljs-built_in">sortList</span>(rightHead);<br>         <span class="hljs-comment">//当前层业务操作（合并有序链表）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//找到链表中间节点（876. 链表的中间结点）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;     <br>        ListNode* prev=<span class="hljs-literal">nullptr</span>; <br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            prev=slow;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br><br>     <span class="hljs-comment">//合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：快速排序（递归法）"><a href="#解法二：快速排序（递归法）" class="headerlink" title="解法二：快速排序（递归法）"></a>解法二：快速排序（递归法）</h2><p>使用快速排序对链表排序，关键在于最后将链表链接好。快速排序的基本思想为：使用一个基准结点，将链表分为左链表、中链表和右链表。对左右链表递归执行这一步。最后要将左中右链表链接好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*leftHead=left;<br>        ListNode* mid=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*midHead=mid;<br>        ListNode* right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*rightHead=right;<br>        <span class="hljs-type">int</span> pivot=head-&gt;val;<span class="hljs-comment">//基准节点值</span><br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val&lt;pivot)<br>            &#123;<br>                left-&gt;next=head;<br>                left=head;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;val==pivot)<br>            &#123;<br>                mid-&gt;next=head;<br>                mid=head;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                right-&gt;next=head;<br>                right=head;<br>            &#125;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//断链</span><br>        left-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        mid-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        right-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">concat</span>(<span class="hljs-built_in">sortList</span>(leftHead-&gt;next),midHead-&gt;next,<span class="hljs-built_in">sortList</span>(rightHead-&gt;next));<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">concat</span><span class="hljs-params">(ListNode* left,ListNode* mid,ListNode* right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* leftTail=<span class="hljs-built_in">getTail</span>(left);<br>        ListNode* midTail=<span class="hljs-built_in">getTail</span>(mid);<br>        midTail-&gt;next=right;<br>        <span class="hljs-keyword">if</span>(leftTail!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            leftTail-&gt;next=mid;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-comment">//没有左链表</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getTail</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>            head=head-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：归并排序（从底至顶直接合并）——O-1-空间"><a href="#解法三：归并排序（从底至顶直接合并）——O-1-空间" class="headerlink" title="解法三：归并排序（从底至顶直接合并）——O(1)空间"></a>解法三：归并排序（从底至顶直接合并）——O(1)空间</h2><p>对于非递归的归并排序，需要使用迭代的方式替换解法一中的 cut 环节：<br>cut 环节本质上是通过不断二分得到链表最小节点单元，再通过多轮合并得到排序结果。每一轮合并 merge 操作针对的单元都有固定长度 intv，例如：</p><ul><li>第一轮合并时<code>intv = 1</code>，即将整个链表切分为多个长度为 1 的单元，并按顺序两两排序合并，合并完成的已排序单元长度为 2。</li><li>第二轮合并时<code>intv = 2</code>，即将整个链表切分为多个长度为 2 的单元，并按顺序两两排序合并，合并完成已排序单元长度为 4。</li><li>以此类推，直到单元长度<code>intv &gt;= 链表长度</code>，代表已经排序完成。</li></ul><p>根据以上推论，我们可以仅根据 intv 计算每个单元边界，并完成链表的每轮排序合并，例如:</p><ul><li>当<code>intv = 1</code>时，将链表第 1 和第 2 节点排序合并，第 3 和第 4 节点排序合并，……。</li><li>当<code>intv = 2</code>时，将链表第 1-2 和第 3-4 节点排序合并，第 5-6 和第 7-8 节点排序合并，……。</li><li>当<code>intv = 4</code>时，将链表第 1-4 和第 5-8 节点排序合并，第 9-12 和第 13-16 节点排序合并，……。</li></ul><p>此方法时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112439.png" style="zoom:67%;" /><p>链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，主要用到链表操作的两个技术：</p><ul><li><code>mergeTwoLists(l1, l2)</code>，将两个有序链表合并，转化为一个排序链表，为题目 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>。</li><li><code>cut(l, n)</code>，一种 split 操作，即断链操作。它表示，将链表 <code>l</code> 切掉前 n 个节点，并返回后半部分的链表头。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        <span class="hljs-comment">//统计链表长度</span><br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        ListNode* node=head;<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            node=node-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//循环切割和合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> size=<span class="hljs-number">1</span>;size&lt;length;size=size*<span class="hljs-number">2</span>)<br>        &#123;<br>            ListNode* cur=dummy-&gt;next;<br>            ListNode* tail=dummy;<br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                ListNode* left=cur;<br>                <span class="hljs-comment">//链表切掉size,剩下的返还给right</span><br>                ListNode* right=<span class="hljs-built_in">cut</span>(left,size);<br>                <span class="hljs-comment">//链表切掉size,剩下的返还给cur</span><br>                cur=<span class="hljs-built_in">cut</span>(right,size);<br>                tail-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>                <span class="hljs-comment">//保持最尾端</span><br>                <span class="hljs-keyword">while</span>(tail-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>                    tail=tail-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//将链表L切掉前n个节点 并返回后半部分的链表头</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">cut</span><span class="hljs-params">(ListNode* head,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* p=head;<br>        <span class="hljs-comment">//往前走n-1步</span><br>        <span class="hljs-keyword">while</span>(--n&gt;<span class="hljs-number">0</span>&amp;&amp;p!=<span class="hljs-literal">nullptr</span>)<br>            p=p-&gt;next;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* next=p-&gt;next;<br>        p-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>     <span class="hljs-comment">//合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="25-K-个一组翻转链表-hard"><a href="#25-K-个一组翻转链表-hard" class="headerlink" title="25. K 个一组翻转链表[hard]"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>[hard]</h1><h2 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>大致过程可以分解为：</p><ul><li>找到待翻转的k个节点（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。</li><li>对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。</li><li>对下一轮 k 个节点也进行翻转操作。</li><li>将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。</li></ul><p>具体过程看下图。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425101751.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* tail=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>        &#123;<br>            <span class="hljs-comment">// 剩余数量小于k的话，不需要反转</span><br>            <span class="hljs-keyword">if</span>(tail==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            tail=tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 反转前 k 个元素</span><br>        ListNode* newHead=<span class="hljs-built_in">reverse</span>(head,tail);<br>        <span class="hljs-comment">// 下一轮的开始的地方就是tail</span><br>        head-&gt;next=<span class="hljs-built_in">reverseKGroup</span>(tail,k);<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 左闭又开区间</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(head!=tail)<br>        &#123;<br>            next=head-&gt;next;<br>            head-&gt;next=pre;<br>            pre=head;<br>            head=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><ul><li>链表分区为已翻转部分+待翻转部分+未翻转部分</li><li>每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定</li><li>需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来</li><li>初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾</li><li>经过 k 次循环，end 到达末尾，记录待翻转链表的后继 next &#x3D; end.next</li><li>翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环</li><li>特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end&#x3D;&#x3D;null，已经到达末尾，说明题目已完成，直接返回即可</li><li>时间复杂度为 O(n∗K) 最好的情况为 O(n) 最差的情况为 O(n^2)</li><li>空间复杂度为 O(1) 除了几个必须的节点指针外，并没有占用其他空间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425104123.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* pre=dummy;<br>        ListNode* end=dummy;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k&amp;&amp;end!=<span class="hljs-literal">nullptr</span>;++i)<br>                end=end-&gt;next;<br>            <span class="hljs-keyword">if</span>(end==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">break</span>;<br>            ListNode* start=pre-&gt;next;<br>            ListNode* next=end-&gt;next;<br>            end-&gt;next=<span class="hljs-literal">nullptr</span>;<br>            pre-&gt;next=<span class="hljs-built_in">reverse</span>(start);<br>            start-&gt;next=next;<br>            pre=start;<br>            end=pre;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="补充题目：字节跳动高频题——排序奇升偶降链表"><a href="#补充题目：字节跳动高频题——排序奇升偶降链表" class="headerlink" title="补充题目：字节跳动高频题——排序奇升偶降链表"></a>补充题目：字节跳动高频题——排序奇升偶降链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个奇数位升序，偶数位降序的链表，将其重新排序。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">8</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">8</span>-&gt;NULL<br></code></pre></td></tr></table></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ul><li>按奇偶位置拆分链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和8-&gt;6-&gt;4-&gt;2-&gt;NULL</li><li>反转偶链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和2-&gt;4-&gt;6-&gt;8-&gt;NULL</li><li>合并两个有序链表，得1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</li></ul><p>时间复杂度为 O(N)，空间复杂度 O(1)。</p><p>注意事项：</p><p>在第一步中，循环结束后需要将奇数链表最后节点的 next 指针置空，当链表节点个数为偶数时，不置空会有问题。</p><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426145056.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value):<span class="hljs-built_in">val</span>(value),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>    ListNode* next=<span class="hljs-literal">nullptr</span>;<br>    ListNode* cur=head;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        next=cur-&gt;next;<br>        cur-&gt;next=pre;<br>        pre=cur;<br>        cur=next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* tail=dummy;<br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span> &amp;&amp; l2!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>        &#123;<br>            tail-&gt;next=l1;<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next=l2;<br>            l2=l2-&gt;next;<br>        &#125;<br>        tail=tail-&gt;next;<br>    &#125;<br>    tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>    ListNode* tmp=dummy-&gt;next;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">mysort</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    ListNode* ohead=head;<br>    ListNode* ehead=head-&gt;next;<br>    ListNode* odd=ohead;<br>    ListNode* even=ehead;<br>    <span class="hljs-keyword">while</span>(even!=<span class="hljs-literal">nullptr</span> &amp;&amp; even-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        odd-&gt;next=even-&gt;next;<br>        odd=odd-&gt;next;<br>        even-&gt;next=odd-&gt;next;<br>        even=even-&gt;next;<br>    &#125;<br>    odd-&gt;next=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 见上述注意事项</span><br>    ListNode* reEhead=<span class="hljs-built_in">reverseList</span>(ehead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(ohead,reEhead);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* one=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br>    ListNode* two=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">200</span>);<br>    ListNode* three=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>);<br>    ListNode* four=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">120</span>);<br>    one-&gt;next=two;<br>    two-&gt;next=three;<br>    three-&gt;next=four;<br>    ListNode* res=<span class="hljs-built_in">mysort</span>(one);<br>    <span class="hljs-keyword">while</span>(res!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        cout&lt;&lt;res-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        res=res-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> one,two,three,four;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="61-旋转链表-medium"><a href="#61-旋转链表-medium" class="headerlink" title="61. 旋转链表[medium]"></a><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a>[medium]</h1><h2 id="解法：快慢指针"><a href="#解法：快慢指针" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h2><p>题意：将链表每个节点向右移动 k 个位置，相当于把链表的后面 k % len  个节点移到链表的最前面。（len 为 链表长度）</p><ul><li>求链表长度；</li><li>找出倒数第 k+1 个节点；<ul><li>两个指针 <code>slow</code> 和 <code>fast</code> 值距离是 k，先让 <code>fast</code> 指向链表的第 k + 1 个节点，<code>slow</code> 指向第 1 个节点；</li><li>然后 <code>slow</code> 和 <code>fast</code> 同时向后移动，当 <code>fast</code> 移动到链表的最后一个节点的时候，那么 <code>slow</code> 指向链表的倒数第 k + 1 个节点</li></ul></li><li>链表重整：将链表的倒数第 k+1 个节点和倒数第 k 个节点断开，并把后半部分拼接到链表的头部。<ul><li><code>newHead</code> 是新链表的头部，它应该是原链表倒数第 k 个节点，即 <code>slow.next</code>；</li><li><code>slow</code> 需要跟 <code>slow.next</code> 断开；</li><li><code>fast</code> 是老链表的结尾，将 <code>fast.next</code> 设置为老链表的开头，实现首尾相接。</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426154405.jpeg" style="zoom:80%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode *cur=head;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-number">0</span>)<br>        &#123;<br>            len++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        k=k%len;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            fast=fast-&gt;next;<br>        <span class="hljs-comment">// 当 fast-&gt;next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点</span><br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        ListNode* newHead=slow-&gt;next;<br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        fast-&gt;next=head;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="86-分隔链表-medium"><a href="#86-分隔链表-medium" class="headerlink" title="86. 分隔链表[medium]"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>[medium]</h1><p>用两个链表，一个链表放小于 <code>x</code> 的节点，一个链表放大于等于 <code>x</code> 的节点。最后，拼接这两个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        ListNode* less=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* more=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p1=less;<br>        ListNode* p2=more;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val&lt;x)<br>            &#123;<br>                p1-&gt;next=head;<br>                p1=p1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                p2-&gt;next=head;<br>                p2=p2-&gt;next;<br>            &#125;<br>            head=head-&gt;next;<br>        &#125;<br>        p1-&gt;next=more-&gt;next;<br>        p2-&gt;next=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 注意断链</span><br>        <span class="hljs-keyword">return</span> less-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="92-反转链表-II-medium"><a href="#92-反转链表-II-medium" class="headerlink" title="92. 反转链表 II[medium]"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>[medium]</h1><h2 id="解法：头插法"><a href="#解法：头插法" class="headerlink" title="解法：头插法"></a>解法：头插法</h2><ul><li>定义两个指针，分别称之为 <code>g(guard 守卫)</code> 和 <code>p(point)</code>。首先根据方法的参数 <code>left</code> 确定 <code>g</code> 和 <code>p</code> 的位置。将 <code>g</code> 移动到第一个要反转的节点的前面，将 <code>p</code> 移动到第一个要反转的节点的位置上。以 <code>left=2</code>，<code>right=4</code>为例</li><li>将 <code>p</code> 后面的元素删除，然后添加到 <code>g</code> 的后面。也即头插法</li><li>根据 <code>left</code> 和 <code>right</code> 重复（2）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426161340.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* g=dummy;<br>        ListNode* p=dummy-&gt;next;<br>        <span class="hljs-comment">// 将指针移到相应的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            p=p-&gt;next;<br>            g=g-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 头插法插入节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left;++i)<br>        &#123;<br>            ListNode* remove=p-&gt;next;<br>            p-&gt;next=remove-&gt;next;<br>            remove-&gt;next=g-&gt;next;<br>            g-&gt;next=remove;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="143-重排链表-medium"><a href="#143-重排链表-medium" class="headerlink" title="143. 重排链表[medium]"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a>[medium]</h1><h2 id="解法：寻找链表中点-链表逆序-合并链表"><a href="#解法：寻找链表中点-链表逆序-合并链表" class="headerlink" title="解法：寻找链表中点 + 链表逆序 + 合并链表"></a>解法：寻找链表中点 + 链表逆序 + 合并链表</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span><br>第一步，将链表平均分成两半<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span><br>    <br>第二步，将第二个链表逆序<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">6</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">4</span><br>    <br>第三步，依次连接两个链表<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>第一步使用快慢指针寻找中点。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。<strong>如果链表节点个数是偶数的话，slow 需要走到的是左端点</strong>，这样可以把奇数和偶数的情况合并，不需要分开考虑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span> || head-&gt;next-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        ListNode* newHead=slow-&gt;next;<br>        <span class="hljs-comment">// 注意断链</span><br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 第二个链表倒置</span><br>        newHead=<span class="hljs-built_in">reverseList</span>(newHead);<br>        <span class="hljs-built_in">merge</span>(head,newHead);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">// 依次合并两个链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* next1=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next2=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span> &amp;&amp; l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next1=l1-&gt;next;<br>            next2=l2-&gt;next;<br>            l1-&gt;next=l2;<br>            l1=next1;<br>            l2-&gt;next=l1;<br>            l2=next2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/reorder-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-34/">windliang</a> 题解。</p></blockquote><h1 id="203-移除链表元素-easy"><a href="#203-移除链表元素-easy" class="headerlink" title="203. 移除链表元素[easy]"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a>[easy]</h1><h2 id="解法一：迭代-2"><a href="#解法一：迭代-2" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val!=val)<br>                cur=cur-&gt;next;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                ListNode* next=cur-&gt;next;<br>                cur-&gt;next=next-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：递归-6"><a href="#解法二：递归-6" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        head-&gt;next=<span class="hljs-built_in">removeElements</span>(head-&gt;next,val);<br>        <span class="hljs-keyword">if</span>(head-&gt;val==val)<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="237-删除链表中的节点-easy"><a href="#237-删除链表中的节点-easy" class="headerlink" title="237. 删除链表中的节点[easy]"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a>[easy]</h1><h2 id="解法：与下一个节点交换"><a href="#解法：与下一个节点交换" class="headerlink" title="解法：与下一个节点交换"></a>解法：与下一个节点交换</h2><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改之前节点的 <code>next</code> 指针，使其指向之后的节点。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427203956.png" style="zoom:67%;" /><p>因为我们无法访问想要删除的节点之前的节点，所以始终不能修改该节点的 <code>next</code>指针。相反，必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204208.png" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204137.png" alt="img" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204153.png" style="zoom:67%;" /><p>因为知道要删除的节点不是列表的末尾，所以可以保证这种方法是可行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        node-&gt;val=node-&gt;next-&gt;val;<br>        node-&gt;next=node-&gt;next-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="138-复制带随机指针的链表-medium"><a href="#138-复制带随机指针的链表-medium" class="headerlink" title="138. 复制带随机指针的链表[medium]"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a>[medium]</h1><h2 id="解法一：DFS-amp-BFS"><a href="#解法一：DFS-amp-BFS" class="headerlink" title="解法一：DFS&amp;BFS"></a>解法一：DFS&amp;BFS</h2><blockquote><p>参考 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">剑指offer题解——25.复杂链表的复制</a>。</p></blockquote><h2 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h2><p>遍历链表，建立一张 Hashmap，将链表的所有结点复制一份，存储到哈希表中（key 为原链表的结点，value 为新链表的结点，即复制结点）。再遍历原链表，借助哈希表查表的方式拷贝 next 和 random 指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        unordered_map&lt;Node*,Node*&gt; mp;<br>        Node* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            mp[cur]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur=cur-&gt;next;<br>        &#125;<br>        cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            mp[cur]-&gt;next=mp[cur-&gt;next];<br>            mp[cur]-&gt;random=mp[cur-&gt;random];<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法三：空间O-1-的迭代"><a href="#解法三：空间O-1-的迭代" class="headerlink" title="解法三：空间O(1)的迭代"></a>解法三：空间O(1)的迭代</h2><p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个节点后面添加原节点的拷贝。</p><ul><li><p>第一步，在每个节点的后面插入复制的节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png" style="zoom:67%;" /></li><li><p>第二步，对复制节点的 random 链接进行赋值。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png" style="zoom:67%;" /></li><li><p>第三步，拆分。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png" style="zoom:67%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 插入新节点</span><br>        Node* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* next=cur-&gt;next;<br>            Node* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur-&gt;next=clone;<br>            clone-&gt;next=next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-comment">// 建立 random 链接</span><br>        cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* clone=cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">nullptr</span>)<br>                clone-&gt;random=cur-&gt;random-&gt;next;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        cur=head;<br>        Node* cloneHead=head-&gt;next;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* clone=cur-&gt;next;<br>            Node* next=clone-&gt;next;<br>            cur-&gt;next=next;<br>            clone-&gt;next=next==<span class="hljs-literal">nullptr</span>?<span class="hljs-literal">nullptr</span>:next-&gt;next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linked List</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Stack and Queue</title>
    <link href="/2020/08/15/Leetcode%20Notes%E2%80%94%E2%80%94Stack%20and%20Queue/"/>
    <url>/2020/08/15/Leetcode%20Notes%E2%80%94%E2%80%94Stack%20and%20Queue/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>栈和队列</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a href="https://leetcode.wang/">wind-liang</a> 题解。</p><span id="more"></span><h1 id="232-用栈实现队列-easy"><a href="#232-用栈实现队列-easy" class="headerlink" title="232. 用栈实现队列[easy]"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>[easy]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>使用栈实现队列的下列操作：</p><ul><li>push(x) – 将一个元素放入队列的尾部。</li><li>pop() – 从队列首部移除元素。</li><li>peek() – 返回队列首部的元素。</li><li>empty() – 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp">MyQueue queue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyQueue</span>();<br><br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);  <br>queue.<span class="hljs-built_in">peek</span>();  <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">pop</span>();   <span class="hljs-comment">// 返回 1</span><br>queue.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 返回 false</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 – 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路：使用两个栈，一个栈<code>stackPush</code>用来放数据，一个栈<code>stackPop</code>用来取数据。取数据时，如果<code>stackPop</code>为空则需要将<code>stackPush</code>中的<strong>所有元素</strong>一次性依次<code>pop</code>并放入<code>stackPop</code>。</p><p>特别要注意的是这个<strong>倒数据</strong>的原则：</p><ul><li>只有当<code>stackPop</code>为空时才能往里倒；</li><li><strong>倒数据</strong>时必须一次性将<code>stackPush</code>中的数据倒完。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stackPush;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stackPop;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stackPush.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//如果stackPop中没有元素，就先把stackPush中的元素依次弹出压入stackPop</span><br>        <span class="hljs-keyword">if</span>(stackPop.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stackPush.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stackPop.<span class="hljs-built_in">push</span>(stackPush.<span class="hljs-built_in">top</span>());<br>                stackPush.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//stackPop中已经有元素了,就直接弹出栈顶元素</span><br>        <span class="hljs-type">int</span> res=stackPop.<span class="hljs-built_in">top</span>();<br>        stackPop.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//如果stackPop中没有元素，就先把stackPush中的元素依次弹出压入stackPop</span><br>        <span class="hljs-keyword">if</span>(stackPop.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stackPush.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stackPop.<span class="hljs-built_in">push</span>(stackPush.<span class="hljs-built_in">top</span>());<br>                stackPush.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//stackPop中已经有元素了,就直接获取栈顶元素</span><br>        <span class="hljs-keyword">return</span> stackPop.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//只要有一个栈元素不为空，队列就不为空</span><br>        <span class="hljs-keyword">return</span> stackPush.<span class="hljs-built_in">empty</span>()&amp;&amp;stackPop.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h1 id="225-用队列实现栈-easy"><a href="#225-用队列实现栈-easy" class="headerlink" title="225. 用队列实现栈[easy]"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a>[easy]</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 push to back, peek&#x2F;pop from front, size, 和 is empty 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：两个队列——压入O-1-、弹出O-n"><a href="#解法一：两个队列——压入O-1-、弹出O-n" class="headerlink" title="解法一：两个队列——压入O(1)、弹出O(n)"></a>解法一：两个队列——压入O(1)、弹出O(n)</h3><p>使用一个数据队列和辅助队列，当放入数据时使用队列的操作正常向数据队列中放，但出队元素时，需将数据队列的前 n-1 个数入队辅助队列，而将数据队列的队尾元素弹出来，最后数据队列和辅助队列交换角色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; data,help;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(data.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">1</span>)<br>        &#123;<br>            help.<span class="hljs-built_in">push</span>(data.<span class="hljs-built_in">front</span>());<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;                  <br>        <span class="hljs-type">int</span> res=data.<span class="hljs-built_in">front</span>();<br>        data.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">swapstack</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(data.<span class="hljs-built_in">size</span>()!=<span class="hljs-number">1</span>)<br>        &#123;<br>            help.<span class="hljs-built_in">push</span>(data.<span class="hljs-built_in">front</span>());<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;        <br>        <span class="hljs-type">int</span> res=data.<span class="hljs-built_in">front</span>();<br>        data.<span class="hljs-built_in">pop</span>();<br>        help.<span class="hljs-built_in">push</span>(res);<br>        <span class="hljs-built_in">swapstack</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>()&amp;&amp;help.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapstack</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt; tmp=help;<br>        help=data;<br>        data=tmp;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="解法二：一个队列——压入O-n-、弹出O-1"><a href="#解法二：一个队列——压入O-n-、弹出O-1" class="headerlink" title="解法二：一个队列——压入O(n)、弹出O(1)"></a>解法二：一个队列——压入O(n)、弹出O(1)</h3><p>在每一次 push 进新元素 x 时，需将前面的元素移到 x 的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; data;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        data.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            data.<span class="hljs-built_in">push</span>(data.<span class="hljs-built_in">front</span>());<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=data.<span class="hljs-built_in">front</span>();<br>        data.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="155-最小栈-easy"><a href="#155-最小栈-easy" class="headerlink" title="155. 最小栈[easy]"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a>[easy]</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>pop、top 和 getMin 操作总是在 非空栈 上调用。</li></ul><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里介绍两个思路，更多可看 <a href="https://leetcode.wang/leetcode-155-Min-Stack.html">wind-liang</a> 题解。</p><h3 id="解法一：两个栈"><a href="#解法一：两个栈" class="headerlink" title="解法一：两个栈"></a>解法一：两个栈</h3><p>使用两个栈，一个栈（stackData）保存数据，一个栈（stackMin）保存最小值。</p><ul><li>入栈：如果栈为空，则将 x 压入两个栈中。如果栈不为空，将 x 压入 stackData 中，如果 <code>x&lt;stackMin.top()</code>，将 x 压入 stackMin 中，否则将 <code>stackMin.top()</code> 压入 stackMin 中。</li><li>出栈：栈不为空时，将两个栈的栈顶元素弹出。</li><li>查询栈顶元素：stackData 不为空时，返回 stackData 栈顶元素。</li><li>查询最小值：stackMin 不为空时，返回 stackMin 栈顶元素。</li></ul><p>栈的对应关系如下图，一次压入3、4、5、1、2、1。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200816121923.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stackData,stackMin;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;       <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stackMin.<span class="hljs-built_in">empty</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x&lt;stackMin.<span class="hljs-built_in">top</span>())<br>            stackMin.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">else</span><br>            stackMin.<span class="hljs-built_in">push</span>(stackMin.<span class="hljs-built_in">top</span>());<br>        stackData.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        stackData.<span class="hljs-built_in">pop</span>();<br>        stackMin.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackData.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stackMin.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="解法二：一个栈"><a href="#解法二：一个栈" class="headerlink" title="解法二：一个栈"></a>解法二：一个栈</h3><p>解法一中单独用了一个栈去保存所有最小值，那么能不能只用一个变量去保存最小值呢？看一下下面的例子。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">入栈 3 <br>|<span class="hljs-string">   </span>|<span class="hljs-string">   min = 3</span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack   </span><br><span class="hljs-string"></span><br><span class="hljs-string">入栈 5 </span><br><span class="hljs-string"></span>|<span class="hljs-string">   </span>|<span class="hljs-string">   min = 3</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack  </span><br><span class="hljs-string"></span><br><span class="hljs-string">入栈 2 </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">   min = 2?</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack</span><br></code></pre></td></tr></table></figure><p>如果只用一个变量就会遇到一个问题，如果把 <code>min</code> 更新为 <code>2</code>，那么之前的最小值 <code>3</code> 就丢失了。怎么把 <code>3</code> 保存起来呢？把它在 <code>2</code> 之前压入栈中即可。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">入栈 2 ，同时将之前的 min 值 3 入栈，再把 2 入栈，同时更新 min = 2<br>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">   min = 2</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string">  </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack  </span><br><span class="hljs-string"></span><br><span class="hljs-string">入栈 6 </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 6 </span>|<span class="hljs-string">  min = 2</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">   </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string">  </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack  </span><br><span class="hljs-string"></span><br><span class="hljs-string">出栈 6     </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">   min = 2</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string">  </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack  </span><br><span class="hljs-string"></span><br><span class="hljs-string">出栈 2     </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string">   min = 2</span><br><span class="hljs-string"></span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string">  </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">     </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack</span><br></code></pre></td></tr></table></figure><p>上边的最后一个状态，当出栈元素是最小元素该如何处理呢？只需要把 <code>2</code> 出栈，然后再出栈一次，把 <code>3</code> 赋值给 <code>min</code> 即可。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">出栈 2     <br>|<span class="hljs-string">   </span>|<span class="hljs-string">  min = 3   </span><br><span class="hljs-string"></span>|<span class="hljs-string"> 5 </span>|<span class="hljs-string">   </span><br><span class="hljs-string"></span>|<span class="hljs-string">_3_</span>|<span class="hljs-string">    </span><br><span class="hljs-string">stack</span><br></code></pre></td></tr></table></figure><p>通过上边的方式，就只需要一个栈了。当有更小的值来的时候，只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; data;<br>    <span class="hljs-type">int</span> minValue=INT_MAX;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;       <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">//当前值更小</span><br>        <span class="hljs-keyword">if</span>(x&lt;=minValue)<br>        &#123;<br>            <span class="hljs-comment">//将之前的最小值保存</span><br>            data.<span class="hljs-built_in">push</span>(minValue);<br>            <span class="hljs-comment">//更新最小值</span><br>            minValue=x;<br>        &#125;<br>        data.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//如果弹出的值是最小值，那么将下一个元素更新为最小值并弹出</span><br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">top</span>()==minValue)<br>        &#123;           <br>            data.<span class="hljs-built_in">pop</span>();<br>            minValue=data.<span class="hljs-built_in">top</span>();<br>        &#125;<br>        data.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minValue;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20. 有效的括号[easy]"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a>[easy]</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;(]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;([)]&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入: <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>判断括号的有效性可以使用「栈」这一数据结构来解决。</p></blockquote><p>对给定的字符串 s 进行遍历，当遇到一个左括号时，会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此可以将这个左括号放入栈顶。</p><p>当遇到一个右括号时，需要将一个相同类型的左括号闭合。此时，可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。</p><p>在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。</p><p>注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，可以直接返回 False，省去后续的遍历判断过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(size%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>)<br>                stk.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-type">char</span> c=stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;c!=<span class="hljs-string">&#x27;(&#x27;</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;c!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;c!=<span class="hljs-string">&#x27;[&#x27;</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="739-每日温度-medium"><a href="#739-每日温度-medium" class="headerlink" title="739. 每日温度[medium]"></a><a href="https://leetcode-cn.com/problems/daily-temperatures/">739. 每日温度</a>[medium]</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p><strong>提示：</strong>气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>针对每个温度值向后进行依次搜索 ，找到比当前温度更高的值。</p><p>C++ 超时，java 不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] dailyTemperatures(<span class="hljs-type">int</span>[] T) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> T.length;<br>    <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> T[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>            <span class="hljs-keyword">if</span> (T[j] &gt; current) &#123;<br>                result[i] = j - i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="解法二：单调栈"><a href="#解法二：单调栈" class="headerlink" title="解法二：单调栈"></a>解法二：单调栈</h3><blockquote><p><strong>什么时候用单调栈：</strong></p><ul><li>通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素</li><li>且要求 O(n) 的时间复杂度</li></ul></blockquote><p>维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p><p>正向遍历温度列表，对于温度列表中的每个元素 <code>T[i]</code>：</p><ul><li>如果栈非空且当前值大于<code>单调栈</code>的栈顶元素，则将栈顶元素出栈，并计算时间差；</li><li>否则，将当前元素的索引<code>push</code>到栈中。</li></ul><p>由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size=T.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;T[i]&gt;T[s.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                <span class="hljs-type">int</span> top=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res[top]=i-top;<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，对于温度列表中的每个下标，最多有一次进栈和出栈的操作。</li><li>空间复杂度：O(n)，需要维护一个单调栈存储温度列表中的下标。</li></ul><h3 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h3><p>从最后一天推到第一天，这样会简单很多。因为最后一天显然不会再有升高的可能，结果直接为0。再看倒数第二天的温度，如果比倒数第一天低，那么答案显然为 1，如果比倒数第一天高，又因为倒数第一天对应的结果为 0，即表示之后不会再升高，所以倒数第二天的结果也应该为 0。自此容易观察出规律，要求出第 i 天对应的结果，只需要知道第 i+1 天对应的结果就可以：</p><ul><li>如果<code>T[i] &lt; T[i + 1]</code>，则<code>res[i] = 1</code>。</li><li>如果<code>T[i] &gt; T[i + 1]</code>，<ul><li>如果<code>res[i + 1] = 0</code>，那么<code>res[i] = 0</code>；</li><li>如果<code>res[i + 1] != 0</code>，那就比较<code>T[i]</code>和<code>T[i + 1 + res[i + 1]]</code>（即将第 i 天的温度与比第 i+1 天大的那天的温度进行比较）。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; T)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size=T.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//从右向左遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=size<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-comment">//j+=res[j]是利用已经有的结果进行跳跃</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;size;j+=res[j])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(T[i]&lt;T[j])<br>                &#123;<br>                    res[i]=j-i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//遇到0表示后面不会有更大的值，那当然当前值就应该也为0</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    res[i]=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="496-下一个更大元素-I-easy"><a href="#496-下一个更大元素-I-easy" class="headerlink" title="496. 下一个更大元素 I[easy]"></a><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a>[easy]</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中 nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p><strong>示例 1:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>].<br>输出: [<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释:<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">4</span>，你无法在第二个数组中找到下一个更大的数字，因此输出 <span class="hljs-number">-1</span>。<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">1</span>，第二个数组中数字<span class="hljs-number">1</span>右边的下一个较大数字是 <span class="hljs-number">3</span>。<br>    对于<span class="hljs-symbol">num1</span>中的数字<span class="hljs-number">2</span>，第二个数组中没有下一个更大的数字，因此输出 <span class="hljs-number">-1</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入: <span class="hljs-symbol">nums1</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-symbol">nums2</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>].<br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>]<br>解释:<br>    对于 <span class="hljs-symbol">num1</span> 中的数字 <span class="hljs-number">2</span> ，第二个数组中的下一个较大数字是 <span class="hljs-number">3</span> 。<br>    对于 <span class="hljs-symbol">num1</span> 中的数字 <span class="hljs-number">4</span> ，第二个数组中没有下一个更大的数字，因此输出 <span class="hljs-number">-1</span> 。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>nums1和 nums2 中所有元素是唯一的。</li><li>nums1和 nums2 的数组大小都不超过1000。</li></ol><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力-1"><a href="#解法一：暴力-1" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>对于<code>nums1</code>的每个元素，在<code>nums2</code>中找到它，假设它的下标为<code>i</code>，那么从第<code>i+1</code>位开始搜索是否存在比它大的，找到就将该值加入记录中，否则加入<code>-1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> size1=nums1.<span class="hljs-built_in">size</span>(); <br>        <span class="hljs-type">int</span> size2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n:nums1)<br>        &#123;<br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(nums2[i]!=n)<br>                i++;<br>            i++;<br>            <span class="hljs-keyword">for</span>(;i&lt;size2;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums2[i]&gt;n)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;    <br>            <span class="hljs-keyword">if</span>(i==size2)<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);    <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：单调栈-1"><a href="#解法二：单调栈-1" class="headerlink" title="解法二：单调栈"></a>解法二：单调栈</h3><p>忽略数组 nums1，先对 nums2 中的每一个元素，求出其下一个更大的元素。将这些答案放入哈希映射（HashMap）中，再遍历数组 nums1，并直接找出答案。对于 nums2，可以使用单调栈来解决这个问题。即</p><ol><li>遍历数组<code>nums2</code>，当当前元素小于栈顶元素时，继续将它入栈；当当前元素大于栈顶元素时，栈顶元素出栈，此时插入到哈希表中：<code>m[出栈的元素] = 当前元素</code>；</li><li>当遍历完<code>nums2</code>后，将栈中的元素出栈，插入到哈希表，其值为<code>-1</code>；</li><li>遍历数组<code>nums1</code>，从哈希表中找到元素对应的下一个更大的元素，将其添加到结果数组中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums2)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;num&gt;s.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                mp[s.<span class="hljs-built_in">top</span>()]=num;<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            mp[s.<span class="hljs-built_in">top</span>()]=<span class="hljs-number">-1</span>;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums1)<br>            res.<span class="hljs-built_in">push_back</span>(mp[num]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(M+N)，其中 M 和 N 分别是数组 nums1 和 nums2 的长度。</li><li>空间复杂度：O(N)。在遍历 nums2 时，需要使用栈，以及哈希映射用来临时存储答案。</li></ul><h1 id="503-下一个更大元素-II-medium"><a href="#503-下一个更大元素-II-medium" class="headerlink" title="503. 下一个更大元素 II[medium]"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>[medium]</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,1]</span><br><span class="hljs-section">输出: [2,-1,2]</span><br><span class="hljs-section">解释: 第一个 1 的下一个更大的数是 2；</span><br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p><h2 id="解题思路：单调栈"><a href="#解题思路：单调栈" class="headerlink" title="解题思路：单调栈"></a>解题思路：单调栈</h2><blockquote><p>单调栈主要用来处理 <strong>Next Greater Element</strong> 这类典型问题。单调栈的套路模板可以学习 <a href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dan-tiao-zhan">labuladong的算法小抄</a>。</p></blockquote><p>思路摘抄自上述博客。</p><p>与普通数组不同的是，本题需要处理循环数组。循环数组拥有环形属性，即可以绕一圈来找比自己大的元素。比如数组 [2,1,2,4,3]，返回数组 [4,2,4,-1,4]，最后一个元素 3 绕了一圈后找到了比自己大的元素 4 。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818194014.png" style="zoom: 50%;" /><p>计算机的内存都是线性的，没有真正意义上的环形数组，但是可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br><span class="hljs-built_in">int</span> n = arr.length, <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">print</span>(arr[<span class="hljs-keyword">index</span> % n]);<br>    <span class="hljs-keyword">index</span>++;<br>&#125;<br></code></pre></td></tr></table></figure><p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边（如上例）。</p><p>可以考虑这样的思路：将原始数组“翻倍”，就是在后面再接一个原始数组，这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818194023.png" style="zoom:80%;" /><p>怎么实现呢？当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，我们可以不用构造新数组，而是利用循环数组的技巧来模拟。</p><h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> size=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(size)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-comment">// 假装这个数组长度翻倍了</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>*size<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;s.<span class="hljs-built_in">top</span>()&lt;=nums[i%size])<br>                s.<span class="hljs-built_in">pop</span>();<br>            res[i%size]=s.<span class="hljs-built_in">empty</span>()?<span class="hljs-number">-1</span>:s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">push</span>(nums[i%size]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><blockquote><p>参考 @<a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dong-hua-jiang-jie-dan-diao-zhan-by-fuxu-4z2g/">负雪明烛</a> 题解。</p></blockquote><p>栈里面需要保存元素在数组中的下标，而不是具体的数字。因为需要根据下标修改结果数组 <code>res</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n;++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;nums[i%n]&gt;nums[s.<span class="hljs-built_in">top</span>()])<br>            &#123;<br>                res[s.<span class="hljs-built_in">top</span>()]=nums[i%n];<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i%n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N)。</li></ul><p>以12443111为例，可以发现低位的3是比高位的2大的最小值(4也比2大，但不是最小值)，那么可以将3和2进行交换，得到13442111，然后再把4以后的数按从小到大的顺序进行排列即可，答案为13111244.</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Stack and Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——BST</title>
    <link href="/2020/08/11/Leetcode%20Notes%E2%80%94%E2%80%94BST/"/>
    <url>/2020/08/11/Leetcode%20Notes%E2%80%94%E2%80%94BST/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为**二叉搜索树(BST)**篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a href="https://leetcode.wang/">wind-liang</a> 题解。</p><span id="more"></span><h1 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98. 验证二叉搜索树[medium]"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>[medium]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br>解释: 输入为: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]。<br>     根节点的值为 <span class="hljs-number">5</span> ，但是其右子节点值为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><blockquote><p>二叉搜索树性质：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p></blockquote><p>设计一个递归函数 <code>helper(root, lower, upper)</code> 来递归判断，函数表示考虑以 <code>root</code> 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（<strong>注意是开区间</strong>）。如果 <code>root</code> 节点的值 <code>val</code>  不在 (l,r) 的范围内说明不满足条件直接返回，否则继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>根据二叉搜索树的性质，在递归调用左子树时，需要把上界 <code>upper</code> 改为 <code>root.val</code>，即调用 <code>helper(root.left, lower, root.val)</code>，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，需要把下界 <code>lower</code> 改为 <code>root.val</code>，即调用 <code>helper(root.right, root.val, upper)</code>。</p><p>函数递归调用的入口为 <code>helper(root, -inf, +inf)</code>， <code>inf</code> 表示一个无穷大的值。本题设置为 <code>LONG_MIN</code> 和 <code>LONG_MAX</code>（用 <code>long</code> 防止 <code>INT_MAX</code> 溢出，当输入测试样例为 <code>2^32-1</code> 时会发生等于情况，边界要比这个大）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root,LONG_MIN,LONG_MAX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">long</span> lower,<span class="hljs-type">long</span> upper)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val&gt;=upper||root-&gt;val&lt;=lower)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root-&gt;left,lower,root-&gt;val)&amp;&amp;<span class="hljs-built_in">isValidBST</span>(root-&gt;right,root-&gt;val,upper);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 : O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。</li><li>空间复杂度 : O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。</li></ul><h3 id="解法二：中序遍历"><a href="#解法二：中序遍历" class="headerlink" title="解法二：中序遍历"></a>解法二：中序遍历</h3><blockquote><p>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的。</p></blockquote><p>在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">long</span> pre=LONG_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 访问左子树</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValidBST</span>(root-&gt;left))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val&lt;=pre)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre=root-&gt;val;<br>        <span class="hljs-comment">// 访问右子树</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* pre=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(root);<br>                root=root-&gt;left;<br>            &#125;<br>            root=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;val&lt;=pre-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            pre=root;<br>            root=root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 : O(n)，其中 n 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。</li><li>空间复杂度 : O(n)，其中 n 为二叉树的节点个数。栈最多存储 n 个节点，因此需要额外的 O(n) 的空间。</li></ul><h1 id="530-二叉搜索树的最小绝对差-easy"><a href="#530-二叉搜索树的最小绝对差-easy" class="headerlink" title="530. 二叉搜索树的最小绝对差[easy]"></a><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a>[easy]</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：<br><br>   1<br>    \<br>     3<br>    /<br>   2<br><br>输出：<br>1<br><br>解释：<br>最小绝对差为 1，其中<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 1 </span>的差的绝对值为 1（或者<span class="hljs-number"> 2 </span>和 3）。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中至少有 2 个节点。</li><li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同。</li></ul><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的。</p></blockquote><p> <code>pre</code> 存储前继数，遍历时求相邻两个节点之间的最小绝对差值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> res=INT_MAX;<br>    TreeNode* pre=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>)<br>            res=<span class="hljs-built_in">min</span>(res,root-&gt;val-pre-&gt;val);<br>        pre=root;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索-easy"><a href="#700-二叉搜索树中的搜索-easy" class="headerlink" title="700. 二叉搜索树中的搜索[easy]"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a>[easy]</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><p>给定二叉搜索树:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">        <span class="hljs-number">4</span><br>       / <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>   <span class="hljs-number">7</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br><br>和值: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>你应该返回如下子树:</p><div class="code-wrapper"><pre><code class="hljs">  2      / \   1   3</code></pre></div><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉搜索树是一棵二叉树，每个节点都有以下特性：</p><ul><li>大于左子树上任意一个节点的值，</li><li>小于右子树上任意一个节点的值。</li></ul><h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><ul><li>如果根节点为空 root&#x3D;&#x3D;null 或者根节点的值等于搜索值 val &#x3D;&#x3D; root.val，返回根节点。</li><li>如果 val&lt;root.val，进入根节点的左子树查找 searchBST(root.left, val)。</li><li>如果 val&gt;root.val，进入根节点的右子树查找 searchBST(root.right, val)。</li><li>返回根节点。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200811100450.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||root-&gt;val==val)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">return</span> root-&gt;val&lt;val?<span class="hljs-built_in">searchBST</span>(root-&gt;right,val):<span class="hljs-built_in">searchBST</span>(root-&gt;left,val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(H)，其中 H 是树高。平均时间复杂度为 O(logN)，最坏时间复杂度为 O(N)。</li><li>空间复杂度：O(H)，递归栈的深度为 H。平均情况下深度为 O(logN)，最坏情况下深度为 O(N)。</li></ul><h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>为了降低空间复杂度，将递归转换为迭代：</p><ul><li>如果根节点不空 root !&#x3D;null 且根节点不是目的节点 val !&#x3D; root.val：<ul><li>如果 val&lt;root.val，进入根节点的左子树查找 root&#x3D;root.left。</li><li>如果 val&gt;root.val，进入根节点的右子树查找 root&#x3D;root.right。</li></ul></li><li>返回 root。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>&amp;&amp;val!=root-&gt;val)<br>            root=val&lt;root-&gt;val?root-&gt;left:root-&gt;right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(H)，其中 H 是树高。平均时间复杂度为 O(logN)，最坏时间复杂度为 O(N)。</li><li>空间复杂度：O(1)，恒定的额外空间。</li></ul><h1 id="701-二叉搜索树中的插入操作-medium"><a href="#701-二叉搜索树中的插入操作-medium" class="headerlink" title="701. 二叉搜索树中的插入操作[medium]"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a>[medium]</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p><p>例如, </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉搜索树:<br><br>        <span class="hljs-number">4</span><br>       / <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>   <span class="hljs-number">7</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br><br>和 插入的值: <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>你可以返回这个二叉搜索树:</p><div class="code-wrapper"><pre><code class="hljs">     4   /   \  2     7 / \   /1   3 5</code></pre></div><p>或者这个树也是有效的:</p><div class="code-wrapper"><pre><code class="hljs">     5   /   \  2     7 / \   1   3     \      4</code></pre></div><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉搜索树的巨大优势就是：在平均情况下，能够在 O(logN) 的时间内完成搜索和插入元素。</p><p>二叉搜索树的插入方法非常简单，将插入的节点作为叶子节点的子节点插入。插入到哪个叶节点可以遵循以下原则：</p><ul><li>若 val &gt; node.val，插入到右子树。</li><li>若 val &lt; node.val，插入到左子树。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200819221944.jpeg" style="zoom:67%;" /><h3 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><ul><li>若 root &#x3D;&#x3D; null，则返回 TreeNode(val)。</li><li>若 val &gt; root.val，插入到右子树。</li><li>若 val &lt; root.val，插入到左子树。</li><li>返回 root。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span>(val&gt;root-&gt;val)<br>            root-&gt;right=<span class="hljs-built_in">insertIntoBST</span>(root-&gt;right,val);<br>        <span class="hljs-keyword">else</span> <br>            root-&gt;left=<span class="hljs-built_in">insertIntoBST</span>(root-&gt;left,val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(H)，其中 H 指的是树的高度。平均情况下 O(logN)，最坏的情况下 O(N)。</li><li>空间复杂度：平均情况下 O(H)。最坏的情况下是 O(N)，是在递归过程中堆栈使用的空间。</li></ul><h3 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>上面的递归可以转换为迭代的解决方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        TreeNode* node=root;<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val&gt;node-&gt;val)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    node-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    <span class="hljs-keyword">return</span> root;<br>                &#125;    <br>                <span class="hljs-keyword">else</span><br>                    node=node-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(node-&gt;left==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    node-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    <span class="hljs-keyword">return</span> root;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    node=node-&gt;left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(H)，其中 H 指的是树的高度。平均情况下 O(logN)，最坏的情况下 O(N)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="230-二叉搜索树中第K小的元素-medium"><a href="#230-二叉搜索树中第K小的元素-medium" class="headerlink" title="230. 二叉搜索树中第K小的元素[medium]"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a>[medium]</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p><strong>说明：</strong><br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">1</span><br>   <span class="hljs-number">3</span><br>  / <span class="hljs-string">\</span><br> <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>       <span class="hljs-number">5</span><br>      / <span class="hljs-string">\</span><br>     <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span>   <span class="hljs-number">4</span><br>  /<br> <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>进阶：<br>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：中序遍历"><a href="#解法一：中序遍历" class="headerlink" title="解法一：中序遍历"></a>解法一：中序遍历</h3><blockquote><p>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的。</p></blockquote><p>使用中序遍历，遍历到的第 K 个结点就是第 K 小的结点。增加两个变量 count 和 res。count 记录中序遍历已经输出的元素个数，当 count&#x3D;&#x3D;k 的时候，将当前元素保存到 res 中，然后返回。</p><h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root,k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,k);<br>        count++;<br>        <span class="hljs-keyword">if</span>(count==k)<br>        &#123;<br>            res=root-&gt;val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            count++;<br>            <span class="hljs-keyword">if</span>(count==k)<br>            &#123;<br>                res=cur-&gt;val;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><p>先计算左右子树的结点数，设左子树的结点数为<code>n</code>：</p><ul><li>如果<code>k &lt;= n</code>，则递归地在左子树中查找第<code>k</code>小的结点（同样要先计算左子树根结点的左右子树的结点数）；</li><li>如果<code>k == n + 1</code>，则当前结点为第<code>k</code>小的结点；</li><li>如果<code>k &gt; n + 1</code>，则递归地在右子树中查找第<code>n - k - 1</code>小的结点（同样要先计算右子树根结点的左右子树的结点数）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">count</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(k&lt;=n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">kthSmallest</span>(root-&gt;left,k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&gt;n+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">kthSmallest</span>(root-&gt;right,k-n<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">count</span>(root-&gt;left)+<span class="hljs-built_in">count</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="99-恢复二叉搜索树-hard"><a href="#99-恢复二叉搜索树-hard" class="headerlink" title="99. 恢复二叉搜索树[hard]"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">99. 恢复二叉搜索树</a>[hard]</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉搜索树中的两个节点被错误地交换。</p><p>请在不改变其结构的情况下，恢复这棵树。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br><br>   <span class="hljs-number">1</span><br>  /<br> <span class="hljs-number">3</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br><br>输出: [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br><br>   <span class="hljs-number">3</span><br>  /<br> <span class="hljs-number">1</span><br>  <span class="hljs-string">\</span><br>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br><br>  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>   /<br>  <span class="hljs-number">2</span><br><br>输出: [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br><br>  <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>   /<br>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong></p><ul><li>使用 O(n) 空间复杂度的解法很容易实现。</li><li>你能想出一个只使用常数空间的解决方案吗？</li></ul><h2 id="解题思路：中序遍历"><a href="#解题思路：中序遍历" class="headerlink" title="解题思路：中序遍历"></a>解题思路：中序遍历</h2><blockquote><p>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的。</p></blockquote><p>题目交换了两个数字，其实就是在有序序列中交换了两个数字。而我们只需要找到那两个交换数字，把它还原。</p><p>交换的位置有两种情况：</p><ul><li><p>相邻的两个数字交换</p><p>[ 1 2 3 4 5 ] 中 2 和 3 进行交换，[ 1 3 2 4 5 ]，这样的话只产生一组逆序的数字（正常情况是从小到大排序，交换后产生了从大到小），3 2。</p><p>我们只需要遍历数组，找到后，把这一组的两个数字进行交换即可。</p></li><li><p>不相邻的两个数字交换</p><p>[ 1 2 3 4 5 ] 中 2 和 5 进行交换，[ 1 5 3 4 2 ]，这样的话其实就是产生了两组逆序的数字对。5 3 和 4 2。</p><p>我们只需要遍历数组，然后找到这两组逆序对，然后把第一组前一个数字和第二组后一个数字进行交换即完成了还原。</p></li></ul><p>所以在中序遍历中，只需要利用一个 pre 节点和当前节点比较，如果 pre 节点的值大于当前节点的值，那么就是我们要找的逆序的数字。分别用两个指针 first 和 second 保存即可。如果找到第二组逆序的数字，就把 second 更新为当前节点。最后把 first 和 second 两个的数字交换即可。</p><p>中序遍历思路参考 <a href="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/">Leetcode Notes——Tree</a> 部分 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>。</p><h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-built_in">swap</span>(first-&gt;val,second-&gt;val);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    TreeNode* first=<span class="hljs-literal">nullptr</span>;<br>    TreeNode* second=<span class="hljs-literal">nullptr</span>;<br>    TreeNode* pre=<span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        <span class="hljs-comment">//------------------------------------</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;val&gt;root-&gt;val)<br>        &#123;<br>            <span class="hljs-comment">//第一次遇到逆序对</span><br>            <span class="hljs-keyword">if</span>(first==<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                first=pre;<br>                second=root;<br>            &#125;<br>            <span class="hljs-comment">//第二次遇到逆序对</span><br>            <span class="hljs-keyword">else</span><br>                second=root;<br>        &#125;<br>        pre=root;<br>        <span class="hljs-comment">//-------------------------------------</span><br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="基于栈的迭代"><a href="#基于栈的迭代" class="headerlink" title="基于栈的迭代"></a>基于栈的迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode* first=<span class="hljs-literal">nullptr</span>;<br>        TreeNode* second=<span class="hljs-literal">nullptr</span>;<br>        TreeNode* pre=<span class="hljs-literal">nullptr</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(root);<br>                root=root-&gt;left;<br>            &#125;<br>            root=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//----------------------------------------</span><br>            <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;val&gt;root-&gt;val)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(first==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    first=pre;<br>                    second=root;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    second=root;<br>            &#125;<br>            pre=root;<br>            <span class="hljs-comment">//----------------------------------------</span><br>            root=root-&gt;right;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(first-&gt;val,second-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：最坏情况下（即待交换节点为二叉搜索树最右侧的叶子节点）需要遍历整棵树，时间复杂度为 O(N)，其中 N 为二叉搜索树的节点个数。</li><li>空间复杂度：O(H)，其中 H 为二叉搜索树的高度。中序遍历的时候栈的深度取决于二叉搜索树的高度。</li></ul><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* first=<span class="hljs-literal">nullptr</span>;<br>        TreeNode* second=<span class="hljs-literal">nullptr</span>;<br>        TreeNode* pre_new=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode* pre=root-&gt;left;<br>                <span class="hljs-comment">// 找左子树最右边的节点</span><br>                <span class="hljs-keyword">while</span>(pre-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;right!=root)<br>                    pre=pre-&gt;right;<br>                <span class="hljs-comment">// 情况 2.1</span><br>                <span class="hljs-keyword">if</span>(pre-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre-&gt;right=root;<br>                    root=root-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">//情况 2.2</span><br>                &#123;<br>                    pre-&gt;right=<span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//这里可以恢复为 null</span><br>                    <span class="hljs-comment">//-------------------------------------------</span><br>                    <span class="hljs-keyword">if</span>(pre_new!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre_new-&gt;val&gt;root-&gt;val)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(first==<span class="hljs-literal">nullptr</span>)<br>                        &#123;<br>                            first=pre_new;<br>                            second=root;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                            second=root;<br>                    &#125;<br>                    pre_new=root;<br>                    <span class="hljs-comment">//--------------------------------------------</span><br>                    root=root-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-comment">//情况1</span><br>            &#123;<br>                <span class="hljs-comment">//--------------------------------------------</span><br>                <span class="hljs-keyword">if</span>(pre_new!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre_new-&gt;val&gt;root-&gt;val)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(first==<span class="hljs-literal">nullptr</span>)<br>                    &#123;<br>                        first=pre_new;<br>                        second=root;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        second=root;<br>                &#125;<br>                pre_new=root;<br>                <span class="hljs-comment">//---------------------------------------------</span><br>                root=root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(first-&gt;val,second-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 为二叉搜索树的节点个数。Morris 遍历中每个节点会被访问两次，因此总时间复杂度为 O(2N)&#x3D;O(N)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="108-将有序数组转换为二叉搜索树-easy"><a href="#108-将有序数组转换为二叉搜索树-easy" class="headerlink" title="108. 将有序数组转换为二叉搜索树[easy]"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a>[easy]</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定有序数组: [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9],<br><br>一个可能的答案是：[0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]，它可以表示下面这个高度平衡二叉搜索树：<br><br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>BST 的中序遍历是升序的，因此本题等同于根据中序遍历的序列恢复二叉搜索树。因此可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树。又因为本题要求高度平衡，因此需要选择升序序列的中间元素作为根节点。注意这里的边界情况，包括左边界，不包括右边界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left=<span class="hljs-built_in">dfs</span>(nums,left,mid);<br>        root-&gt;right=<span class="hljs-built_in">dfs</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。</li><li>空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(logn)。</li></ul><h1 id="109-有序链表转换二叉搜索树-medium"><a href="#109-有序链表转换二叉搜索树-medium" class="headerlink" title="109. 有序链表转换二叉搜索树[medium]"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a>[medium]</h1><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><strong>示例:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs subunit">给定的有序链表： [<span class="hljs-string">-10</span>, <span class="hljs-string">-3</span>, 0, 5, 9],<br><br>一个可能的答案是：[0, <span class="hljs-string">-3</span>, 9, <span class="hljs-string">-10</span>, null, 5], 它可以表示下面这个高度平衡二叉搜索树：<br><br>      0<br>     / \<br>   <span class="hljs-string">-3</span>   9<br>   /   /<br> <span class="hljs-string">-10</span>  5<br></code></pre></td></tr></table></figure><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：转成数组-递归"><a href="#解法一：转成数组-递归" class="headerlink" title="解法一：转成数组+递归"></a>解法一：转成数组+递归</h3><p>将有序链表转换成有序数组，然后使用 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a> 的方法构建高度平衡的二叉搜索树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            nums.<span class="hljs-built_in">push_back</span>(head-&gt;val);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left=<span class="hljs-built_in">dfs</span>(nums,left,mid);<br>        root-&gt;right=<span class="hljs-built_in">dfs</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，需要将链表转成数组。取中间元素的开销为 O(1) 。</li><li>空间复杂度：O(N)，数组进行辅助。</li></ul><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p>直接使用链表构建高度平衡的二叉搜索树：</p><ol><li>选取链表中间的结点作为根结点。</li><li>根结点左边部分作为左子树，右边部分作为右子树。</li></ol><p>递归执行步骤1、2。</p><p>查找链表中间结点使用<strong>快慢指针</strong>的方法。快指针和慢指针同时从头部开始遍历，快指针每次走两步，慢指针每次走一步，当快指针走到链表尾部，此时慢指针就指向了中间位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(head,<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">getMidNode</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=tail&amp;&amp;fast-&gt;next!=tail)<br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==tail)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* midNode=<span class="hljs-built_in">getMidNode</span>(head,tail);<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(midNode-&gt;val);<br>        root-&gt;left=<span class="hljs-built_in">dfs</span>(head,midNode);<br>        root-&gt;right=<span class="hljs-built_in">dfs</span>(midNode-&gt;next,tail);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：递推式为<code>T(n)=2*T(n/2)+O(n)</code>，根据 <a href="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/#%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E8%B4%A8">master 公式</a>，时间复杂度为<code>O(nlog(n))</code>。</li><li>空间复杂度：O(logN)。因为使用递归的方法，需要考虑递归栈的空间复杂度。对于一棵平衡二叉树，可能需要 O(N) 的空间，但是问题描述中要求维护一棵高度平衡二叉树，所以保证树的高度上界为 O(logN)，因此空间复杂度为 O(logN)。</li></ul><h3 id="解法三：中序遍历模拟"><a href="#解法三：中序遍历模拟" class="headerlink" title="解法三：中序遍历模拟"></a>解法三：中序遍历模拟</h3><p>解法二虽然没有借助数组，优化了空间复杂度，但是时间复杂度增加了，那么有没有一种两全其美的方法，时间复杂度是解法一，空间复杂度是解法二。</p><p>主要思想是，因为我们知道题目给定的升序链表，其实就是二叉搜索树的中序遍历。那么完全可以按照这个顺序去为每个节点赋值。</p><p>实现的话，套用中序遍历的递归过程，并且将 <code>left</code> 和 <code>right</code> 作为递归参数，当 <code>left==right</code> 的时候，就返回 <code>null</code>。中序遍历是将 <code>node.val</code> 进行保存，这里的话是给当前节点进行赋值，为了依次赋值，需要一个<code>cur</code>指针指向给定的链表，每赋一个值就进行后移。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        cur=head;<br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            end++;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,end);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode* cur=<span class="hljs-literal">nullptr</span>;    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//遍历左子树并且将根节点返回</span><br>        TreeNode* left=<span class="hljs-built_in">dfs</span>(l,mid);<br>        <span class="hljs-comment">//遍历当前根节点并进行赋值</span><br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(cur-&gt;val);<br>        root-&gt;left=left;<br>        cur=cur-&gt;next;<span class="hljs-comment">//指针后移，进行下一次的赋值</span><br>        <span class="hljs-comment">//遍历右子树并且将根节点返回</span><br>        root-&gt;right=<span class="hljs-built_in">dfs</span>(mid+<span class="hljs-number">1</span>,r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，需要遍历链表中所有的节点一次并构造相应的二叉搜索树节点。</li><li>空间复杂度：O(logN) ，额外空间只有一个递归栈，由于是一棵高度平衡的二叉搜索树，所以高度上界为 logN。</li></ul><h1 id="501-二叉搜索树中的众数-easy"><a href="#501-二叉搜索树中的众数-easy" class="headerlink" title="501. 二叉搜索树中的众数[easy]"></a><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a>[easy]</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p><p>假定 BST 有如下定义：</p><ul><li>结点左子树中所含结点的值小于等于当前结点的值</li><li>结点右子树中所含结点的值大于等于当前结点的值</li><li>左子树和右子树都是二叉搜索树</li></ul><p><strong>例如：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">给定 <span class="hljs-symbol">BST</span> [<span class="hljs-number">1</span>,null,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],<br>   <span class="hljs-number">1</span><br>    \<br>     <span class="hljs-number">2</span><br>    /<br>   <span class="hljs-number">2</span><br>返回[<span class="hljs-number">2</span>].<br></code></pre></td></tr></table></figure><p>提示：如果众数超过1个，不需考虑输出顺序</p><p>进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题让我们求二叉搜索树中的众数，这里定义的二叉搜索树中左根右结点之间的关系是小于等于的，有些题目中是严格小于的，所以一定要看清题目要求。</p><h3 id="解法一：利用哈希表"><a href="#解法一：利用哈希表" class="headerlink" title="解法一：利用哈希表"></a>解法一：利用哈希表</h3><p>所谓的众数就是出现最多次的数字，可以有多个，那么这道题比较直接点思路就是利用一个哈希表来记录数字和其出现次数之前的映射，然后维护一个变量 mx 来记录当前最多的次数值，这样在遍历完树之后，根据这个 mx 值就能把对应的元素找出来。用这种方法的话就不需要用到二叉搜索树的性质了，随意一种遍历方式都可以。这里采用递归中序遍历的写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:mp)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i.second==mx)<br>                res.<span class="hljs-built_in">push_back</span>(i.first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        mx=<span class="hljs-built_in">max</span>(mx,++mp[root-&gt;val]);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N)，需要用哈希表统计结点值出现的次数。</li></ul><h3 id="解法二：二叉搜索树中序遍历性质"><a href="#解法二：二叉搜索树中序遍历性质" class="headerlink" title="解法二：二叉搜索树中序遍历性质"></a>解法二：二叉搜索树中序遍历性质</h3><p>题目进阶中让我们不用除了递归中的隐含栈之外的额外空间，所以不能使用哈希表。二叉搜索树中序遍历的结果是有序的，因此只要比较前后两个元素是否相等以及统计某个元素出现的次数，因为相同的元素是连在一起的。</p><p>利用一个节点变量 pre 记录上一个遍历到的节点，变量 mx 记录出现次数的最大值，变量 cnt 计数当前元素出现的次数。在中序遍历的时候，如果 pre 不为空，说明当前不是第一个节点，就和前一个结点进行比较，如果相等，cnt 自增 1，如果不等，cnt 重置 1。再比较 mx 和 cnt 的大小：</p><ul><li>如果 cnt&#x3D;&#x3D;mx，直接将当前节点值加入结果 res。</li><li>如果 cnt&gt;mx，则清空结果 res，并把当前节点值加入结果 res。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorder</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    TreeNode* pre=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> mx=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left,res);<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>)<br>            cnt=root-&gt;val==pre-&gt;val?cnt+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(cnt==mx)<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt&gt;mx)<br>        &#123;<br>            res.<span class="hljs-built_in">clear</span>();<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            mx=cnt;<br>        &#125;<br>        pre=root;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(H)，H 为二叉搜索树的高度，额外空间为递归栈。</li></ul><h1 id="450-删除二叉搜索树中的节点-medium"><a href="#450-删除二叉搜索树中的节点-medium" class="headerlink" title="450. 删除二叉搜索树中的节点[medium]"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a>[medium]</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root = [<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>key = <span class="hljs-number">3</span><br><br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br> / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">4</span>   <span class="hljs-number">7</span><br><br>给定需要删除的节点值是 <span class="hljs-number">3</span>，所以我们首先找到 <span class="hljs-number">3</span> 这个节点，然后删除它。<br><br>一个正确的答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>], 如下图所示。<br><br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>   <span class="hljs-number">6</span><br> /     <span class="hljs-string">\</span><br><span class="hljs-number">2</span>       <span class="hljs-number">7</span><br><br>另一个正确答案是 [<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]。<br><br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br>   <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>    <span class="hljs-number">4</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>由于这是一棵二叉搜索树，所以对于要删除的节点我们需要找到他并进行删除操作，根据二叉搜索树的性质，可以进行以下三步：</p><ul><li>当前节点值比 key 小，则需要删除当前节点的左子树中 key 对应的值，并保证二叉搜索树的性质不变。</li><li>当前节点值比 key 大，则需要删除当前节点的右子树中 key 对应的值，并保证二叉搜索树的性质不变。</li><li>当前节点等于 key，则需要删除当前节点，并保证二叉搜索树的性质不变。</li></ul><p>可以用递归进行，递归的一个非常重要的点就是：<strong>不去管函数的内部细节是如何处理的，只看其函数作用以及输入与输出</strong>。对于函数 deleteNode 来说：</p><ul><li>函数作用：删除搜索二叉树中的 key 对应的节点，并保证二叉搜索树的性质不变。</li><li>输入：二叉搜索树的根节点 root 和一个值 key。</li><li>输出：新二叉搜索的根节点的引用。</li></ul><p>那么前两步就可以直接表示为：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">root.left = delete<span class="hljs-constructor">Node(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>,<span class="hljs-params">key</span>)</span>;<br>root.right = delete<span class="hljs-constructor">Node(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>,<span class="hljs-params">key</span>)</span>;<br></code></pre></td></tr></table></figure><p>对于一棵二叉搜索树要删除某个节点，一般会面临如下情况：</p><ul><li>当前节点没有左子树。</li><li>当前节点没有右子树。</li><li>当前节点既有左子树又有右子树。</li></ul><p>如图所示：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200819222013.png"></p><ul><li>对于第一种情况来说：要删除节点 5(root)，直接 return root.right 即可。</li><li>对于第二种情况来说：要删除节点 5(root)，直接 return root.left 即可。</li><li>对于第三种情况来说：要删除节点 5(root)，只需将 root 的左子树放到 root 的右子树的最下面的左叶子节点的左子树上即可。如图所示：</li></ul><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200819222021.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//当前节点值比key小，则需要删除当前节点的左子树中key对应的值，并保证二叉搜索树的性质不变</span><br>        <span class="hljs-keyword">if</span>(key&lt;root-&gt;val)<br>            root-&gt;left=<span class="hljs-built_in">deleteNode</span>(root-&gt;left,key);<br>        <span class="hljs-comment">//当前节点值比key大，则需要删除当前节点的右子树中key对应的值，并保证二叉搜索树的性质不变</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&gt;root-&gt;val)<br>            root-&gt;right=<span class="hljs-built_in">deleteNode</span>(root-&gt;right,key);<br>        <span class="hljs-comment">//当前节点等于key，则需要删除当前节点，并保证二叉搜索树的性质不变</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//当前节点没有左子树</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> root-&gt;right;<br>            <span class="hljs-comment">//当前节点没有右子树</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            <span class="hljs-comment">//当前节点既有左子树又有右子树</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* node=root-&gt;right;<br>                <span class="hljs-comment">//找到当前节点右子树最左边的叶子结点</span><br>                <span class="hljs-keyword">while</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    node=node-&gt;left;<br>                <span class="hljs-comment">//将root的左子树放到root的右子树的最下面的左叶子节点的左子树上</span><br>                node-&gt;left=root-&gt;left;<br>                <span class="hljs-keyword">return</span> root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：用前驱或者后继结点代替被删除结点"><a href="#解法二：用前驱或者后继结点代替被删除结点" class="headerlink" title="解法二：用前驱或者后继结点代替被删除结点"></a>解法二：用前驱或者后继结点代替被删除结点</h3><p><strong>前驱、后继结点的概念：</strong></p><ul><li><p>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">successor</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>  root = root.right;<br>  <span class="hljs-keyword">while</span> (root.left != <span class="hljs-literal">null</span>) root = root.left;<br>  <span class="hljs-keyword">return</span> root;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">predecessor</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>  root = root.left;<br>  <span class="hljs-keyword">while</span> (root.right != <span class="hljs-literal">null</span>) root = root.right;<br>  <span class="hljs-keyword">return</span> root;<br>&#125; <br></code></pre></td></tr></table></figure></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102459.jpeg" style="zoom:67%;" /><p><strong>注意：</strong>上面说的前驱和后继概念并不是通用的前驱和后继概念，因为如果找某个叶节点的前驱和后继的话，上面给出的方法是不正确的。按照上面的概念，叶节点的前驱和后继都最终会返回自身节点。如上图中，叶节点13的前驱应该是12，后继应该是25，但是单纯按照上面所给定义，得到的是自身——13。所以说，上面前驱和后继的定义应该加上限制条件，对于前驱，节点要有左子树；对于后继，节点要有右子树。</p><p><strong>思路：</strong></p><p>总体的思路还是递归，这里有三种可能的情况：</p><ul><li><p>要删除的节点为叶子节点，可以直接删除。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102509.jpeg" style="zoom:67%;" /></li><li><p>要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102515.jpeg" style="zoom:67%;" /></li><li><p>要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102522.jpeg" style="zoom:67%;" /></li></ul><p><strong>算法：</strong></p><ul><li>如果 key&gt;root.val，说明要删除的节点在右子树，root.right&#x3D;deleteNode(root.right, key)。</li><li>如果 key&lt;root.val，说明要删除的节点在左子树，root.left&#x3D;deleteNode(root.left, key)。</li><li>如果 key&#x3D;&#x3D;root.val，则该节点就是我们要删除的节点，则：<ul><li>如果该节点是叶子节点，则直接删除它：root&#x3D;null。</li><li>如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 root.val&#x3D;successor.val，然后删除后继节点。</li><li>如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 root.val&#x3D;predecessor.val，然后删除前驱节点。</li></ul></li><li>返回 root。</li></ul><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102532.jpeg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//如果查找的结点比根节点大，继续在右子树查找删除该结点</span><br>        <span class="hljs-keyword">if</span>(key&gt;root-&gt;val)<br>            root-&gt;right=<span class="hljs-built_in">deleteNode</span>(root-&gt;right,key);<br>        <span class="hljs-comment">//如果查找的结点比根节点小，继续在左子树查找删除该结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key&lt;root-&gt;val)<br>            root-&gt;left=<span class="hljs-built_in">deleteNode</span>(root-&gt;left,key);<br>        <span class="hljs-comment">//如果找到了该结点，删除它</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//当前结点为叶子结点,直接删除</span><br>            <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                root=<span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-comment">//当前结点有右孩子,用后继替换，然后删除</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                root-&gt;val=<span class="hljs-built_in">successor</span>(root);<br>                root-&gt;right=<span class="hljs-built_in">deleteNode</span>(root-&gt;right,root-&gt;val);<br>            &#125;<br>            <span class="hljs-comment">//当前结点无右孩子，有左孩子，用前驱替换，然后删除</span><br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                root-&gt;val=<span class="hljs-built_in">predecessor</span>(root);<br>                root-&gt;left=<span class="hljs-built_in">deleteNode</span>(root-&gt;left,root-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//找后继结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">successor</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        root=root-&gt;right;<br>        <span class="hljs-keyword">while</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            root=root-&gt;left;<br>        <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">//找前驱结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">predecessor</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        root=root-&gt;left;<br>        <span class="hljs-keyword">while</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            root=root-&gt;right;<br>        <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(logN)。在算法的执行过程中，一直在树上向左或向右移动。首先先用 O(H1)<br>的时间找到要删除的节点，H1 是从根节点到要删除节点的高度。然后删除节点需要 O(H2) 的时间，H2 是从要删除节点到替换节点的高度。由于 O(H1+H2)&#x3D;O(H)，H 是树的高度，若树是一个平衡树则 H&#x3D; logN。</li><li>空间复杂度：O(H)，递归时堆栈使用的空间，H 是树的高度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode Notes——Tree</title>
    <link href="/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/"/>
    <url>/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己 leetcode 的刷题记录，本部分为<strong>树</strong>篇。部分内容搬运自 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a href="https://leetcode.wang/">wind-liang</a> 题解。</p><span id="more"></span><h1 id="94-二叉树的中序遍历-medium"><a href="#94-二叉树的中序遍历-medium" class="headerlink" title="94. 二叉树的中序遍历[medium]"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>[medium]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的中序遍历。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span><br>   1<br>    \<br>     2<br>    /<br>   3<br><br>输出: <span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>中序遍历:左-打印-右。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;left,res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li><li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li></ul><h3 id="解法二：基于栈的迭代"><a href="#解法二：基于栈的迭代" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><p>利用栈来模拟中序的递归过程。递归的过程是不断往左边走，当左边走不下去了，就打印结点，并转向右边，然后右边继续这个过程。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141547.gif"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//节点不为空一直压栈</span><br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<span class="hljs-comment">//考虑左子树</span><br>            &#125;<br>             <span class="hljs-comment">//节点为空，就出栈</span><br>            cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//当前值加入</span><br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-comment">//考虑右子树</span><br>            cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法三：Morris遍历"><a href="#解法三：Morris遍历" class="headerlink" title="解法三：Morris遍历"></a>解法三：Morris遍历</h3><p>解法一和解法二本质上是一致的，都需要 O(h) ( h 为二叉树高度）的空间来保存上一层的信息。而中序遍历，就是遍历完左子树，然后遍历根节点。如果把当前根节点存起来，然后遍历左子树，左子树遍历完以后回到当前根节点就可以了，怎么做到呢？</p><p>左子树最后遍历的节点一定是一个叶子节点，它的左右孩子都是 null，把它右孩子指向当前根节点存起来，这样就不需要额外空间了。这样做，遍历完当前左子树，就可以回到根节点了。</p><p>当然如果当前根节点左子树为空，那么只需要保存根节点的值，然后考虑右子树即可。</p><p>所以总体思想就是：记当前遍历的节点为 cur。</p><ol><li>cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right；</li><li>cur.left 不为 null，找到 cur.left 这颗子树最右边的节点记做 last；<ul><li>last.right 为 null，那么将 last.right &#x3D; cur，更新 cur &#x3D; cur.left；</li><li>last.right 不为 null，说明之前已经访问过，第二次来到这里，表明当前子树遍历完成，保存 cur 的值，更新 cur &#x3D; cur.right。</li></ul></li></ol><p>结合图示：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140908.jpeg"></p><p>如上图，cur 指向根节点。 当前属于 2.1 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子为 null，那么把最右边的节点的右孩子指向 cur。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140943.jpeg"></p><p>接着，更新 cur &#x3D; cur.left。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141010.jpeg"></p><p>如上图，当前属于 2.1 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子为 null，那么把最右边的节点的右孩子指向 cur。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141035.jpeg"></p><p>更新 cur &#x3D; cur.left。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141051.jpeg"></p><p>如上图，当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141111.jpeg"></p><p>如上图，当前属于 2.2 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子已经指向 cur，保存 cur 的值，更新 cur &#x3D; cur.right。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141131.jpeg"></p><p>如上图，当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141148.jpeg"></p><p>如上图，当前属于 2.2 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子已经指向 cur，保存 cur 的值，更新 cur &#x3D; cur.right。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141209.jpeg"></p><p>当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141226.jpeg"></p><p>cur 指向 null，结束遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">nullptr</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;left!=<span class="hljs-literal">nullptr</span>) <br>            &#123;<br>                TreeNode* pre=root-&gt;left;<br>                <span class="hljs-comment">// 找左子树最右边的节点</span><br>                <span class="hljs-keyword">while</span> (pre-&gt;right!=<span class="hljs-literal">nullptr</span> &amp;&amp; pre-&gt;right!=root) <br>                    pre=pre-&gt;right;<br>                <span class="hljs-comment">// 情况 2.1</span><br>                <span class="hljs-keyword">if</span> (pre-&gt;right==<span class="hljs-literal">nullptr</span>) <br>                &#123;<br>                    pre-&gt;right=root;<br>                    root=root-&gt;left;<br>                &#125; <br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">//情况 2.2</span><br>                &#123;<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//这里可以恢复为 null</span><br>                    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    root=root-&gt;right;<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">//情况1</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root=root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。每个节点遍历常数次。</li><li>空间复杂度：O(1)。</li></ul><h1 id="144-二叉树的前序遍历-medium"><a href="#144-二叉树的前序遍历-medium" class="headerlink" title="144. 二叉树的前序遍历[medium]"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>[medium]</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的前序遍历。</p><p> <strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span>  <br>   1<br>    \<br>     2<br>    /<br>   3 <br><br>输出: <span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>前序遍历:打印-左-右。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li><li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li></ul><h3 id="解法二：基于栈的迭代-1"><a href="#解法二：基于栈的迭代-1" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>利用栈模拟递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<span class="hljs-comment">//考虑左子树</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//节点为空，就出栈</span><br>                cur=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                cur=cur-&gt;right;<span class="hljs-comment">//考虑右子树</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>首先将根节点压入栈中，打印根节点的数据，然后将左右子树分别压栈，每次从栈里取元素。需要注意的是，因为我们应该先访问左子树，而栈的话是先进后出，所以压栈先压右子树。此时得到的流程如下:</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150827.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            s.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法三：Morris遍历-1"><a href="#解法三：Morris遍历-1" class="headerlink" title="解法三：Morris遍历"></a>解法三：Morris遍历</h3><p>详细过程参考 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>。</p><ol><li>在某个根结点创建连线的时候打印。因为是顺着左边的根节点来创建连线，且创建的过程只有一次。</li><li>打印某些自身无法创建连线的节点，也就是叶子节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode* pre=root-&gt;left;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;right!=root)<br>                    pre=pre-&gt;right;<br>                <span class="hljs-keyword">if</span>(pre-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre-&gt;right=root;<br>                    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    root=root-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>;<br>                    root=root-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root=root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="145-二叉树的后序遍历-hard"><a href="#145-二叉树的后序遍历-hard" class="headerlink" title="145. 二叉树的后序遍历[hard]"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>[hard]</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的后序遍历。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span>  <br>   1<br>    \<br>     2<br>    /<br>   3 <br><br>输出: <span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>后序遍历:左-右-打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">postorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;right,res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li><li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li></ul><h3 id="解法二：基于栈的迭代-2"><a href="#解法二：基于栈的迭代-2" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><p>后序遍历的非递归形式相比中序、先序会比较难一些。主要是因为，当遍历完某个根节点的左子树，回到根节点的时候，对于中序和先序遍历可以把当前根节点从栈里弹出，然后转到右子树。而对于后序遍历，当到达根节点的时候，不能立刻弹出，因为遍历完右子树，还需要将这个根节点打印。所以就需要进行<strong>判断</strong>，是左子树到的根节点，还是右子树到的根节点。</p><ul><li>如果是左子树到的根节点，应该转到右子树；</li><li>如果是右子树到的根节点，那么就可以把当前节点弹出并打印。</li><li>如果是左子树到的根节点，此时如果根节点的右子树为 NULL，此时也可以把当前节点弹出并打印。</li></ul><h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 解法二。开始的话，也是不停的往左子树走，直到 NULL。不同之处是，中序直接把节点 pop 并打印，然后转到右子树。而后序应该把节点 top 出来，然后判断一下当前根节点的右子树是否为空或者是否从右子树回到根节点。</p><p>第一个想法是用一个 set，当从左子树到根节点的时候，把根节点加入到 set 中，之后就可以判断当前节点在不在 set 中，如果在的话就意味着当前是第二次回来，也就意味着是从右子树到的根节点。</p><p>利用 set 会浪费额外的空间，还有一个更直接的方法，通过记录上一次遍历的节点。如果当前节点的右节点和上一次遍历的节点相同，那就表明是从右节点过来的了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">//是否变到右子树</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                    last=tmp;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 解法二中思路二。将左右子树分别压栈，然后从栈里取元素。需要注意的是，因为我们应该先访问左子树，而栈的话是先进后出，所以压栈先压右子树。而后序遍历遇到的问题是到根节点的时候不能直接 pop，因为后边还需要回来。</p><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45582/A-real-Postorder-Traversal-.without-reverse-or-insert-4ms">有人</a>提出只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。</p><ul><li>如果相同，就意味着是从左子树到的根节点。</li><li>如果不同，就意味着是从右子树到的根节点，此时就可以把节点打印。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(root);<br>            s.<span class="hljs-built_in">push</span>(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;cur==s.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法三：前序的转换"><a href="#解法三：前序的转换" class="headerlink" title="解法三：前序的转换"></a>解法三：前序的转换</h3><p>参考<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 解法二中思路一。前序遍历的顺序是<strong>根 -&gt; 左 -&gt; 右</strong>，左右其实是等价的，因此也可以写出<strong>根 -&gt; 右 -&gt; 左</strong>的代码。然后把<strong>根 -&gt; 右 -&gt; 左</strong>逆序，就是<strong>左-&gt; 右 -&gt; 根</strong>了，也就是后序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                cur=cur-&gt;left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法四：Morris遍历"><a href="#解法四：Morris遍历" class="headerlink" title="解法四：Morris遍历"></a>解法四：Morris遍历</h3><h4 id="思路一-2"><a href="#思路一-2" class="headerlink" title="思路一"></a>思路一</h4><p>参考前序遍历的 Morris 遍历，把 left 改成 right，right 改成 left，最后再倒置。</p><h4 id="思路二-2"><a href="#思路二-2" class="headerlink" title="思路二"></a>思路二</h4><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 的 Morris 遍历详细过程。发现除了叶子节点只访问一次，其他节点都会访问两次，结合下图。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150840.jpeg"></p><p>当第二次访问某个节点的时候，只需要将它的左节点，以及左节点的右节点，左节点的右节点的右节点… 逆序打印即可。比如上边的例子。上边的遍历顺序其实就是按照深度优先的方式。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tap">先访问 15, 7, 3,<span class="hljs-number"> 1 </span>然后往回走<br>3 第二次访问，将它的左节点逆序打印<br>list = [1]<br><br>继续访问 2, 然后往回走<br>7 第二次访问，将它的左节点，左节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3]<br><br>继续访问<span class="hljs-number"> 6 </span>4, 然后往回走<br>6 第二次访问, 将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3 4]<br><br>继续访问 5, 然后往回走<br>15 第二次访问, 将它的左节点, 左节点的右节点, 左节点的右节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7]<br><br>然后访问<span class="hljs-number"> 14 </span>10 8, 然后往回走<br>10 第二次访问，将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7 8]<br><br>继续访问 9, 然后往回走<br>14 第二次访问，将它的左节点，左节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 10]<br><br>继续访问<span class="hljs-number"> 13 </span>11, 然后往回走<br>13 第二次访问, 将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11]<br><br>继续遍历 12，结束遍历<br><br>然后单独把根节点，以及根节点的右节点，右节点的右节点，右节点的右节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11<span class="hljs-number"> 12 </span>13<span class="hljs-number"> 14 </span>15]<br><br>得到的结果就刚好是后序遍历<br></code></pre></td></tr></table></figure><p>如下图，问题就转换成了 <code>9</code> 组单链表的逆序问题。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150847.jpeg"></p><p>当遇到第二次访问的节点，将单链表逆序，然后打印并且还原即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        TreeNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;left=root;<br>        TreeNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode* pre=cur-&gt;left;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;right!=cur)<br>                    pre=pre-&gt;right;<br>                <span class="hljs-keyword">if</span>(pre-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre-&gt;right=cur;<br>                    cur=cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">reverseAddNodes</span>(cur-&gt;left,pre,res);<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>;<br>                    cur=cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseNodes</span><span class="hljs-params">(TreeNode* start,TreeNode* end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==end)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode* x=start;<br>        TreeNode* y=start-&gt;right;<br>        TreeNode* z;<br>        <span class="hljs-keyword">while</span>(x!=end)<br>        &#123;<br>            z=y-&gt;right;<br>            y-&gt;right=x;<br>            x=y;<br>            y=z;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseAddNodes</span><span class="hljs-params">(TreeNode* start,TreeNode* end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">reverseNodes</span>(start,end);<br>        TreeNode* node=end;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node==start)<br>                <span class="hljs-keyword">break</span>;<br>            node=node-&gt;right;<br>        &#125;<br>        <span class="hljs-built_in">reverseNodes</span>(end,start);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="102-二叉树的层序遍历-medium"><a href="#102-二叉树的层序遍历-medium" class="headerlink" title="102. 二叉树的层序遍历[medium]"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>[medium]</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按<strong>层序遍历</strong>得到的节点值。（即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong></p><p>二叉树：[3,9,20,null,null,15,7],</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>利用广度优先搜索 BFS。层序遍历的顺序与 BFS 是相同的。但是层序遍历要求区分每一层，即返回一个二维数组，而 BFS 是一个一维数组，无法区别每一层。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150753.jpeg" style="zoom:67%;" /><p>那么，怎么给 BFS 遍历的结果分层呢？首先观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150945.gif"></p><p>截取 BFS 遍历过程中的某个时刻：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726151006.jpeg"></p><p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，无法区分队列中的结点来自哪一层。</p><p>因此，需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 cnt（也就是这一层的结点数量），然后一口气处理完这一层的 cnt 个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>记树上所有节点的个数为 n。</p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li></ul><h3 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h3><p>DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 level。递归到新节点要把该节点放入 level 对应列表的末尾。</p><p>当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，应该在 res 中新建一个列表用来保存该 level 的所有节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(h)，<code>h</code> 是树的高度。</li></ul><h1 id="103-二叉树的锯齿形层序遍历-medium"><a href="#103-二叉树的锯齿形层序遍历-medium" class="headerlink" title="103. 二叉树的锯齿形层序遍历[medium]"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a>[medium]</h1><h2 id="解法一：BFS层序遍历"><a href="#解法一：BFS层序遍历" class="headerlink" title="解法一：BFS层序遍历"></a>解法一：BFS层序遍历</h2><blockquote><p>参考 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">剑指offer题解——59.按之字形顺序打印二叉树</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="解法二：DFS-1"><a href="#解法二：DFS-1" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><p>思路与 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> DFS解法相同，只不过根据 level 是否是偶数进行不同的插入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ());<br>        <span class="hljs-comment">// 这里默认根节点是第0层</span><br>        <span class="hljs-keyword">if</span>(level%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 偶数层相当于从左往右遍历，所以要添加到集合的末尾，</span><br>            res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 奇数层相当于从右往左遍历，要把数据添加到集合的开头</span><br>            res[level].<span class="hljs-built_in">insert</span>(res[level].<span class="hljs-built_in">begin</span>(),root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101. 对称二叉树[easy]"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a>[easy]</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">1</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>详细思路参考<strong>剑指offer题解</strong> <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">58.对称的二叉树</a>。</p><h3 id="解法一：递归-3"><a href="#解法一：递归-3" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left,root-&gt;right);        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* l,TreeNode* r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>&amp;&amp;r==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>||r==<span class="hljs-literal">nullptr</span>||l-&gt;val!=r-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(l-&gt;left,r-&gt;right)&amp;&amp;<span class="hljs-built_in">isSymmetric</span>(l-&gt;right,r-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)。</li><li>空间复杂度 O(N)。</li></ul><h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        s.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* curR=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* curL=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>&amp;&amp;curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>||curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(curL!=<span class="hljs-literal">nullptr</span>&amp;&amp;curR!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(curL-&gt;val!=curR-&gt;val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                s.<span class="hljs-built_in">push</span>(curL-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curL-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)。</li><li>空间复杂度 O(N)。</li></ul><h1 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104. 二叉树的最大深度[easy]"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>[easy]</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-4"><a href="#解法一：递归-4" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>分别计算左子树和右子树的最大深度，返回左子树和右子树最大深度的较大值 +1，递归退出条件为到叶子节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left),<span class="hljs-built_in">maxDepth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：每个结点只访问一次，因此时间复杂度为 O(N)，其中 N 是结点的数量。</li><li>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li></ul><h3 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>利用队列进行 BFS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N)。</li></ul><h1 id="110-平衡二叉树-easy"><a href="#110-平衡二叉树-easy" class="headerlink" title="110. 平衡二叉树[easy]"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a>[easy]</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>返回 false 。</p><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>详细思路参考<strong>剑指offer题解</strong> <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">39.平衡二叉树</a>。</p><h3 id="解法一：从顶至底（暴力法）"><a href="#解法一：从顶至底（暴力法）" class="headerlink" title="解法一：从顶至底（暴力法）"></a>解法一：从顶至底（暴力法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left)&amp;&amp;<span class="hljs-built_in">isBalanced</span>(root-&gt;right)&amp;&amp;<span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(root-&gt;left),<span class="hljs-built_in">depth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(NlogN)： 最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历各子树的所有节点 。</li><li>空间复杂度 O(N)：最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li></ul><h3 id="解法二：从底至顶（提前阻断）"><a href="#解法二：从底至顶（提前阻断）" class="headerlink" title="解法二：从底至顶（提前阻断）"></a>解法二：从底至顶（提前阻断）</h3><p>使用 flag 做标记，进行剪枝。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>)<br>            flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li></ul><h1 id="111-二叉树的最小深度-easy"><a href="#111-二叉树的最小深度-easy" class="headerlink" title="111. 二叉树的最小深度[easy]"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a>[easy]</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:</p><p>给定二叉树 [3,9,20,null,null,15,7],</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最小深度  2.</p><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-5"><a href="#解法一：递归-5" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>叶子节点的定义是左孩子和右孩子都为空。因此递归结束条件为：</p><ol><li>左孩子和右孩子都为空，说明到达了叶子节点，直接返回 1；</li><li>左孩子和右孩子有一个为空，那么需要返回较大的那个孩子的深度+1；</li><li>左右孩子都不为空，那么返回左右孩子较小孩子的深度+1。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>        <span class="hljs-comment">// left和right有一个必然为0</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>||root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left+right+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left,right)+<span class="hljs-number">1</span>;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。</li><li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</li></ul><h3 id="解法二：迭代-2"><a href="#解法二：迭代-2" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><h4 id="思路一：BFS"><a href="#思路一：BFS" class="headerlink" title="思路一：BFS"></a>思路一：BFS</h4><p>在 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a> 的解法二上稍作修改，在第二个 while 中增加一个判断，即判断当前节点是否是叶子节点，如果是，返回当前的 depth。实际的效果为层次遍历遇到第一个叶子节点，就返回当前的节点深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    <span class="hljs-keyword">return</span> depth;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：最坏情况下，这是一棵平衡树，需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N&#x2F;2 个节点，因此复杂度是 O(N)。</li><li>空间复杂度：和时间复杂度相同，也是 O(N)。</li></ul><h4 id="思路二：DFS"><a href="#思路二：DFS" class="headerlink" title="思路二：DFS"></a>思路二：DFS</h4><p>用 pair 记录节点和节点的深度，模拟二叉树的遍历，当遇到叶子节点时，更新最小深度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        stack&lt;pair&lt;TreeNode*,<span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> mindepth=INT_MAX;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>().first;<br>            <span class="hljs-type">int</span> depth=s.<span class="hljs-built_in">top</span>().second;<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                mindepth=<span class="hljs-built_in">min</span>(mindepth,depth);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(cur-&gt;left,depth+<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(cur-&gt;right,depth+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> mindepth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。</li><li>空间复杂度：最坏情况下会在栈中保存整棵树，此时空间复杂度为 O(N)。</li></ul><h1 id="100-相同的树-easy"><a href="#100-相同的树-easy" class="headerlink" title="100. 相同的树[easy]"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a>[easy]</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span>   <span class="hljs-number"> 2 </span>  3<br><br>        [1,2,3],   [1,2,3]<br><br>输出: true<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入:      <span class="hljs-number">1</span>          <span class="hljs-number">1</span><br>          /           \<br>         <span class="hljs-number">2</span>             <span class="hljs-number">2</span><br><span class="hljs-string"></span><br><span class="hljs-string">        [1,2]</span>,     [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>  2<br><br>        [1,2,1],   [1,1,2]<br><br>输出: false<br></code></pre></td></tr></table></figure><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-6"><a href="#解法一：递归-6" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>判断两棵树是否相等有三个条件：</p><ul><li>根节点值相等；</li><li>并且，p 的左子树和 q 的左子树相等；</li><li>并且，p 的右子树和 q 的右子树相等。</li></ul><p>终止条件：</p><ul><li>两棵树的当前结点同时为 null 时返回 true；</li><li>其中一个为 null 另一个不为 null 时返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>&amp;&amp;q==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>||q==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp;<span class="hljs-built_in">isSameTree</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="hljs-built_in">isSameTree</span>(p-&gt;right,q-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</li><li>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护递归栈。</li></ul><h3 id="解法二：迭代-3"><a href="#解法二：迭代-3" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>把两个树同时遍历一下，遍历过程中判断数值是否相等或者同时为 null 即可。遍历的方法，可以选择 DFS 里的先序遍历，中序遍历，后序遍历，或者 BFS。</p><p>这里选择先序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(q);<br>        s.<span class="hljs-built_in">push</span>(p);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* p_cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* q_cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(p_cur==<span class="hljs-literal">nullptr</span>&amp;&amp;q_cur==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(p_cur==<span class="hljs-literal">nullptr</span>||q_cur==<span class="hljs-literal">nullptr</span>||p_cur-&gt;val!=q_cur-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            s.<span class="hljs-built_in">push</span>(q_cur-&gt;right);<br>            s.<span class="hljs-built_in">push</span>(p_cur-&gt;right);<br>            s.<span class="hljs-built_in">push</span>(q_cur-&gt;left);<br>            s.<span class="hljs-built_in">push</span>(p_cur-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</li><li>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护栈。</li></ul><h1 id="572-另一个树的子树-easy"><a href="#572-另一个树的子树-easy" class="headerlink" title="572. 另一个树的子树[easy]"></a><a href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a>[easy]</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p>示例 1:<br>给定的树 s:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">4</span> <br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><p>示例 2:<br>给定的树 s：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br>   /<br>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>给定的树 t：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">4</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>返回 false。</p><h2 id="解题思路：递归"><a href="#解题思路：递归" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>判断 t 是否为 s 的子树的三个条件时或的关系：</p><ul><li>t 是 s 的左子树的子树；</li><li>t 是 s 的右子树的子树；</li><li>t 和 s 两棵树相等。</li></ul><p>而判断两棵树是否相等的三个条件是与的关系：</p><ul><li>根节点值相等；</li><li>并且，s 的左子树和 t 的左子树相等；</li><li>并且，s 的右子树和 t 的右子树相等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubtree</span>(s-&gt;left,t)||<span class="hljs-built_in">isSubtree</span>(s-&gt;right,t)||<span class="hljs-built_in">isSameTree</span>(s,t);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* s,TreeNode* t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>&amp;&amp;t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>||t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> s-&gt;val==t-&gt;val&amp;&amp;<span class="hljs-built_in">isSameTree</span>(s-&gt;left,t-&gt;left)&amp;&amp;<span class="hljs-built_in">isSameTree</span>(s-&gt;right,t-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="965-单值二叉树-easy"><a href="#965-单值二叉树-easy" class="headerlink" title="965. 单值二叉树[easy]"></a><a href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a>[easy]</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p><p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p><p>示例 1：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120337.png" style="zoom: 33%;" /><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120331.png" style="zoom:33%;" /><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,5,2]</span><br>输出：false<br></code></pre></td></tr></table></figure><p>提示：</p><ol><li>给定树的节点数范围是 [1, 100]。</li><li>每个节点的值都是整数，范围为 [0, 99] 。</li></ol><h2 id="解题思路：递归-1"><a href="#解题思路：递归-1" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>把当前节点的值记为 val，和左&#x2F;右子树一起传入递归函数。</p><p>递归终止条件：</p><ul><li>节点为 null 则返回 true；</li><li>如果传入进来的父节点的值 val 和 当前节点的值不相等，则返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isUnivalTree</span>(root,root-&gt;val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val!=val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isUnivalTree</span>(root-&gt;left,root-&gt;val)&amp;&amp;<span class="hljs-built_in">isUnivalTree</span>(root-&gt;right,root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是给定树中节点的数量。</li><li>空间复杂度：O(H)，其中 H 是给定树的高度。</li></ul><h1 id="107-二叉树的层次遍历-II-easy"><a href="#107-二叉树的层次遍历-II-easy" class="headerlink" title="107. 二叉树的层次遍历 II[easy]"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a>[easy]</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其自底向上的层次遍历为：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>一种思路是，顺序的层次遍历，然后将结果翻转，但是这里采用不用翻转结果的方法。</p><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 解法二，需要做两处修改：</p><ol><li><p>之前根据 level 得到数组的位置，然后添加。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">res[level].push_back(root-&gt;val);<br><br>res   [] [] [] [] []<br>index<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>level<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>      -------------&gt;<br>index=0+level<br>    <br>现在 level 是逆过来存的<br>res   [] [] [] [] []<br>index<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>level<span class="hljs-number"> 4 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 1 </span> 0<br>      &lt;----------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml"><span class="hljs-string">index=4-level</span></span><br><span class="language-yaml"><span class="hljs-string">即</span> <span class="hljs-string">res.size()-1-level</span></span><br></code></pre></td></tr></table></figure></li><li><p>在添加当前 level 的第一个元素的时候，首先添加一个空列表到 res 中</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">level</span>&gt;=res.size())<br>    res.push_back(vector&lt;<span class="hljs-type">int</span>&gt;());<br><br>假设当前 <span class="hljs-keyword">level</span>=<span class="hljs-number">2</span>,res 中只添加了 <span class="hljs-keyword">level</span> 是 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 的元素<br>res   [<span class="hljs-number">3</span>] [<span class="hljs-number">9</span>] <br><span class="hljs-keyword">index</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span> <br><span class="hljs-keyword">level</span>  <span class="hljs-number">1</span>   <span class="hljs-number">0</span><br>因为 <span class="hljs-keyword">level</span> 是从右往左增加的，所以空列表要加到 res 的头部<br>res   [] [<span class="hljs-number">3</span>] [<span class="hljs-number">9</span>] <br><span class="hljs-keyword">index</span> <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br><span class="hljs-keyword">level</span> <span class="hljs-number">2</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span><br><br>所以改成：<br>res.<span class="hljs-keyword">insert</span>(res.<span class="hljs-keyword">begin</span>(),vector&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 当前层数还没有元素，先创建一个空的列表</span><br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-comment">// 当前值加入</span><br>        res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(h)，<code>h</code> 是树的高度。</li></ul><h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 解法一，BFS 的修改相比 DFS 比较简单，只需要做一处修改，即把当前层遍历的结果加到 res 头部即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)</li></ul><h1 id="872-叶子相似的树-easy"><a href="#872-叶子相似的树-easy" class="headerlink" title="872. 叶子相似的树[easy]"></a><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a>[easy]</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个叶值序列。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120312.png" style="zoom: 33%;" /><p>举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。</p><p>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p><p>如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p><p><strong>提示：</strong></p><ul><li>给定的两颗树可能会有 <code>1</code> 到 <code>200</code> 个结点。</li><li>给定的两颗树上的值介于 <code>0</code> 到 <code>200</code> 之间。</li></ul><h2 id="解题思路：深度优先搜索"><a href="#解题思路：深度优先搜索" class="headerlink" title="解题思路：深度优先搜索"></a>解题思路：深度优先搜索</h2><p>找出给定的两个树的叶值序列。之后，比较它们，看它们是否相等。</p><p>要找出树的叶值序列，可以使用深度优先搜索。如果结点是叶子，那么 dfs 函数会写入结点的值，然后递归地探索每个子结点。这可以保证按从左到右的顺序访问每片叶子，因为在右孩子结点之前完全探索了左孩子结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; leaves1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; leaves2;<br>        <span class="hljs-built_in">dfs</span>(root1,leaves1);<br>        <span class="hljs-built_in">dfs</span>(root2,leaves2);<br>        <span class="hljs-keyword">return</span> leaves1==leaves2;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaves)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            leaves.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,leaves);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,leaves);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(T1 + T2)，其中 T1, T2 是给定的树的长度。</li><li>空间复杂度：O(T1 + T2)，存储叶值所使用的空间。</li></ul><h1 id="814-二叉树剪枝-medium"><a href="#814-二叉树剪枝-medium" class="headerlink" title="814. 二叉树剪枝[medium]"></a><a href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a>[medium]</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例1:</span><br><span class="hljs-section">输入: [1,null,0,0,1]</span><br><span class="hljs-section">输出: [1,null,0,null,1]</span><br><br><span class="hljs-section">解释: </span><br>只有红色节点满足条件“所有不包含 1 的子树”。<br>右图为返回的答案。<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101346.png"  style="zoom: 33%;" /><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例2:</span><br><span class="hljs-section">输入: [1,0,1,0,0,0,1]</span><br><span class="hljs-section">输出: [1,null,1,null,1]</span><br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101434.png" style="zoom:33%;" /><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例<span class="hljs-number">3</span>:<br>输入: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1,0,1,0</span>]<br>输出: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1</span>,null,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101459.png" style="zoom:33%;" /><p><strong>说明:</strong></p><ul><li>给定的二叉树最多有 <code>100</code> 个节点。</li><li>每个节点的值只会为 <code>0</code> 或 <code>1</code> 。</li></ul><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：自顶向下递归"><a href="#解法一：自顶向下递归" class="headerlink" title="解法一：自顶向下递归"></a>解法一：自顶向下递归</h3><p>用 containsOne(node) 函数来判断以 node 为根的子树中是否包含 1，其不包含 1 当且仅当以 node 的左右孩子为根的子树均不包含 1，并且 node 节点本身的值也不为 1。</p><p>如果 node 的左右孩子为根的子树不包含 1，那就需要把对应的指针置为空。例如当 node 的左孩子为根的子树不包含 1 时，我们将 node.left 置为 null。</p><p>在递归结束之后，如果整颗二叉树都不包含 1，那么返回 null，否则返回原来的根节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">containsOne</span>(root)?root:<span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsOne</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> left=<span class="hljs-built_in">containsOne</span>(node-&gt;left);<br>        <span class="hljs-type">bool</span> right=<span class="hljs-built_in">containsOne</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(!left) node-&gt;left=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(!right) node-&gt;right=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> node-&gt;val==<span class="hljs-number">1</span>||left||right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是树中节点的个数。</li><li>空间复杂度：O(H)，其中 H 是树的高度，为在递归时使用的栈空间大小。</li></ul><h3 id="解法二：从底向上后序遍历"><a href="#解法二：从底向上后序遍历" class="headerlink" title="解法二：从底向上后序遍历"></a>解法二：从底向上后序遍历</h3><p>本质是找到叶子节点，对于操作叶子节点，首先考虑后序遍历，因为叶子节点的处理可能影响到根节点的操作，而只有后序遍历是先处理左右孩子，再处理根节点的顺序。从底向上后序遍历，如果当前节点值为 0，且左右子树均为 null，则删除节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left=<span class="hljs-built_in">pruneTree</span>(root-&gt;left);<br>        root-&gt;right=<span class="hljs-built_in">pruneTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(root-&gt;val==<span class="hljs-number">0</span>&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是树中节点的个数。</li><li>空间复杂度：O(H)，其中 H 是树的高度，为在递归时使用的栈空间大小。</li></ul><h1 id="669-修剪二叉搜索树-easy"><a href="#669-修剪二叉搜索树-easy" class="headerlink" title="669. 修剪二叉搜索树[easy]"></a><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>[easy]</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;&#x3D;L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p>示例 1:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: <br>    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">0</span>   <span class="hljs-number">2</span><br><br>  L = <span class="hljs-number">1</span><br>  R = <span class="hljs-number">2</span><br><br>输出: <br>    <span class="hljs-number">1</span><br>      <span class="hljs-string">\</span><br>       <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal">输入: <br>    <span class="hljs-number">3</span><br>   <span class="hljs-regexp">/ \</span><br><span class="hljs-regexp">  0   4</span><br><span class="hljs-regexp">   \</span><br><span class="hljs-regexp">    2</span><br><span class="hljs-regexp">   /</span><br>  <span class="hljs-number">1</span><br><br>  L = <span class="hljs-number">1</span><br>  R = <span class="hljs-number">3</span><br><br>输出: <br>      <span class="hljs-number">3</span><br>     <span class="hljs-regexp">/ </span><br><span class="hljs-regexp">   2   </span><br><span class="hljs-regexp">  /</span><br> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求返回 BST 被修剪后的根结点，那么从根结点开始修剪。</p><ul><li>如果根结点太小，根结点的左子树的所有结点只会更小，说明根结点及其左子树都应该剪掉，因此直接返回右子树的修剪结果。</li><li>如果根结点太大，根结点的右子树的所有结点只会更大，说明根结点及其右子树都应该剪掉，因此直接返回左子树的修剪结果。</li><li>如果根结点没问题，则递归地修剪左子结点和右子结点。</li><li>如果结点为空，说明无需修剪，直接返回空即可。</li><li>左右子结点都修剪完后，返回自身。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val&gt;R)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>        <span class="hljs-keyword">if</span>(root-&gt;val&lt;L)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>        root-&gt;left=<span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>        root-&gt;right=<span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是给定的树的全部节点。最多访问每个节点一次。</li><li>空间复杂度：O(N)，即使没有明确使用任何额外的内存，在最糟糕的情况下，递归调用的栈可能与节点数一样大。</li></ul><h1 id="1325-删除给定值的叶子节点-medium"><a href="#1325-删除给定值的叶子节点-medium" class="headerlink" title="1325. 删除给定值的叶子节点[medium]"></a><a href="https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/">1325. 删除给定值的叶子节点</a>[medium]</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p><p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p><p>也就是说，你需要重复此过程直到不能继续删除。</p><p><strong>示例 1：</strong></p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104913.png" style="zoom:50%;" /><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">4</span>]<br>解释：<br>上面左边的图中，绿色节点为叶子节点，且它们的值与 <span class="hljs-keyword">target</span> 相同（同为 <span class="hljs-number">2</span> ），它们会被删除，得到中间的图。<br>有一个新的节点变成了叶子节点且它的值与 <span class="hljs-keyword">target</span> 相同，所以将再次进行删除，从而得到最右边的图。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104956.png" style="zoom: 67%;" /><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801105031.png" style="zoom: 67%;" /><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>]<br>解释：每一步都删除一个绿色的叶子节点（值为 <span class="hljs-number">2</span>）。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,1,1]</span>, target = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2,3]</span>, target = 1<br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 1000</code></li><li>每一棵树最多有 <code>3000</code> 个节点。</li><li>每一个节点值的范围是 <code>[1, 1000]</code> 。</li></ul><h2 id="解题思路：二叉树的后序遍历"><a href="#解题思路：二叉树的后序遍历" class="headerlink" title="解题思路：二叉树的后序遍历"></a>解题思路：二叉树的后序遍历</h2><p>基本思路与 <a href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a> 解法二相同。二叉树的遍历无非就先序，中序和后序三种。根据题目要求，由于子节点的处理结果会影响到父节点的处理过程，所以应当先访问左右两个子节点，再访问节点本身。这也就对应着二叉树遍历方式中的后序遍历。即节点遍历顺序为左子节点 -&gt; 右子节点 -&gt; 节点本身。</p><p>有了遍历过程，接下来的就是返回值的处理。因为如果当前节点需要被删除，那么方式其实是通过修改父节点对应的指针。而父节点无法直接在当前节点访问到。如果重新从根节点开始查找当前节点的父节点，还需要额外的遍历开销。所以这里考虑通过递归调用的返回值来做处理。</p><p><strong>递归流程：</strong></p><ol><li>如果左子节点存在，递归的处理当前节点的左子节点，并更新左子节点的值。</li><li>如果右子节点存在，递归的处理当前节点的右子节点，并更新右子节点的值。</li><li>判断当前节点是否是符合要求的叶节点，并返回当前节点的最新值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left=<span class="hljs-built_in">removeLeafNodes</span>(root-&gt;left,target);<br>        root-&gt;right=<span class="hljs-built_in">removeLeafNodes</span>(root-&gt;right,target);<br>        <span class="hljs-keyword">if</span>(root-&gt;val==target&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(N)，其中 N 是二叉树的节点个数。</li><li>空间复杂度：O(H)，其中 H 是二叉树的高度。</li></ul><h1 id="112-路径总和-easy"><a href="#112-路径总和-easy" class="headerlink" title="112. 路径总和[easy]"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>[easy]</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><div class="code-wrapper"><pre><code class="hljs">          5         / \        4   8       /   / \      11  13  4     /  \      \    7    2      1</code></pre></div><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS递归"><a href="#解法一：DFS递归" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>题目询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。假定从根节点到当前节点的值之和为 val，可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p><p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，只需要递归地询问它的子节点是否能满足条件即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> root-&gt;val==sum;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,sum-root-&gt;val)||<span class="hljs-built_in">hasPathSum</span>(root-&gt;right,sum-root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</li><li>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li></ul><h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>对二叉树进行层次遍历，除了遍历需要的队列外，再准备一个队列，保存从根节点到当前节点的路径和，以防止重复计算。两个队列同步进行压入和弹出操作，当遇到叶子节点，且路径和为 sum 时返回 true。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        queue&lt;<span class="hljs-type">int</span>&gt; queSum;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        queSum.<span class="hljs-built_in">push</span>(root-&gt;val);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> curSum=queSum.<span class="hljs-built_in">front</span>();<br>                queSum.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//判断叶子节点是否满足了条件</span><br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>&amp;&amp;curSum==sum)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    queSum.<span class="hljs-built_in">push</span>(curSum+cur-&gt;left-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queSum.<span class="hljs-built_in">push</span>(curSum+cur-&gt;right-&gt;val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</li><li>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li></ul><h3 id="解法三：DFS迭代"><a href="#解法三：DFS迭代" class="headerlink" title="解法三：DFS迭代"></a>解法三：DFS迭代</h3><p>DFS 本身也可以用栈去模拟，参考二叉树前序、中序、后序的非递归版本。对于这道题，可以像解法二 BFS 一样，再增加一个栈，去保存从根节点到当前节点的路径和。</p><p>但是对于这种利用栈模拟递归的思路，对时间复杂度和空间复杂度没有什么提高。只是把递归的压栈过程变成了手动压栈。那么能不能提高一下，省去额外的保存路径和的栈，参考<a href="https://leetcode.com/problems/path-sum/discuss/36382/Accepted-By-using-postorder-traversal">这里</a>。</p><p>如果只用一个变量 curSum 来记录根节点到当前节点的路径和，有节点入栈就加上节点的值，有节点出栈就减去节点的值。</p><p>比如对于下边的树，进行中序遍历。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">     <span class="hljs-number">3</span><br>    / \<br>   <span class="hljs-number">9</span>   <span class="hljs-number">20</span><br>  / \   <br> <span class="hljs-number">8</span>   <span class="hljs-number">15</span>   <br><br><span class="hljs-attribute">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">3</span>，<span class="hljs-number">3</span><br><span class="hljs-number">9</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">12</span>，<span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">8</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">20</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">8</span><br><span class="hljs-number">8</span> 出栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">12</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">9</span> 出栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">3</span>， <br><span class="hljs-number">15</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">18</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>此时路径是 <code>3 -&gt; 9 -&gt; 15</code>，和应该是 <code>27</code>。但得到的是 <code>18</code>，少加了 <code>9</code>。原因是进行的是中序遍历，当我们还没访问右边的节点的时候，根节点已经出栈了，再访问右边节点的时候，<code>curSum</code>就会少一个根节点的值。所以，需要使用后序遍历，先访问左子树，再访问右子树，最后访问根节点。再看一下上边的二叉树。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">3</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">9</span>   <span class="hljs-number">20</span><br>  / <span class="hljs-string">\</span>   <br> <span class="hljs-number">8</span>   <span class="hljs-number">15</span>   <br><br>curSum = <span class="hljs-number">0</span><br><span class="hljs-number">3</span> 入栈， curSum = <span class="hljs-number">3</span>，<span class="hljs-number">3</span><br><span class="hljs-number">9</span> 入栈， curSum = <span class="hljs-number">12</span>，<span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">8</span> 入栈， curSum = <span class="hljs-number">20</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">8</span><br><span class="hljs-number">8</span> 出栈， curSum = <span class="hljs-number">12</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">15</span> 入栈， curSum = <span class="hljs-number">27</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>此时路径 <code>3 -&gt; 9 -&gt; 15</code> 对应的 <code>curSum</code> 就是正确的了。</p><p>参考 <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a> 解法二思路一，修改相关代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                curSum+=cur-&gt;val;<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(curSum==sum&amp;&amp;tmp-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    curSum-=tmp-&gt;val;<br>                    last=tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="113-路径总和-II-medium"><a href="#113-路径总和-II-medium" class="headerlink" title="113. 路径总和 II[medium]"></a><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a>[medium]</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><div class="code-wrapper"><pre><code class="hljs">          5         / \        4   8       /   / \      11  13  4     /  \    / \    7    2  5   1</code></pre></div><p>返回:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">   <span class="hljs-comment">[5,4,11,2]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[5,8,4,5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a> 的升级版，给定一个<code>sum</code>，输出从根节点开始到叶子节点，和为<code>sum</code> 的所有路径可能。</p><h3 id="解法一：DFS递归-1"><a href="#解法一：DFS递归-1" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>深度优先搜索。使用前序遍历，使用两个全局变量 res 和 path，res 来存放最终结果，path 用来存放临时结果。</p><p>若当前节点是叶子节点，那么直接判断 sum 是否等于 val 即可，如果满足条件，就将 path 压入 res 中。若当前节点不是叶子节点，只需要递归地询问它的子节点是否能满足条件即可。向上回溯前，需要将当前节点从路径 path 中删除，不要影响到其他分支的临时结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root,sum,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> sum,vector&lt;<span class="hljs-type">int</span>&gt;&amp; path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(sum==root-&gt;val&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,sum-root-&gt;val,path,res);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,sum-root-&gt;val,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：DFS迭代"><a href="#解法二：DFS迭代" class="headerlink" title="解法二：DFS迭代"></a>解法二：DFS迭代</h3><p>112 题中解法二为BFS，但是这题需要保存一条一条的路径，而 BFS 是一层一层进行的。在遍历过程中，需要保存不同的路径，对于这题不划算。</p><p>和 112 解法三一样，进行后序遍历。使用两个变量 res 和 path，res 来存放最终结果，path 用来存放临时结果，向上回溯前，需要将当前节点从路径 path 中删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                curSum+=cur-&gt;val;<br>                path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//将当前节点加入路径</span><br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">//判断是否满足条件</span><br>                <span class="hljs-keyword">if</span>(curSum==sum&amp;&amp;tmp-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    curSum-=tmp-&gt;val;<br>                    last=tmp;<br>                    path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//将当前节点从入路径中删除</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="437-路径总和-III-medium"><a href="#437-路径总和-III-medium" class="headerlink" title="437. 路径总和 III[medium]"></a><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>[medium]</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p><p>示例：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], sum = <span class="hljs-number">8</span><br><br>      <span class="hljs-number">10</span><br>     /  <span class="hljs-string">\</span><br>    <span class="hljs-number">5</span>   -<span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span>    <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">2</span>   <span class="hljs-number">11</span><br> / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  -<span class="hljs-number">2</span>   <span class="hljs-number">1</span><br><br>返回 <span class="hljs-number">3</span>。和等于 <span class="hljs-number">8</span> 的路径有:<br><br><span class="hljs-number">1.</span>  <span class="hljs-number">5</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">2.</span>  <span class="hljs-number">5</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">3.</span>  -<span class="hljs-number">3</span> -&gt; <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-7"><a href="#解法一：递归-7" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>题目要求路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。这就要求我们只需要去求三部分即可：</p><ul><li>以当前节点作为头节点的满足条件的路径数量</li><li>当前节点的左子树中满足条件的路径数量</li><li>当前节点的右子树中满足条件的路径数量</li></ul><p>将这三部分之和作为最后的结果。接下来的问题是，如何求以当前节点作为头节点的路径数量，继续遍历树，按照 <a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>、<a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a> 的思路 DFS 递归进行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">paths</span>(root,sum)+<span class="hljs-built_in">pathSum</span>(root-&gt;left,sum)+<span class="hljs-built_in">pathSum</span>(root-&gt;right,sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">paths</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;val==sum)<br>            cnt+=<span class="hljs-number">1</span>;<br>        cnt+=<span class="hljs-built_in">paths</span>(node-&gt;left,sum-node-&gt;val);<br>        cnt+=<span class="hljs-built_in">paths</span>(node-&gt;right,sum-node-&gt;val);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(n^2)。如果是高度平衡的二叉树，时间复杂度为 O(nlogn)，如果是斜的二叉树，时间复杂度为 O(n)。</li><li>空间复杂度：O(h)，h为树的高度。</li></ul><h3 id="解法二：前缀和-回溯"><a href="#解法二：前缀和-回溯" class="headerlink" title="解法二：前缀和+回溯"></a>解法二：前缀和+回溯</h3><p>解法一存在大量重复计算，因此采取前缀和的思路。前缀和就是到达当前元素的路径上，之前所有元素的和。</p><p>如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和 currSum，在节点 A 和节点 B 处相差 target，则位于节点 A 和节点 B 之间的元素之和是 target。</p><p>因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)</p><p>抵达当前节点(即 B 节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和 currSum-target 的节点(即 A 节点)，存在即表示从 A 到 B 有一条路径之和满足条件的情况。结果加上满足前缀和 currSum-target 的节点的数量。然后递归进入左右子树。</p><p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// key是前缀和, value是大小为key的前缀和出现的次数</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; prefixSumCount;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">// 前缀和为0的一条路径</span><br>        prefixSumCount[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursionPathSum</span>(root,sum,<span class="hljs-number">0</span>);<br>    &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前缀和的递归回溯思路</span><br><span class="hljs-comment">     * 从当前节点反推到根节点(反推比较好理解，正向其实也只有一条)，有且仅有一条路径，因为这是一棵树</span><br><span class="hljs-comment">     * 如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span><br><span class="hljs-comment">     * 所以前缀和对于当前路径来说是唯一的，当前记录的前缀和，在回溯结束，回到本层时去除，保证其不影响其他分支的结果</span><br><span class="hljs-comment">     * @param node 树节点</span><br><span class="hljs-comment">     * @param target 目标值</span><br><span class="hljs-comment">     * @param currSum 当前路径和</span><br><span class="hljs-comment">     * @return 满足题意的解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recursionPathSum</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> currSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 1.递归终止条件</span><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 2.本层要做的事情</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当前路径上的和</span><br>        currSum+=node-&gt;val;<br>        <span class="hljs-comment">// 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径</span><br>        <span class="hljs-comment">// 当前节点-&gt;root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span><br>        <span class="hljs-comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span><br>        res+=prefixSumCount[currSum-target];<br>        <span class="hljs-comment">// 更新路径上当前节点前缀和的个数</span><br>        prefixSumCount[currSum]++;<br>         <span class="hljs-comment">// 3.进入下一层</span><br>         res+=<span class="hljs-built_in">recursionPathSum</span>(node-&gt;left,target,currSum);<br>         res+=<span class="hljs-built_in">recursionPathSum</span>(node-&gt;right,target,currSum);<br>         <span class="hljs-comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span><br>         prefixSumCount[currSum]--;<br>         <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：O(n)，每个节点只遍历一次。</p><p>空间复杂度：O(n)，开辟了一个 hashMap。</p><h1 id="129-求根到叶子节点数字之和-medium"><a href="#129-求根到叶子节点数字之和-medium" class="headerlink" title="129. 求根到叶子节点数字之和[medium]"></a><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a>[medium]</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-number">25</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12</span>.<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13</span>.<br>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25</span>.<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br>    <span class="hljs-number">4</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>   <span class="hljs-number">0</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">5</span>   <span class="hljs-number">1</span><br>输出: <span class="hljs-number">1026</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40.</span><br>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026.</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归先序遍历"><a href="#解法一：递归先序遍历" class="headerlink" title="解法一：递归先序遍历"></a>解法一：递归先序遍历</h3><ol><li>先遍历根节点；</li><li>遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；</li><li>遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；</li><li>更新总的和。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current=father*<span class="hljs-number">10</span>+node-&gt;val;<br>        <span class="hljs-keyword">if</span>(node-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> current;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(node-&gt;left,current)+<span class="hljs-built_in">dfs</span>(node-&gt;right,current);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：非递归先序遍历"><a href="#解法二：非递归先序遍历" class="headerlink" title="解法二：非递归先序遍历"></a>解法二：非递归先序遍历</h3><p>准备一个额外的 stack，用来记录数字。每次出 stack 之后，如果是叶子节点，那么加和。如果不是，那么就看左右子树入 stack。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> sum;<br>        stack&lt;TreeNode*&gt; s;<br>        stack&lt;<span class="hljs-type">int</span>&gt; sNum;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        sNum.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> curNum=sNum.<span class="hljs-built_in">top</span>()*<span class="hljs-number">10</span>+cur-&gt;val;<br>            sNum.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                sum+=curNum;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                sNum.<span class="hljs-built_in">push</span>(curNum);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                sNum.<span class="hljs-built_in">push</span>(curNum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：BFS"><a href="#解法三：BFS" class="headerlink" title="解法三：BFS"></a>解法三：BFS</h3><p>本质上是层序遍历，准备一个额外的 queue，用来记录数字。每次出 queue 之后，如果是叶子节点，那么加和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        queue&lt;<span class="hljs-type">int</span>&gt; queNum;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        queNum.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> curNum=queNum.<span class="hljs-built_in">front</span>()*<span class="hljs-number">10</span>+cur-&gt;val;<br>                queNum.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    sum+=curNum;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    queNum.<span class="hljs-built_in">push</span>(curNum);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queNum.<span class="hljs-built_in">push</span>(curNum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="257-二叉树的所有路径-easy"><a href="#257-二叉树的所有路径-easy" class="headerlink" title="257. 二叉树的所有路径[easy]"></a><a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a>[easy]</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br><br>   <span class="hljs-number">1</span><br> /   <span class="hljs-string">\</span><br><span class="hljs-number">2</span>     <span class="hljs-number">3</span><br> <span class="hljs-string">\</span><br>  <span class="hljs-number">5</span><br><br>输出: [<span class="hljs-string">&quot;1-&gt;2-&gt;5&quot;</span>, <span class="hljs-string">&quot;1-&gt;3&quot;</span>]<br><br>解释: 所有根节点到叶子节点的路径为: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-8"><a href="#解法一：递归-8" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>在遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，就在当前的路径末尾添加该节点，并递归遍历该结点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，把该路径添加到答案中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">constructPaths</span>(root,<span class="hljs-string">&quot;&quot;</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constructPaths</span><span class="hljs-params">(TreeNode* root,string path,vector&lt;string&gt;&amp; paths)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            path+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>            paths.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">constructPaths</span>(root-&gt;left,path+<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;-&gt;&quot;</span>,paths);<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">constructPaths</span>(root-&gt;right,path+<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;-&gt;&quot;</span>,paths);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)，其中 N 表示节点数目。</li><li>空间复杂度：O(N)。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log(N)，此时空间复杂度为 O(log(N))。</li></ul><h3 id="解法二：迭代-4"><a href="#解法二：迭代-4" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>DFS 和 BFS 都可以实现。除了本身遍历使用的栈&#x2F;队列以外，额外维护一个栈&#x2F;队列存储节点以及根到该节点的路径，或者采用 pair 的形式。整体思路仍然与递归相同。这里只写 DFS。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        stack&lt;string&gt; path_stack;<br>        node_stack.<span class="hljs-built_in">push</span>(root);<br>        path_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur_node=node_stack.<span class="hljs-built_in">top</span>();<br>            node_stack.<span class="hljs-built_in">pop</span>();<br>            string cur_path=path_stack.<span class="hljs-built_in">top</span>();<br>            path_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur_node-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                res.<span class="hljs-built_in">push_back</span>(cur_path);<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>                path_stack.<span class="hljs-built_in">push</span>(cur_path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(cur_node-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>                path_stack.<span class="hljs-built_in">push</span>(cur_path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(cur_node-&gt;left-&gt;val));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(N)，每个节点只会被访问一次。</li><li>空间复杂度：O(N)，在最坏情况下，栈中有 N 个节点。</li></ul><h1 id="235-二叉搜索树的最近公共祖先-easy"><a href="#235-二叉搜索树的最近公共祖先-easy" class="headerlink" title="235. 二叉搜索树的最近公共祖先[easy]"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>[easy]</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095809.png"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span> <br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉搜索树（BST）的性质如下：</p><blockquote><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li>没有键值相等的节点。</li></ol></blockquote><p>节点 p，q 的最近公共祖先（LCA）是距离这两个节点最近的公共祖先节点。在这里 <code>最近</code> 考虑的是节点的深度。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095759.png" style="zoom:67%;" /><h3 id="解法一：递归-9"><a href="#解法一：递归-9" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>由于是二叉搜索树，所以找最近的共同祖先比较容易，总共就三种情况。</p><ul><li><p>如果给定的两个节点的值都小于根节点的值，那么最近的共同祖先一定在左子树</p></li><li><p>如果给定的两个节点的值都大于根节点的值，那么最近的共同祖先一定在右子树</p></li><li><p>如果一个大于等于、一个小于等于根节点的值，那么当前根节点就是最近的共同祖先了</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095745.png" style="zoom: 67%;" /></li></ul><p>前两种情况用递归继续去解决即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：O(N)，其中 N 为 BST 中节点的个数，在最坏的情况下需要访问 BST 中所有的节点。</li><li>空间复杂度：O(N)，所需开辟的额外空间主要是递归栈产生的。</li></ul><h3 id="解法二：迭代-5"><a href="#解法二：迭代-5" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>用迭代的方式替代递归来遍历整棵树。由于不需要回溯来找到 LCA 节点，所以是完全可以不利用栈或者是队列的。实际上这个问题本身就是可以迭代的，只需要找到分割点就可以了。这个分割点就是能让节点 p 和节点 q 不能在同一颗子树上的那个节点，或者是节点 p 和节点 q 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val)<br>                root=root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val)<br>                root=root-&gt;left;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 为 BST 中节点的个数，在最坏的情况下需要遍历 BST 中所有的节点。</li><li>空间复杂度：O(1)。</li></ul><h1 id="236-二叉树的最近公共祖先-medium"><a href="#236-二叉树的最近公共祖先-medium" class="headerlink" title="236. 二叉树的最近公共祖先[medium]"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>[medium]</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095731.png"></p><p><strong>示例 1:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-10"><a href="#解法一：递归-10" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：</p><ul><li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li><li>p &#x3D; root ，且 q 在 root 的左或右子树中；</li><li>q &#x3D; root ，且 p 在 root 的左或右子树中；</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805100145.png" style="zoom:67%;" /><p>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p><p><strong>具体思路：</strong></p><ul><li>如果当前结点 root 等于 NULL，则直接返回 NULL；</li><li>如果 root 等于 p 或者 q ，那这棵树一定返回 p 或者 q；</li><li>然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 left 和 right 表示；</li><li>此时若 left 为空，那最终结果只要看 right；若 right 为空，那最终结果只要看 left；</li><li>如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先；</li><li>如果 left 和 right 都为空，则返回空（其实已经包含在前面的情况中了）。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root==p||root==q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode* left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>&amp;&amp;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//if(left != null and right != null)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可将上述代码合并一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||root==p||root==q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode* left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。</li></ul><h3 id="解法二：存储父节点"><a href="#解法二：存储父节点" class="headerlink" title="解法二：存储父节点"></a>解法二：存储父节点</h3><p>用哈希表存储所有节点的父节点，然后利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是最近公共祖先。</p><p><strong>具体算法：</strong></p><ol><li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li><li>从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li><li>同样，再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        unordered_map&lt;TreeNode*,TreeNode*&gt; childToFather;<span class="hljs-comment">// &lt;子结点 , 父结点&gt;</span><br>        childToFather[root]=<span class="hljs-literal">nullptr</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 层序遍历</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                childToFather[cur-&gt;left]=cur;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                childToFather[cur-&gt;right]=cur;<br>            &#125;   <br>        &#125;<br>        unordered_set&lt;TreeNode*&gt; parentSet;<br>        <span class="hljs-comment">// 找出 p 的所有父结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            parentSet.<span class="hljs-built_in">insert</span>(p);<br>            p=childToFather[p];<br>        &#125;<br>         <span class="hljs-comment">// 第一个存在于parentSet的q的父结点，即为最近公共祖先</span><br>        <span class="hljs-keyword">while</span>(parentSet.<span class="hljs-built_in">count</span>(q)==<span class="hljs-number">0</span>)<br>            q=childToFather[q];<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 p 和 q 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。</li><li>空间复杂度：O(N) ，其中 N 是二叉树的节点数。哈希表存储每个节点的父节点需要 O(N) 的空间复杂度。</li></ul><h1 id="508-出现次数最多的子树元素和-medium"><a href="#508-出现次数最多的子树元素和-medium" class="headerlink" title="508. 出现次数最多的子树元素和[medium]"></a><a href="https://leetcode-cn.com/problems/most-frequent-subtree-sum/">508. 出现次数最多的子树元素和</a>[medium]</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入:<br>  5<br> /  \<br>2   <span class="hljs-string">-3</span><br>返回 [2, <span class="hljs-string">-3</span>, 4]，所有的值均只出现一次，以任意顺序返回所有值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：<br>  5<br> /  \<br>2   <span class="hljs-string">-5</span><br>返回 [2]，只有 2 出现两次，<span class="hljs-string">-5</span> 只出现 1 次。<br></code></pre></td></tr></table></figure><p>提示： 假设任意子树元素和均可以用 32 位有符号整数表示。</p><h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>计算子树元素和，应该自底向上，故考虑后序遍历，遍历过程中存取每个节点为根节点的子树元素和，用 hashmap 记录和出现的次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findFrequentTreeSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-built_in">dfs</span>(m,root);<br>        <span class="hljs-type">int</span> maxTime=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:m)<br>            maxTime=<span class="hljs-built_in">max</span>(maxTime,item.second);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(item.second==maxTime)<br>                res.<span class="hljs-built_in">push_back</span>(item.first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; m,TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">dfs</span>(m,root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">dfs</span>(m,root-&gt;right);<br>        <span class="hljs-type">int</span> sum=left+right+root-&gt;val;<br>        m[sum]++;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化-hard"><a href="#297-二叉树的序列化与反序列化-hard" class="headerlink" title="297. 二叉树的序列化与反序列化[hard]"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a>[hard]</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p>示例: </p><p>你可以将以下二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span><br></code></pre></td></tr></table></figure><p>提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>说明: 不要使用类的成员 &#x2F; 全局 &#x2F; 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p><h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS递归-2"><a href="#解法一：DFS递归-2" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>递归遍历一棵树，只关注当前单个节点就好，子树的遍历交给递归完成。这里选择前序遍历，因为前序遍历为<strong>根-左-右</strong>的顺序，反序列化更容易定位出根节点的值。遇到 null 节点也要翻译成一个特殊符号，反序列化时才知道这里对应 null 节点。按什么方法序列化，就按什么方法反序列化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>        <span class="hljs-built_in">serialize</span>(root,out);<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root,ostringstream&amp; out)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            out&lt;&lt;<span class="hljs-string">&quot;# &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            out&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-built_in">serialize</span>(root-&gt;left,out);<br>            <span class="hljs-built_in">serialize</span>(root-&gt;right,out);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream&amp; in)</span></span><br><span class="hljs-function">    </span>&#123;<br>        string val;<br>        in&gt;&gt;val;<br>        <span class="hljs-keyword">if</span>(val==<span class="hljs-string">&quot;#&quot;</span>)<span class="hljs-comment">//这里无&quot; &quot;字符</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>        node-&gt;left=<span class="hljs-built_in">deserialize</span>(in);<br>        node-&gt;right=<span class="hljs-built_in">deserialize</span>(in);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec;</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure><h3 id="解法二：BFS-2"><a href="#解法二：BFS-2" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>序列化：</p><ul><li>让 null 也入列，说它是真实节点也行，它有对应的”#”，只是没有子节点入列。</li><li>考察出列节点<ul><li>如果不为 null，则将它的值推入 out，并将它的左右子节点入列；</li><li>如果是 null ，则将 ‘#’ 推入 out。</li></ul></li><li>出列…入列…直到队列为空，所有节点遍历完，out 也构建完，转成字符串。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105628.png" style="zoom:67%;" /><p>反序列化：</p><ul><li>除了第一个是根节点的值，其他节点值都是成对的，分别对应左右子节点。</li><li>从第二项开始遍历，每次考察两个节点值。</li><li>起初构建 root 节点并入列。</li><li>安排节点出列，找出子节点入列，连续考察两个 string，第一个为左子节点，第二个为右子节点<ul><li>如果子节点值不为 ‘#’，则为它创建节点，并认父亲，并作为未来的父亲入列；</li><li>如果子节点值为 ‘#’，什么都不做即可。</li></ul></li><li>所有的父节点（真实节点）都会在队列里走一遍。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105648.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)<br>                out&lt;&lt;<span class="hljs-string">&quot;# &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                out&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        string val;<br>        in&gt;&gt;val;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//左子树</span><br>            in&gt;&gt;val;<br>            <span class="hljs-keyword">if</span>(val!=<span class="hljs-string">&quot;#&quot;</span>)<br>            &#123;<br>                cur-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            &#125;<br>            <span class="hljs-comment">//右子树</span><br>            in&gt;&gt;val;<br>            <span class="hljs-keyword">if</span>(val!=<span class="hljs-string">&quot;#&quot;</span>)<br>            &#123;<br>                cur-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="124-二叉树中的最大路径和-hard"><a href="#124-二叉树中的最大路径和-hard" class="headerlink" title="124. 二叉树中的最大路径和[hard]"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>[hard]</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3]</span><br><br>       1<br>      / \<br>     2   3<br><br><span class="hljs-section">输出: 6</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [-<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br>   -<span class="hljs-number">10</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>输出: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到二叉树的题，首先想到递归。递归常规的思路，是递归考虑左子树的最大值，递归考虑右子树的最大值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">PathSum(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) &#123;<br>        return Integer.MIN_VALUE;<br>    &#125;<br>    <span class="hljs-comment">//左子树的最大值</span><br>    <span class="hljs-built_in">int</span> left = max<span class="hljs-constructor">PathSum(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-comment">//右子树的最大值</span><br>    <span class="hljs-built_in">int</span> right = max<span class="hljs-constructor">PathSum(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;  <br>    <span class="hljs-comment">//再考虑包含根节点的最大值</span><br>    <span class="hljs-built_in">int</span>  all = ....;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(left, right), all);<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么考虑包含根节点的最大路径等于多少？因为我们递归求出来的最大 <code>left</code> 可能不包含根节点的左孩子，例如下边的情况。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">8</span><br>    / <span class="hljs-string">\</span><br>  -<span class="hljs-number">3</span>   <span class="hljs-number">7</span><br> /  <span class="hljs-string">\</span><br><span class="hljs-number">1</span>    <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>左子树的最大值 <code>left</code> 肯定就是 <code>4</code> 了，然而此时的根节点 <code>8</code> 并不能直接和 <code>4</code> 去相连。所以考虑包含根节点的路径的最大值时，并不能单纯的用 <code>root.val + left + right</code>。</p><p>所以如果考虑包含当前根节点的 <code>8</code> 的最大路径，首先必须包含左右孩子，其次每次遇到一个分叉，就要选择能产生更大的值的路径。例如下边的例子：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">8</span><br>    /  <span class="hljs-string">\</span><br>   -<span class="hljs-number">3</span>   <span class="hljs-number">7</span><br> /    <span class="hljs-string">\</span><br><span class="hljs-number">1</span>      <span class="hljs-number">4</span><br> <span class="hljs-string">\</span>    / <span class="hljs-string">\</span>    <br>  <span class="hljs-number">3</span>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br><br>考虑左子树 -<span class="hljs-number">3</span> 的路径的时候，我们有左子树 <span class="hljs-number">1</span> 和右子树 <span class="hljs-number">4</span> 的选择，但我们不能同时选择<br>如果同时选了，路径就是 ... -&gt; <span class="hljs-number">1</span> -&gt; -<span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; ... 就无法通过根节点 <span class="hljs-number">8</span> 了<br>所以我们只能去求左子树能返回的最大值，右子树能返回的最大值，选一个较大的<br></code></pre></td></tr></table></figure><p>假设我们只考虑通过根节点 <code>8</code> 的最大路径是多少，那么代码就可以写出来了。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs qml">public <span class="hljs-built_in">int</span> maxPathSum(TreeNode root) &#123;<br>    <span class="hljs-comment">//如果最大值是负数，我们选择不选</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">Math</span>.max(helper(root.left), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">Math</span>.max(helper(root.right), <span class="hljs-number">0</span>); <br>    <span class="hljs-keyword">return</span> root.val + left + right;<br>&#125;<br><br><span class="hljs-built_in">int</span> helper(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">Math</span>.max(helper(root.left), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">Math</span>.max(helper(root.right), <span class="hljs-number">0</span>);  <br>    <span class="hljs-comment">//选择左子树和右子树产生的值较大的一个</span><br>    <span class="hljs-keyword">return</span> root.val + <span class="hljs-built_in">Math</span>.max(left, right);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在我们只考虑了包含最初根节点 <code>8</code> 的路径。那如果不包含当前根节点，而是其他的路径呢？</p><p>可以发现在 <code>helper</code> 函数中，我们每次都求了当前给定的节点的左子树和右子树的最大值，和我们 <code>maxPathSum</code> 函数的逻辑是一样的。所以我们利用一个全局变量，在考虑 <code>helper</code> 函数中当前 <code>root</code> 的时候，同时去判断一下包含当前 <code>root</code> 的路径的最大值。</p><p>这样在递归过程中就考虑了所有包含当前节点的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxpath=INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> maxpath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//计算左边分支最大值，左边分支如果为负数还不如不选择</span><br>        <span class="hljs-type">int</span> leftmax=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;left));<br>        <span class="hljs-comment">//计算右边分支最大值，右边分支如果为负数还不如不选择</span><br>        <span class="hljs-type">int</span> rightmax=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;right));<br>        <span class="hljs-comment">//求的过程中考虑包含当前根节点的最大路径，left-&gt;root-&gt;right 作为路径与历史最大值做比较</span><br>        maxpath=<span class="hljs-built_in">max</span>(maxpath,root-&gt;val+leftmax+rightmax);<br>        <span class="hljs-comment">// 返回经过root的单边最大分支给上游，即只返回包含当前根节点和左子树或者右子树的路径</span><br>        <span class="hljs-keyword">return</span> root-&gt;val+<span class="hljs-built_in">max</span>(leftmax,rightmax);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是二叉树中的节点个数。对每个节点访问不超过 2 次。</li><li>空间复杂度：O(N)，其中 N 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。</li></ul><h1 id="543-二叉树的直径-easy"><a href="#543-二叉树的直径-easy" class="headerlink" title="543. 二叉树的直径[easy]"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>[easy]</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><div class="code-wrapper"><pre><code class="hljs">      1     / \    2   3   / \       4   5    </code></pre></div><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><p>思想与 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 相似。</p><blockquote><p>一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p></blockquote><p>任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200807100242.png" style="zoom:67%;" /><p>如图可以知道路径 [9, 4, 2, 5, 7, 8] 可以被看作以 2 为起点，从其左儿子向下遍历的路径 [2, 4, 9] 和从其右儿子向下遍历的路径 [2, 5, 7, 8] 拼接得到。</p><p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p><p>记节点 node 为起点的路径经过节点数的最大值为 max ，那么二叉树的直径就是所有节点 max 的最大值减一。</p><p>最后的算法流程为：定义一个递归函数 depth(node) 计算 max，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为 max(L,R)+1，该节点的 max 值为 L+R+1，递归搜索每个节点并设一个全局变量 res 记录 max的最大值，最后返回 <code>res-1</code> 即为树的直径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        res=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-comment">// 边数 = 结点数 - 1</span><br>        <span class="hljs-keyword">return</span> res<span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 左子树高度</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-comment">// 右子树高度</span><br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        res=<span class="hljs-built_in">max</span>(res,left+right+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(N)，其中 N 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li><li>空间复杂度：O(Height)，其中 Height 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(Height) 。</li></ul><h1 id="687-最长同值路径-easy"><a href="#687-最长同值路径-easy" class="headerlink" title="687. 最长同值路径[easy]"></a><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687. 最长同值路径</a>[easy]</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>              <span class="hljs-number">5</span><br>             / <span class="hljs-string">\</span><br>            <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>           / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>          <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">5</span><br><br>输出:<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>              <span class="hljs-number">1</span><br>             / <span class="hljs-string">\</span><br>            <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>           / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>          <span class="hljs-number">4</span>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>输出:<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>注意:</strong> 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p><h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><p>思想与 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>、<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a> 相似。</p><p>可以将任何路径（具有相同值的节点）看作是最多两个从其根延伸出的箭头。</p><p>最长的路径可能有三种情况：</p><ul><li>在左子树内部。</li><li>在右子树内部。</li><li>在穿过左子树，根节点，右子树的一条路径中。</li></ul><p>设计一个递归函数，返回以该节点为根节点，向下走的最长同值路径，知道这个值以后，以某个节点为根节点的最长同值路径就是</p><ul><li>如果该节点的值等于其左子树的值，则最长同值路径为左子树的最长同值路径+1，如果不等，左子树的路径为 0。</li><li>如果该节点的值等于其右子树的值，则最长同值路径为右子树的最长同值路径+1，如果不等，右子树的路径为 0。</li><li>返回上述两种情况的最大值。</li></ul><p>当我们计算箭头长度时，候选答案将是该节点在两个方向上的箭头之和。用一个全局变量记录这个最大值，不断更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">arrowLength</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arrowLength</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">arrowLength</span>(node-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">arrowLength</span>(node-&gt;right);<br>        <span class="hljs-type">int</span> arrowleft=<span class="hljs-number">0</span>,arrowright=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;left-&gt;val==node-&gt;val)<br>            arrowleft=left+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;right-&gt;val==node-&gt;val)<br>            arrowright=right+<span class="hljs-number">1</span>;<br>        res=<span class="hljs-built_in">max</span>(res,arrowleft+arrowright);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(arrowleft,arrowright);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)，其中 N 是树中节点数。处理每个节点一次。</li><li>空间复杂度：O(H)，其中 H 是树的高度。递归调用栈可以达到 H 层的深度。</li></ul><h1 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树[medium]"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>[medium]</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">前序遍历 preorder = <span class="hljs-string">[3,9,20,15,7]</span><br>中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br></code></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>给定二叉树前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树。其中的规律为，<strong>前序遍历序列的第一个元素为二叉树的根结点，在中序遍历序列中，根结点左边的元素为左子树的结点，右边的元素为右子树上的结点</strong>。</p></blockquote><h3 id="解法一：递归-11"><a href="#解法一：递归-11" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。所以只需要根据先序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">preorder = <span class="hljs-comment">[3,9,20,15,7]</span><br>inorder = <span class="hljs-comment">[9,3,15,20,7]</span><br>首先根据 preorder 找到根节点是 3<br><br>然后根据根节点将 inorder 分成左子树和右子树<br>左子树<br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>把相应的前序遍历的数组也加进来<br>左子树<br>preorder<span class="hljs-comment">[9]</span> <br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>preorder<span class="hljs-comment">[20 15 7]</span> <br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题<br>然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可<br></code></pre></td></tr></table></figure><p>事实上，不需要真的把 <code>preorder</code> 和 <code>inorder</code> 切分了，只需要分别用两个指针指向开头和结束位置即可。下边的两个指针指向的数组范围是包括左边界，不包括右边界，即左闭右开。</p><p>对于下边的树的合成。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141626.jpeg"></p><p>左子树</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141648.jpeg"></p><p>右子树</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141713.jpeg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>(),inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// preorder 为空，直接返回 null</span><br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=preorder[p_start];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-comment">//在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> i_root_index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=i_start;i&lt;i_end;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i]==root_val)<br>            &#123;<br>                i_root_index=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>         <span class="hljs-comment">//递归的构造左子树</span><br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>,p_start+<span class="hljs-number">1</span>+leftNum,inorder,i_start,i_root_index);<br>        <span class="hljs-comment">//递归的构造右子树</span><br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>+leftNum,p_end,inorder,i_root_index+<span class="hljs-number">1</span>,i_end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上边的代码存在一个问题，在中序遍历中找到根节点的位置每次都得遍历中序遍历的数组去寻找。我们可以用一个<code>HashMap</code>把中序遍历数组的每个元素的值和下标存起来，这样在此后构造二叉树的过程中，就只需要 O(1) 的时间对根节点进行定位了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();++i)<br>            valueIndex[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>(),inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; valueIndex;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=preorder[p_start];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-type">int</span> i_root_index=valueIndex[root_val];<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>,p_start+<span class="hljs-number">1</span>+leftNum,inorder,i_start,i_root_index);<br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>+leftNum,p_end,inorder,i_root_index+<span class="hljs-number">1</span>,i_end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li><li>空间复杂度：O(n)，需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</li></ul><h3 id="解法二：迭代-6"><a href="#解法二：迭代-6" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p><strong>思路：</strong></p><p>迭代法是一种非常巧妙的实现方法。</p><p>对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p><ul><li>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</li><li>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 u_a，那么 v 就是 u_a 的右儿子。</li></ul><p>第二种关系看上去有些复杂。举一个例子来说明其正确性，并在例子中给出迭代算法。</p><p><strong>例子：</strong></p><p>以树</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure><p>为例，它的前序遍历和中序遍历分别为</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br><span class="hljs-attr">inorder</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>我们用一个栈  <code>stack</code>  来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针  <code>index</code> 指向中序遍历的某个位置，初始值为 <code>0</code>。<code>index</code>  对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p><p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code> 所指向的节点为 <code>4</code>，随后对于前序遍历中的每个节点，我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p><ul><li><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code> 的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code> 的右儿子，那么 <code>3</code> 没有左儿子，index 应该恰好指向 <code>3</code>，但实际上为 <code>4</code> ，因此产生了矛盾。所以我们将 <code>9</code> 作为 <code>3</code>  的左儿子，并将 <code>9</code> 入栈。</p><ul><li><code>stack = [3, 9]</code> </li><li><code>index -&gt; inorder[0] = 4</code></li></ul></li><li><p>我们遍历 <code>8</code>，<code>5</code> 和 <code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p><ul><li><code>stack = [3, 9, 8, 5, 4]</code> </li><li><code>index -&gt; inorder[0] = 4</code></li></ul></li><li><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现 <code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说 <code>4</code> 没有左儿子，那么 <code>10</code> 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，<strong>那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的</strong>。</p><blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote><p>因此我们可以把 <code>index</code> 不断向右移动，并与栈顶节点进行比较。如果 <code>index</code> 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 <code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到 <code>index</code> 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 <code>x</code> 就是 <code>10</code> 的双亲节点，<strong>这是因为 <code>10</code> 出现在了 <code>x</code> 与 <code>x</code> 在栈中的下一个节点的中序遍历之间</strong>，因此 <code>10</code> 就是 <code>x</code> 的右儿子。</p><p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code> 和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将 <code>10</code> 作为最后弹出的节点 <code>8</code> 的右儿子，并将 <code>10</code>入栈。</p><ul><li><code>stack = [3, 9, 10]</code> </li><li><code>index -&gt; inorder[3] = 10</code></li></ul></li><li><p>我们遍历 <code>20</code>。同理，<code>index</code> 恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出 <code>10</code>，<code>9</code> 和 <code>3</code>，并且将 <code>index</code> 向右移动了三次。我们将 <code>20</code> 作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code> 入栈。</p><ul><li><code>stack = [20]</code> </li><li><code>index -&gt; inorder[6] = 15</code></li></ul></li><li><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点 <code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p><ul><li><code>stack = [20, 15]</code> </li><li><code>index -&gt; inorder[6] = 15</code></li></ul></li><li><p>我们遍历 <code>7</code>。 <code>index</code> 恰好指向当前栈顶节点 <code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和 <code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将 <code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将 <code>7</code> 入栈。</p><ul><li><code>stack = [7]</code> </li><li><code>index -&gt; inorder[8] = 7</code></li></ul></li></ul><p>此时遍历结束，我们就构造出了正确的二叉树。</p><p><strong>算法：</strong></p><p>我们归纳出上述例子中的算法流程：</p><ul><li>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</li><li>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li><li>无论是哪一种情况，我们最后都将当前的节点入栈。</li></ul><p>最后得到的二叉树即为答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; preStack;<br>        preStack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;preorder.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> preorderVal=preorder[i];<br>            TreeNode* node=preStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val!=inorder[inorderIndex])<br>            &#123;<br>                node-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                preStack.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">while</span>(!preStack.<span class="hljs-built_in">empty</span>()&amp;&amp;preStack.<span class="hljs-built_in">top</span>()-&gt;val==inorder[inorderIndex])<br>                &#123;<br>                    node=preStack.<span class="hljs-built_in">top</span>();<br>                    preStack.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                preStack.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li><li>空间复杂度：O(n)，需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</li></ul><h1 id="106-从中序与后序遍历序列构造二叉树-medium"><a href="#106-从中序与后序遍历序列构造二叉树-medium" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树[medium]"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>[medium]</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>后序遍历 postorder = <span class="hljs-string">[9,15,7,20,3]</span><br></code></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><p>与 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a> 思路基本一致。105 题给的是先序遍历和中序遍历，这里把先序遍历换成后序遍历。</p><h3 id="解法一：递归-12"><a href="#解法一：递归-12" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先序遍历的顺序为<strong>根-左-右</strong>，后序遍历的顺序为<strong>左-右-根</strong>，因此与 105 题利用先序遍历第一个节点为根节点不同的是，后序遍历的最后一个节点为根节点。还是先确定根节点，然后在中序遍历中找根节点的位置，然后分出左子树和右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();++i)<br>            valueIndex[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>(),postorder,<span class="hljs-number">0</span>,postorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; valueIndex;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=postorder[p_end<span class="hljs-number">-1</span>];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-type">int</span> i_root_index=valueIndex[root-&gt;val];<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(inorder,i_start,i_root_index,postorder,p_start,p_start+leftNum);<br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(inorder,i_root_index+<span class="hljs-number">1</span>,i_end,postorder,p_start+leftNum,p_end<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li><li>空间复杂度：O(n)，需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</li></ul><h3 id="解法二：迭代-7"><a href="#解法二：迭代-7" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>105 题是通过前序遍历的数组实现的，所以构造过程是根节点，左子树，右子树。但这里是后序遍历，先找根节点，所以相当于从右往左遍历，这样顺序变成了<strong>根-右-左</strong>，会先生成右子树，再生成左子树，相应的中序遍历的指针 <code>index</code> 也要从右往左移动。之前解法是构造左子树、左子树、左子树，出现相等，构造一颗右子树。这里相应的要改成构造右子树、右子树、右子树，出现相等，构造一颗左子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> postSize=postorder.<span class="hljs-built_in">size</span>();<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[postSize<span class="hljs-number">-1</span>]);<br>        stack&lt;TreeNode*&gt; postStack;<br>        postStack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex=inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=postSize<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-type">int</span> postorderVal=postorder[i];<br>            TreeNode* node=postStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val!=inorder[inorderIndex])<br>            &#123;<br>                node-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorderVal);<br>                postStack.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">while</span>(!postStack.<span class="hljs-built_in">empty</span>()&amp;&amp;postStack.<span class="hljs-built_in">top</span>()-&gt;val==inorder[inorderIndex])<br>                &#123;<br>                    node=postStack.<span class="hljs-built_in">top</span>();<br>                    postStack.<span class="hljs-built_in">pop</span>();<br>                    --inorderIndex;<br>                &#125;<br>                node-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorderVal);<br>                postStack.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li><li>空间复杂度：O(n)，需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</li></ul><h1 id="337-打家劫舍-III-medium"><a href="#337-打家劫舍-III-medium" class="headerlink" title="337. 打家劫舍 III[medium]"></a><a href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a>[medium]</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p><p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [3,2,3,null,3,null,1]<br><br>     3<br>    / \<br>  <span class="hljs-number"> 2 </span>  3<br>    \   \ <br>    <span class="hljs-number"> 3 </span>  1<br><br>输出:<span class="hljs-number"> 7 </span><br>解释: 小偷一晚能够盗取的最高金额 =<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>= 7.<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [3,4,5,1,3,null,1]<br><br>     3<br>    / \<br>  <span class="hljs-number"> 4 </span>  5<br>  / \   \ <br><span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>  1<br><br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>= 9.<br></code></pre></td></tr></table></figure><h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>树形 DP 问题。从暴力递归到动态规划。</p></blockquote><h3 id="解法一：暴力递归-最优子结构"><a href="#解法一：暴力递归-最优子结构" class="headerlink" title="解法一：暴力递归-最优子结构"></a>解法一：暴力递归-最优子结构</h3><p>在解法一和解法二中，使用爷爷、两个孩子、4 个孙子来说明问题。首先来定义这个问题的状态，爷爷节点则么获取到最大的偷取的钱数呢？</p><ul><li>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷。</li><li>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子。</li></ul><p>根据以上条件，可以得出单个节点的钱该怎么算，即 <strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构。</strong>由于是二叉树，这里可以选择计算所有子节点。</p><p>4 个孙子投的钱加上爷爷的钱如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">int</span> method1 = root.val + rob(root.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">left</span>) + rob(root.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">right</span>) + rob(root.<span class="hljs-keyword">right</span>.<span class="hljs-keyword">left</span>) + rob(root.<span class="hljs-keyword">right</span>.<span class="hljs-keyword">right</span>)<br></code></pre></td></tr></table></figure><p>两个儿子偷的钱如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">int method2 = rob(root.<span class="hljs-built_in">left</span>) + rob(root.<span class="hljs-built_in">right</span>);<br></code></pre></td></tr></table></figure><p>挑选一个钱数多的方案则：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(method1, method2);<br></code></pre></td></tr></table></figure><p>使用 C++超时，Java 不超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> money=root.val;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)<br>            money+=rob(root.left.left)+rob(root.left.right);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)<br>            money+=rob(root.right.left)+rob(root.right.right);<br>        <span class="hljs-keyword">return</span> Math.max(money,rob(root.left)+rob(root.right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：记忆化-解决重复子问题"><a href="#解法二：记忆化-解决重复子问题" class="headerlink" title="解法二：记忆化 - 解决重复子问题"></a>解法二：记忆化 - 解决重复子问题</h3><p>针对解法一速度太慢的问题，经过分析其实现，发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p><p><strong>重复子问题：</strong></p><p>这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。由于二叉树不适合拿数组当缓存，这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; memo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(root,memo);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root,unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt;&amp; memo)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(memo.<span class="hljs-built_in">count</span>(root)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> memo[root];<br>        <span class="hljs-type">int</span> money=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            money+=<span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right,memo);<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            money+=<span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right,memo);<br>        <span class="hljs-type">int</span> result=<span class="hljs-built_in">max</span>(money,<span class="hljs-built_in">rob</span>(root-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;right,memo));<br>        memo[root]=result;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：树形DP"><a href="#解法三：树形DP" class="headerlink" title="解法三：树形DP"></a>解法三：树形DP</h3><p>换一种办法来定义此问题，每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷：</p><ul><li>当前节点选择偷时，那么两个孩子节点就不能选择偷了。</li><li>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)。</li></ul><p>使用一个大小为 2 的数组来表示 int[] res &#x3D; new int[2] ，0 代表不偷，1 代表偷。<br>任何一个节点能偷到的最大钱的状态可以定义为：</p><ul><li>当前节点选择不偷：当前节点能偷到的最大钱数 &#x3D; 左孩子能偷到的钱 + 右孩子能偷到的钱</li><li>当前节点选择偷：当前节点能偷到的最大钱数 &#x3D; 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li></ul><p>表示为公式如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">res[<span class="hljs-number">0</span>] = Math<span class="hljs-built_in">.max</span>(rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">0</span>], rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">1</span>]) + Math<span class="hljs-built_in">.max</span>(rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">0</span>], rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">1</span>])<br>res[<span class="hljs-number">1</span>] = rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">0</span>] + rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">0</span>] +<span class="hljs-built_in"> root</span>.val;<br></code></pre></td></tr></table></figure><p>用两个 hashmap 来保存结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(unselected[root],selected[root]);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; unselected;<br>    unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; selected;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        unselected[root]=<span class="hljs-built_in">max</span>(unselected[root-&gt;left],selected[root-&gt;left])+<span class="hljs-built_in">max</span>(unselected[root-&gt;right],selected[root-&gt;right]);<br>        selected[root]=unselected[root-&gt;left]+unselected[root-&gt;right]+root-&gt;val;     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法四：降维优化空间复杂度"><a href="#解法四：降维优化空间复杂度" class="headerlink" title="解法四：降维优化空间复杂度"></a>解法四：降维优化空间复杂度</h3><p>观察上面发现，左右子树的两个状态影响当前子树的两个状态，但别的子树的状态影响不了。因此没必要用 hashmap 记录每一个子树的状态，递归总是子调用的解返回给父调用，所以只需在每次递归中用两个变量，存当前子问题的两个状态，返回出来给父调用即可。用一个 pair 来返回，分别存放不偷和偷两种状态，即 res[0]，res[1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; money=<span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(money.first,money.second);<br>    &#125;<br><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; money;<br>        <span class="hljs-keyword">auto</span> left=<span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right=<span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        money.first=<span class="hljs-built_in">max</span>(left.first,left.second)+<span class="hljs-built_in">max</span>(right.first,right.second);<br>        money.second=left.first+right.first+root-&gt;val;<br>        <span class="hljs-keyword">return</span> money;      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer题解</title>
    <link href="/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己剑指 offer 的刷题记录。部分内容搬运自 <a href="https://cyc2018.github.io/CS-Notes/#/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%951">cyc2018</a> 、<a href="https://github.com/Jack-Cherish/LeetCode">Jack-Cherish</a>、<a href="https://light-city.club/">light-city</a> 博客以及 <a href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 部分大佬题解，其中特别鸣谢 <a href="https://leetcode-cn.com/u/jyd/">Krahets</a> 大佬提供了非常清晰、详细的解答过程。</p><span id="more"></span><h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html">Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><br>Given target = 5, return true.<br>Given target = 20, return false.<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221222.gif" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(row&lt;array.<span class="hljs-built_in">size</span>()&amp;&amp;col&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(array[row][col]==target)<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[row][col]&lt;target)<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Input:<br>&quot;We Are Happy&quot;<br><br>Output:<br>&quot;We%20Are%20Happy&quot;<br></code></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>最简单的方法就是从头到尾遍历，在每一次碰到空格字符的时候都做替换，并且由于是把 1 个字符替换成 3 个字符，那么每次替换一个空格后都需要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖。假设字符串的长度是 n 。对每个空格字符，需要移动后面 O(n) 个字符，因此对含有 O(n) 个空格字符的字符串而言总的时间复杂度是 O(n^2) 。</p><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。</p><p>② 准备两个指针，P1 和 P2 。令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），同时把 P2 向前移动三个位置，否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><p>移动示意图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221536.jpg" style="zoom: 80%;" /><p>③ 当 P2 遇到 P1 时（P2 &lt;&#x3D; P1），或者遍历结束（P1 &lt; 0），退出。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221356.gif" style="zoom:80%;" /><p>解法二的时间复杂度为 O(n)  级别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-type">char</span> *str,<span class="hljs-type">int</span> length)</span> </span>&#123;<br>        <span class="hljs-type">int</span> spacenum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            spacenum++;<br>        &#125;<br>        <span class="hljs-type">int</span> newlength=length+<span class="hljs-number">2</span>*spacenum;<br>        <span class="hljs-type">int</span> p1=length<span class="hljs-number">-1</span>,p2=newlength<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(p1&gt;=<span class="hljs-number">0</span>&amp;&amp;p2&gt;p1)<br>        &#123;<br>            <span class="hljs-type">char</span> c = str[p1--];<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;<br>                str[p2--]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>                str[p2--]=<span class="hljs-string">&#x27;2&#x27;</span>;<br>                str[p2--]=<span class="hljs-string">&#x27;%&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                str[p2--]=c;<br>        &#125;          <br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221512.png" style="zoom:80%;" /><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用栈"><a href="#解法一：使用栈" class="headerlink" title="解法一：使用栈"></a>解法一：使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221710.gif" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         vector &lt;<span class="hljs-type">int</span>&gt; result;<br>         stack&lt;<span class="hljs-type">int</span>&gt; node;<br>         ListNode* p=head;<br>         <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)<br>         &#123;<br>              node.<span class="hljs-built_in">push</span>(p-&gt;val);<br>              p=p-&gt;next;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(!node.<span class="hljs-built_in">empty</span>())<br>         &#123;<br>           result.<span class="hljs-built_in">push_back</span>(node.<span class="hljs-built_in">top</span>());  <br>           node.<span class="hljs-built_in">pop</span>();<br>         &#125;<br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：使用递归"><a href="#解法二：使用递归" class="headerlink" title="解法二：使用递归"></a>解法二：使用递归</h3><p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         ListNode* p=head;<br>         <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>         &#123;<br>             <span class="hljs-keyword">if</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)<br>                 <span class="hljs-built_in">printListFromTailToHead</span>(p-&gt;next);<br>             result.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>         &#125;<br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：反转链表"><a href="#解法三：反转链表" class="headerlink" title="解法三：反转链表"></a>解法三：反转链表</h3><p>首先准备一个 pre 结点初始指向 nullptr ，表示正在反转结点的前一个结点，再准备一个 cur ，表示当前正在反转的结点，cur 初始化为head 。最后再准备一个 temp ，表示还未反转的第一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        ListNode* temp=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            temp=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=temp;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(pre-&gt;val);<br>            pre=pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法四：使用头插法"><a href="#解法四：使用头插法" class="headerlink" title="解法四：使用头插法"></a>解法四：使用头插法</h3><p>头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。</p><p>链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">node3 = node1.next;<br>node2.next = node3;<br>node1.next = node2;<br></code></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221823.gif" style="zoom:80%;" /><p>为了能将一个节点插入头部，引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221939.gif" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> &#123;<br>    <span class="hljs-comment">// 头插法构建逆序链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">memo</span> <span class="hljs-operator">=</span> listNode.next;<br>        listNode.next = head.next;<br>        head.next = listNode;<br>        listNode = memo;<br>    &#125;<br>    <span class="hljs-comment">// 构建 ArrayList</span><br>    ArrayList&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    head = head.next;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        ret.add(head.val);<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095922.png" style="zoom:80%;" /><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>通常树有如下几种遍历方式：</p><ul><li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。</li><li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。</li><li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。</li></ul><p>本题为前序遍历和中序遍历，最少需要两种遍历方式，才能重建二叉树。</p><p>前序遍历序列的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095932.gif" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)  <span class="hljs-comment">//如果为空，返回NULL</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>         <span class="hljs-comment">//依次是先序遍历左子树，先序遍历右子树，中序遍历左子树，中序遍历右子树</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; left_pre,right_pre,left_vin,right_vin;<br>        <span class="hljs-comment">//先序遍历第一个节点一定为根节点</span><br>        TreeNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>       <span class="hljs-comment">//找到中序遍历的根节点</span><br>        <span class="hljs-type">int</span> root=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vin.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vin[i]==pre[<span class="hljs-number">0</span>])<br>            &#123;<br>                root=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>         <span class="hljs-comment">//利用中序遍历的根节点，对二叉树节点进行归并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;root;i++)<br>        &#123;<br>            left_pre.<span class="hljs-built_in">push_back</span>(pre[i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//先序遍历第一个为根节点</span><br>            left_vin.<span class="hljs-built_in">push_back</span>(vin[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=root+<span class="hljs-number">1</span>;i&lt;vin.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            right_pre.<span class="hljs-built_in">push_back</span>(pre[i]);<br>            right_vin.<span class="hljs-built_in">push_back</span>(vin[i]);<br>        &#125;<br>        <span class="hljs-comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br>        head-&gt;left=<span class="hljs-built_in">reConstructBinaryTree</span>(left_pre,left_vin);<br>        head-&gt;right=<span class="hljs-built_in">reConstructBinaryTree</span>(right_pre,right_vin);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h1><h2 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈（stack1）用来处理入栈（push）操作，out 栈（stack2）用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p><p>因此整体思路为：当 out 栈不为空时， out 栈的栈顶元素是最先进入队列的元素，可以弹出。如果 out 栈为空，就把 in 栈中的元素全部弹出并压入 out 栈。由于先进入队列的元素被压到 in 栈的栈底，经过弹出和压入之后就处于 out 栈的栈顶，可以直接弹出。如果有新元素插入，直接把它压入 in 栈即可。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095941.gif" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;                <br>        &#125; <br>        <span class="hljs-type">int</span> node=stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><h2 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095947.png" style="zoom:80%;" /><h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直观的解法是从头到尾遍历数组一次，轻轻松松就能找出最小的元素。这种思路的时间复杂度为O(n) 。</p><p>一般，O(n) 复杂度的优化是往二分查找这个思路上去考虑的。</p><p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)（为了方便，这里将 log2N 写为 logN）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095953.png" style="zoom:80%;" /><p>此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p><p>通过修改二分查找算法进行求解（left 代表 low，mid 代表 mid，right 代表 high）：</p><ul><li>当 nums[mid] &lt;&#x3D; nums[right] 时，表示 [mid, right] 区间内的数组是非递减数组，[left, mid] 区间内的数组是旋转数组，此时令 right &#x3D; mid；</li><li>否则 [mid+ 1, right] 区间内的数组是旋转数组，令 left &#x3D; mid+ 1。</li></ul><p>如果数组元素允许重复，会出现一个特殊的情况：nums[left] &#x3D;&#x3D; nums[mid] &#x3D;&#x3D; nums[right]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，left、mid 和 right 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; rotateArray)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(rotateArray.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=rotateArray.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(rotateArray[left]==rotateArray[mid]&amp;&amp;rotateArray[mid]==rotateArray[right])<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">minNumber</span>(rotateArray,left,right);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rotateArray[mid]&lt;rotateArray[right])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rotateArray[left];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> min=nums[left];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left+<span class="hljs-number">1</span>;i&lt;right;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;min)<br>                min=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><h2 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&&tqId=11160&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1），n&lt;&#x3D;39。即</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100001.jpeg" style="zoom:80%;" /><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="解法一：使用递归"><a href="#解法一：使用递归" class="headerlink" title="解法一：使用递归"></a>解法一：使用递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。而且重复的结点数会随着 n 的增加而急剧增加，这意味计算量会随着 n 的增加而急剧增大。其复杂度是指数级的，为$O(1.6180^n)$。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100007.png" style="zoom:80%;" /><h3 id="解法二：记忆化搜索算法-x2F-动态规划法"><a href="#解法二：记忆化搜索算法-x2F-动态规划法" class="headerlink" title="解法二：记忆化搜索算法&#x2F;动态规划法"></a>解法二：记忆化搜索算法&#x2F;动态规划法</h3><p>记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。</p><p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在时间复杂度为 O(n),空间复杂度为 O(n)。</p><h3 id="解法三：将空间复杂度降为O-1"><a href="#解法三：将空间复杂度降为O-1" class="headerlink" title="解法三：将空间复杂度降为O(1)"></a>解法三：将空间复杂度降为O(1)</h3><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> fib=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">0</span>,pre1=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        &#123;<br>            fib=pre2+pre1;<br>            pre2=pre1;<br>            pre1=fib;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fib;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><h2 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100015.png" style="zoom:80%;" /><h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n &#x3D; 1 时，只有一种跳法：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100021.png"></p><p>当 n &#x3D; 2 时，有两种跳法：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100028.png" style="zoom:80%;" /><p>跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100036.jpeg" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">1</span>,pre1=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;i++)<br>        &#123;<br>            sum=pre2+pre1;<br>            pre2=pre1;<br>            pre1=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h1><h2 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100048.png" style="zoom:80%;" /><h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>下图来自灵魂画手@<a href="https://blog.csdn.net/qq_40662074/article/details/106573261">小鱼</a> 博客~</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100055.png" style="zoom:80%;" /><h3 id="解法一：使用递归-1"><a href="#解法一：使用递归-1" class="headerlink" title="解法一：使用递归"></a>解法一：使用递归</h3><p>第 n 阶的小青蛙上一步可能来自于 0 到 n-1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;i++)<br>                result+=<span class="hljs-built_in">jumpFloorII</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：数学推导"><a href="#解法二：数学推导" class="headerlink" title="解法二：数学推导"></a>解法二：数学推导</h3><p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去…，那么<br>$$<br>f(n-1) &#x3D; f(n-2) + f(n-3) + … + f(0)<br>$$<br>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去… ，那么<br>$$<br>f(n) &#x3D; f(n-1) + f(n-2) + … + f(0)<br>$$<br>综上可得<br>$$<br>f(n) - f(n-1) &#x3D; f(n-1)<br>$$<br>即<br>$$<br>f(n) &#x3D; 2*f(n-1)<br>$$<br>所以 f(n) 是一个等比数列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(--number)<br>            result*=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h1><h2 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 $2<em>1$ 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 $2</em>1$ 的小矩形无重叠地覆盖一个 $2*n$ 的大矩形，总共有多少种方法？</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100109.gif"></p><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n 为 1 时，只有一种覆盖方法：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100115.png" style="zoom:80%;" /><p>当 n 为 2 时，有两种覆盖方法：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100121.png" style="zoom:80%;" /><p>要覆盖 $2<em>n$ 的大矩形，可以先覆盖 $2</em>1$ 的矩形，再覆盖 $2*(n-1)$ 的矩形；或者先覆盖 $2<em>2$ 的矩形，再覆盖 $2</em>(n-2)$ 的矩形。而覆盖 $2*(n-1)$ 和 $2*(n-2)$ 的矩形可以看成子问题。该问题的递推公式如下：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100126.jpeg" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">1</span>,pre1=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;i++)<br>        &#123;<br>            sum=pre2+pre1;<br>            pre2=pre1;<br>            pre1=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="11-二进制中-1-的个数"><a href="#11-二进制中-1-的个数" class="headerlink" title="11.二进制中 1 的个数"></a>11.二进制中 1 的个数</h1><h2 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h3><p>将整数的每一位与 1 进行与运算，统计 1 的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>         <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>         <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>         &#123;<br>             <span class="hljs-keyword">if</span>(n&amp;num)<br>                 count++;<br>             num&lt;&lt;=<span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">return</span> count;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：n-amp-n-1"><a href="#解法二：n-amp-n-1" class="headerlink" title="解法二：n&amp;(n-1)"></a>解法二：n&amp;(n-1)</h3><p>如果一个整数不为 0，那么这个整数至少有一位是 1。如果把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，原来在1后面的所有的 0都会变成 1 (如果最右边的 1 后面还有 0 的话)。其余所有位将不会受到影响。</p><p>这个时候如果再把原来的整数和减去 1 之后的结果做与运算，从原来整数最右边一个 1 那一位开始所有位都会变成 0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个 1 变成 0。即 n&amp;(n-1) 该位运算去除 n 的位级表示中最低的那一位。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span>       : <span class="hljs-number">10110100</span><br><span class="hljs-attribute">n</span>-<span class="hljs-number">1</span>     : <span class="hljs-number">10110011</span><br><span class="hljs-attribute">n</span>&amp;(n-<span class="hljs-number">1</span>) : <span class="hljs-number">10110000</span><br></code></pre></td></tr></table></figure><p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>         <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)<br>         &#123;<br>            count++;<br>            n&amp;=(n<span class="hljs-number">-1</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> count;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据该方法的拓展得到， 判断一个数是否是2的幂：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">powerof2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((n &amp; (n<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><h2 id="题目链接-11"><a href="#题目链接-11" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。保证 base 和 exponent 不同时为 0。</p><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归法（快速幂）"><a href="#解法一：递归法（快速幂）" class="headerlink" title="解法一：递归法（快速幂）"></a>解法一：递归法（快速幂）</h3><p>下面的讨论中 x 代表 base，n 代表 exponent。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100135.jpeg"></p><p>因为 $(x*x)^{n&#x2F;2}$ 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(exponent==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(exponent==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> base;<br>        <span class="hljs-type">bool</span> isNegative=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(exponent&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            exponent=-exponent;<br>            isNegative=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> pow=<span class="hljs-built_in">Power</span>(base*base,exponent/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(exponent%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<br>            pow*=base;<br>        <span class="hljs-keyword">return</span> isNegative?<span class="hljs-number">1</span>/pow:pow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>空间复杂度：O(logn)，递归栈，因为要记住logn个变量。</p><h3 id="解法二：非递归的快速幂"><a href="#解法二：非递归的快速幂" class="headerlink" title="解法二：非递归的快速幂"></a>解法二：非递归的快速幂</h3><p>假设求$x^6$ ,已知6可以表示成二进制<code>110</code>，可以表示成 $6&#x3D;0<em>2^0+1</em>2^1+1<em>2^2$,所以$x^6$可以表示成$x^6&#x3D;x^{0</em>2^0+1<em>2^1+1</em>2^2}&#x3D;x^0<em>x^{1</em>2^1}<em>x^{1</em>2^2}$所以，对于二进制数，遇到位数是 1 的就乘到答案中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(exponent&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            base=<span class="hljs-number">1</span>/base;<br>            exponent=-exponent;<br>        &#125;<br>        <span class="hljs-type">double</span> x=base; <span class="hljs-comment">// 记录x^0, x^1, x^2 ...</span><br>        <span class="hljs-type">double</span> res=<span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span>(exponent)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(exponent&amp;<span class="hljs-number">1</span>)<br>                res*=x; <span class="hljs-comment">// 二进制位数是1的，乘进答案</span><br>            x*=x;<br>            exponent&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><h2 id="题目链接-12"><a href="#题目链接-12" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100144.png"></p><h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用辅助数组"><a href="#解法一：使用辅助数组" class="headerlink" title="解法一：使用辅助数组"></a>解法一：使用辅助数组</h3><p>创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> oddCnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 奇数个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:array)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                oddCnt++;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(array)</span></span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,j=oddCnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:copy)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                array[k++]=i;<br>            <span class="hljs-keyword">else</span><br>                array[j++]=i;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：稳定排序思想"><a href="#解法二：稳定排序思想" class="headerlink" title="解法二：稳定排序思想"></a>解法二：稳定排序思想</h3><p><strong>相对位置不变—&gt;保持稳定性；奇数位于前面，偶数位于后面 —&gt;存在判断，挪动元素位置；</strong>这些都和内部排序算法相似，考虑到具有稳定性的排序算法不多，例如冒泡排序，插入排序，归并排序等。</p><h4 id="冒泡排序思想"><a href="#冒泡排序思想" class="headerlink" title="冒泡排序思想"></a>冒泡排序思想</h4><p>使用冒泡思想，每次都将当前偶数上浮到当前最右边。时间复杂度 O(N^2)，空间复杂度 O(1)，时间换空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(array[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; array[j+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-built_in">swap</span>(array[j],array[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(array[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; array[j+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-built_in">swap</span>(array[j],array[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="14-链表中倒数第-K-个结点"><a href="#14-链表中倒数第-K-个结点" class="headerlink" title="14.链表中倒数第 K 个结点"></a>14.链表中倒数第 K 个结点</h1><h2 id="题目链接-13"><a href="#题目链接-13" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第 k 个结点。</p><h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100152.png" style="zoom: 67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pListHead, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* P1=pListHead, *P2=pListHead;<br>        <span class="hljs-keyword">while</span>(k--)<br>        &#123;<br>            <span class="hljs-comment">// 链表节点少于k</span><br>            <span class="hljs-keyword">if</span>(P1==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            P1=P1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(P1!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            P1=P1-&gt;next;<br>            P2=P2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> P2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><h2 id="题目链接-14"><a href="#题目链接-14" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead||!pHead-&gt;next)<br>            <span class="hljs-keyword">return</span> pHead;        <br>         <span class="hljs-comment">// 4-&gt;5-&gt;NULL   cur 5  head 4</span><br>        ListNode* head=<span class="hljs-built_in">ReverseList</span>(pHead-&gt;next);<br>        pHead-&gt;next-&gt;next=pHead; <span class="hljs-comment">// 5-&gt;4</span><br>        pHead-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 4-&gt;NULL</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>首先准备一个 pre 结点初始指向 NULL，表示正在反转结点的前一个结点，再准备一个 cur ，表示当前正在反转的结点，cur 初始化为head 。最后再准备一个 temp ，表示还未反转的第一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead||!pHead-&gt;next)<br>            <span class="hljs-keyword">return</span> pHead;<br>        ListNode* pre=<span class="hljs-literal">NULL</span>;<br>        ListNode* cur=pHead;<br>        ListNode* temp=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            temp=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h1><h2 id="题目链接-15"><a href="#题目链接-15" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100203.png" style="zoom:80%;" /><h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。</p><p>两个链表都是排序好的，只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span>(!pHead2) <span class="hljs-keyword">return</span> pHead1;<br>        <span class="hljs-keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)<br>        &#123;<br>            pHead1-&gt;next=<span class="hljs-built_in">Merge</span>(pHead1-&gt;next,pHead2);<br>            <span class="hljs-keyword">return</span> pHead1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pHead2-&gt;next=<span class="hljs-built_in">Merge</span>(pHead1,pHead2-&gt;next);<br>            <span class="hljs-keyword">return</span> pHead2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(m+n)<br>空间复杂度：O(m+n),每一次递归，递归栈都会保存一个变量，最差情况会保存 (m+n) 个变量</p><h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>使用归并排序思想。</p><blockquote><p>一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* vhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); <br>        ListNode* cur=vhead; <span class="hljs-comment">//设定虚拟头结点，也叫哨兵，前驱结点</span><br>        <span class="hljs-keyword">while</span>(pHead1!=<span class="hljs-literal">NULL</span> &amp;&amp; pHead2!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)<br>            &#123;<br>                cur-&gt;next=pHead1;<br>                pHead1=pHead1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;next=pHead2;<br>                pHead2=pHead2-&gt;next;<br>            &#125;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pHead1!=<span class="hljs-literal">NULL</span>)<br>            cur-&gt;next=pHead1;<br>        <span class="hljs-keyword">if</span>(pHead2!=<span class="hljs-literal">NULL</span>)<br>            cur-&gt;next=pHead2;<br>        cur=vhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> vhead;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(m+n),m，n分别为两个单链表的长度<br>空间复杂度：O(1)</p><h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><h2 id="题目链接-16"><a href="#题目链接-16" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构（ps：我们约定空树不是任意一个树的子结构）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100211.jpeg" style="zoom:80%;" /><h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>要查找树 A 中是否存在和树 B 结构一样的子树，可以分为两步：第一步在树 A 中找到和 B 的根结点的值一样的结点 R，第二步再判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构。这里使用递归的方法即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-comment">// HasSubtree 寻找相同根节点：判断A、B根节点是否相同。相同就用 isSubTreeWithRoot 进一步判断；没找到就继续尝试A的左右子树。</span><br><span class="hljs-comment">//isSubTreeWithRoot 根节点相同的情况下，进一步判断：判断节点是否相同，相同则进一步比较左右树。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">bool</span> result=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//当Tree1和Tree2均不为空的时候</span><br>        <span class="hljs-keyword">if</span>(pRoot1!=<span class="hljs-literal">NULL</span> &amp;&amp; pRoot2!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">//如果根节点相同，则进一步判断tree2是否为tree1的子树</span><br>            <span class="hljs-keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)<br>                result=<span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1,pRoot2);<br>            <span class="hljs-comment">//如果根节点不同，则去root的左子树中找</span><br>            <span class="hljs-keyword">if</span>(!result)<br>                result=<span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left,pRoot2);<br>            <span class="hljs-comment">//如果左子树没找到，则去root的右子树中找</span><br>            <span class="hljs-keyword">if</span>(!result)<br>                result=<span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right,pRoot2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//如果根节点相同，进一步判断tree2是否为tree1的子树</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubTreeWithRoot</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//如果Tree2已经遍历完了都能对应的上，返回true</span><br>        <span class="hljs-keyword">if</span>(pRoot2==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span><br>        <span class="hljs-keyword">if</span>(pRoot1==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果其中有一个点没有对应上，返回false</span><br>        <span class="hljs-keyword">if</span>(pRoot1-&gt;val!=pRoot2-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;<span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1-&gt;right,pRoot2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><h2 id="题目链接-17"><a href="#题目链接-17" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724101030.png"></p><h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>把当前根节点的左右结点交换，然后以递归的方式进一步 mirror 左右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode *pTemp=pRoot-&gt;left;<br>        pRoot-&gt;left=pRoot-&gt;right;<br>        pRoot-&gt;right=pTemp;<br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：非递归"><a href="#解法二：非递归" class="headerlink" title="解法二：非递归"></a>解法二：非递归</h3><h4 id="栈模拟二叉树的先序遍历"><a href="#栈模拟二叉树的先序遍历" class="headerlink" title="栈模拟二叉树的先序遍历"></a>栈模拟二叉树的先序遍历</h4><p>非递归版本，只需要模拟一次树遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(cur-&gt;left,cur-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="队列模拟二叉树的先序遍历"><a href="#队列模拟二叉树的先序遍历" class="headerlink" title="队列模拟二叉树的先序遍历"></a>队列模拟二叉树的先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(cur-&gt;left,cur-&gt;right);<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><h2 id="题目链接-18"><a href="#题目链接-18" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下 4 * 4 矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg"></p><h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>从左到右，再从上到下，再从右到左，最后从下到上遍历。打印一个矩阵某个正方形上的点的逻辑如下：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100238.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-type">int</span> rows=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=cols<span class="hljs-number">-1</span>,top=<span class="hljs-number">0</span>,bottom=rows<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;=right;++i)<br>                result.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=top+<span class="hljs-number">1</span>;i&lt;=bottom;++i)<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            <span class="hljs-keyword">if</span>(top!=bottom)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=right<span class="hljs-number">-1</span>;i&gt;=left;--i)<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>            <span class="hljs-keyword">if</span>(left!=right)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bottom<span class="hljs-number">-1</span>;i&gt;top;--i)<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            left++,top++,right--,bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="20-包含-min-函数的栈"><a href="#20-包含-min-函数的栈" class="headerlink" title="20.包含 min 函数的栈"></a>20.包含 min 函数的栈</h1><h2 id="题目链接-19"><a href="#题目链接-19" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 O(1）。</p><p>注意：保证测试中不会当栈为空的时候，对栈调用 pop() 或者 min() 或者 top() 方法。</p><h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个 stack ，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。</p><p>（1）压入数据规则<br>假设当前数据为 value，先将其压入 dataStack。然后判断 dataStack 是否为空。<br>如果为空，则 value 也压入 minStack；如果不为空，则比较 value 和 minStack 的栈顶<br>元素中哪一个更小。<br>如果 value 更小或者两者相等，则 value 也压入 minStack；如果 minStack 中栈顶元素<br>小，则把 minStack 的栈顶元素重复压入 minStack ，即在栈顶元素上再压入一个栈顶元素。</p><p>举例：依次压入 3、4、5、1、2、1 的过程中，dataStack 和 minStack 的变化如下图所示。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100328.png"></p><p>（2）弹出数据规则<br>在 dataStack 中弹出数据，并弹出 minStack中的栈顶。</p><p>（3）获得栈顶元素</p><p>直接返回 dataStack 的栈顶元素。</p><p>（4）查询当前栈中的最小值操作<br>minStack 始终记录着 dataStack 中的最小值，所以 minStack 的栈顶元素始终是当前 dataStack  中的最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(minStack.<span class="hljs-built_in">empty</span>())<br>            minStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&lt;=minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span><br>            minStack.<span class="hljs-built_in">push</span>(minStack.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">pop</span>();<br>        minStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; dataStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minStack;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><h2 id="题目链接-20"><a href="#题目链接-20" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p><p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个辅助栈来模拟压入弹出操作。遍历压入序列，将 pushV 数组的元素入栈，碰到与 popV 数组相同的元素进行出栈并将弹出序列向后移动一位，等压入序列遍历完成，以 popV 数组元素是否访问完毕或者辅助栈是否为空判断是否是弹出序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV,vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;pushV.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            data.<span class="hljs-built_in">push</span>(pushV[i]);<br>            <span class="hljs-keyword">while</span>(j&lt;popV.<span class="hljs-built_in">size</span>()&amp;&amp;!data.<span class="hljs-built_in">empty</span>()&amp;&amp;data.<span class="hljs-built_in">top</span>()==popV[j])<br>            &#123;<br>                data.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><h2 id="题目链接-21"><a href="#题目链接-21" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100348.jpeg" style="zoom:80%;" /><h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><p>借助队列来进行层次遍历。每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都打印出来为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">NULL</span>)<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">NULL</span>)<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。</li><li>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li></ul><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">levelOrder</span>(root,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:res)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> el:elem)<br>                result.<span class="hljs-built_in">push_back</span>(el);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> level,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==level)<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">levelOrder</span>(root-&gt;left,level+<span class="hljs-number">1</span>,res);<br>        <span class="hljs-built_in">levelOrder</span>(root-&gt;right,level+<span class="hljs-number">1</span>,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><h2 id="题目链接-22"><a href="#题目链接-22" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归分治"><a href="#解法一：递归分治" class="headerlink" title="解法一：递归分治"></a>解法一：递归分治</h3><p>举例说明：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100356.jpeg" style="zoom:80%;" /><p>以 {5,7,6,9,11,10,8} 为例，后序遍历结果的最后一个数字 8 就是根结点的值。在这个数组中，前 3 个数字 5、7 和 6 都比 8 小，是值为 8 的结点的左子树结点；后 3 个数字 9、11 和 10 都比 8 大，是值为 8 的结点的右子树结点。</p><p>接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实就是一个递归的过程。对于序列 5、7、6，最后一个数字 6 是左子树的根结点的值。数字 5 比 6 小，是值为 6 的结点的左子结点，而 7 则是它的右子结点。同样，在序列 9、11、10 中，最后一个数字 10 是右子树的根结点，数字 9 比 10 小，是值为 10 的结点的左子结点，而 11 则是它的右子结点。</p><p>使用递归的方法，先判断数组的左子树和右子树的位置，然后再判断左子树、右子树是不是二叉搜索树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verify</span>(sequence,<span class="hljs-number">0</span>,sequence.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; seq,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;=end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历左子树，找到右子树的第一个元素</span><br>        <span class="hljs-keyword">for</span>(i=start;i&lt;end;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(seq[i]&gt;seq[end])<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 左子树：[start,i-1] 右子树：[i,end-1]  根节点：end</span><br><span class="hljs-comment">// 遍历右子树，判断右树都大于根节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;end;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(seq[j]&lt;seq[end])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verify</span>(seq,start,i<span class="hljs-number">-1</span>)&amp;&amp;<span class="hljs-built_in">verify</span>(seq,i,end<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：辅助单调栈"><a href="#解法二：辅助单调栈" class="headerlink" title="解法二：辅助单调栈"></a>解法二：辅助单调栈</h3><p>具体解法参考 Leetcode 上大佬 @<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">Krahets</a> 、@<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/dan-diao-di-zeng-zhan-by-shi-huo-de-xia-tian/">失火的夏天</a> 的解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> root=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sequence.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-comment">// 左子树大于上一步的栈顶元素，否则不满足二叉搜索树</span><br>            <span class="hljs-keyword">if</span>(sequence[i]&gt;root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">// 左子树节点小于递增栈栈顶元素，则出栈</span><br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;sequence[i]&lt;s.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                root=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// 更新栈中元素，入栈，保持递增</span><br>            s.<span class="hljs-built_in">push</span>(sequence[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><h2 id="题目链接-23"><a href="#题目链接-23" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100404.jpeg" style="zoom:80%;" /><h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p></blockquote><p>深度优先搜索。使用前序遍历，使用两个全局变量 res 和 path，res 来存放最终结果，path 用来存放临时结果。</p><p>每次遍历，我们先把 root 的值压入 path，然后判断当前 root 是否同时满足：</p><ul><li>与目标值相减为0；</li><li>左子树为空；</li><li>右子树为空。</li></ul><p>如果满足条件，就将 path 压入 res 中，否则，依次遍历左右子树。向上回溯前，需要将当前节点从路径 path 中删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">FindPath</span>(TreeNode* root,<span class="hljs-type">int</span> expectNumber) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root,expectNumber,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> expectNumber,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        expectNumber-=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(expectNumber==<span class="hljs-number">0</span>&amp;&amp;root-&gt;left==<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">NULL</span>)<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,expectNumber,path,res);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,expectNumber,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><h2 id="题目链接-24"><a href="#题目链接-24" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针 random 指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100413.png" style="zoom:67%;" /><h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS-amp-BFS"><a href="#解法一：DFS-amp-BFS" class="headerlink" title="解法一：DFS &amp; BFS"></a>解法一：DFS &amp; BFS</h3><p>图的基本单元是顶点，顶点之间的关联关系称为边，可以将此链表看成一个图：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100418.png" style="zoom:67%;" /><p>由于图的遍历方式有深度优先搜索和广度优先搜索，同样地，对于此链表也可以使用深度优先搜索和广度优先搜索两种方法进行遍历。</p><h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h4><ol><li>从头结点开始拷贝；</li><li>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</li><li>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</li><li>使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(pHead)&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> mp[pHead];<br>        RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(pHead-&gt;label);<br>        mp[pHead]=clone;<br>        clone-&gt;next=<span class="hljs-built_in">Clone</span>(pHead-&gt;next);<br>        clone-&gt;random=<span class="hljs-built_in">Clone</span>(pHead-&gt;random);<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度O(n)。</p><h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h4><p>使用一个队列，将本题看成树的层次遍历。</p><ol><li>创建哈希表保存已拷贝结点，格式 {原结点：拷贝结点}</li><li>创建队列，并将头结点入队；</li><li>当队列不为空时，弹出一个结点，如果该结点的 next 结点未被拷贝过，则拷贝 next 结点并加入队列；同理，如果该结点的 random 结点未被拷贝过，则拷贝 random 结点并加入队列。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        queue&lt;RandomListNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pHead);<br>        RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(pHead-&gt;label);<br>        mp[pHead]=clone;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            RandomListNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// cur-&gt;next 并没有复制过</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;mp.<span class="hljs-built_in">count</span>(cur-&gt;next)==<span class="hljs-number">0</span>)<br>            &#123;<br>                mp[cur-&gt;next]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;next-&gt;label);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;next);<br>            &#125;<br>            <span class="hljs-comment">// cur-&gt;random 并没有复制过</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>&amp;&amp;mp.<span class="hljs-built_in">count</span>(cur-&gt;random)==<span class="hljs-number">0</span>)<br>            &#123;<br>                mp[cur-&gt;random]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;random-&gt;label);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;random);<br>            &#125;<br>            mp[cur]-&gt;next=mp[cur-&gt;next];<br>            mp[cur]-&gt;random=mp[cur-&gt;random];<br>        &#125;<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度O(n)。</p><h3 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>该方法的思路比较直接，对于一个结点，分别拷贝此结点、next 指针指向的结点、random 指针指向的结点，然后进行下一个结点…如果遇到已经出现的结点，那么不用拷贝该结点，只需将 next 或 random 指针指向该结点即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br>        RandomListNode* cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            mp[cur]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            cur=cur-&gt;next;<br>        &#125;<br>        cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>)<br>                mp[cur]-&gt;next=mp[cur-&gt;next];<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>)<br>                mp[cur]-&gt;random=mp[cur-&gt;random];<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp[pHead];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度O(n)。</p><h3 id="解法三：优化的迭代"><a href="#解法三：优化的迭代" class="headerlink" title="解法三：优化的迭代"></a>解法三：优化的迭代</h3><p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个节点后面添加原节点的拷贝。</p><p>第一步，在每个节点的后面插入复制的节点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png" style="zoom:67%;" /><p>第二步，对复制节点的 random 链接进行赋值。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png" style="zoom:67%;" /><p>第三步，拆分。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 插入新节点</span><br>        RandomListNode* cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            clone-&gt;next=cur-&gt;next;<br>            cur-&gt;next=clone;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 建立 random 链接</span><br>        cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* clone=cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>)<br>                clone-&gt;random=cur-&gt;random-&gt;next;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        cur=pHead;<br>        RandomListNode* pCloneHead=pHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* next=cur-&gt;next;<br>            cur-&gt;next=next-&gt;next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pCloneHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度O(1)。</p><h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><h2 id="题目链接-25"><a href="#题目链接-25" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100449.jpeg" style="zoom: 80%;" /><h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>解题思路基于性质：二叉搜索树的中序遍历为<strong>递增序列</strong> 。</p></blockquote><p>将二叉搜索树转换成一个“排序的双向链表”，其中包含两个要素：</p><ul><li>排序链表： 节点应从小到大排序，因此应使用中序遍历“从小到大”访问树的节点；</li><li>双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre-&gt;right &#x3D; cur，也应 cur-&gt;left &#x3D; pre。</li></ul><p>算法流程——递归法中序遍历：</p><ol><li><p>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</p></li><li><p>递归左子树；</p></li><li><p>构建链表：</p><p>当 pre 为空时： 代表正在访问链表头节点，记为 head。<br>当 pre 不为空时： 修改双向节点引用，即 pre-&gt;right &#x3D; cur， cur-&gt;left &#x3D; pre ；<br>保存 cur： 更新 pre &#x3D; cur，即节点 cur 是后继节点的 pre ；</p></li><li><p>递归右子树；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TreeNode* pre=<span class="hljs-literal">NULL</span>;<br>    TreeNode* head=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">inOrder</span>(pRootOfTree);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* cur)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(cur-&gt;left);<br>        <span class="hljs-comment">// pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>)<br>            pre-&gt;right=cur;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点</span><br>            head=cur;<br>        <span class="hljs-comment">// pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的</span><br>        cur-&gt;left=pre;<br>        <span class="hljs-comment">// pre指向当前的cur</span><br>        pre=cur;<br>        <span class="hljs-comment">// 全部迭代完成后，pre指向双向链表中的尾节点</span><br>        <span class="hljs-built_in">inOrder</span>(cur-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)： N 为二叉树的节点数，中序遍历需要访问所有节点。</li><li>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</li></ul><h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><h2 id="题目链接-26"><a href="#题目链接-26" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc,则打印出由字符 a,b,c 所能排列出来的所有字符串 abc,acb,bac,bca,cab 和 cba。</p><p>输入一个字符串,长度不超过 9 (可能有字符重复),字符只包括大小写字母。</p><h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>采用回溯法。</p></blockquote><p>排列方案数量： 对于一个长度为 n 的字符串（假设字符互不重复），其排列共有 $n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1$ 种方案。</p><p>排列方案的生成方法： 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n-1 种情况）、… 、最后固定第 n 位字符（ 1 种情况）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100459.png" style="zoom:67%;" /><p>重复方案与剪枝： 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，采用 set 来保存，并且可以达到按字母顺序排序。</p><p>递归解析：</p><ol><li>终止条件： 当 x &#x3D; len(str) - 1 时，代表所有位已固定（最后一位只有 1 种情况），则将当前字符串加入 res，并返回；</li><li>递推参数： 当前固定位 x ；</li><li>递推工作： 将第 x 位字符与 i∈[x,len(str)] 字符分别交换，并进入下层递归，调用 dfs(x + 1)，即开始固定第 x + 1 个字符；</li><li>还原交换： 将字符 str[i]和 str[x] 交换（还原之前的交换）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        set&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(str,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;string&gt;(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string str,set&lt;string&gt; &amp;result,<span class="hljs-type">int</span> begin)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            result.<span class="hljs-built_in">insert</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(str[i],str[begin]);<br>            <span class="hljs-built_in">dfs</span>(str,result,begin+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(str[i],str[begin]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N!) ： N 为字符串 str 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 $N \times (N-1) \times (N-2) … \times 2 \times 1N×(N−1)×(N−2)…×2×1$ ，因此复杂度为 O(N!) 。<br>空间复杂度 O(N^2)： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N)；递归中辅助 Set 累计存储的字符数量最多为 N + (N-1) + … + 2 + 1 &#x3D; (N+1)N&#x2F;2，即占用 O(N^2) 的额外空间。</p><h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><h2 id="题目链接-27"><a href="#题目链接-27" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组 {1,2,3,2,2,2,5,4,2} 。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2 。如果不存在则输出 0 。</p><h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>本题常见解法如下：</p><p>哈希表统计法： 遍历 numbers ，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 O(N) 。<br>数组排序法： 将 numbers 排序，由于众数的数量超过数组长度一半，因此数组中点的元素一定为众数。此方法时间复杂度 O(Nlog N)​。<br>摩尔投票法： 核心理念为 “正负抵消” ；时间和空间复杂度分别为 O(N) 和 O(1) ；是本题的最佳解法。</p></blockquote><h3 id="解法一：使用-map-统计"><a href="#解法一：使用-map-统计" class="headerlink" title="解法一：使用 map 统计"></a>解法一：使用 map 统计</h3><p>key 为元素，value 为出现次数，当出现次数达到超过一半的时候，返回该元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-type">int</span> overhalf=numbers.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:numbers)<br>        &#123;<br>            mp[elem]++;<br>            <span class="hljs-keyword">if</span>(mp[elem]==overhalf)<br>                <span class="hljs-keyword">return</span> elem;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：摩尔投票法"><a href="#解法二：摩尔投票法" class="headerlink" title="解法二：摩尔投票法"></a>解法二：摩尔投票法</h3><p><strong>摩尔投票法：</strong></p><ul><li><p>票数和： 由于众数出现的次数超过数组长度的一半；若记众数的票数为 +1 ，非众数的票数为 -1，则一定有所有数字的票数和 &gt;0 。</p></li><li><p>票数正负抵消： 设数组 nums 中的众数为 x ，数组长度为 n 。若 nums 的前 a 个数字的 票数和 &#x3D;0 ，则数组后 (n-a) 个数字的票数和一定仍 &gt;0 （即后 (n−a) 个数字的众数仍为 x ）。</p></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100511.png" style="zoom:67%;" /><p><strong>算法原理：</strong></p><ul><li><p>为构建正负抵消，假设数组首个元素 n1 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 x ）：</p><ul><li>当 n1 &#x3D; x ： 抵消的所有数字中，有一半是众数 x 。</li><li>当 n1 !&#x3D; x： 抵消的所有数字中，少于或等于一半是众数 x 。</li></ul></li><li><p>利用此特性，每轮假设都可以缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）。</p></li></ul><p><strong>算法流程:</strong></p><ol><li>初始化： 票数统计 votes &#x3D; 0， 众数 x；</li><li>循环抵消： 遍历数组 nums 中的每个数字 num ；<ul><li>当票数 votes 等于 0 ，则假设当前数字 num 为 众数 x ；</li><li>当 num &#x3D; x 时，票数 votes 自增 1 ；否则，票数 votes 自减 1 。</li></ul></li><li>验证环节：遍历数组 nums 统计 x 的数量。<ul><li>若 x 的数量超过数组长度一半，则返回 x ；</li><li>否则，返回 0 （这里根据不同题目的要求而定）。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,votes=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:numbers)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(votes==<span class="hljs-number">0</span>)<br>                x=elem;<br>            votes=elem==x?votes+<span class="hljs-number">1</span>:votes<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//验证x是否为众数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:numbers)<br>            <span class="hljs-keyword">if</span>(elem==x)<br>                count++;<br>        <span class="hljs-keyword">return</span> count&gt;numbers.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>?x:<span class="hljs-number">0</span>;<span class="hljs-comment">//当无众数时返回0</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： N 为数组 nums 长度。<br>空间复杂度 O(1)： votes 变量使用常数大小的额外空间。</p><h1 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29.最小的 K 个数"></a>29.最小的 K 个数</h1><h2 id="题目链接-28"><a href="#题目链接-28" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4 。</p><h2 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>经典的 <strong>Top K 问题</strong>。Top K 问题有两种不同的解法，一种解法使用堆（优先队列），另一种解法使用类似快速排序的分治法。</p></blockquote><h3 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h3><p>使用堆数据结构来辅助得到最小的 k 个数。堆的性质是每次可以找出最大或最小的元素。可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，将堆顶元素与数组元素进行比较，若数组元素较小，则将堆顶元素弹出，数组元素入堆，若数组元素较大，直接丢弃。</p><p>这样，<strong>由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里</strong>。这样，把数组中的元素全部入堆之后，堆中剩下的 k 个元素就是最小的 k 个数了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k&gt;input.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// C++优先级队列默认大顶堆，若需要小顶堆，则声明priority_queue&lt;int，vector&lt;int&gt;,greater&lt;int&gt;&gt; que;</span><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            que.<span class="hljs-built_in">push</span>(input[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;input.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">top</span>()&gt;input[i])<br>            &#123;<br>                que.<span class="hljs-built_in">pop</span>();<br>                que.<span class="hljs-built_in">push</span>(input[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">top</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>由于使用了一个大小为 k 的堆，空间复杂度为 O(k)；</li><li>入堆和出堆操作的时间复杂度均为 O(logk)，最坏情况下数组的每个元素都需要进行一次入堆操作，故算法的时间复杂度为 O(nlogk)。</li></ul><h3 id="解法二：快排变形"><a href="#解法二：快排变形" class="headerlink" title="解法二：快排变形"></a>解法二：快排变形</h3><p>“查找第 k 大的元素”是一类算法问题，称为选择问题。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p><p>快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100521.jpeg" style="zoom:80%;" /><p>这个 partition 操作是原地进行的，需要 O(n) 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p><p>我们的目的是寻找最小的 k个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p><ul><li>若 k&#x3D;m，我们就找到了最小的 k 个数，就是左侧的数组；</li><li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li><li>若 k&gt;m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k&gt;input.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">quickSelect</span>(input,<span class="hljs-number">0</span>,input.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);<br>        <span class="hljs-comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            res.<span class="hljs-built_in">push_back</span>(input[i]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; input,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 做一次partition操作</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">partition</span>(input,lo,hi);<br>        <span class="hljs-comment">// 此时数组前m个数，就是最小的m个数</span><br>        <span class="hljs-keyword">if</span>(k==m)<br>            <span class="hljs-comment">// 正好找到最小的 k(m) 个数</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&lt;m)<br>            <span class="hljs-comment">// 最小的k个数一定在前m个数中，递归划分</span><br>            <span class="hljs-built_in">quickSelect</span>(input,lo,m<span class="hljs-number">-1</span>,k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 在右侧数组中寻找最小的k-m个数</span><br>            <span class="hljs-built_in">quickSelect</span>(input,m+<span class="hljs-number">1</span>,hi,k);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 快排的partition过程 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> less=lo<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> more=hi;<br>        <span class="hljs-keyword">while</span>(lo&lt;more)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[lo]&lt;arr[hi])<br>                <span class="hljs-built_in">swap</span>(arr[++less],arr[lo++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[lo]&gt;arr[hi])<br>                <span class="hljs-built_in">swap</span>(arr[--more],arr[lo]);<br>            <span class="hljs-keyword">else</span><br>                lo++;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[more],arr[hi]);<br>        <span class="hljs-keyword">return</span> less+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>空间复杂度期望为 O(logn)。递归调用的期望深度为 O(logn)，每层需要的空间为 O(1)，只有常数个变量。 最坏情况下的空间复杂度为 O(n)。最坏情况下需要划分 n 次，即函数递归调用最深 n−1 层，而每层由于需要 O(1) 的空间，所以一共需要 O(n) 的空间复杂度。</li><li>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2)。情况最差时，每次的划分点都是最大值或最小值，一共需要划分 n−1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 O(n^2)。</li></ul><h3 id="两种方法的优劣性比较"><a href="#两种方法的优劣性比较" class="headerlink" title="两种方法的优劣性比较"></a>两种方法的优劣性比较</h3><p>在面试中，常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p><ul><li>算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li><li>算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</li></ul><h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><h2 id="题目链接-29"><a href="#题目链接-29" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如: {6,-3,-2,7,-15,1,2,2} ,连续子向量的最大和为 8 (从第 0 个开始,到第 3 个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是 1 )</p><h2 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：贪心法"><a href="#解法一：贪心法" class="headerlink" title="解法一：贪心法"></a>解法一：贪心法</h3><p>举例分析：下图是计算（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析发现，累加的子数组和，如果大于 0 ，那么继续累加，即将下一个数值加入和中；如果累加和小于 0 ，则需要剔除原来的累加和，从下一个数重新开始。同时，更新最大和的值。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100530.jpeg" style="zoom:80%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> greatSum=INT_MIN;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:array)<br>        &#123;<br>            curSum=curSum&lt;<span class="hljs-number">0</span>?elem:curSum+elem;<br>            greatSum=<span class="hljs-built_in">max</span>(greatSum,curSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> greatSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><p> 分治法模板： </p><ol><li>定义基本情况 </li><li>将问题分解为子问题并递归解决子问题 </li><li>合并子问题的解以获得原始问题的解</li></ol><p>将 array 中点 mid 分为三种情况： </p><ol><li>最大子串在左边 </li><li>最大子串在右边 </li><li>最大子串跨中点，左右都有</li></ol><p>当子串在左边或右边时，继续分中点递归分解到一个数为止，对于递归后横跨的子串，再分治为左侧和右侧求最大子串，可使用贪心算法求最大子串值，再合并为原始的最大子串值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(array,<span class="hljs-number">0</span>,array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 分解到一个值时返回该值</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> array[left];<br>        <span class="hljs-comment">// 求中点值</span><br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>         <span class="hljs-comment">// 中点左边的最大值</span><br>        <span class="hljs-type">int</span> leftSum=<span class="hljs-built_in">helper</span>(array,left,mid);<br>        <span class="hljs-comment">// 中点右边的最大值</span><br>        <span class="hljs-type">int</span> rightSum=<span class="hljs-built_in">helper</span>(array,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-comment">// 横跨中点的最大值</span><br>        <span class="hljs-type">int</span> croSum=<span class="hljs-built_in">crossSum</span>(array,left,right,mid);<br>        <span class="hljs-comment">// 返回以上三种情况中的最大值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(leftSum,rightSum),croSum);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">crossSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 分解到一个值时返回该值</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> array[left];<br>         <span class="hljs-comment">// 贪心法求左边的最大值</span><br>        <span class="hljs-type">int</span> leftSubSum=INT_MIN;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid;i&gt;=left;--i)<br>        &#123;<br>            curSum+=array[i];<br>            leftSubSum=<span class="hljs-built_in">max</span>(leftSubSum,curSum);<br>        &#125;<br>        <span class="hljs-comment">// 贪心法求右边的最大值</span><br>        <span class="hljs-type">int</span> rightSubSum=INT_MIN;<br>        curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=right;++i)<br>        &#123;<br>            curSum+=array[i];<br>            rightSubSum=<span class="hljs-built_in">max</span>(rightSubSum,curSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftSubSum+rightSubSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(nlogn)。</li><li>空间复杂度：O(logn)。</li></ul><h3 id="解法三：动态规划——-Kadane算法"><a href="#解法三：动态规划——-Kadane算法" class="headerlink" title="解法三：动态规划—— Kadane算法"></a>解法三：动态规划—— Kadane算法</h3><blockquote><p>在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题，可通过动态规划(DP)在线性时间内解决。</p><p>两种标志 DP 适用于数组：</p><ul><li>常数空间，沿数组移动并在原数组修改；</li><li>线性空间，首先沿 left-&gt;right 方向移动，然后沿 right-&gt;left 方向移动，最后合并结果。</li></ul></blockquote><p><strong>动态规划解析：</strong></p><ul><li><p>状态定义： 设动态规划列表 dp ，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</p><p>为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的连续子数组要求。</p></li><li><p>转移方程： 若 dp[i-1]≤0 ，说明 dp[i - 1] 对 dp[i] 产生负贡献，即 dp[i-1] + nums[i]  还不如 nums[i] 本身大。</p><ul><li>当 dp[i - 1]&gt;0 时：执行 dp[i] &#x3D; dp[i-1] + nums[i] ；</li><li>当 dp[i - 1]≤0 时：执行 dp[i] &#x3D; nums[i] ；</li></ul></li><li><p>初始状态： dp[0]&#x3D;nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。</p></li><li><p>返回值： 返回 dp 列表中的最大值，代表全局最大值。</p></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110816.png" style="zoom:67%;" /><p>空间复杂度降低：</p><ul><li>由于 dp[i]  只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums上修改即可。</li><li>由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;array.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            array[i]+=<span class="hljs-built_in">max</span>(array[i<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>);<br>            res=<span class="hljs-built_in">max</span>(res,array[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。</li><li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li></ul><h1 id="31-从-1-到-n-整数中-1-出现的次数"><a href="#31-从-1-到-n-整数中-1-出现的次数" class="headerlink" title="31.从 1 到 n 整数中 1 出现的次数"></a>31.从 1 到 n 整数中 1 出现的次数</h1><h2 id="题目链接-30"><a href="#题目链接-30" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出 1<del>13 的整数中 1 出现的次数,并算出 100</del>1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、12、13 因此共出现 6 次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中 1 出现的次数（从 1 到 n 中 1 出现的次数）。</p><h2 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>从 1 到 n 遍历，每次通过对 10 求余数判断整数的个位数字是不是 1，大于 10 的除以 10 之后再判断。对每个数字都要做除法和求余运算以求出该数字中 1 出现的次数。如果输入数字 n ，n 有 O(logn) 位，需要判断每一位是不是 1，那么时间复杂度为 O(n*logn) 。计算量大，效率不高。</p><h3 id="解法二：递归-1"><a href="#解法二：递归-1" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><ul><li>最高位为 1<ul><li>不包含高位下 1 的个数</li><li>除最高位剩余数字中 1 的情况</li><li>固定高位下 1 的个数</li></ul></li><li>最高位不为 1<ul><li>固定最高位为 1 的情况</li><li>不包含高位下 1 的情况</li><li>除最高位剩余数字中 1 的情况</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(n);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        string num=<span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> p=<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,num.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> high=num[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> last=n-high*p;<br>        <span class="hljs-keyword">if</span>(high==<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 最高位为1，例如: 12345 就需要计算 0~9999 、2345、10000~12345中的1</span><br>        <span class="hljs-comment">// dfs(p-1)表示[0,9999]中的1</span><br>        <span class="hljs-comment">// dfs(last)表示2345中1出现的个数</span><br>        <span class="hljs-comment">// last+1表示固定高位1有多少种情况</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(last)+last+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 最高位不为1，如 22347，就需要计算</span><br>            <span class="hljs-comment">// p 固定高位为1有多少种可能，[10000,19999]</span><br>            <span class="hljs-comment">// high*dfs(p-1) 不固定高位下，[0,9999]及[10000,19999]中非高位1的出现的个数</span><br>            <span class="hljs-comment">// dfs(last) 表示2347中的1</span><br>            <span class="hljs-keyword">return</span> p+high*<span class="hljs-built_in">dfs</span>(p<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(last);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>将 1~n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p><p>设数字 n 是个 x 位数，记 n 的第 i 位为 $n_i$，则可将 n 写为 $n_{x} n_{x-1} \cdots n_{2} n_{1}$：</p><ul><li>称 “ $n_i$ “ 为 当前位 ，记为 cur ，</li><li>将 “ $n_{i-1} n_{i-2} \cdots n_{2} n_{1}$ “ 称为 低位 ，记为 low ；</li><li>将 “ $n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}$ “ 称为 高位 ，记为 high 。</li><li>将 $10^i$ 称为 位因子 ，记为 digit 。</li></ul><p><strong>某位中 1 出现次数的计算方法：</strong></p><p>根据当前位 cur 值的不同，分为以下三种情况：</p><ol><li><p>当 cur&#x3D;0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：<br>$$<br>high \times digit<br>$$<br>如下图所示，以 n&#x3D;2304 为例，求 digit&#x3D;10 （即十位）的 1 出现次数。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110721.png" style="zoom:67%;" /></li><li><p>当 cur &#x3D; 1 时：此位 1 的出现次数由高位 high 和低位 low 决定，计算公式为：<br>$$<br>high×digit+low+1<br>$$<br>如下图所示，以 n &#x3D; 2314 为例，求 digit &#x3D; 10 （即十位）的 1 出现次数。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105552.png" style="zoom:67%;" /></li><li><p>当 cur &#x3D; 2,3,…9 时：此位 1 的出现次数只由高位 high 决定，计算公式为：<br>$$<br>(high+1)×digit<br>$$<br>如下图所示，以 n &#x3D; 2324 为例，求 digit &#x3D; 10（即十位）的 1 出现次数。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105514.png" style="zoom:67%;" /></li></ol><p><strong>变量递推公式：</strong></p><p>设计按照 “个位、十位、…” 的顺序计算，则 high &#x2F; cur &#x2F; low &#x2F; digit 应初始化为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">high</span> = n / <span class="hljs-number">10</span><br><span class="hljs-attr">cur</span> = n % <span class="hljs-number">10</span><br><span class="hljs-attr">low</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">digit</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># 个位</span><br></code></pre></td></tr></table></figure><p>因此，从个位到最高位的变量递推公式为：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">while high !=<span class="hljs-number"> 0 </span>or cur != 0: <span class="hljs-comment"># 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span><br>   low += cur * digit <span class="hljs-comment"># 将 cur 加入 low ，组成下轮 low</span><br>   cur = high %<span class="hljs-number"> 10 </span><span class="hljs-comment"># 下轮 cur 是本轮 high 的最低位</span><br>   high /=<span class="hljs-number"> 10 </span><span class="hljs-comment"># 将本轮 high 最低位删除，得到下轮 high</span><br>   digit *=<span class="hljs-number"> 10 </span><span class="hljs-comment"># 位因子每轮 × 10</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> digit=<span class="hljs-number">1</span>,res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high=n/<span class="hljs-number">10</span>,cur=n%<span class="hljs-number">10</span>,low=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high!=<span class="hljs-number">0</span>||cur!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)<br>                res+=high*digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">1</span>)<br>                res+=high*digit+low+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                res+=(high+<span class="hljs-number">1</span>)*digit;<br>            low+=cur*digit;<br>            cur=high%<span class="hljs-number">10</span>;<br>            high/=<span class="hljs-number">10</span>;<br>            digit*=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logn) ： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 $\log_{10}{n}$，因此循环使用 O(logn) 时间。空</li><li>间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li></ul><h3 id="解法四：数学之美"><a href="#解法四：数学之美" class="headerlink" title="解法四：数学之美"></a>解法四：数学之美</h3><p>采用数学之美上面提出的方法，设定整数点（如 1、10、100 等等）作为位置点 i（对应 n 的各位、十位、百位等等），分别对每个数位上有多少包含 1 的点进行分析。</p><ul><li>根据设定的整数位置，对 n 进行分割，分为两部分，高位 n&#x2F;i ，低位 n%i ；</li><li>当 i 表示百位，且百位对应的数 &gt;&#x3D;2 ,如 n&#x3D;31456,i&#x3D;100 ，则 a&#x3D;314,b&#x3D;56 ，此时百位为 1 的次数有 a&#x2F;10+1&#x3D;32（最高两位 0~31），每一次都包含 100 个连续的点，即共有 (a&#x2F;10+1)*100 个点的百位为 1；</li><li>当 i 表示百位，且百位对应的数为 1，如 n&#x3D;31156,i&#x3D;100，则 a&#x3D;311,b&#x3D;56，此时百位对应的就是 1，则共有 a&#x2F;10 (最高两位 0-30 )次是包含 100 个连续点，当最高两位为 31（即a&#x3D;311），本次只对应局部点 00~56，共 b+1 次，所有点加起来共有（a&#x2F;10*100）+(b+1)，这些点百位对应为 1；</li><li>当 i 表示百位，且百位对应的数为 0,如 n&#x3D;31056,i&#x3D;100，则 a&#x3D;310,b&#x3D;56，此时百位为 1 的次数有 a&#x2F;10&#x3D;31（最高两位0~30）；</li><li>综合以上三种情况，当百位对应 0 或 &gt;&#x3D;2 时，有 (a+8)&#x2F;10 次包含所有 100 个点，还有当百位为 1(a%10&#x3D;&#x3D;1)，需要增加局部点 b+1；</li><li>之所以补 8，是因为当百位为 0，则 a&#x2F;10&#x3D;&#x3D;(a+8)&#x2F;10，当百位 &gt;&#x3D;2，补 8 会产生进位，效果等同于 (a&#x2F;10+1)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> ones=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i*=<span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> a=n/i,b=n%i;<br>            ones+=(a+<span class="hljs-number">8</span>)/<span class="hljs-number">10</span>*i+(a%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>)*(b+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><h2 id="题目链接-31"><a href="#题目链接-31" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321} ，则打印出这三个数字能排成的最小数字为 321323 。</p><h2 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：全排列"><a href="#解法一：全排列" class="headerlink" title="解法一：全排列"></a>解法一：全排列</h3><p>将数组进行全排列，再选取最小的为答案，时间复杂度为 O(N*N!)，全排列的时间复杂度为N！，每次排列结果需要遍历一次 nums 数组。</p><h3 id="解法二：贪心-自定义排序"><a href="#解法二：贪心-自定义排序" class="headerlink" title="解法二：贪心+自定义排序"></a>解法二：贪心+自定义排序</h3><ul><li><p>此题求拼接起来的“最小数字”，本质上是一个排序问题。</p></li><li><p>排序判断规则： 设 nums 任意两数字的字符串格式 x 和 y ，则</p><p>若拼接字符串 x+y&gt;y+x ，则应该把 y 排在前面；<br>反之，若 x+y&lt;y+x ，则应该把 x 排在前面；</p></li><li><p>根据以上规则，套用任何排序方法对 nums 执行排序即可。</p></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105416.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        vector&lt;string&gt; strs;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.<span class="hljs-built_in">size</span>();++i)<br>            strs.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(numbers[i]));<br>        <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(),strs.<span class="hljs-built_in">end</span>(),[](string&amp; s1,string&amp; s2)&#123;<span class="hljs-keyword">return</span> s1+s2&lt;s2+s1;&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();++i)<br>            res+=strs[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度 ≤N ) 。</li><li>空间复杂度 O(N)： 字符串列表 strs 占用线性大小的额外空间。</li></ul><h1 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h1><h2 id="题目链接-32"><a href="#题目链接-32" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p><h2 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h2><p>丑数的递推性质： 丑数只包含因子 2, 3, 5，因此有 “丑数 &#x3D; 某较小丑数 × 某因子” （例如：10 &#x3D; 5×2）。</p><p>设已知长度为 n 的丑数序列 $x_1, x_2, \cdots , x_n$，求第 n+1 个丑数 $x_{n+1}$ 。根据递推性质，丑数 $x_{n+1}$只可能是以下三种情况其中之一（索引 a, b, c 为未知数）<br>$$<br>x_{n+1}&#x3D;\left{\begin{array}{ll}x_{a} \times 2 &amp; , a \in[1, n] \ x_{b} \times 3 &amp; , b \in[1, n] \ x_{c} \times 5 &amp; , c \in[1, n]\end{array}\right.<br>$$<br>由于 $x_{n+1}$ 是 <strong>最接近</strong> $x_n$ 的丑数，因此索引 a, b, c 需满足以下条件：<br>$$<br>\left{\begin{array}{l}x_{a} \times 2&gt;x_{n} \geq x_{a-1} \times 2 \ x_{b} \times 3&gt;x_{n} \geq x_{b-1} \times 3 \ x_{c} \times 5&gt;x_{n} \geq x_{c-1} \times 5\end{array}\right.<br>$$<br>即 $x_a$ 为首个乘以 2 后大于 $x_n$ 的丑数，即 $x_b$ 为首个乘以 2 后大于 $x_n$ 的丑数，即 $x_c$ 为首个乘以 2 后大于 $x_n$ 的丑数。</p><p>若索引 a,b,c 满足以上条件，则可使用递推公式计算下个丑数 $x_{n+1}$ ，其为三种情况中的<strong>最小值</strong>，即：<br>$$<br>x_{n+1}&#x3D;\min \left(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5\right)<br>$$<br>因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105313.png" style="zoom:67%;" /><p><strong>动态规划解析：</strong></p><ul><li><p>状态定义： 设动态规划列表 dp ，dp[i] 代表第 i+1个丑数。</p></li><li><p>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a,b,c 加 1 。<br>$$<br>\left{\begin{array}{l}d p[a] \times 2&gt;d p[i-1] \geq d p[a-1] \times 2 \ d p[b] \times 3&gt;d p[i-1] \geq d p[b-1] \times 3 \ d p[c] \times 5&gt;d p[i-1] \geq d p[c-1] \times 5\end{array}\right.<br>$$</p><p>$$<br>d p[i]&#x3D;\min (d p[a] \times 2, d p[b] \times 3, d p[c] \times 5)<br>$$</p></li><li><p>初始状态： dp[0]&#x3D;1 ，即第一个丑数为 1 ；</p></li><li><p>返回值： dp[n-1] ，即返回第 n 个丑数。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;=<span class="hljs-number">6</span>)<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(index)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;index;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> next2=dp[a]*<span class="hljs-number">2</span>,next3=dp[b]*<span class="hljs-number">3</span>,next5=dp[c]*<span class="hljs-number">5</span>;<br>            dp[i]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(next2,next3),next5);<br>            <span class="hljs-keyword">if</span>(dp[i]==next2) <br>                a++;<br>            <span class="hljs-keyword">if</span>(dp[i]==next3)<br>                b++;<br>            <span class="hljs-keyword">if</span>(dp[i]==next5)<br>                c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N&#x3D;n ，动态规划需遍历计算 dp 列表。</li><li>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间</li></ul><h1 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h1><h2 id="题目链接-33"><a href="#题目链接-33" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&&tqId=11187&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串( 0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从 0 开始计数）</p><h2 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用-map"><a href="#解法一：使用-map" class="headerlink" title="解法一：使用 map"></a>解法一：使用 map</h3><p>建立一个 map ，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为 1，则返回这个字符的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>            mp[i]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp[str[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；Map 查找的操作复杂度为 O(1)；</li><li>空间复杂度 O(N)：Map 需存储 N 个字符的键值对，使用 O(N) 大小的额外空间。</li></ul><h3 id="解法二：用数组代替-map"><a href="#解法二：用数组代替-map" class="headerlink" title="解法二：用数组代替 map"></a>解法二：用数组代替 map</h3><p>需要统计的字符范围有限，所以考虑用有限数组代替 map ，将空间复杂度由 O(N) 降为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> mp[<span class="hljs-number">128</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>            mp[i]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp[str[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法三：使用-bitset"><a href="#解法三：使用-bitset" class="headerlink" title="解法三：使用 bitset"></a>解法三：使用 bitset</h3><p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p><p>具体过程：</p><ol><li>初始化：bitset&lt;128&gt; b1表示只出现 1 次， b2 表示出现 2 次以上 </li><li>遍历字符串，第一次出现，b1[ch] &#x3D; 1 ；</li><li>如果第二次出现，b2[ch] &#x3D; 1 ；</li><li>最后，找出第一个b1[ch] &#x3D;&#x3D; 1 &amp;&amp; b2[ch] &#x3D;&#x3D; 0 的字符。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        bitset&lt;128&gt; b1,b2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!b1[i]&amp;&amp;!b2[i])<br>                b1[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b1[i]&amp;&amp;!b2[i])<br>                b2[i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(b1[str[i]]&amp;&amp;!b2[str[i]])<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><h2 id="题目链接-34"><a href="#题目链接-34" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P。并将 P 对 1000000007 取模的结果输出。 即输出 P%1000000007。</p><p>输入描述:</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">题目保证输入的数组中没有的相同的数字数据范围：<br>对于%50的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">4</span><br>对于%75的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span><br>对于%100的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">2</span>*<span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>示例1</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<br><span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,0</span><br>输出：<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：归并排序思想"><a href="#解法一：归并排序思想" class="headerlink" title="解法一：归并排序思想"></a>解法一：归并排序思想</h3><p>利用归并排序来解决，在并入操作时记录<code>nums[L]&gt;nums[R]</code>的情况即可。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105128.png" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105054.png" style="zoom:67%;" /><p>在 merge 函数内部开辟额外空间的做法很不好。因为这样会涉及到频繁的构建 vector 和析构vector，所以比较好的做法是：直接在最外层开辟一个足够大的数组，然后传引用到函数。此外注意 res 的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">help</span><span class="hljs-params">(data.size())</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(data,help,<span class="hljs-number">0</span>,data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)%<span class="hljs-number">1000000007</span>;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp; help,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(nums,help,l,mid)+<span class="hljs-built_in">mergeSort</span>(nums,help,mid+<span class="hljs-number">1</span>,r)+<span class="hljs-built_in">merge</span>(nums,help,l,mid,r);<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp; help,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> p1=l;<br>        <span class="hljs-type">int</span> p2=m+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;=m&amp;&amp;p2&lt;=r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[p1]&gt;nums[p2])<br>            &#123;<br>                res+=m-p1+<span class="hljs-number">1</span>;<br>                help[i++]=nums[p2++];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                help[i++]=nums[p1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p1&lt;=m)<br>            help[i++]=nums[p1++];<br>        <span class="hljs-keyword">while</span>(p2&lt;=r)<br>            help[i++]=nums[p2++];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,p1=l;p1&lt;=r;)<br>            nums[p1++]=help[i++];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：同归并排序 O(nlogn)。</li><li>空间复杂度：同归并排序 O(n），因为归并排序需要用到一个临时数组。</li></ul><h3 id="解法二：离散化树状数组"><a href="#解法二：离散化树状数组" class="headerlink" title="解法二：离散化树状数组"></a>解法二：离散化树状数组</h3><p>见 Leetcode 题解，链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></p><h1 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h1><h2 id="题目链接-35"><a href="#题目链接-35" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104929.png" style="zoom: 67%;" /><h2 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：链表拼接"><a href="#解法一：链表拼接" class="headerlink" title="解法一：链表拼接"></a>解法一：链表拼接</h3><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b &#x3D; b + c + a。</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct ListNode *next;</span><br><span class="hljs-comment">ListNode(int x) :</span><br><span class="hljs-comment">val(x), next(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1||!pHead2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* l1=pHead1,*l2=pHead2;<br>        <span class="hljs-keyword">while</span>(l1!=l2)<br>        &#123;<br>            l1=(l1==<span class="hljs-literal">NULL</span>)?pHead2:l1-&gt;next;<br>            l2=(l2==<span class="hljs-literal">NULL</span>)?pHead1:l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(M+N)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="解法二：双指针-1"><a href="#解法二：双指针-1" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>如果链表相交，则链表公共节点都在尾部。</p><ol><li>先计算两个链表长度。</li><li>让长链表指针先走多出的长度，然后两个链表同时走，如果相遇则为相交节点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1||!pHead2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> len1=<span class="hljs-built_in">len</span>(pHead1),len2=<span class="hljs-built_in">len</span>(pHead2);<br>        <span class="hljs-keyword">if</span>(len1&gt;=len2)<br>        &#123;<br>            <span class="hljs-type">int</span> move=len1-len2;<br>            <span class="hljs-keyword">while</span>(move--)<br>                pHead1=pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> move=len2-len1;<br>            <span class="hljs-keyword">while</span>(move--)<br>                pHead2=pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(pHead1!=pHead2)<br>        &#123;<br>            pHead1=pHead1-&gt;next;<br>            pHead2=pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead1;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pHead!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ++len;<br>            pHead=pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n + m)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h1><h2 id="题目链接-36"><a href="#题目链接-36" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p></blockquote><p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的左&#x2F;右边界索引分别为 left 和 right，分别对应窗口左边&#x2F;右边的首个元素。</p><p>本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到左边界 left 和 右边界 right，易得数字 target 的数量为 right−left−1 。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104621.png" style="zoom:67%;" /><p><strong>算法解析：</strong></p><ol><li>初始化： 左边界 i&#x3D;0 ，右边界 j&#x3D;len(nums)-1 。</li><li>循环二分： 当闭区间 [i,j ] 无元素时跳出；<ol><li>计算中点 m&#x3D;(i+j)&#x2F;2 （向下取整）；</li><li>若 nums[m]&lt;target ，则 target 在闭区间 [m+1,j] 中，因此执行 i&#x3D;m+1；</li><li>若 nums[m]&gt;target ，则 target 在闭区间 [i,m-1] 中，因此执行 j&#x3D;m−1；</li><li>若 nums[m]&#x3D;target ，则右边界 right 在闭区间 [m+1,j] 中；左边界 left 在闭区间 [i,m-1] 中。因此分为以下两种情况：<br>若查找右边界 right ，则执行 i&#x3D;m+1 ；（跳出时 i 指向右边界）<br>若查找 左边界 left ，则执行 j&#x3D;m−1 ；（跳出时 j 指向左边界）</li></ol></li><li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right−left−1 即可。</li></ol><p><strong>效率优化：</strong></p><p>以下优化基于：查找完右边界 right&#x3D;i 后，则 nums[j] 指向最右边的 target（若存在）。</p><ol><li>查找完右边界后，可用 nums[j]&#x3D;j 判断数组中是否包含 target ，若不包含则直接提前返回 0 ，无需后续查找左边界。</li><li>查找完右边界后，左边界 left 一定在闭区间 [0,j] 中，因此直接从此区间开始二分查找即可。</li></ol><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104527.png" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104449.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data ,<span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m]&lt;=k)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> right=i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;data[j]!=k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 搜索左边界 left</span><br>        i=<span class="hljs-number">0</span>;j=data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m]&lt;k)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left=j;<br>        <span class="hljs-keyword">return</span> right-left<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data ,<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(data,k)-<span class="hljs-built_in">binarySearch</span>(data,k<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m]&lt;=target)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>本质上看， <code>binarySearch()</code> 函数旨在查找数字 target 在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。</p><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(log N)：二分法为对数级别复杂度。</li><li>空间复杂度 O(1)：几个变量使用常数大小的额外空间。</li></ul><h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><h2 id="题目链接-37"><a href="#题目链接-37" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104349.jpg" style="zoom:67%;" /><h2 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p><ul><li>常见的 DFS ： 先序遍历、中序遍历、后序遍历；</li><li>常见的 BFS ： 层序遍历（即按层遍历）。</li></ul></blockquote><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><blockquote><p>树的深度优先搜索往往利用 <strong>递归</strong> 或 <strong>栈</strong> 实现。</p></blockquote><p>树的深度等于左子树的深度与右子树的深度中的<strong>最大值+1</strong>。</p><p><strong>算法解析：</strong></p><ol><li>终止条件： 当 root 为空，说明已越过叶节点，因此返回深度 0 。</li><li>递推工作： 本质上是对树做后序遍历。<br>计算节点 root 的 左子树的深度 ；<br>计算节点 root 的 右子树的深度 ；</li><li>返回值： 返回此树的深度 。</li></ol><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104257.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">int val;</span><br><span class="hljs-comment">struct TreeNode *left;</span><br><span class="hljs-comment">struct TreeNode *right;</span><br><span class="hljs-comment">TreeNode(int x) :</span><br><span class="hljs-comment">val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> left&gt;right?left+<span class="hljs-number">1</span>:right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li><li>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li></ul><h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><blockquote><p>树的层序遍历 &#x2F; 广度优先搜索往往利用 <strong>队列</strong> 实现。</p></blockquote><p>关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</p><p><strong>算法解析：</strong></p><ol><li>特例处理： 当 root 为空，直接返回深度 0 。</li><li>初始化： 队列 queue （加入根节点 root ），深度 depth&#x3D; 0。</li><li>循环遍历： 当 queue 为空时跳出。<br>遍历队列： 弹出 queue 的第一个结点 ，如果该结点有左子节点或右子节点则加入 queue；<br>统计层数： 执行 depth+&#x3D; 1 ，代表层数加 1；</li><li>返回值： 返回 depth 即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* node=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li><li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 queue 同时存储 N&#x2F;2 个节点。</li></ul><h1 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h1><h2 id="题目链接-38"><a href="#题目链接-38" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树（平衡二叉树左右子树高度差不超过 1）。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104152.jpg" style="zoom:80%;" /><h2 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：先序遍历-判断深度-（从顶至底）"><a href="#解法一：先序遍历-判断深度-（从顶至底）" class="headerlink" title="解法一：先序遍历 + 判断深度 （从顶至底）"></a>解法一：先序遍历 + 判断深度 （从顶至底）</h3><p>思路是构造一个获取当前子树的深度的函数 depth(root) （即 38. 二叉树的深度 ），通过比较某子树的左右子树的深度差 abs(depth(root.left) - depth(root.right)) &lt;&#x3D; 1 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p><p><strong>算法流程：</strong><br><strong>isBalanced(root) 函数</strong>： 判断树 root 是否平衡</p><ul><li>特例处理： 若树根节点 root 为空，则直接返回 true ；</li><li>返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑 &amp;&amp; 连接：<br>abs(self.depth(root.left) - self.depth(root.right)) &lt;&#x3D; 1 ：判断 当前子树 是否是平衡树；<br>self.isBalanced(root.left) ：先序遍历递归，判断当前子树的左子树是否是平衡树；<br>self.isBalanced(root.right) ：先序遍历递归，判断当前子树的右子树是否是平衡；</li></ul><p><strong>depth(root) 函数</strong>：计算树 root 的深度</p><ul><li>终止条件： 当 root 为空，即越过叶子节点，则返回深度 0 ；</li><li>返回值： 返回左 &#x2F; 右子树的深度的最大值 +1 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;left)&amp;&amp;<span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(pRoot-&gt;left),<span class="hljs-built_in">depth</span>(pRoot-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(NlogN)： 最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历各子树的所有节点 。</li><li>空间复杂度 O(N)：最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li></ul><p>解法一首先判断根结点是不是平衡的，需要使用 depth 获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用 depth 获得子树的左右子树的深度，这样就导致了大量的重复遍历，时间复杂度较高。</p><h3 id="解法二：后序遍历-剪枝-（从底至顶）"><a href="#解法二：后序遍历-剪枝-（从底至顶）" class="headerlink" title="解法二：后序遍历 + 剪枝 （从底至顶）"></a>解法二：后序遍历 + 剪枝 （从底至顶）</h3><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p><h4 id="用负值表示不平衡，避免重复计算"><a href="#用负值表示不平衡，避免重复计算" class="headerlink" title="用负值表示不平衡，避免重复计算"></a>用负值表示不平衡，避免重复计算</h4><p><strong>算法流程：</strong><br><strong>depth(root) 函数：</strong></p><ul><li><p>返回值：</p><p>当节点 root 左 &#x2F; 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左&#x2F;右子树的深度最大值 +1（ max(left, right) + 1 ）；<br>当节点root 左 &#x2F; 右子树的深度差 &gt;2 ：则返回 -1 ，代表此子树不是平衡树 。</p></li><li><p>终止条件：<br>当 root 为空：说明越过叶节点，因此返回高度 0 ；<br>当左（右）子树深度为 −1 ：代表此树的 左（右）子树不是平衡树，因此剪枝，直接返回 −1；</p></li></ul><p><strong>isBalanced(root) 函数：</strong></p><ul><li>返回值： 若 depth(root) !&#x3D; -1 ，则说明此树平衡，返回 true； 否则返回 false 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(pRoot)!=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">-1</span>||right==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>?<span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="使用flag标记"><a href="#使用flag标记" class="headerlink" title="使用flag标记"></a>使用flag标记</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(pRoot);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>)<br>            flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li><li>空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li></ul><h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><h2 id="题目链接-39"><a href="#题目链接-39" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="解题思路：分组异或"><a href="#解题思路：分组异或" class="headerlink" title="解题思路：分组异或"></a>解题思路：分组异或</h2><p>先考虑一个比较简单的问题：</p><blockquote><p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p></blockquote><p>答案：全员进行异或操作。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。</p><p>扩展到找出<strong>两个</strong>出现一次的数字：</p><p>思路：把所有数字分成两组，使得：</p><ol><li>两个只出现一次的数字在不同的组中；</li><li>相同的数字会被分到相同的组中。</li></ol><p><strong>算法流程：</strong></p><ol><li>设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的两种数的异或结果，即 a^b，eor !&#x3D; 0。</li><li>eor 不为 0，其数值必然有一个位置上是1，提取 eor 最右的1，假设为第 n 位，则两个只出现一次的数字 a 和 b 在第 n 位不同。</li><li>将数组中的数与提取的结果相与，将数分为两类，即第 n 位为 1 的数和第 n 位不为 1 的数，a 和 b 不在同一类。</li><li>设置 eor’ （only）为 0 ，将两类中的一类与 eor’ 进行异或，最后的值即为其中一个出现了奇数次的数。</li><li>将 eor’ 和 eor 进行异或，则得到另一个出现了奇数次的数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data,<span class="hljs-type">int</span>* num1,<span class="hljs-type">int</span> *num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            eor^=data[i];<br>        &#125;<br>        <span class="hljs-comment">// eor = num1 ^ num2</span><br><span class="hljs-comment">// eor != 0</span><br><span class="hljs-comment">// eor必然有一个位置上是1</span><br>        <span class="hljs-type">int</span> rightone = eor &amp; (~eor+<span class="hljs-number">1</span>);<span class="hljs-comment">// 提取出最右的1</span><br>        <span class="hljs-type">int</span> only=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((rightone&amp;data[i])== <span class="hljs-number">0</span>)<br>            &#123;<br>                only^=data[i];<br>            &#125;<br>        &#125;<br>        *num1=only;<br>        *num2=only^eor;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，只需要遍历数组两次。</li><li>空间复杂度：O(1)，只需要常数的空间存放若干变量。</li></ul><h1 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41.和为 S 的连续正数序列"></a>41.和为 S 的连续正数序列</h1><h2 id="题目链接-40"><a href="#题目链接-40" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100 (至少包括两个数)。没多久,他就得到另一组连续正数和为 100 的序列: 18,19,20,21,22 。现在把问题交给你,你能不能也很快的找出所有和为 S 的连续正数序列? Good Luck!</p><p><strong>输出描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br></code></pre></td></tr></table></figure><h2 id="解题思路：双指针滑动窗口"><a href="#解题思路：双指针滑动窗口" class="headerlink" title="解题思路：双指针滑动窗口"></a>解题思路：双指针滑动窗口</h2><p>用两个指针 l 和 r 表示当前枚举到的以 l 为起点到 r 的区间，sum 表示 [l,r] 的区间和，由于 [l,r] 是连续的，所以直接使用求和公式：<code>(l+r)*(r-l+1)/2</code> ，起始 l&#x3D;1,r&#x3D;2 。</p><p>一共有三种情况：</p><ul><li>如果 sum&lt;target 则说明指针 r 还可以向右拓展使得 sum 增大，此时指针 r 向右移动，即 r+&#x3D;1；</li><li>如果 sum&gt;target 则说明以 l 为起点不存在一个 r 使得 sum&#x3D;target ，此时要枚举下一个起点，指针 l 向右移动，即 l+&#x3D;1；</li><li>如果 sum&#x3D;&#x3D;target 则说明找到了以 l 为起点的合法解 [l,r] ，需要将 [l,r] 的序列放进答案数组，且以 l 为起点的合法解最多只有一个，所以需要枚举下一个起点，指针 l 向右移动，即 l+&#x3D;1。</li></ul><p>终止条件即为 l&gt;&#x3D;r 的时候，这种情况的发生指针 r 移动到了$\lfloor\frac{\textit{target}}{2}\rfloor+1$ 的位置，导致 l&lt;r 的时候区间和始终大于 target。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> curSum=(left+right)*(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(curSum==sum)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;=right;++i)<br>                    tmp.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curSum&lt;sum)<br>                right++;<br>            <span class="hljs-keyword">else</span> <br>                left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：由于两个指针移动均单调不减，且最多移动 $\lfloor\frac{\textit{target}}{2}\rfloor$次，即枚举的上界，所以时间复杂度为 O(target) 。</li><li>空间复杂度：O(1) ，除了答案数组只需要常数的空间存放若干变量。</li></ul><h1 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42.和为 S 的两个数字"></a>42.和为 S 的两个数字</h1><h2 id="题目链接-41"><a href="#题目链接-41" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><p><strong>输出描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对应每个测试案例，输出两个数，小的先输出。<br></code></pre></td></tr></table></figure><h2 id="解题思路：双指针"><a href="#解题思路：双指针" class="headerlink" title="解题思路：双指针"></a>解题思路：双指针</h2><p>利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N)；本题的 nums 是 <strong>排序数组</strong> ，因此可使用 <strong>双指针法</strong> 将空间复杂度降低至 O(1) 。</p><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum &#x3D;&#x3D; target，那么得到要求的结果；</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><p>这么做的好处是，也保证了乘积最小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array,<span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> cur=array[i]+array[j];<br>            <span class="hljs-keyword">if</span>(cur==sum)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(array[i]);<br>                res.<span class="hljs-built_in">push_back</span>(array[j]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur&lt;sum)<br>                i++;<br>            <span class="hljs-keyword">else</span><br>                j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为数组 nums 的长度；双指针共同线性遍历整个数组。</li><li>空间复杂度 O(1) ： 变量 i , j 使用常数大小的额外空间。</li></ul><h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><h2 id="题目链接-42"><a href="#题目链接-42" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S&#x3D;”abcXYZdef”,要求输出循环左移 3 位后的结果，即 “XYZdefabc”。是不是很简单？OK，搞定它！</p><h2 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：字符串切片"><a href="#解法一：字符串切片" class="headerlink" title="解法一：字符串切片"></a>解法一：字符串切片</h3><p>分割两个部分字符串，后面拼接前面。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104034.png" style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=str.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> str;<br>        <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(str.begin()+n,str.end())</span></span>;<br>        <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str.begin(),str.begin()+n)</span></span>;<br>        <span class="hljs-keyword">return</span> s1+s2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li><li>空间复杂度 O(N)： 两个字符串切片的总长度为 N 。</li></ul><h3 id="解法二：三次翻转"><a href="#解法二：三次翻转" class="headerlink" title="解法二：三次翻转"></a>解法二：三次翻转</h3><p>先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=str.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> str;<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(str,n,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(begin&lt;end)<br>            <span class="hljs-built_in">swap</span>(str[begin++],str[end--]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li><li>空间复杂度 O(1)： 原地翻转，无需额外的空间 。</li></ul><h1 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h1><h2 id="题目链接-43"><a href="#题目链接-43" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h2 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h2><p>先旋转每个单词，再旋转整个字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j==len||str[j]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">reverse</span>(str,i,j<span class="hljs-number">-1</span>);<br>                i=j+<span class="hljs-number">1</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(begin&lt;end)<br>            <span class="hljs-built_in">swap</span>(str[begin++],str[end--]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li><li>空间复杂度 O(1)： 原地翻转，无需额外的空间 。</li></ul><h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><h2 id="题目链接-44"><a href="#题目链接-44" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL 今天心情特别好,因为他去买了一副扑克牌,发现里面居然有 2 个大王, 2 个小王(一副牌原本是 54 张^_^)…他随机从中抽出了 5 张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心 A,黑桃 3,小王,大王,方片 5”,“Oh My God!”不是顺子…..LL 不高兴了,他想了想,决定大\小王可以看成任何数字,并且 A 看作 1,J 为 11,Q 为 12,K 为 13。上面的 5 张牌就可以变成“1,2,3,4,5”(大小王分别看作 2 和 4 ),“So Lucky!”。LL 决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们 LL 的运气如何， 如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见,你可以认为大小王是 0。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103918.png" style="zoom:80%;" /><h2 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，此 5 张牌是顺子的充分条件如下：</p><ol><li>除大小王外，所有牌无重复 ；</li><li>设此 5 张牌中最大的牌为 max，最小的牌为 min （大小王除外），则需满足：max−min&lt;5。</li></ol><p>因而，可将问题转化为：此 5 张牌是否满足以上两个条件？</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103829.png" style="zoom: 33%;" /><h3 id="解法一：集合-set-遍历"><a href="#解法一：集合-set-遍历" class="headerlink" title="解法一：集合 set +遍历"></a>解法一：集合 set +遍历</h3><ol><li>遍历五张牌，遇到大小王（即 0 ）直接跳过。</li><li>判别重复： 利用 unordered_set 实现遍历判重， unordered_set 的查找方法的时间复杂度为 O(1) ；</li><li>获取最大 &#x2F; 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; repeat;<br>        <span class="hljs-type">int</span> ma=INT_MIN,mi=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:numbers)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            ma=<span class="hljs-built_in">max</span>(num,ma);<br>            mi=<span class="hljs-built_in">min</span>(num,mi);<br>            <span class="hljs-keyword">if</span>(repeat.<span class="hljs-built_in">count</span>(num))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            repeat.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ma-mi&lt;<span class="hljs-number">5</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)&#x3D;O(5)&#x3D;O(1) ： 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</li><li>空间复杂度 O(N)&#x3D;O(5)&#x3D;O(1) ： 用于判重的辅助 set 使用 O(N) 额外空间。</li></ul><h3 id="解法二：排序-遍历"><a href="#解法二：排序-遍历" class="headerlink" title="解法二：排序 + 遍历"></a>解法二：排序 + 遍历</h3><ol><li>先对数组执行排序。</li><li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i]&#x3D;nums[i+1] 是否成立来判重。</li><li>获取最大 &#x2F; 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> joker=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(),numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]==<span class="hljs-number">0</span>)<br>                joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[i]==numbers[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">4</span>]-numbers[joker]&lt;<span class="hljs-number">5</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(NlogN)&#x3D;O(5log5)&#x3D;O(1) ： 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用 O(NlogN) 时间。</li><li>空间复杂度 O(1)： 变量 joker 使用 O(1) 大小的额外空间。</li></ul><h1 id="46-孩子们的游戏（圆圈中最后剩下的数）"><a href="#46-孩子们的游戏（圆圈中最后剩下的数）" class="headerlink" title="46.孩子们的游戏（圆圈中最后剩下的数）"></a>46.孩子们的游戏（圆圈中最后剩下的数）</h1><h2 id="题目链接-45"><a href="#题目链接-45" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF 作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数 m,让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续 0…m-1 报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 n-1)。</p><p>如果没有小朋友，请返回 -1。</p><h2 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h2><p>一篇比较好的约瑟夫环讲解文章：<a href="https://blog.csdn.net/u011500062/article/details/72855826">https://blog.csdn.net/u011500062/article/details/72855826</a></p><h3 id="解法一：递归-3"><a href="#解法一：递归-3" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 特殊输入的处理</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">LastRemaining_Solution</span>(n<span class="hljs-number">-1</span>,m)+m)%n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)，需要求解的函数值有 n 个。</li><li>空间复杂度：O(n)，函数的递归深度为 n，需要使用 O(n) 的栈空间。</li></ul><h3 id="解法二：迭代-2"><a href="#解法二：迭代-2" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>可以改写为迭代，避免递归使用栈空间。</p><p>最终剩下一个人时的安全位置肯定为 0，反推安全位置在人数为 n 时的编号：<br>人数为1： 0<br>人数为2： (0+m) % 2<br>人数为3： ((0+m) % 2 + m) % 3<br>人数为4： (((0+m) % 2 + m) % 3 + m) % 4<br>……..<br>迭代推理到 n 就可以得出答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            res=(res+m)%i;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：O(n)，需要求解的函数值有 n 个。</li><li>空间复杂度：O(1)，只使用常数个变量。</li></ul><h1 id="47-求-1-2-3-…-n"><a href="#47-求-1-2-3-…-n" class="headerlink" title="47.求 1+2+3+…+n"></a>47.求 1+2+3+…+n</h1><h2 id="题目链接-46"><a href="#题目链接-46" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p><h2 id="解题思路：递归"><a href="#解题思路：递归" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>本题在简单问题上做了许多限制，可使用排除法一步步导向答案。1+2+…+(n−1)+n 的计算方法主要有三种：平均计算、迭代、递归。</p><p><strong>方法一：</strong> 平均计算<br><strong>问题：</strong> 此计算必须使用 <strong>乘除法</strong> ，因此本方法不可取，直接排除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二：</strong> 迭代<br><strong>问题：</strong> 循环必须使用 while 或 for ，因此本方法不可取，直接排除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        res += i;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法三：</strong> 递归<br>问题： 终止条件需要使用 if ，因此本方法不可取。<br>思考： 除了 if 和 switch 等判断语句外，是否有其他方法可用来终止递归？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    n += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逻辑运算符的短路效应：</strong></p><p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 ∣∣”，“非 !”；而其有重要的短路效应，如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(A &amp;&amp; B)</span></span>  <span class="hljs-comment">// 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(A || B)</span></span> <span class="hljs-comment">// 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span><br></code></pre></td></tr></table></figure><p>本题需要实现 “当 n &#x3D; 1 时终止递归”的需求，可通过短路效应实现。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">n</span>+=sumNums(<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) // 当 <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span> 时 <span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span> 不成立 ，此时 “短路” ，终止后续递归<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        n&gt;<span class="hljs-number">1</span>&amp;&amp;(n+=<span class="hljs-built_in">Sum_Solution</span>(n<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(n) ： 计算 n+(n−1)+…+2+1 需要开启 n 个递归函数。</li><li>空间复杂度 O(n) ： 递归深度达到 n ，系统使用 O(n) 大小的额外空间。</li></ul><h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><h2 id="题目链接-47"><a href="#题目链接-47" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、&#x2F;四则运算符号。</p><h2 id="解题思路：位运算"><a href="#解题思路：位运算" class="headerlink" title="解题思路：位运算"></a>解题思路：位运算</h2><p>三步走的方式计算二进制值相加： 5-101，7-111</p><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p><p>第三步：重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。</p><p>继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。</p><p><strong>算法流程：</strong></p><ul><li>（和 s ）&#x3D;（非进位和 n ）+（进位 c ）。即可将 s&#x3D;a+b 转化为：s&#x3D;a+b⇒s&#x3D;n+c。</li><li>循环求 n 和 c ，直至进位 c &#x3D; 0；此时 s&#x3D;n ，返回 n 即可。</li></ul><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(num2==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(num1^num2,(num1&amp;num2)&lt;&lt;<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 当进位为 0 时跳出</span><br>        <span class="hljs-keyword">while</span>(num2!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> c=(num1&amp;num2)&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-comment">//c = 进位</span><br>            num1^=num2; <span class="hljs-comment">//num1 = 非进位和</span><br>            num2=c; <span class="hljs-comment">//num2 = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> num1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1)： 最差情况下（例如 a&#x3D;0x7fffffff , b&#x3D;1 时），需循环 31 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。</li><li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li></ul><h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><h2 id="题目链接-48"><a href="#题目链接-48" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。</p><p><strong>输入描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输入一个字符串,包括数字字母符号,可以为空。<br></code></pre></td></tr></table></figure><p><strong>输出描述:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果是合法的数值表达则返回该数字，否则返回0。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">Input：<br>+<span class="hljs-number">2147483647</span><br><span class="hljs-number">1</span>a33<br><br>Output：<br><span class="hljs-number">2147483647</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，有以下四种字符需要考虑：</p><ol><li>首部空格： 删除之即可；</li><li>符号位： 三种情况，即 ‘’+’’ , ‘’−’’ , ‘’无符号” ；新建一个变量保存符号位，返回前判断正负即可。</li><li>非数字字符： 遇到首个非数字的字符时，应立即返回 0。</li><li>数字字符：<ul><li>字符转数字：“此数字的 ASCII 码” 与 “ 0 的 ASCII 码” 相减即可；</li><li>数字拼接： 若从左向右遍历数字，设当前位字符为 c ，当前位数字为 x ，数字结果为 res ，则数字拼接公式为：</li></ul></li></ol><p>$$<br>res &#x3D; 10 \times res + x \ x &#x3D; ascii(c) - ascii(‘0’)<br>$$</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103637.png"  style="zoom:67%;" /><p><strong>数字越界处理：</strong></p><p>题目要求返回的数值范围应在 [−2^31 ,2^31 −1] ，因此需要考虑数字越界问题。而由于题目指出 环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p><p>在每轮数字拼接前，判断 res 在此轮拼接后是否超过 2147483647 ，若超过则加上符号位直接返回。<br>设数字拼接边界 bndry&#x3D;2147483647 &#x2F; 10&#x3D;214748364 ，则以下两种情况越界：<br>$$<br>\left{\begin{array}{l}r e s&gt;b n d r y \ r e s&#x3D;b n d r y, x&gt;7\end{array}\right.<br>$$</p><ul><li>情况一：执行拼接 10×res≥2147483650 越界</li><li>情况二：拼接后是 2147483648 或 2147483649 越界</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103627.png"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,bndry=INT_MAX/<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(str[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;i&lt;str.<span class="hljs-built_in">size</span>())<br>            i++;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            sign=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span>||str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            i++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;str.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[j]&lt;<span class="hljs-string">&#x27;0&#x27;</span>||str[j]&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(res&gt;bndry||res==bndry&amp;&amp;str[j]&gt;<span class="hljs-string">&#x27;7&#x27;</span>)<br>                <span class="hljs-keyword">return</span> sign==<span class="hljs-number">1</span>?INT_MAX:INT_MIN;<br>            res=res*<span class="hljs-number">10</span>+(str[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign*res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。</li><li>空间复杂度 O(N) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间</li></ul><h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><h2 id="题目链接-49"><a href="#题目链接-49" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2 。</p><h2 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：哈希-遍历"><a href="#解法一：哈希-遍历" class="headerlink" title="解法一：哈希+遍历"></a>解法一：哈希+遍历</h3><p>直接想到的方法是遍历数组，并使用 HashMap 统计每个数字的数量，遇到数量大于 1 的数字则返回。此方法时间复杂度和空间复杂度均为 O(N) 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Parameters:</span><br>    <span class="hljs-comment">//        numbers:     an array of integers</span><br>    <span class="hljs-comment">//        length:      the length of array numbers</span><br>    <span class="hljs-comment">//        duplication: (Output) the duplicated number in the array number</span><br>    <span class="hljs-comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span><br>    <span class="hljs-comment">//                     otherwise false</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> numbers[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span>* duplication)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">NULL</span> || length &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; repeat;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(repeat.<span class="hljs-built_in">count</span>(numbers[i]))<br>            &#123;<br>                *duplication=numbers[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                repeat.<span class="hljs-built_in">insert</span>(numbers[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂性分析：</strong></p><ul><li>时间复杂度：O(n)。遍历数组一遍。使用哈希集合，添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。</li><li>空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。</li></ul><h3 id="解法二：原地交换"><a href="#解法二：原地交换" class="headerlink" title="解法二：原地交换"></a>解法二：原地交换</h3><p>题目指出在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 因此，可遍历数组并通过交换操作使元素的索引与值 一一对应（即 nums[i] &#x3D; i ）。因而，就能通过索引找到对应的值。</p><p>遍历中，当第二次遇到数字 x 时，一定有 nums[x] &#x3D; x （因为第一次遇到 x 时已经将其交换至 nums[x] 处了）。利用以上方法，即可得到一组重复数字。</p><p><strong>算法流程：</strong></p><ul><li>遍历数组 nums ，设索引初始值为 i&#x3D;0:<ol><li>若 nums[i] &#x3D;&#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此执行 i +&#x3D; 1 与 continue ；</li><li>若 nums[nums[i]] &#x3D;&#x3D; nums[i] ： 说明索引 nums[i] 处的元素值也为 nums[i]，即找到一组相同值，返回此值 nums[i]；</li><li>否则： 当前数字是第一次遇到，因此交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</li></ol></li><li>若遍历完毕尚未返回，则返回 false ，代表数组中无相同值。</li></ul><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103608.gif"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> numbers[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span>* duplication)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">NULL</span> || length &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]==i)<br>            &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(numbers[i]==numbers[numbers[i]])<br>            &#123;<br>                *duplication=numbers[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(numbers[i],numbers[numbers[i]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</li><li>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</li></ul><h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><h2 id="题目链接-50"><a href="#题目链接-50" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 A[0, 1,…, n-1] ,请构建一个数组 B[0,1,…,n-1] ,其中 B 中的元素 B[i]&#x3D;A[0] * A[1]*…<em>A[i-1] * A[i+1]</em>…*A[n-1]。不能使用除法（注意：规定B[0] &#x3D; A[1] * A[2] * … * A[n-1]，B[n-1] &#x3D; A[0] * A[1] * … * A[n-2]）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103555.png"  style="zoom: 80%;" /><h2 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h2><p>观察公式发现，B[i] 公式中没有 A[i] 项，也就是说如果可以使用除法，就可以用公式B[i]&#x3D;A[0] * A[1]*…..*A[n-1]&#x2F;A[i] 来计算 B[i]，但是题目要求不能使用。</p><p>根据题目对 B[i] 的定义可列表格，如下图所示。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103545.png"  style="zoom:67%;" /><p>根据表格的主对角线（全为 1 ），可将表格分为上三角和下三角 两部分。分别迭代计算下三角和上三角两部分的乘积，即可不使用除法就获得结果。即把 B[i]&#x3D;A[0]* A[1]<em>….. * A[i-1]</em> A[i+1]<em>…..<em>A[n-1]。看成A[0]</em> A[1]</em>….. * A[i-1]和 A[i+1]* …..A[n-2]*A[n-1]两部分的乘积。</p><p><strong>算法流程：</strong></p><ol><li>初始化：数组 B ，其中 B[0] &#x3D; 1 ；辅助变量 tmp&#x3D;1 ；</li><li>计算 B[i] 的下三角各元素的乘积，直接乘入B[i]，即B[i]&#x3D;B[i-1]*A[i-1] ；</li><li>计算 B[i] 的上三角各元素的乘积，记为 tmp ，并乘入 B[i] ，即 B[i]&#x3D;B[i+1]*A[i+1]；</li><li>返回 B 。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">B</span><span class="hljs-params">(length)</span></span>;<br>        <span class="hljs-keyword">if</span>(length==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> B;<br>        B[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;length;++i)<br>            B[i]=B[i<span class="hljs-number">-1</span>]*A[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            tmp*=A[i+<span class="hljs-number">1</span>];<br>            B[i]*=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> B;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为数组长度，两轮遍历数组 a ，使用 O(N) 时间。</li><li>空间复杂度 O(1)： 变量 tmp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。</li></ul><h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><h2 id="题目链接-51"><a href="#题目链接-51" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括 ‘ . ‘ 和 ‘ * ‘ 的正则表达式。模式中的字符 ‘ . ‘ 表示任意一个字符，而 ‘ * ‘ 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p><h2 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设主串为 A，模式串为 B 。从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、* 和 .（点），那针对这三种情况讨论即可，如下：</p><ol><li>如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m−1]，相等则看 A{0..m-2} 与 B {0..m−2}，不等则是不能匹配，这就是子问题。</li><li>如果 B 的最后一个字符是‘ . ’，它能匹配任意字符，直接看 A{0..n-2}与 B{0..m-2}</li><li>如果 B 的最后一个字符是 ‘ * ’，它代表 B[m−2]&#x3D;c 可以重复 0 次或多次，它们是一个整体 c∗<ul><li>情况一：A[n−1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A{0..n-1} 和 B{0..m-3} 是否匹配；</li><li>情况二：A[n-1] 是多个 c 中的最后一个（这种情况必须 A[n-1]&#x3D;c 或者 c&#x3D;’ . ‘ ），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A{0..n-2} 和 B{0..m-1} 是否匹配。</li></ul></li></ol><p><strong>转移方程：</strong></p><p>f [i] [j] 代表 A 的前 i 个和 B 的前 j 个能否匹配：</p><ul><li>对于前面两个情况，可以合并成一种情况 f [i] [j] &#x3D; f [i-1] [j-1]；</li><li>对于第三种情况，对于 c∗ 分为看和不看两种情况：<ul><li>不看：直接砍掉正则串的后面两个， f [i] [j] &#x3D; f [i] [j-2]；</li><li>看：正则串不动，主串前移一个，f [i] [j] &#x3D; f [i-1] [j]。</li></ul></li></ul><p><strong>初始条件：</strong></p><p>特判：需要考虑空串空正则</p><ul><li>空串和空正则是匹配的，f [0] [0] &#x3D; true；</li><li>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如 A&#x3D; ‘’ ‘’, B&#x3D;a∗b∗c∗）；</li><li>非空串和空正则必不匹配，f [1] [0]&#x3D;…&#x3D;f [n] [0]&#x3D; false；</li><li>非空串和非空正则，那肯定是需要计算的了。</li></ul><p>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。</p><p><strong>结果：</strong></p><p>开数组要开 n+1，这样对于空串的处理十分方便。结果就是 f [n] [m]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>* pattern)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(str);<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">strlen</span>(pattern);<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">f</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;++j)<br>            &#123;<br>                <span class="hljs-comment">//分成空正则和非空正则两种</span><br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    f[i][j]=(i==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//非空正则分为两种情况 * 和 非*</span><br>                    <span class="hljs-keyword">if</span>(pattern[j<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(str[i<span class="hljs-number">-1</span>]==pattern[j<span class="hljs-number">-1</span>]||pattern[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                            f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">//碰到 * 了，分为看和不看两种情况</span><br>                        <span class="hljs-comment">//不看，重复 0 次</span><br>                        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">2</span>)<br>                            f[i][j]=f[i][j<span class="hljs-number">-2</span>];<br>                        <span class="hljs-comment">//看，重复 1 次或者多次</span><br>                        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;j&gt;=<span class="hljs-number">2</span>&amp;&amp;(str[i<span class="hljs-number">-1</span>]==pattern[j<span class="hljs-number">-2</span>]||pattern[j<span class="hljs-number">-2</span>]==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                            <span class="hljs-comment">//这里要用 || 连接， 不然重复 0 次的会直接覆盖</span><br>                            f[i][j]=f[i][j<span class="hljs-number">-2</span>]||f[i<span class="hljs-number">-1</span>][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：递归-2"><a href="#解法二：递归-2" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p>递归三部曲为：</p><ol><li>递归函数功能：match(s, p) -&gt; bool , 表示 p 是否可以匹配 s；</li><li>递归终止条件：<ul><li>如果 s 和 p 同时为空，表明正确匹配 ；</li><li>如果 s 不为空，p 为空，表明，不能正确匹配； </li><li>如果 s 为空，p 不为空，需要计算，不能直接给出结果 。</li></ul></li><li>下一步递归：<ul><li>对于前面讨论的情况 1，2 进行合并，如果 *s &#x3D;&#x3D; *p || *p &#x3D;&#x3D; ‘ . ‘,则 match(s+1, p+1)；</li><li>对于情况 3，如果重复一次或者多次，则 match(s+1,p),如果重复 0 次，则 match(s, p+2)。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>* pattern)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果 s 和 p 同时为空</span><br>        <span class="hljs-keyword">if</span>(*str==<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;*pattern==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果 s不为空， 但是 p 为空</span><br>        <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;*pattern==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果pattern下一个字符没有 &#x27;*&#x27;</span><br>        <span class="hljs-keyword">if</span>(*(pattern+<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;(*str==*pattern||*pattern==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">match</span>(str+<span class="hljs-number">1</span>,pattern+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果有 &#x27;*&#x27;</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">bool</span> ret=<span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 重复 1 次或多次</span><br>            <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;(*str==*pattern||*pattern==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                ret=<span class="hljs-built_in">match</span>(str+<span class="hljs-number">1</span>,pattern);<br>            <span class="hljs-comment">// 重复 0 次</span><br>            <span class="hljs-keyword">return</span> ret||<span class="hljs-built_in">match</span>(str,pattern+<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><h2 id="题目链接-52"><a href="#题目链接-52" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&&tqId=11206&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”,”5e2”,”-123”,”3.1416”和”-1E-16” 都表示数值。 但是 “12e”,”1a3.14”,”1.2.3”,”+-5” 和 “12e+4.3” 都不是。</p><h2 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h2><p>启用 3 个标记，分别是 +&#x2F;- 标记，. 标记，e&#x2F;E 标记，标记它们是否多次访问。</p><ul><li>+&#x2F;-<ul><li>第一次出现 不在开头，也不再 e&#x2F;E 后面 就返回 false；</li><li>后续出现次数，不在 e&#x2F;E 后面 也返回 false。</li></ul></li><li>e&#x2F;E<ul><li>到末尾了，直接返回 false；</li><li>存在多个，直接返回 false；</li></ul></li><li>.<ul><li>. 多次出现或者出现在 e&#x2F;E 后面，直接返回 false。</li></ul></li><li>不是数字<ul><li>直接返回 false。</li></ul></li><li>其他<ul><li>返回 true。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(<span class="hljs-type">char</span>* string)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">bool</span> sign=<span class="hljs-literal">false</span>,decimal=<span class="hljs-literal">false</span>,hasE=<span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(string);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27;</span><br>            <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;+&#x27;</span>||string[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27; 第一次出现 不在开头，也不在e/E后面</span><br>                <span class="hljs-keyword">if</span>(!sign&amp;&amp;i!=<span class="hljs-number">0</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27; 其他出现次数 不在e/E后面</span><br>                <span class="hljs-keyword">if</span>(sign&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                sign=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;e&#x27;</span>||string[i]==<span class="hljs-string">&#x27;E&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// 后面没有数字</span><br>                <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==len)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(hasE)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                hasE=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-comment">// &#x27;.&#x27;</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(decimal||hasE)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                decimal=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>||string[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><h2 id="题目链接-53"><a href="#题目链接-53" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p><strong>输出描述:</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">如果当前字符流没有存在出现一次的字符，返回<span class="hljs-meta">#字符。</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h2><p>将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在 string 中，然后再遍历 string ，从哈希表中找到第一个出现一次的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span><br><span class="hljs-function">    </span>&#123;<br>        s+=ch;<br>        count[ch]++;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(count[s[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> s[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    string s;<br>    <span class="hljs-type">int</span> count[<span class="hljs-number">256</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h1><h2 id="题目链接-54"><a href="#题目链接-54" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。</p><h2 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h3><ol><li>遍历单链表的每个结点；</li><li>如果当前结点地址没有出现在 set 中，则存入 set 中；</li><li>否则，出现在 set 中，则当前结点就是环的入口结点；</li><li>整个单链表遍历完，若没出现在 set 中，则不存在环。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(pHead)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(pHead)==<span class="hljs-number">0</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">insert</span>(pHead);<br>                pHead=pHead-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(n)，最坏情况下，单链表的所有结点都在存入 set。</li></ul><h3 id="解法二：双指针-2"><a href="#解法二：双指针-2" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>使用双指针，一个快指针 fast 每次移动两个节点，一个慢指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。</p><p>假设环入口节点为 y1，相遇所在节点为 z1。</p><p>假设快指针 fast 在圈内绕了 N 圈，则总路径长度为 x+Ny+(N-1)z。z 为 (N-1) 倍是因为快慢指针最后已经在 z1 节点相遇了，后面就不需要再走了。而慢指针 slow 总路径长度为 x+y。因为快指针是慢指针的两倍，因此 x+Ny+(N-1)z &#x3D; 2(x+y)。我们要找的是环入口节点 y1，也可以看成寻找长度 x 的值，因此我们先将上面的等值分解为和 x 有关：x&#x3D;(N-2)y+(N-1)z。</p><p>上面的等值没有很强的规律，但是我们可以发现 y+z 就是圆环的总长度，因此我们将上面的等式再分解：x&#x3D;(N-2)(y+z)+z。这个等式左边是从起点x1 到环入口节点 y1 的长度，而右边是在圆环中走过 (N-2) 圈，再从相遇点 z1 再走过长度为 z 的长度。此时我们可以发现如果让两个指针同时从起点 x1 和相遇点 z1 开始，每次只走过一个距离，那么最后他们会在环入口节点相遇。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103453.png"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">nullptr</span>||pHead-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* slow=pHead;<br>        ListNode* fast=pHead;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(slow!=fast);<br>        fast=pHead;<br>        <span class="hljs-keyword">while</span>(slow!=fast)<br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：O(1)。</li></ul><h1 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h1><h2 id="题目链接-55"><a href="#题目链接-55" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p><h2 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>为了防止删除头结点的极端情况发生，先创建空结点 dummy，使 dummy 指向传入的 head 结点；</li><li>创建cur的指针，指向链表的头部（即dummy）；</li><li>对cur指针迭代，因为要对比 cur ( cur 最初始的定义指向空结点)指针的下一个结点与下下一个结点的值是否相等，为了防止产生空指针异常，故退出迭代的条件为：cur.next !&#x3D; null &amp;&amp; cur.next.next !&#x3D; null；</li><li>在迭代过程中，如果 cur.next.val &#x3D;&#x3D; cur.next.next.val 说明此时有重复元素，此时创建一个临时指针 tmp，指向 cur 的下一个节点，即 tmp 指向第一个重复元素所在的位置。通过 while 循环去重，去重后，tmp 指向重复元素中的最后一个位置。最后 cur.next &#x3D; temp.next 就实现了消除重复元素。</li><li>如果未发现重复元素，则直接向后迭代即可。</li><li>迭代完成后，返回 dummy 的 next。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=pHead;<br>        ListNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)<br>            &#123;<br>                ListNode* tmp=cur-&gt;next;<br>                <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;val==tmp-&gt;next-&gt;val)<br>                    tmp=tmp-&gt;next;<br>                cur-&gt;next=tmp-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h1><h2 id="题目链接-56"><a href="#题目链接-56" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103413.png"></p><p>以上图为例，二叉树的中序遍历是 d,b,h,e,i,a,f,c,g。以这棵树为例来分析如何找出二叉树的下一个结点。</p><p>如果一个结点有右子树，那么它的下一个结点就是它的右子树的最左子结点。也就是说从右子结点出发一直沿着指向左子树结点的指针，就能找到它的下一个结点。例如，图中结点 b 的下一个结点是 h，结点 a 的下一个结点是 f。</p><p>接着分析一下结点没有右子树的情形。如果结点是它父结点的左子结点，那么它的下一个结点就是它的父结点。例如，途中结点 d 的下一个结点是 b，f 的下一个结点是 c。</p><p>如果一个结点既没有右子树，并且它还是父结点的右子结点，这种情形就比较复杂。可以沿着指向父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点。如果这样的结点存在，那么这个结点的父结点就是要找的下一个结点。例如，为了找到结点 g 的下一个结点，沿着指向父结点的指针向上遍历，先到达结点 c。由于结点 c 是父结点 a 的右结点，继续向上遍历到达结点a。由于结点 a 是树的根结点，它没有父结点。因此结点 g 没有下一个结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pNode==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeLinkNode* pNext=<span class="hljs-literal">nullptr</span>;<br>         <span class="hljs-comment">// 当前结点有右子树，那么它的下一个结点就是它的右子树中最左子结点</span><br>        <span class="hljs-keyword">if</span>(pNode-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            TreeLinkNode* pRight=pNode-&gt;right;<br>            <span class="hljs-keyword">while</span>(pRight-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                pRight=pRight-&gt;left;<br>            pNext=pRight;<br>        &#125;<br>         <span class="hljs-comment">// 当前结点无右子树，则需要找到一个是它父结点的左子树结点的结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pNode-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 当前结点</span><br>            TreeLinkNode* pCur=pNode;<br>            <span class="hljs-comment">// 父节点</span><br>            TreeLinkNode* pPar=pNode-&gt;next;<br>            <span class="hljs-keyword">while</span>(pPar!=<span class="hljs-literal">nullptr</span>&amp;&amp;pCur==pPar-&gt;right)<br>            &#123;<br>                pCur=pPar;<br>                pPar=pPar-&gt;next;<br>            &#125;<br>            pNext=pPar;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pNext;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h1><h2 id="题目链接-57"><a href="#题目链接-57" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><h2 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-4"><a href="#解法一：递归-4" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>对称二叉树定义： 对于树中任意两个对称节点 L 和 R ，一定有：</p><ul><li>L.val&#x3D;R.val ：即此两对称节点值相等。</li><li>L.left.val&#x3D;R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li><li>L.right.val&#x3D;R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li></ul><p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103304.png"  style="zoom:67%;" /><p><strong>算法流程：</strong><br>isSymmetric(root) ：</p><ul><li>特例处理： 若根节点 root 为空，则直接返回 true ；</li><li>返回值： 即 recur(root.left, root.right) 。</li></ul><p>recur(L, R) ：</p><ul><li>终止条件：<ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li><li>当节点 L 值 !&#x3D; 节点 R 值： 此树不对称，因此返回 false ；</li></ul></li><li>递推工作：<ul><li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li><li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li></ul></li><li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot-&gt;left,pRoot-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode* L,TreeNode* R)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">nullptr</span>&amp;&amp;R==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">nullptr</span>||R==<span class="hljs-literal">nullptr</span>||L-&gt;val!=R-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(L-&gt;left,R-&gt;right)&amp;&amp;<span class="hljs-built_in">recur</span>(L-&gt;right,R-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N&#x2F;2 次 recur() 方法。</li><li>空间复杂度 O(N) ： 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103253.png"  style="zoom:67%;" /><h3 id="解法二：非递归-1"><a href="#解法二：非递归-1" class="headerlink" title="解法二：非递归"></a>解法二：非递归</h3><p>用 stack 或者 queue 模拟 bfs 。</p><p>首先从队列中拿出两个节点( left 和 right )比较。将 left 的 left 节点和 right 的 right 节点放入队列，将 left 的 right 节点和 right 的 left 节点放入队列。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200727104447.gif"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(pRoot-&gt;left);<br>        s.<span class="hljs-built_in">push</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* curR=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* curL=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>&amp;&amp;curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>||curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(curL&amp;&amp;curR)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(curL-&gt;val!=curR-&gt;val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 左子树的左孩子、右子树的右孩子</span><br>                s.<span class="hljs-built_in">push</span>(curL-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;right);<br>                <span class="hljs-comment">// 左子树的右孩子、右子树的左孩子</span><br>                s.<span class="hljs-built_in">push</span>(curL-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)。</li><li>空间复杂度 O(N)。</li></ul><h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><h2 id="题目链接-58"><a href="#题目链接-58" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>建议先做 <a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">22.从上往下打印二叉树</a>、<a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">60.把二叉树打印成多行</a>，本题在前两题的基础上增加额外要求，即打印顺序交替变化。</p></blockquote><h3 id="解法一：层序遍历-倒序"><a href="#解法一：层序遍历-倒序" class="headerlink" title="解法一：层序遍历+倒序"></a>解法一：层序遍历+倒序</h3><p>增加 flag 标记，初始化为 false，即从左到右打印，当一层打印结束后，修改 flag 为 !flag，当 flag&#x3D;true 时，利用 reverse 函数将 tmp 进行倒序，即从右到左打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>            flag=!flag;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成少于 N 个节点的倒序操作，占用 O(N) 。</li><li>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li></ul><h3 id="解法二：层序遍历-双端队列（奇偶层逻辑分离）"><a href="#解法二：层序遍历-双端队列（奇偶层逻辑分离）" class="headerlink" title="解法二：层序遍历 + 双端队列（奇偶层逻辑分离）"></a>解法二：层序遍历 + 双端队列（奇偶层逻辑分离）</h3><p>利用双端队列 deque 可从两边添加元素的特性，从第 1 层开始，规定：</p><ul><li>打印奇数层时，从左到右打印，即正序打印，从 deque 前面取，后面放元素；</li><li>打印偶数层时，从右到左打印，即逆序打印，从 deque 后面取，前面放元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        deque&lt;TreeNode*&gt; dq;<br>        dq.<span class="hljs-built_in">push_back</span>(pRoot);<br>        <span class="hljs-type">int</span> level=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=dq.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur;<br>                <span class="hljs-comment">// 前取后放 从左边往右， 正序 前面取 后面放</span><br>                <span class="hljs-keyword">if</span>((level&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>                &#123;<br>                    cur=dq.<span class="hljs-built_in">front</span>();<br>                    dq.<span class="hljs-built_in">pop_front</span>();<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_back</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_back</span>(cur-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">// 后取前放 从右边向左，逆序 前面放 后面取</span><br>                &#123;<br>                    cur=dq.<span class="hljs-built_in">back</span>();<br>                    dq.<span class="hljs-built_in">pop_back</span>();<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_front</span>(cur-&gt;right);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_front</span>(cur-&gt;left);<br>                &#125;<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125;<br>            level++;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。</li><li>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 deque 中，使用 O(N) 大小的额外空间。</li></ul><h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><h2 id="题目链接-59"><a href="#题目链接-59" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h2 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>建议先做 <a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">22.从上往下打印二叉树</a>，两题仅有微小区别，即本题需将每一层打印到一行。</p></blockquote><h3 id="解法一：迭代-1"><a href="#解法一：迭代-1" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><ul><li><p>按层打印： 题目要求二叉树的从上至下打印（即按层打印），又称为二叉树的广度优先搜索（BFS）。BFS 通常借助队列的先入先出特性来实现。</p></li><li><p>每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103229.png"  style="zoom:67%;" /><p><strong>算法流程：</strong></p><ol><li>特例处理： 当根节点为空，则返回空列表 [ ] ；</li><li>初始化： 打印结果列表 res &#x3D; [ ] ，包含根节点的队列 queue &#x3D; [root] ；</li><li>BFS 循环： 当队列 queue 为空时跳出；<ol><li>新建一个临时列表 tmp ，用于存储当前层打印结果；</li><li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<ul><li>出队： 队首元素出队，记为 cur；</li><li>打印： 将 cur.val 添加至 tmp 尾部；</li><li>添加子节点： 若 cur 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li></ul></li><li>将当前层结果 tmp 添加入 res 。</li></ol></li><li>返回值： 返回打印结果列表 res 即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>            <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> res;<br>            queue&lt;TreeNode*&gt; que;<br>            que.<span class="hljs-built_in">push</span>(pRoot);<br>            <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                    que.<span class="hljs-built_in">pop</span>();<br>                    tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N 次。</li><li>空间复杂度 O(N)： 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li></ul><h3 id="解法二：递归-3"><a href="#解法二：递归-3" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>            <span class="hljs-built_in">levelOrder</span>(pRoot,<span class="hljs-number">0</span>,res);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> level,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==level)<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">levelOrder</span>(root-&gt;left,level+<span class="hljs-number">1</span>,res);<br>            <span class="hljs-built_in">levelOrder</span>(root-&gt;right,level+<span class="hljs-number">1</span>,res);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><h2 id="题目链接-60"><a href="#题目链接-60" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树。</p><p>例如，我们可以把一个只有根节点为 1 的二叉树序列化为”1!##”，然后通过自己的函数来解析回这个二叉树。</p><h2 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。一般有两种策略：</p><ul><li>BFS：按照层次的顺序从上到下遍历所有的节点；</li><li>DFS（可分为先序、中序、后序遍历）：从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。</li></ul></blockquote><h3 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>这里采用先序遍历的方式，中序、后序遍历思路与其相同。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103208.png"  style="zoom:67%;" /><p>序列化：</p><p>先序遍历二叉树，遇到空子树的时候序列化成 ‘#’，否则继续递归序列化。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103157.png"  style="zoom:67%;" /><p>反序列化：</p><p>从左向右遍历这个序列：</p><ul><li>如果当前的元素为 ‘#’，则当前为空树；</li><li>否则先解析这棵树的左子树，再解析它的右子树</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103145.png"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        string str;<br>        <span class="hljs-built_in">SerializeCore</span>(root,str);<br>        <span class="hljs-comment">// 把str流转换为字符串返回</span><br>        <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">char</span>* res=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            res[i]=str[i];<br>        res[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* res=<span class="hljs-built_in">DeserializeCore</span>(&amp;str);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SerializeCore</span><span class="hljs-params">(TreeNode* root, string&amp; str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果指针为空，表示左子节点或右子节点为空，则在序列中用#表示</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            str+=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        str+=<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&#x27;!&#x27;</span>;<br>        <span class="hljs-built_in">SerializeCore</span>(root-&gt;left,str);<br>        <span class="hljs-built_in">SerializeCore</span>(root-&gt;right,str);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 递归时改变了str值使其指向后面的序列，因此要声明为char**</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">DeserializeCore</span><span class="hljs-params">(<span class="hljs-type">char</span>** str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 到达叶节点时，调用两次，都返回null，所以构建完毕，返回父节点的构建</span><br>        <span class="hljs-keyword">if</span>(**str==<span class="hljs-string">&#x27;#&#x27;</span>)<br>        &#123;<br>            (*str)++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">// 因为整数是用字符串表示，一个字符表示一位，先进行转换</span><br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(**str!=<span class="hljs-string">&#x27;!&#x27;</span>&amp;&amp;**str!=<span class="hljs-string">&#x27;\0&#x27;</span>)<br>        &#123;<br>            num=(**str)-<span class="hljs-string">&#x27;0&#x27;</span>+num*<span class="hljs-number">10</span>;<br>            (*str)++;<br>        &#125;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>        <span class="hljs-keyword">if</span>(**str==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span><br>            (*str)++;<br>        root-&gt;left=<span class="hljs-built_in">DeserializeCore</span>(str);<br>        root-&gt;right=<span class="hljs-built_in">DeserializeCore</span>(str);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：在序列化和反序列化函数中，只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</li><li>空间复杂度：在序列化和反序列化函数中，递归会使用栈空间，故渐进空间复杂度为 O(n)。</li></ul><h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>序列化：</p><ul><li>让 null 也入列，说它是真实节点也行，它有对应的”X”，只是没有子节点入列；</li><li>考察出列节点：<ul><li>如果不为 null，则将它的值推入 string，并将它的左右子节点入列；</li><li>如果是 null ，则将 ‘X’ 推入 string。</li></ul></li><li>出列…入列…直到队列为空，所有节点遍历完，string 也构建完，转成 char*。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103112.png"  style="zoom:67%;" /><p>反序列化：</p><ul><li>除了第一个是根节点的值，其他节点值都是成对的，分别对应左右子节点；</li><li>从第二项开始遍历，每次考察两个节点值；</li><li>队列初始推入root 节点。父节点出列，找出子节点入列；</li><li>出列的父节点，它对应到指针指向的左子节点值，和指针右边的右子节点值<ul><li>如果子节点值不为 ‘X’，则为它创建节点，并认父亲，并作为未来父亲入列；</li><li>如果子节点值为 ‘X’，什么都不做即可。</li></ul></li><li>所有父节点（真实节点）都会在队列里走一遍。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103058.png"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123; <br>        string str;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                str+=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                str+=<span class="hljs-string">&#x27;!&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            str+=<span class="hljs-built_in">to_string</span>(cur-&gt;val)+<span class="hljs-string">&#x27;!&#x27;</span>;<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        <span class="hljs-type">char</span> *res=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[str.<span class="hljs-built_in">length</span>()+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(res,str.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str)</span></span>;<br>        <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode *root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>        s = s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>)+<span class="hljs-number">1</span>);<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 根据序列化字符串再层次遍历一遍，来构造树</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()&amp;&amp;!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>            &#123;<br>                cur-&gt;left=<span class="hljs-literal">nullptr</span>;<br>                s=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                s = s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>            &#123;<br>                cur-&gt;right=<span class="hljs-literal">nullptr</span>;<br>                s=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                s=s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="62-二叉搜索树的第-K-个结点"><a href="#62-二叉搜索树的第-K-个结点" class="headerlink" title="62.二叉搜索树的第 K 个结点"></a>62.二叉搜索树的第 K 个结点</h1><h2 id="题目链接-61"><a href="#题目链接-61" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&&tqId=11215&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第 k 小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为 4。</p><h2 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：中序遍历-递归"><a href="#解法一：中序遍历-递归" class="headerlink" title="解法一：中序遍历+递归"></a>解法一：中序遍历+递归</h3><blockquote><p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p></blockquote><p>为求第 k 个节点，需要实现以下三项工作 ：</p><ol><li>递归遍历时计数，统计当前节点的序号；</li><li>递归到第 k 个节点时，应记录结果 res ；</li><li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TreeNode* target=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* pRoot, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(pRoot,k);<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||count&gt;=k)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left,k);<br>        count++;<br>        <span class="hljs-keyword">if</span>(count==k)<br>            target=root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right,k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。</li><li>空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</li></ul><h3 id="解法二：迭代-3"><a href="#解法二：迭代-3" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>用栈来模拟递归中序遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* pRoot, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">while</span>(pRoot!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(pRoot!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(pRoot);<br>                pRoot=pRoot-&gt;left;<br>            &#125;<br>            pRoot=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(++count==k)<br>                <span class="hljs-keyword">return</span> pRoot;<br>            pRoot=pRoot-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><h2 id="题目链接-62"><a href="#题目链接-62" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。</p><h2 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：排序法"><a href="#解法一：排序法" class="headerlink" title="解法一：排序法"></a>解法一：排序法</h3><p>将添加的数保存在数组中，返回中位数时，只需将数组排序，返回中间位置数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; store;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        store.<span class="hljs-built_in">push_back</span>(num);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-built_in">sort</span>(store.<span class="hljs-built_in">begin</span>(),store.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=store.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> store[n/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (store[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+store[n/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(nlogn)。Insert() 函数消耗 O(1) 的时间复杂度，GetMedian() 函数使用了排序，时间复杂度为 O(nlogn)。因此总的时间复杂度为 O(nlogn)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法二：二分查找插入"><a href="#解法二：二分查找插入" class="headerlink" title="解法二：二分查找插入"></a>解法二：二分查找插入</h3><p>方法一的缺点在于对数组进行了排序操作，导致时间复杂度较高，假如每次插入一个值前数组已经排好序了呢？这样只需考虑每次将值插在合适的位置即可，所以使用二分查找来找到这个合适的位置，会将时间复杂度降低到 O(n)（查找: O(logn)，插入: O(n)）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; store;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(store.<span class="hljs-built_in">empty</span>())<br>            store.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">else</span><br>            store.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">lower_bound</span>(store.<span class="hljs-built_in">begin</span>(),store.<span class="hljs-built_in">end</span>(),num),num);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-type">int</span> n=store.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> store[n/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (store[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+store[n/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)。O(logn)+O(n)≈O(n)。</li><li>空间复杂度：O(n)。使用了数组保存输入。</li></ul><h3 id="解法三：优先队列-x2F-堆"><a href="#解法三：优先队列-x2F-堆" class="headerlink" title="解法三：优先队列&#x2F;堆"></a>解法三：优先队列&#x2F;堆</h3><blockquote><p>借助 <strong>堆</strong> 可进一步优化时间复杂度。</p></blockquote><p>建立一个 小顶堆 A 和 大顶堆 B ，各保存列表的一半元素，且规定：</p><ul><li>A 保存较大的一半，长度为 N&#x2F;2（ N 为偶数）或  (N+1)&#x2F;2（ N 为奇数）；</li><li>B 保存较小的一半，长度为 N&#x2F;2（ N 为偶数）或（N-1)&#x2F;2（ N 为奇数）。</li></ul><p>随后，中位数可仅根据 A,B 的堆顶元素计算得到。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103031.png"  style="zoom:67%;" /><p><strong>算法流程：</strong></p><p>设元素总数为 N&#x3D;m + n，其中 m 和 n 分别为 A 和 B 中的元素个数。</p><p>Insert(num) 函数：</p><ol><li>当 m&#x3D;n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A （由于 num 可能属于“较小的一半”，即属于 B ，因此不能将 num 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半）。</li><li>当 m!&#x3D;n（即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B 。</li></ol><p>GetMedian() 函数：</p><p>当 m&#x3D;n（ N 为 偶数）：则中位数为 （A 的堆顶元素 + B 的堆顶元素 )&#x2F;2。<br>当 m!&#x3D;n（ N 为 奇数）：则中位数为 A 的堆顶元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; A; <span class="hljs-comment">//小顶堆，保存较大的一半</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; B; <span class="hljs-comment">//大顶堆，保存较小的一半</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()==B.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            B.<span class="hljs-built_in">push</span>(num);<br>            A.<span class="hljs-built_in">push</span>(B.<span class="hljs-built_in">top</span>());<br>            B.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            A.<span class="hljs-built_in">push</span>(num);<br>            B.<span class="hljs-built_in">push</span>(A.<span class="hljs-built_in">top</span>());<br>            A.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (A.<span class="hljs-built_in">top</span>()+B.<span class="hljs-built_in">top</span>())/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(logN) ：<ul><li>查找中位数 O(1) ： 获取堆顶元素使用 O(1) 时间；</li><li>添加数字 O(logN) ： 堆的插入和弹出操作使用 O(logN) 时间。</li></ul></li><li>空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。</li></ul><h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><h2 id="题目链接-63"><a href="#题目链接-63" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组 {2,3,4,2,6,2,5,1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4,4,6,6,6,5}； 针对数组 {2,3,4,2,6,2,5,1} 的滑动窗口有以下 6 个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><h2 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力方法"><a href="#解法一：暴力方法" class="headerlink" title="解法一：暴力方法"></a>解法一：暴力方法</h3><p>每次窗口滑动到一个位置就去计算一下这个窗口里的最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (num.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||size&lt;<span class="hljs-number">1</span>||num.<span class="hljs-built_in">size</span>()&lt;size)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=num.<span class="hljs-built_in">size</span>()-size;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> max_val=num[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i;j&lt;i+size;++j)<br>                max_val=<span class="hljs-built_in">max</span>(max_val,num[j]);<br>            res.<span class="hljs-built_in">push_back</span>(max_val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n*k), 其中 n 为数组大小，k 为窗口大小；</li><li>空间复杂度：O(n-k+1)，用于输出数组。</li></ul><h3 id="解法二：单调双向队列"><a href="#解法二：单调双向队列" class="headerlink" title="解法二：单调双向队列"></a>解法二：单调双向队列</h3><p>如何优化时间复杂度呢？首先想到的是使用堆，因为在最大堆中 heap[0] 永远是最大的元素。在大小为 k 的堆中插入一个元素消耗 log(k) 时间，因此算法的时间复杂度为 O(Nlog(k))。</p><p>能否得到只要 O(N) 的算法？</p><p>可以使用<strong>双向队列</strong>，该数据结构可以从两端以常数时间压入&#x2F;弹出元素。</p><p>存储双向队列的索引比存储元素更方便，因为两者都能在数组解析中使用。</p><p><strong>算法流程</strong>：</p><ol><li>处理前 size 个元素，初始化双向队列。</li><li>遍历整个数组。在每一步清理双向队列:<ul><li>只保留当前滑动窗口中有的元素的索引，即当上一轮窗口首元素不在当前窗口中时，需要将它从队列中弹出。   </li><li>移除比当前元素小的所有元素，它们不可能是最大的。</li></ul></li><li>将当前元素添加到双向队列中。</li><li>形成窗口后，将 deque[0] 添加到输出中。</li><li>返回输出数组。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||size&lt;<span class="hljs-number">1</span>||num.<span class="hljs-built_in">size</span>()&lt;size)<br>            <span class="hljs-keyword">return</span> res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标</span><br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>()&amp;&amp;num[dq.<span class="hljs-built_in">back</span>()]&lt;num[i])<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-comment">//把每次滑动的num下标加入队列</span><br>            dq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span><br>            <span class="hljs-keyword">if</span>(i-dq.<span class="hljs-built_in">front</span>()+<span class="hljs-number">1</span>&gt;size)<br>                dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-comment">//当i大于等于size时才开始写入窗口最大值</span><br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&gt;=size)<br>                res.<span class="hljs-built_in">push_back</span>(num[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析:</strong></p><ul><li>时间复杂度：O(N)，每个元素被处理两次（其索引被添加到双向队列中和被双向队列删除）。</li><li>空间复杂度：O(N)，输出数组使用了 O(N−k+1) 空间，双向队列使用了 O(k)。</li></ul><h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><h2 id="题目链接-64"><a href="#题目链接-64" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下图中矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102945.png"></p><h2 id="解题思路：深度优先搜索-DFS-回溯"><a href="#解题思路：深度优先搜索-DFS-回溯" class="headerlink" title="解题思路：深度优先搜索 DFS +回溯"></a>解题思路：深度优先搜索 DFS +回溯</h2><blockquote><p>典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p></blockquote><p><strong>算法原理：</strong></p><ul><li>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝： 在搜索中，遇到这条路不可能和目标字符串匹配成功的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为可行性剪枝 。</li></ul><p><strong>算法剖析：</strong></p><ul><li>递归参数： 当前元素在矩阵 matrix 中的行列索引 i 和 j ，当前目标字符在 str 中的索引 k 。</li><li>终止条件：<ul><li>返回 false ： ① 行或列索引越界或 ② 当前矩阵元素与目标字符不同或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。</li><li>返回 true ： 字符串 str 已全部匹配，即 k &#x3D; len(str) - 1 (str[k+1]&#x3D;&#x3D;’\0’)。</li></ul></li><li>递推工作：<ol><li>标记当前矩阵元素： 将 matrix[i,j] 值暂存于变量 tmp ，并修改为字符  ‘&#x2F;‘ ，代表此元素已访问过，防止之后搜索时重复访问。</li><li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 “||” 连接 （代表只需一条可行路径） ，并记录结果至 res 。</li><li>还原当前矩阵元素： 将 tmp 暂存值还原至 matrix[i,j] 元素。</li></ol></li><li>回溯返回值： 返回 res ，代表是否搜索到目标字符串。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix==<span class="hljs-literal">nullptr</span>||rows&lt;<span class="hljs-number">1</span>||cols&lt;<span class="hljs-number">1</span>||str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j,str,<span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span>* str,<span class="hljs-type">int</span> pathlength)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||i&lt;<span class="hljs-number">0</span>||j&gt;=cols||j&lt;<span class="hljs-number">0</span>||matrix[i*cols+j]!=str[pathlength])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(str[pathlength+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp=matrix[i*cols+j];<span class="hljs-comment">// 用于暂时保存字符</span><br>        matrix[i*cols+j]=<span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-comment">// 代表这个字符已经访问过</span><br>        <span class="hljs-type">bool</span> res=<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i+<span class="hljs-number">1</span>,j,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i<span class="hljs-number">-1</span>,j,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j+<span class="hljs-number">1</span>,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j<span class="hljs-number">-1</span>,str,pathlength+<span class="hljs-number">1</span>);<br>        matrix[i*cols+j]=tmp;<span class="hljs-comment">// 遍历结束后改回来</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>matrix[i,j] 临时赋值成 ‘&#x2F;‘，用来标记已访问的元素，省下了bool[][] visited的空间，很巧妙，并且省略了当前矩阵元素是否访问过的判断，因为访问后矩阵元素修改为 ‘&#x2F;‘ 后，与字符串必不相等。</p><p>另一种写法：</p><p>用数组循环写代替四个 dfs。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix==<span class="hljs-literal">nullptr</span>||rows&lt;<span class="hljs-number">1</span>||cols&lt;<span class="hljs-number">1</span>||str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j,str,<span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span>* str,<span class="hljs-type">int</span> pathlength)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||i&lt;<span class="hljs-number">0</span>||j&gt;=cols||j&lt;<span class="hljs-number">0</span>||matrix[i*cols+j]!=str[pathlength])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(str[pathlength+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp=matrix[i*cols+j];<br>        matrix[i*cols+j]=<span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;q&lt;<span class="hljs-number">4</span>;++q)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+dx[q],n=j+dy[q];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,m,n,str,pathlength+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        matrix[i*cols+j]=tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小， K 为字符串 str 长度。</p><ul><li>时间复杂度 O(MN3^K)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<ul><li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K)。</li></ul></li><li>空间复杂度 O(K)： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K&#x3D;MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li></ul><h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><h2 id="题目链接-65"><a href="#题目链接-65" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 &#x3D; 18。但是，它不能进入方格（35,38），因为 3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>典型的矩阵搜索问题。此类问题通常可使用 <strong>深度优先搜索（DFS）</strong> 或 <strong>广度优先搜索（BFS）</strong> 解决。</p></blockquote><p><strong>数位之和计算：</strong></p><p>设一数字 x ，向下取整除法符号 &#x2F; ，求余符号 % ，则有：</p><ul><li>x %10 ：得到 x 的个位数字；</li><li>x &#x2F;10 ： 令 x 的十进制数向右移动一位，即删除个位数字。</li></ul><p>因此，可通过循环求得数位和 ，数位和计算的封装函数如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>    &#123;<br>        sum+=num%<span class="hljs-number">10</span>;<br>        num=num/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>搜索方向简化：</strong></p><ul><li>数位和特点： <ul><li>设 x 的数位和为 $s_x$，x+1 的数位和为 $s_{x+1}$：<ul><li>当 (x+1)%10&#x3D;0 时： $s_{x+1}$ &#x3D; $s_x$ - 8。例如 19, 20 的数位和分别为 10, 2；</li><li>当 (x+1)%10 !&#x3D;0 时： $s_{x+1}$ &#x3D; $s_x$ + 1 。例如 1,2 的数位和分别为 1, 2。</li></ul></li><li>根据数位和增量得知，数位和每逢进位突变一次。</li></ul></li><li>解的三角形结构：<ul><li>根据数位和特点，矩阵中满足数位和的解构成的几何形状形如多个等腰直角三角形 ，每个三角形的直角顶点位于 0,10,20,… 等数位和突变的矩阵索引处 。</li><li>三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。</li></ul></li><li>结论： 根据可达解的结构，易推出机器人可仅通过向右和向下移动，访问所有可达解 。<ul><li>三角形内部： 全部连通，易证；</li><li>两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。</li></ul></li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102529.png"  style="zoom:67%;" /><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102515.png"  style="zoom:67%;" /><h3 id="解法一：深度优先遍历-DFS"><a href="#解法一：深度优先遍历-DFS" class="headerlink" title="解法一：深度优先遍历 DFS"></a>解法一：深度优先遍历 DFS</h3><ul><li>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为可行性剪枝 。</li></ul><p><strong>算法解析：</strong></p><ul><li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li><li>终止条件： 当 ① 行列索引越界或 ② 数位和超出目标值 k或 ③ 当前元素已访问过时，返回 0 ，代表不计入可达解。</li><li>递推工作：<ul><li>标记当前单元格 ：将 visited [i] [j] 标记为 true ，代表此单元格已被访问过。</li><li>搜索下一单元格： 计算当前元素的下、右两个方向元素的数位和，并开启下层递归 。</li></ul></li><li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,threshold,rows,cols,visited);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> threshold,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||j&gt;=cols||<span class="hljs-built_in">bitsum</span>(i)+<span class="hljs-built_in">bitsum</span>(j)&gt;threshold||visited[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,threshold,rows,cols,visited)+<span class="hljs-built_in">dfs</span>(i,j+<span class="hljs-number">1</span>,threshold,rows,cols,visited);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            sum+=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小。</p><ul><li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li><li>空间复杂度 O(MN) ： visited 使用 O(MN) 的额外空间。</li></ul><h3 id="解法二：广度优先遍历-BFS"><a href="#解法二：广度优先遍历-BFS" class="headerlink" title="解法二：广度优先遍历 BFS"></a>解法二：广度优先遍历 BFS</h3><ul><li>BFS&#x2F;DFS ： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。</li><li>BFS 实现： 通常利用队列实现广度优先遍历。</li></ul><p><strong>算法解析：</strong></p><ul><li>初始化： 将机器人初始点 (0,0) 加入队列 queue ；</li><li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li><li>迭代工作：<ul><li>单元格出队： 将队首单元格的索引弹出，作为当前搜索单元格。</li><li>判断是否跳过： 若 ① 行列索引越界或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li><li>标记当前单元格 ：将 visited [i] [j] 标记为 true，代表此单元格已被访问过 。</li><li>可达解数目加 1，即 res++。</li><li>单元格入队： 将当前元素的下方、右方单元格的索引加入 queue 。</li></ul></li><li>返回值： 返回 res，即可达解的数量。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> i_j=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> i=i_j.first;<br>            <span class="hljs-type">int</span> j=i_j.second;<br>            <span class="hljs-keyword">if</span>(i&gt;=rows||j&gt;=cols||<span class="hljs-built_in">bitsum</span>(i)+<span class="hljs-built_in">bitsum</span>(j)&gt;threshold||visited[i][j])<br>                <span class="hljs-keyword">continue</span>;<br>            visited[i][j]=<span class="hljs-literal">true</span>;<br>            res++;<br>            que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i+<span class="hljs-number">1</span>,j));<br>            que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            sum+=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong><br>M, N 分别为矩阵行列大小。</p><ul><li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li><li>空间复杂度 O(MN) ： visited 使用 O(MN) 的额外空间。</li></ul><h1 id="67-剪绳子"><a href="#67-剪绳子" class="headerlink" title="67.剪绳子"></a>67.剪绳子</h1><h2 id="题目链接-66"><a href="#题目链接-66" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p><h2 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n都是整数，n&gt;1 并且 m&gt;1，m&lt;&#x3D;n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入描述<span class="hljs-symbol">:</span><br>输入一个数<span class="hljs-built_in">n</span>，意义见题面。（<span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">60</span>）<br>输出描述<span class="hljs-symbol">:</span><br>输出答案。<br><br>示例：<br>输入<br><span class="hljs-number">8</span><br>输出<br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><h2 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力递归（超时）"><a href="#解法一：暴力递归（超时）" class="headerlink" title="解法一：暴力递归（超时）"></a>解法一：暴力递归（超时）</h3><p>假设现在绳子长度为 n，由题知绳子n&gt;1，最少长度为2，设 F(n) 为长度为 n 的绳子可以得到的最大乘积，对于每一个 F(n)，可以得到如下分解，从而形成类似于斐波那契数列的递归树。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102458.png"  style="zoom: 50%;" /><p>从上图看出可以把求解 F(n) 的问题分解成求解 F(n−1) 的问题，以此类推，直到求解到 F(2) 时，F(2)&#x3D;1，递推回去，问题就得到了解决。这用到的就是分治的思想。</p><p>分治思想的解决方法往往是递归，注意到每次将一段绳子剪成两段时，剩下的部分可以继续剪，也可以不剪，选择不剪此时 F(n)&#x3D;1*(n-1)， 选择剪就是根据 F(n) 一样求 F(n-1)。因此得到了递归函数 F(n)&#x3D;max(i×(n−i),i×F(n−i)) , i&#x3D;1,2,…,n−2。</p><p>注意以下代码<strong>超时</strong>，无法通过！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 隐含F(1) = -1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;++i)<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">max</span>(i*(number-i),i*<span class="hljs-built_in">cutRope</span>(number-i)));<span class="hljs-comment">// 当调用F(1)的时候就是-1</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n!)。</li><li>空间复杂度：O(n), 最多分 n 段，每段长度为 1， 所以递归深度为 n。</li></ul><h3 id="解法二：记忆化搜索"><a href="#解法二：记忆化搜索" class="headerlink" title="解法二：记忆化搜索"></a>解法二：记忆化搜索</h3><p>上述暴力解法会超时，但是很多进阶解法往往是暴力解法的优化。注意到上述代码中超时的原因主要是因为重复计算了 F(n)，为了避免重复计算可以使用记忆化（memoization）技术。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102447.png"  style="zoom:67%;" /><p>因此可以将每次 F(x) 计算的结果进行存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; memo=<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">59</span>,<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>)<br>            memo[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> eachFn;<br>            <span class="hljs-keyword">if</span>(memo[number-i]!=<span class="hljs-number">-1</span>)<br>                eachFn=<span class="hljs-built_in">max</span>(i*(number-i),i*memo[number-i]);<br>            <span class="hljs-keyword">else</span><br>                eachFn=<span class="hljs-built_in">max</span>(i*(number-i),i*<span class="hljs-built_in">cutRope</span>(number-i));<br>            memo[number]=<span class="hljs-built_in">max</span>(memo[number],eachFn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[number];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n^2)，对于每一个 i 调用一次递归，递归的时间复杂度为 O(N)，故时间复杂度为 O(n^2)。</li><li>空间复杂度：O(n)。</li></ul><h3 id="解法三：动态规划（自底向上）"><a href="#解法三：动态规划（自底向上）" class="headerlink" title="解法三：动态规划（自底向上）"></a>解法三：动态规划（自底向上）</h3><p>同样地，也可以使用动态规划，从已知值 F(2) 逐步迭代到目标值 F(n)，它是一种自底向上的方法。</p><p><strong>算法流程：</strong></p><p>建立一维动态数组 dp：</p><ul><li>边界条件：dp[1] &#x3D; dp[2] &#x3D; 1，表示长度为 2 的绳子最大乘积为 1；</li><li>状态转移方程：dp[i] &#x3D; max(dp[i], max((i - j) * j, j * dp[i - j]))，可以这样理解：</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102432.jpg"  style="zoom:67%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">59</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*(i-j),j*dp[i-j]));<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N^2)。</li><li>空间复杂度：O(N)。</li></ul><h3 id="解法四：动态规划优化解法"><a href="#解法四：动态规划优化解法" class="headerlink" title="解法四：动态规划优化解法"></a>解法四：动态规划优化解法</h3><p>可以发现任何大于 3 的数都可以拆分为数字 1，2，3 的和，且它们对 3 的余数总是 0，1，2，因此可以仅用 dp[0]，dp[1]，dp[2] 表示所有大于 3 的值，这样空间复杂度可降到 O(1)。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102413.gif" style="zoom: 67%;" /><p>这样重复使用 dp 数组，只须一趟遍历即可完成，可使时间复杂度降到 O(N)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;++i)<br>            dp[i%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>((<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-1</span>)),<span class="hljs-number">2</span>*<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-2</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-2</span>)),<span class="hljs-number">3</span>*<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-3</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-3</span>));<br>        <span class="hljs-keyword">return</span> dp[number%<span class="hljs-number">3</span>];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(1)。使用了有限长的数组。</li></ul><h3 id="解法五：找规律-x2F-贪心思想"><a href="#解法五：找规律-x2F-贪心思想" class="headerlink" title="解法五：找规律&#x2F;贪心思想"></a>解法五：找规律&#x2F;贪心思想</h3><p>题目分析：</p><p>先举几个例子，可以看出规律来。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span>： <span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">7 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">8 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">9 </span>： <span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">10</span>：<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">11</span>：<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">12</span>：<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">13</span>：<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>下面是分析：<br>首先判断 F[0] 到 F[n] 可能有哪些数字，实际上只可能是 2 或者 3。<br>当然也可能有 4，但是<code>4=2*2</code>，就简单些不考虑了。<br><code>5&lt;2*3</code>，<code>6&lt;3*3</code>,比 6 更大的数字就更不用考虑了，肯定要继续分。<br>其次看 2 和 3 的数量，2 的数量肯定小于 3 个，为什么呢？因为<code>2*2*2&lt;3*3</code>，那么题目就简单了。<br>直接用 n 除以3，根据得到的余数判断是一个 2 还是两个 2 还是没有 2 就行了。<br>由于题目规定<code>n&gt;1</code>，所以2只能是<code>1*1</code>，3只能是<code>2*1</code>，这两个特殊情况直接返回就行了。</p><p>详细思想和数学推导过程参考@ <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">Krahets </a>大佬题解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> a=number/<span class="hljs-number">3</span>,b=number%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a);<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a)*<span class="hljs-number">2</span>;<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度 O(1)： 仅有求整、求余、次方运算。<ul><li>求整和求余运算：资料提到不超过机器数的整数可以看作是 O(1) ；</li><li>幂运算：查阅资料，提到浮点取幂为 O(1)。</li></ul></li><li>空间复杂度 O(1)： 变量 a 和 b 使用常数大小额外空间。</li></ul><hr><p>完结撒花~</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客左神算法课笔记——算法入门</title>
    <link href="/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己在学习左神算法课时的笔记，部分内容转载自 <a href="https://zhenganwen.top/posts/d162ff6c/">loveforever</a> 博客。 </p><span id="more"></span><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>常数时间的操作</strong>：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</p><p>时间复杂度为一个算法流程中，常数操作数量的一个指标，是衡量算法好坏的重要指标之一。常用O(读作big O)来表示。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为<code>O(n)</code>），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于<strong>常数</strong>时间内的操作（对应时间复杂度<code>O(1)</code>）。</p><p>时间复杂度表达式化简原则：</p><ul><li>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如<code>O(n^2)+O(n)</code>可化简为<code>O(n^2)</code>，<code>O(n)+O(1)</code>可化简为<code>O(n)</code>。</li><li>可省去样本量前的常量系数，如<code>O(2n)</code>可化简为<code>O(n)</code>，<code>O(8)</code>可化简为<code>O(1)</code>。</li><li>对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如<code>O(logm)+O(n^2)</code>不能化简为<code>O(n^2)</code>或<code>O(logm)</code>。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为<code>O(logm)</code>，因为表达式增量是由样本量决定的。</li></ul><p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。</p><h1 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h1><p>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量<code>temp</code>，那么该算法的额外空间复杂度为<code>O(1)</code>。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为<code>O(n)</code>。</p><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="交换操作swap"><a href="#交换操作swap" class="headerlink" title="交换操作swap"></a>交换操作swap</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交换arr的i和j位置上的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>arr[i] = arr[j];<br>arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>以升序排序为例：找到 n 个数中最小数的下标<code>minIndex</code>，将其与第一个数（数组下标为 0 ）交换。接着对剩下的 n-1 个数，即子序列（1-n）重复该操作，直到子序列只含一个元素为止。(即选出最小的数放到第一个位置，该数安排好了，再对剩下的数选出最小的放到第二个位置，以此类推）。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145522.jpeg"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span><br>minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<br>&#125;<br>swap(arr, i, minIndex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的时间复杂度（big o）为<code>O(n^2)</code>（n-1+n-2+n-3+…+1）</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725150132.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; e &gt; <span class="hljs-number">0</span>; e--) &#123; <span class="hljs-comment">// 0 ~ e</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; e; i++) &#123;<br><span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>swap(arr, i, i + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法的时间复杂度为<code>n+(n-1)+...+1</code>，很明显是一个等差数列，由（首项+末项）*项数&#x2F;2求其和为<code>(n+1)n/2</code>，可知时间复杂度为<code>O(n^2)</code>。</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的过程可以联想到打扑克时揭一张牌然后将其到手中有序纸牌的合适位置上。比如我现在手上的牌是7、8、9、J、Q、K，这时揭了一张10，我需要将其依次与K、Q、J、9、8、7比较，当比到9时发现大于9，于是将其插入到9之后。对于一个无序序列，可以将其当做一摞待揭的牌，首先将首元素揭起来，因为揭之前手上无牌，因此此次揭牌无需比较，此后每揭一次牌都需要进行上述的插牌过程，当揭完之后，手上的握牌顺序就对应着该序列的有序形式。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145556.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 0~0 有序的</span><br><span class="hljs-comment">// 0~i 想有序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;<br>swap(arr, j, j + <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入排序的big o该如何计算？可以发现如果序列有序，那么该算法的big o为<code>O(n)</code>，因为只是遍历了一次序列（这是最好情况）；如果序列降序排列，那么该算法的big o为<code>O(n^2)</code>（每次插入前的比较交换加起来要：1+2+…+n-1）（最坏情况）。<strong>一般应用场景中都是按算法的最坏情况来考量算法的效率的，因为你做出来的应用要能够承受最坏情况。</strong>即该算法的big o为<code>O(n^2)</code>。</p><h3 id="归并排序及其扩展"><a href="#归并排序及其扩展" class="headerlink" title="归并排序及其扩展"></a>归并排序及其扩展</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序整体是一个简单递归，核心思想是先让序列的左半部分有序，再让序列的右半部分有序，最后让其整体有序。先对左右两部分分别递归执行归并排序，直到某次递归时左右两半部分均为一个元素时递归终止。让其整体有序的过程里使用了<strong>外排</strong>的方式，即用两个指针分别指向两个子序列（左右两半）的头，再依次进行比较，往辅助数组中填入较小的数。</p><p>以序列<code>&#123;2,1,4,3&#125;</code>为例，归并排序的过程大致如下：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145625.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br><span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">//(L+R)/2可能会溢出</span><br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>process(arr, L, mid);<span class="hljs-comment">//让其左半部分有序</span><br>process(arr, mid + <span class="hljs-number">1</span>, R);<span class="hljs-comment">//让其右半部分有序</span><br>merge(arr, L, mid, R);<span class="hljs-comment">//外排方式使其整体有序</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span> &#123;<br><span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//辅助数组指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<span class="hljs-comment">//左指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M + <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span><br><span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;<br>    <span class="hljs-comment">//当左指针所指的数=右指针所指的数时，先填左边的</span><br>help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>&#125;<br>    <span class="hljs-comment">//以下两个while只会发生一个</span><br><span class="hljs-keyword">while</span> (p1 &lt;= M) &#123;<br>help[i++] = arr[p1++];<br>&#125;<br><span class="hljs-keyword">while</span> (p2 &lt;= R) &#123;<br>help[i++] = arr[p2++];<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>arr[L + i] = help[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当一个递归过程比较复杂时（不像递归求阶乘那样一幕了然），我们可以列举简短样本进行分析。</p><p>对于这样复杂的递归行为，千万不要想着追溯整个递归过程，只需分析第一步要做的事（比如此例中第一步要做的是就是<code>process</code>函数所呈现出来的那样：对左半部分排序、对右半部分排序、最后并入，你先不管是怎么排序的）和递归终止的条件（比如此例中是要排序的序列只有一个元素时）。</p><p>归并排序的时间复杂度是<code>O(nlogn)</code>，额外空间复杂度是<code>O(n)</code>。</p><p>根据<strong>Master公式</strong>（本文 <strong>小技巧</strong>一节中有讲到）可得<code>T(n)=2T(n/2)+O(n)</code>，第一个2的含义是子过程（对子序列进行归并排序）要执行两次，第二个2的含义是子过程样本量占一半（因为分成了左右两半部分），最后<code>O(n)</code>表示左右有序之后进行的并入操作为<code>O(n+n)=O(n)</code>(L、R指针移动次数总和为n，将辅助数组覆盖源数组为n)，符合<code>T(n)=aT(n/b)+O(n^d)</code>，经计算该算法的时间复杂度为<code>O(nlogn)</code>。</p><p>归并排序的实质：</p><blockquote><p><code>O(n^2)</code>的排序算法（即选择排序、冒泡排序等）之所以时间复杂度差的原因是其大量浪费了比较次数，每次只搞定了一个数。而归并排序快的原因是其比较行为变成了整体有序的部分，再与下一部分进行 merge 。比较行为没被浪费，比较行为变成了共同有序的东西，传递了下去。</p></blockquote><h4 id="归并排序的扩展"><a href="#归并排序的扩展" class="headerlink" title="归并排序的扩展"></a>归并排序的扩展</h4><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">对于数组[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br><span class="hljs-number">1</span>左边比<span class="hljs-number">1</span>小的数，没有；<br><span class="hljs-number">3</span>左边比<span class="hljs-number">3</span>小的数，<span class="hljs-number">1</span>；<br><span class="hljs-number">4</span>左边比<span class="hljs-number">4</span>小的数，<span class="hljs-number">1</span>、<span class="hljs-number">3</span>；<br><span class="hljs-number">2</span>左边比<span class="hljs-number">2</span>小的数，<span class="hljs-number">1</span>；<br><span class="hljs-number">5</span>左边比<span class="hljs-number">5</span>小的数，<span class="hljs-number">1</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">2</span>；<br>所以小和为<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">2</span>=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>简单的做法就是遍历一遍数组，将当前遍历的数与该数之前数比较并记录小于该数的数。易知其时间复杂度为<code>O(n^2)</code>（0+1+2+……+n-1）。</p><p>更优化的做法是利用归并排序的<strong>并入逻辑</strong>，小和问题可理解为在外排过程中右边有多少个数比左指针指向的数大，在这个过程中产生小和。例如：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725144917.jpeg"></p><p>对应代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// arr[L..R]既要排好序，也要求小和</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br><span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> mergeSort(arr, l, mid) <span class="hljs-comment">//左半部分产生的小和</span><br>+ mergeSort(arr, mid + <span class="hljs-number">1</span>, r) <span class="hljs-comment">//右半部分产生的小和</span><br>+ merge(arr, l, mid, r);<span class="hljs-comment">//外排产生的小和</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> &#123;<br><span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//辅助数组指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l;<span class="hljs-comment">//左指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> m + <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;<br><span class="hljs-comment">//当左指针所指的数=右指针所指的数时，先填右边的（与归并排序不同），不然没法知道右边有多少个数比左边大，所以此处为&lt;而不是&lt;=。</span><br>    <span class="hljs-comment">//小和的产生即右边有多少个数比左指针所指的数大，左指针所指的数*右边比它大的个数</span><br>        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="hljs-number">1</span>) * arr[p1] : <span class="hljs-number">0</span>;<br>help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];<br>&#125;<br><span class="hljs-keyword">while</span> (p1 &lt;= m) &#123;<br>help[i++] = arr[p1++];<br>&#125;<br><span class="hljs-keyword">while</span> (p2 &lt;= r) &#123;<br>help[i++] = arr[p2++];<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>arr[l + i] = help[i];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>该算法在归并排序的基础上做了略微改动，即<code>merge</code>中添加了变量<code>res</code>记录每次<strong>并入</strong>操作应该累加的小和、<code>mergeSort</code>则将每次并入应该累加的小和汇总。此种做法的复杂度与归并排序的相同，优于遍历的做法。可以理解，依次求每个数的小和过程中有很多比较是重复的，而利用归并排序求小和时利用了并入的两个序列分别有序的特性省去了不必要的比较，如<code>134并入25</code>时，<code>2&gt;1</code>直接推出<code>2</code>后面的数都<code>&gt;1</code>。这在样本量不大的情况下看不出来优化的效果，试想一下如果样本量为<code>2^32</code>，那么依照前者求小和<code>O(n^2)</code>可知时间复杂度为<code>O(21亿的平方)</code>，而归并排序求小和则只需<code>O(21亿*32)</code>，足以见得<code>O(n^2)</code>和<code>O(nlogn)</code>的优劣。</p><h5 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h5><p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。</p><blockquote><p>这题的思路也可以利用归并排序来解决，在并入操作时记录<code>arr[L]&gt;arr[R]</code>的情况即可。</p></blockquote><h3 id="堆结构和堆排序"><a href="#堆结构和堆排序" class="headerlink" title="堆结构和堆排序"></a>堆结构和堆排序</h3><p>堆结构就是用<strong>数组</strong>实现的完全二叉树结构，是将一颗<strong>完全二叉树</strong>映射到数组中的一种存储方式：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145656.jpeg"></p><h4 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h4><p>完全二叉树中如果每棵子树的最大值都在顶部就是大根堆，如果每棵子树的最小值都在顶部就是小根堆。其中大根堆的应用较为广泛，是一种很重要的数据结构。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae11912cf6"></p><h4 id="heapInsert-和-heapify"><a href="#heapInsert-和-heapify" class="headerlink" title="heapInsert 和 heapify"></a>heapInsert 和 heapify</h4><p>堆的主要操作可以理解为一个黑盒，即用户给你一些数据建立堆的过程和返回当前最大值的过程。</p><p>heapInsert：当一个元素加入到大根堆时应该自底向上与其父结点比较，若大于父结点则交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//index之前的序列符合大根堆，将index位置的元素加入堆结构，但不能破坏大根堆的特性，往上继续移动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-comment">//当该结点大于父结点时</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br>swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">//继续向上比较</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>heapify：当堆中某个结点的数值发生变化时，应不断向下与其孩子结点中的最大值比较，若小于则交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数组中下标从0到heapSize符合大根堆排序</span><br><span class="hljs-comment">// index位置的值发生了变化，重新调整堆结构为大根堆</span><br><span class="hljs-comment">// heapSize指的是数组中符合大根堆排序的范围而不是数组长度,最大为数组长度，最小为0 </span><br><span class="hljs-comment">// 某个数在index位置，能否往下移动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span><br><span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span><br><span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span><br><span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br><span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span><br>largest = arr[largest] &gt; arr[index] ? largest : index;<br><span class="hljs-keyword">if</span> (largest == index) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>swap(arr, largest, index);<br>index = largest;<br>left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组的扩容代价"><a href="#数组的扩容代价" class="headerlink" title="数组的扩容代价"></a>数组的扩容代价</h4><p>在某一个时刻，当数组大小不够使用的时候，会存在一个扩容代价，即将源数组拷贝到新数组的过程。但是平摊下来，时间复杂度很低。扩容通常是成倍扩容的，即1，2，4…这种形式。当加入N个数时，扩容的次数为$log_2N$次，而每次扩容需要<code>O(n)</code>代价，总代价为$log_2N<em>O(N)$。平摊下来，每加入一个数为$log_2N</em>O(N)&#x2F;N$。即加入一个数时间复杂度仍为<code>O(logn)</code>。</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序主要利用 heapInsert 和 heapify 两种操作，主要思想是先建立大根堆，让整个数组变成大根堆结构，然后将堆的最大值和堆末尾的值交换，减小堆的大小 heapSize 之后，再重新将剩下的调整为大根堆，一直周而复始。堆的大小减小成 0 之后，排序完成。在这个过程中，大根堆的根节点就是数组的最大值，可以直接放入堆尾，并将堆范围缩小（表示该元素排好序了）。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae138de589"></p><p>建立大根堆的过程根据用户给数据的方式（一个一个给还是全部一起给）有两种方式，前者利用 heapInsert ，后者利用 heapify。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>    <span class="hljs-comment">//建立堆的两种方式</span><br>    <span class="hljs-comment">// O(NlogN)复杂度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span><br>heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span><br>&#125;<br>    <span class="hljs-comment">// O(N)复杂度</span><br><span class="hljs-comment">// for(int i = arr.length -1; i &gt;=0; i--) &#123;</span><br><span class="hljs-comment">// heapify(arr, i, arr.length);</span><br><span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//循环弹出堆顶元素并heapify</span><br>    <span class="hljs-comment">// O(NlogN)复杂度</span><br><span class="hljs-type">int</span> <span class="hljs-variable">heapSize</span> <span class="hljs-operator">=</span> arr.length;<br>swap(arr, <span class="hljs-number">0</span>, --heapSize);<span class="hljs-comment">//相当于弹出堆顶元素</span><br><span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span><br>heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span><br>swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>堆排序的优势在于无论是入堆一个元素<code>heapInsert</code>还是出堆一个元素之后的<code>heapify</code>都不是将整个样本遍历一遍（<code>O(n)</code>级别的操作），而是树层次上的遍历（<code>O(logn)</code>级别的操作）。</p><p>这样的话堆排序过程中，建立堆的时间复杂度为<code>O(nlogn)</code>，循环弹出堆顶元素并<code>heapify</code>的时间复杂度为<code>O(nlogn)</code>，整个堆排序的时间复杂度为<code>O(nlogn)</code>，额外空间复杂度为<code>O(1)</code>。</p><blockquote><p>优先级队列结构（比如Java中的<code>PriorityQueue</code>）就是堆结构。</p></blockquote><h4 id="堆结构和堆排序扩展题目"><a href="#堆结构和堆排序扩展题目" class="headerlink" title="堆结构和堆排序扩展题目"></a>堆结构和堆排序扩展题目</h4><p>1）已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br><span class="hljs-comment">// 默认小根堆</span><br>PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length, k); index++)&#123;<br>heap.add(arr[index]);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;<br>heap.add(arr[index]);<br>arr[i] = heap.poll();<br>&#125;<br><span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>arr[i++] = heap.poll();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2）一个数据流中，随时可以取得中位数。</p><p>准备一个大根堆和一个小根堆，第一个数先进大根堆，之后进来的数 num 和大根堆堆顶的数 a 进行比较，如果 num&lt;&#x3D;a，则 num 进入大根堆，否则进入小根堆。然后检查大根堆和小根堆中数的数量的差值，如果差值为 2，则从较多数量的那个堆中拿出堆顶进入另一个堆。</p><p>按照上述规则进行后，较小的 2&#x2F;N 个数按照大根堆组织，较大的 2&#x2F;N 个数按照小根堆组织，即可利用两个堆的堆顶求出中位数。</p><ul><li>如果两个堆的 size 不一样，则 size 较大的堆顶即为中位数。</li><li>如果两个堆的 size 一样，则两个堆顶相加除以 2 即为中位数。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145122.png" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianHolder</span> &#123;<br><span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeapComparator</span>());<br><span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MinHeapComparator</span>());<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyTwoHeapsSize</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.maxHeap.size() == <span class="hljs-built_in">this</span>.minHeap.size() + <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">this</span>.minHeap.add(<span class="hljs-built_in">this</span>.maxHeap.poll());<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.minHeap.size() == <span class="hljs-built_in">this</span>.maxHeap.size() + <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">this</span>.maxHeap.add(<span class="hljs-built_in">this</span>.minHeap.poll());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 大根堆为空是进入第一个数的情况</span><br><span class="hljs-keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek()) &#123;<br>maxHeap.add(num);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>minHeap.add(num);<br>&#125;<br>        <span class="hljs-comment">// 检查差值是否为2</span><br>modifyTwoHeapsSize();<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getMedian</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxHeapSize</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.maxHeap.size();<br><span class="hljs-type">int</span> <span class="hljs-variable">minHeapSize</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.minHeap.size();<br><span class="hljs-keyword">if</span> (maxHeapSize + minHeapSize == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">maxHeapHead</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.maxHeap.peek();<br><span class="hljs-type">Integer</span> <span class="hljs-variable">minHeapHead</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.minHeap.peek();<br><span class="hljs-keyword">if</span> (maxHeapSize == minHeapSize) &#123;<br><span class="hljs-keyword">return</span> (maxHeapHead + minHeapHead) / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">return</span> maxHeapSize &gt; minHeapSize ? maxHeapHead : minHeapHead;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeapComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br><span class="hljs-keyword">if</span> (o2 &gt; o1) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinHeapComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br><span class="hljs-keyword">if</span> (o2 &lt; o1) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="荷兰国旗问题和快速排序"><a href="#荷兰国旗问题和快速排序" class="headerlink" title="荷兰国旗问题和快速排序"></a>荷兰国旗问题和快速排序</h3><h4 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h4><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><p>给定一个数组arr，和一个数num，请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边。要求额外空间复杂O(1)，时间复杂度O(N)。</p><p>思路：划分一个<code>&lt;=</code>区，遍历数组，将当前数与区分值进行比较。若当前值<code>&lt;=</code>区分值，将当前数与<code>&lt;=</code>区下一个数交换，<code>&lt;=</code>区往右扩一个位置，当前数跳下一个位置。若当前数<code>&gt;</code>区分值，<code>&lt;=</code>区不扩，当前数跳下一个。相当于<code>&lt;=</code>区推着<code>&gt;</code>区往右走。</p><h5 id="问题二-荷兰国旗问题"><a href="#问题二-荷兰国旗问题" class="headerlink" title="问题二(荷兰国旗问题)"></a>问题二(荷兰国旗问题)</h5><p>给定一个数组arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。</p><p>思路：划分一个<code>&lt;</code>区和一个<code>&gt;</code>区，遍历数组，将当前数与划分值进行比较。若当前值<code>&lt;</code>划分值，将当前数与<code>&lt;</code>区下一个数交换，<code>&lt;</code>区往右扩一个位置，当前数跳下一个位置。若当前数<code>=</code>划分值，当前数直接跳下一个。若当前数<code>&gt;</code>划分值，将当前数与<code>&gt;</code>区前一个数交换，<code>&gt;</code>区向左扩一个位置，当前数停在原地不动。相当于<code>&lt;</code>区推着<code>=</code>区往右走。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 荷兰国旗问题，分3块儿</span><br><span class="hljs-comment">// 在arr[L...R]范围上，根据p分块，&lt;p在左边，==p在中间，&gt;p在右边</span><br><span class="hljs-comment">//返回值含义：一定会返回一个长度为2的数组，记录等于区域的左边界和右边界</span><br><span class="hljs-comment">// arr=[...3 5 5 4 6 7...]</span><br><span class="hljs-comment">// index:  4 5 6 7 8 9</span><br><span class="hljs-comment">// p=5</span><br><span class="hljs-comment">// arr=[...(34)5 5(67)...]</span><br><span class="hljs-comment">//             6 7</span><br><span class="hljs-comment">//返回一个长度为2的数组[6,7]</span><br><span class="hljs-comment">//如果无等于区域，返回值左边界&gt;右边界</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> p) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区的右边界</span><br><span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R + <span class="hljs-number">1</span>; <span class="hljs-comment">// &gt;区的左边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> L;<br><span class="hljs-keyword">while</span> (index &lt; more) &#123; <br><span class="hljs-keyword">if</span> (arr[index] &lt; p) &#123;<br>swap(arr, ++less, index++);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &gt; p) &#123;<br>swap(arr, --more, index);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>index++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>less</code>代表小于<code>num</code>的数的右界，<code>more</code>代表大于<code>num</code>的左界，<code>partition</code>的过程就是遍历元素、不断壮大<code>less、more</code>范围的过程。这里比较难理解的地方可能是为什么<code>arr[index]&lt;num</code>时要右移<code>index</code>而<code>arr[index]&gt;num</code>时却不需要。这是因为对于当前元素<code>arr[index]</code>，如果<code>arr[index]&lt;num</code>时进行<code>swap</code>之后对于当前下标的数据状况是知晓的（一定有<code>arr[index]=arr[less+1]</code>），因为是从头遍历到<code>i</code>的，而<code>less+1&lt;=i</code>。但是如果<code>arr[index]&gt;num</code>进行<code>swap</code>之后对于当前元素的数据状况是不清楚的，因为<code>more-1&gt;=i</code>，<code>arr[more-1]</code>还没遍历到。</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h5><p>将数组的最后一个值作为划分值<code>p</code> ，然后将前面的数进行<code>partition</code> 过程，<code>&lt;=p</code>的放左边，<code>&gt;p</code>的放右边。接着将最后一个数<code>p</code> 与<code>&gt;p</code>的第一个数交换，形成 <code>&lt;=p、p、&gt;p</code>的形式，然后对<code>&lt;=p</code>和<code>&gt;p</code>的区域递归重复执行上述过程。每次递归搞定一个数，最终形成有序。</p><p>快排1.0的时间复杂度与数据状况有关，如果<strong>每一次</strong><code>partition</code>时，尾元素都是序列中最大或最小的，那么去除该元素序列并未给我们划分为样本量相同的左右两个子序列，而是只安排好了一个元素（划分值<code>p</code>），这样的话时间复杂度就是<code>O(n-1+n-2+……+1)=O(n^2)</code>；但如果每一次<code>partition</code>时，都将序列分成了两个样本量相差无几的左右两个子序列，那么时间复杂度就是<code>O(nlogn)</code>（使用Master公式求解）。</p><h5 id="快排2-0（荷兰国旗问题引发的改进）"><a href="#快排2-0（荷兰国旗问题引发的改进）" class="headerlink" title="快排2.0（荷兰国旗问题引发的改进）"></a>快排2.0（荷兰国旗问题引发的改进）</h5><p>将数组的最后一个值作为划分值<code>p</code> ，然后将前面的数进行<code>partition</code> 过程，<code>&lt;p</code>的放左边，<code>=p</code>的放中间，<code>&gt;p</code>的放右边。接着将最后一个数<code>p</code> 与<code>&gt;p</code>的第一个数交换，形成 <code>&lt;=p、=p、&gt;p</code>的形式，然后对<code>&lt;p</code>和<code>&gt;p</code>的区域递归重复执行上述过程。每次递归搞定一组<code>=p</code>的数 ，最终形成有序。</p><p>快排2.0与快排1.0相比，每一次递归<code>partition</code> 都搞定了一组数（<code>=p</code>的区域），而不是一个数，有了一定的优化。但是只是常数时间的优化，实质还要看数据状况（最好的情况为<code>O(nlogn)</code>，最坏的情况为<code>O(n^2)</code>）。</p><h5 id="快排3-0-随机快排-——O-nlogn"><a href="#快排3-0-随机快排-——O-nlogn" class="headerlink" title="快排3.0(随机快排)——O(nlogn)"></a>快排3.0(随机快排)——<code>O(nlogn)</code></h5><p>快排1.0和快排2.0都是以最后一个数作为划分值，随机快排则等概率的挑选一个数，人为的放到最后一个位置上去，再进行<code>partition</code>过程，从而避免了每一轮选择尾元素会受数据状况的影响的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// arr[l..r]排好序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br><span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>         swap(arr, L + (<span class="hljs-type">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);<br><span class="hljs-type">int</span>[] p = partition(arr, L, R);<span class="hljs-comment">// 返回等于区域的左边界和右边界</span><br>quickSort(arr, L, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>); <span class="hljs-comment">// &lt; 区</span><br>quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// &gt; 区</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 这是一个处理arr[l..r]的函数</span><br><span class="hljs-comment">// 默认以arr[r]做划分，arr[r] -&gt; p     &lt;p   ==p   &gt;p</span><br><span class="hljs-comment">// 返回等于区域(左边界，右边界), 所以返回一个长度为2的数组res, res[0] res[1]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区右边界</span><br><span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R; <span class="hljs-comment">// &gt;区左边界</span><br><span class="hljs-keyword">while</span> (L &lt; more) &#123; <span class="hljs-comment">// L表示当前数的位置   arr[R]  -&gt;  划分值</span><br><span class="hljs-keyword">if</span> (arr[L] &lt; arr[R]) &#123; <span class="hljs-comment">// 当前数   &lt;  划分值</span><br>swap(arr, ++less, L++);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[L] &gt; arr[R]) &#123; <span class="hljs-comment">// 当前数   &gt;  划分值</span><br>swap(arr, --more, L);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>L++;<br>&#125;<br>&#125;<br>swap(arr, more, R);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>快排1.0和快排2.0都能很轻易的举出最坏情况的例子，因此实质是<code>O(n^2)</code>的算法。而随机快排每一轮<code>partition</code>选出的作为比较对象的数是随机的，因此好情况和坏情况都是概率事件，每种情况占<code>1/N</code>的概率，其数学期望最终收敛于<code>O(nlogn)</code>，因此随机快排的时间复杂度为<code>O(nlogn)</code>。</p><p>随机快排需要记录<code>p</code>的位置，从而执行递归过程，因此需要<code>O(logn)</code>的额外空间复杂度。快排1.0和快排2.0最好情况为<code>O(logn)</code>，最差情况为<code>O(N)</code>。</p><blockquote><p>事实上，为了让算法中的操作不依托于数据状况（如快排中每一次<code>partition</code>取尾元素作为比较，这就没有规避样本的数据状况，如果尾元素是最大或最小值就成了最坏情况）常常有两种做法：</p><p>1、使用随机取数</p><p>2、将样本数据哈希打乱</p></blockquote><h3 id="比较器的使用"><a href="#比较器的使用" class="headerlink" title="比较器的使用"></a>比较器的使用</h3><p>之前所讲的一些算法大都是对基本类型的排序，但实际工程中要排序的对象可能是无法预测的，那么如何实现一个通用的排序算法以应对呢？事实上，之前的排序都可以归类为<strong>基于比较的排序</strong>。也就是说我们只需要对要比较的对象实现一个比较器，然后排序算法基于比较器来排序，这样算法和具体要排序的对象之间就解耦了。以后在排序之前，基于要排序的对象实现一个比较器（定义了如何比较对象大小的逻辑），然后将比较器丢给排序算法即可，这样就实现了复用。</p><p>在<code>Java</code>中，这个比较器就是<code>Comparator</code>接口，我们需要实现其中的<code>compare</code>方法，对于要排序的对象集合定义一个比较大小的逻辑，然后在构造用来添加这类对象的有序容器时传入这个构造器即可。封装好的容器会在容器元素发生改变时使用我们的比较器来重新组织这些元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>         <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.id = id;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>        <br>    &#125;<br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt; &#123;<br><br><span class="hljs-comment">// 对于任意比较器，首先需要指定两个对象:o1,o2;</span><br>         <span class="hljs-comment">// 返回值有统一的规范：</span><br>         <span class="hljs-comment">// 返回负数时：认为o1应该排在o2的前面</span><br>         <span class="hljs-comment">// 返回正数时：认为o2应该排在o1的前面</span><br>         <span class="hljs-comment">// 返回0时：谁排前面都可以</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br><span class="hljs-keyword">return</span> o2.id - o1.id;<br>&#125;<br><br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//大根堆，默认小根堆</span><br>        PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdAscendingComparator</span>());<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);<br>        heap.add(a);<br>        heap.add(b);<br>        heap.add(c);<br>        <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>            System.out.println(heap.poll());<span class="hljs-comment">//弹出并返回堆顶元素</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有<code>TreeSet</code>等，都是在构造是传入比较器，否则将直接根据元素的值（<code>Java</code>中引用类型变量的值为地址，比较将毫无意义）来比较，这里就不一一列举了。</p><blockquote><p>总结：</p><p>1）比较器的实质就是重载比较运算符。<br>2）比较器可以很好的应用在特殊标准的排序上。<br>3）比较器可以很好的应用在根据特殊标准排序的结构上。</p></blockquote><h3 id="桶排序思想下的排序"><a href="#桶排序思想下的排序" class="headerlink" title="桶排序思想下的排序"></a>桶排序思想下的排序</h3><p>之前的都是基于比较的排序，也即通过比较确定每个元素所处的位置。那么能不能不比较而实现排序呢？这就涉及到了 <strong>桶排序</strong> 这个方法论：准备一些桶，将序列中的元素按某些规则放入对应的桶中，最后根据既定的规则依次倒出桶中的元素。</p><blockquote><p>桶排序思想下的排序都是不基于比较的排序，其应用范围有限，需要样本的数据状况满足桶的划分。所以实际中并不经常使用。</p></blockquote><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序是 <strong>桶排序</strong> 方法论的一种实现，即准备一个与序列中元素的数据范围大小相同的数组，然后遍历序列，将遇到的元素作为数组的下标并将该位置上的数加1。其适用于数据范围小（最大值和最小值相差不大）的数组排序，比如0~200.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// only for 0~200 value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>max = Math.max(max, arr[i]);<br>&#125;<br><span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>bucket[arr[i]]++;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;<br><span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;<br>arr[i++] = j;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序只适用于十进制的无符号整数进行排序。其主要思想是，先找到位数最多的数，不足该位数的数字前面补0.然后准备10个桶（队列结构，保证先进桶的先出），先根据数字的个位决定进入哪个桶，全部进桶之后再从左到右依次倒出回原数组，即按照个位数字排序。再根据数字的十位进桶，进行同样的操作，再按数字的百位进桶，进行同样的操作。依此类推，最后达到全局有序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// only for no-negative value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxbits</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>max = Math.max(max, arr[i]);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>res++;<br>max /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// arr[L..R]排序，digit:最大的数字有多少个十进制位</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 有多少个数准备多少个辅助空间</span><br><span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span><br><br><span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[radix]; <span class="hljs-comment">// count[0..9]，固定的，统计数组</span><br><span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;<br>            <span class="hljs-comment">//example:</span><br>            <span class="hljs-comment">//arr[022,021,032,031,001,100]</span><br>            <span class="hljs-comment">//按个位时：</span><br>            <span class="hljs-comment">//count[1 3 2 0 0 0 0 0 0 0]</span><br>            <span class="hljs-comment">//......0 1 2 3 4 5 6 7 8 9]</span><br>            <span class="hljs-comment">//含义：个位数字为0的有几个，个位数字为1的有几个...</span><br>            <span class="hljs-comment">//d:从右往左第几位的数</span><br>j = getDigit(arr[i], d);<br>            <span class="hljs-comment">//做词频统计</span><br>count[j]++;<br>&#125;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;<br>            <span class="hljs-comment">//example:</span><br>            <span class="hljs-comment">//按个位时：</span><br>            <span class="hljs-comment">//count[1 4 6 6 6 6 6 6 6 6]</span><br>            <span class="hljs-comment">//......0 1 2 3 4 5 6 7 8 9]</span><br>            <span class="hljs-comment">//含义：个位数字&lt;=0的有几个，个位数字&lt;=1的有几个</span><br>   <span class="hljs-comment">// 10个空间</span><br>   <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span><br>   <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span><br>   <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span><br>   <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span><br>count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;<br>            <span class="hljs-comment">//从右往左遍历数组</span><br>j = getDigit(arr[i], d);<br>            <span class="hljs-comment">//放入0~count[j]-1范围的的最后位置</span><br>bucket[count[j] - <span class="hljs-number">1</span>] = arr[i];<br>            <span class="hljs-comment">//词频变小</span><br>count[j]--;<br>&#125;<br><span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;<br>            <span class="hljs-comment">//拷贝回原数组</span><br>arr[i] = bucket[j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> &#123;<br><span class="hljs-keyword">return</span> ((x / ((<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>基数排序的代码用了非常精细的设计代替了生成10个队列的实现方式。通过给数字划片的方式依次从每一片的右侧开始填起，往左填。</p><p>桶排序思想下的排序时间复杂度为<code>O(N)</code>，额外空间复杂度为<code>O(M)</code>。</p><blockquote><p>如果下次面试官问你有没有时间复杂度比<code>O(NlogN)</code>更优的排序算法时，不要忘了桶排序（计数排序和基数排序）哦！！！</p></blockquote><h4 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h4><p>给定一个数组，求如果排序后，相邻两数的最大值，要求时间复杂度为<code>O(N)</code>，且要求不能用非基于比较的排序。</p><p>这道题的思路比较巧妙：首先为这N个数准备N+1个桶，然后以其中的最小值和最大值为边界将数值范围均分成N等分，然后遍历数组将对应范围类的数放入对应的桶中，下图以数组长度为9举例。</p><p><img src="https://user-gold-cdn.xitu.io/2019/2/19/169045ae2427ea5e?w=784&h=340&f=jpeg&s=131998"></p><p>这里比较难理解的是：</p><p>题目问的是求<strong>如果排序后，相邻两数的最大差值</strong>。该算法巧妙的借助一个空桶（N个数进N+1个桶，必然有一个是空桶），将问题转向了求<strong>两个相邻非空桶</strong>（其中可能隔着若干个空桶）之间前桶的最大值和后桶最小值的差值，而无需在意每个桶中进了哪些数（<strong>只需记录每个桶入数的最大值和最小值以及是否有数</strong>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxGap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br><span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-comment">//找出最大最小值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>min = Math.min(min, nums[i]);<br>max = Math.max(max, nums[i]);<br>&#125;<br><span class="hljs-keyword">if</span> (min == max) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <span class="hljs-comment">//记录每个桶的最大最小值以及是否有数，初始时每个桶都没数</span><br><span class="hljs-type">boolean</span>[] hasNum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] maxs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span>[] mins = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">bid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//bucket id</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>bid = bucket(nums[i], len, min, max);<br>        <span class="hljs-comment">//如果桶里没数，则该数入桶后，最大最小值都是它，否则更新最大最小值</span><br>mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];<br>maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];<br>hasNum[bid] = <span class="hljs-literal">true</span>;<br>&#125;<br>    <span class="hljs-comment">//find the max gap between two nonEmpty buckets</span><br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">lastMax</span> <span class="hljs-operator">=</span> maxs[<span class="hljs-number">0</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (; i &lt;= len; i++) &#123;<br><span class="hljs-keyword">if</span> (hasNum[i]) &#123;<br>            <span class="hljs-comment">//the last bucket must has number</span><br>res = Math.max(res, mins[i] - lastMax);<br>lastMax = maxs[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bucket</span><span class="hljs-params">(<span class="hljs-type">long</span> num, <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> min, <span class="hljs-type">long</span> max)</span> &#123;<br>    <span class="hljs-comment">//根据要入桶的数和最大最小值得到对应桶编号</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((num - min) * len / (max - min));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序算法的稳定性及其汇总"><a href="#排序算法的稳定性及其汇总" class="headerlink" title="排序算法的稳定性及其汇总"></a>排序算法的稳定性及其汇总</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>排序算法的稳定性指的是排序前后是否维持值相同的元素在序列中的相对次序。同样值的个体之间，如果不因为排序而改变相对次序，这个排序就是有稳定性的；否则就没有。如序列<code>271532</code>，在排序过程中如果能维持第一次出现的<code>2</code>在第二次出现的<code>2</code>的前面，那么该排序算法能够保证稳定性。首先我们来分析一下前面所讲排序算法的稳定性，再来谈谈稳定性的意义。</p><ul><li><strong>选择排序</strong>：无法保证稳定性，比如序列<code>926532</code>，在第一轮<code>maxIndex</code>的选择出来之后（<code>maxIndex=0</code>），第二次出现的<code>2</code>（尾元素）将与<code>9</code>交换位置，那么两个<code>2</code>的相对次序就发生了变化，破坏了排序的稳定性。</li><li><strong>冒泡排序</strong>：可以保证稳定性，只需在比较相邻两个数时只在后一个数比前一个数大的情况下才交换位置即可，即相等不交换。</li><li><strong>插入排序</strong>：可以保证稳定性，每次插入一个数到有序序列中时，遇到比它大的就替换，否则不替换。这样的话，值相同的元素，后面插入的就总在前面插入的后面了。</li><li><strong>归并排序</strong>：可以保证稳定性，在左右两半子序列排好序后的<code>merge</code>过程中，比较大小时如果相等，那么优先插入左子序列中的数。</li><li><strong>堆排序</strong>：不能保证稳定性。二叉树如果交换位置的结点是相邻层次的可以保证稳定性，但堆排序中弹出堆顶元素后的<code>heapify</code>交换的是第一层的结点和最后一层的结点。</li><li><strong>快速排序</strong>：不能保证稳定性，因为<code>partition</code>的过程会将比<code>num</code>小的数与<code>&lt;</code>区域的右一个数交换位置，将比<code>num</code>大的与<code>&gt;</code>区域的左一个数交换位置，而<code>&lt;</code>区、<code>&gt;</code>区位于序列两侧，很容易打乱值相同元素的相对次序，破坏了稳定性。</li><li><strong>一切桶排序思想下的排序</strong>：可以保证稳定性，按对应规则入桶时保证先进桶的先出，就不会打乱相同元素的相对次序。</li></ul><p>维持稳定性一般是为了满足业务需求。假设下面是一张不同厂商下同一款产品的价格和销售情况表：</p><table><thead><tr><th align="left">品牌</th><th align="left">价格</th><th align="left">销量</th></tr></thead><tbody><tr><td align="left">三星</td><td align="left">1603</td><td align="left">92</td></tr><tr><td align="left">小米</td><td align="left">1603</td><td align="left">74</td></tr><tr><td align="left">vivo</td><td align="left">1604</td><td align="left">92</td></tr></tbody></table><p>要求先按价格排序，再按销量排序。如果保证稳定性，那么排序后应该是这样的：</p><table><thead><tr><th align="left">品牌</th><th align="left">价格</th><th align="left">销量</th></tr></thead><tbody><tr><td align="left">三星</td><td align="left">1603</td><td align="left">92</td></tr><tr><td align="left">vivo</td><td align="left">1604</td><td align="left">92</td></tr><tr><td align="left">小米</td><td align="left">1603</td><td align="left">74</td></tr></tbody></table><p>即按销量排序后，销量相同的两条记录会保持之前的按价格排序的状态，这样先前的价格排序这个工作就没白做。</p><h4 id="排序算法时间复杂度、额外空间复杂度、稳定性汇总"><a href="#排序算法时间复杂度、额外空间复杂度、稳定性汇总" class="headerlink" title="排序算法时间复杂度、额外空间复杂度、稳定性汇总"></a>排序算法时间复杂度、额外空间复杂度、稳定性汇总</h4><table><thead><tr><th align="center"></th><th align="center">时间复杂度</th><th align="center">额外空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">选择排序</td><td align="center">O(N^2)​</td><td align="center">O(1)​</td><td align="center">×</td></tr><tr><td align="center">冒泡排序</td><td align="center">O(N^2)​</td><td align="center">O(1)​</td><td align="center">√</td></tr><tr><td align="center">插入排序</td><td align="center">O(N^2)​</td><td align="center">O(1)​</td><td align="center">√</td></tr><tr><td align="center">归并排序</td><td align="center">O(N*logN)​</td><td align="center">O(N)​</td><td align="center">√</td></tr><tr><td align="center">堆排序</td><td align="center">O(N*logN)​</td><td align="center">O(1)​</td><td align="center">×</td></tr><tr><td align="center">快速排序</td><td align="center">O(N*logN)​</td><td align="center">O(logN)​</td><td align="center">×</td></tr><tr><td align="center">桶排序</td><td align="center">O(N)​</td><td align="center">O(N)​</td><td align="center">√</td></tr></tbody></table><p>具体选择哪个排序算法需要看具体需求：</p><ul><li><strong>快速排序</strong>：不追求稳定性，只追求时间复杂度指标最优，其常数时间最优。</li><li><strong>堆排序</strong>：追求额外空间复杂度最少。</li><li><strong>归并排序</strong>：追求稳定性。</li></ul><blockquote><p>目前没有找到时间复杂度<code>O(nlogn)</code>，额外空间复杂度低于<code>O(n)</code>，又稳定的排序。</p></blockquote><h3 id="有关排序问题常见的坑"><a href="#有关排序问题常见的坑" class="headerlink" title="有关排序问题常见的坑"></a>有关排序问题常见的坑</h3><ul><li>归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法”。</li><li>“原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成<code>O(n^2)</code></li><li>快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜<code>01 stable sort</code>（论文）。</li><li>所有的改进都不重要，因为目前没有找到时间复杂度<code>O(nlogn)</code>，额外空间复杂度低于<code>O(n)</code>，又稳定的排序。</li><li>有一道题目，是奇数放在数组左边，偶数放在数组右边，要求原始的相对次序不变，还要求时间复杂度<code>O(n)</code>，额外空间复杂度<code>O(1)</code>.碰到这个问题，可以怼面试官。因为此题与快速排序如出一辙，均为”01 标准排序问题”，即“一个数非奇即偶”和“一个数<code>&lt;=num</code>或<code>&gt;num</code>”。如果此题能做到，那么快排也能做到。如果不要求时间复杂度和额外空间复杂度，要使这类问题做到稳定性，要看<code>01 stable sort</code>这篇论文。</li></ul><h3 id="工程上对排序的改进"><a href="#工程上对排序的改进" class="headerlink" title="工程上对排序的改进"></a>工程上对排序的改进</h3><p>实际工程中的排序算法一般会将 <strong>归并排序</strong>、<strong>插入排序</strong>、<strong>快速排序</strong>综合起来，集大家之所长来应对不同的场景要求：</p><ul><li>稳定性的考虑：当要排序的元素为基本数据类型且样本规模较大时，将采用 <strong>快速排序</strong>；当要排序的元素为对象数据类型（包括若干字段），为保证稳定性将采用<strong>归并排序</strong>。</li><li>充分利用<code>O(nlogn)</code>和<code>O(n^2)</code>排序各自的优势：当要排序的元素为基本数据类型且元素个数较少时，直接使用 <strong>插入排序</strong>。因为在样本规模较小时（比如60），<code>O(NlogN)</code>的优势并不明显甚至不及<code>O(N^2)</code>，而在<code>O(N^2)</code>的算法中，插入排序的常数时间操作最少。因此在实际工程中，数据规模较大时整体采用<strong>快速排序</strong>，其中数据规模小于60时，内嵌<strong>插入排序</strong>。即采用以下伪代码方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br><span class="hljs-comment">//if (l == r) &#123;</span><br><span class="hljs-comment">//return;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-keyword">if</span> (l &gt; r - <span class="hljs-number">60</span>) &#123;<br>在arr[l..r]插入排序<br>O(N^<span class="hljs-number">2</span>) 小样本量的时候，跑的快<br><span class="hljs-keyword">return</span>;<br>&#125;<br>swap(arr, l + (<span class="hljs-type">int</span>) (Math.random() * (r - l + <span class="hljs-number">1</span>)), r);<br><span class="hljs-type">int</span>[] p = partition(arr, l, r);<br>quickSort(arr, l, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>); <span class="hljs-comment">// &lt; 区</span><br>quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// &gt; 区</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210118133820.png"></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试时链表解题的方法论"><a href="#面试时链表解题的方法论" class="headerlink" title="面试时链表解题的方法论"></a>面试时链表解题的方法论</h3><ol><li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度；</li><li>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法。</li></ol><blockquote><p>重要技巧：</p><ul><li>额外数据结构记录（哈希表等）</li><li>快慢指针（注意 coding 时的边界问题，奇数、偶数个结点等）</li></ul></blockquote><h3 id="1）反转单向和双向链表"><a href="#1）反转单向和双向链表" class="headerlink" title="1）反转单向和双向链表"></a>1）反转单向和双向链表</h3><p> 分别实现反转单向链表和反转双向链表的函数。要求如果链表长度为 <code>N</code>，时间复杂度要求为 <code>O(N)</code> ，额外空间复杂度要求为 <code>O(1)</code>。</p><blockquote><p>此题的难点就是反转一个结点的 <code>next</code> 指针后，就无法在该结点通过<code>next</code>指针找到后续的结点了。因此每次反转之前需要将该结点的后继结点记录下来。</p></blockquote><h4 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node next;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseList</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>next = head.next;<br>head.next = pre;<br>pre = head;<br>head = next;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反转双向链表"><a href="#反转双向链表" class="headerlink" title="反转双向链表"></a>反转双向链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleNode</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> DoubleNode last;<br><span class="hljs-keyword">public</span> DoubleNode next;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(DoubleNode head)</span> &#123;<br><span class="hljs-type">DoubleNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">DoubleNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>next = head.next;<br>head.next = pre;<br>head.last = next;<br>pre = head;<br>head = next;<br>&#125;<br><span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）打印两个有序链表的公共部分"><a href="#2）打印两个有序链表的公共部分" class="headerlink" title="2）打印两个有序链表的公共部分"></a>2）打印两个有序链表的公共部分</h3><p>给定两个有序链表的头指针 head1 和 head2，打印两个链表的公共部分。要求如果两个链表的长度之和为 N，时间复杂度要求为 O(N)，额外空间复杂度要求为 O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node next;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCommonPart</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;Common Part: &quot;</span>);<br><span class="hljs-keyword">while</span> (head1 != <span class="hljs-literal">null</span> &amp;&amp; head2 != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (head1.value &lt; head2.value) &#123;<br>head1 = head1.next;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head1.value &gt; head2.value) &#123;<br>head2 = head2.next;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.print(head1.value + <span class="hljs-string">&quot; &quot;</span>);<br>head1 = head1.next;<br>head2 = head2.next;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3）判断一个链表是否为回文结构"><a href="#3）判断一个链表是否为回文结构" class="headerlink" title="3）判断一个链表是否为回文结构"></a>3）判断一个链表是否为回文结构</h3><p>给定一个单链表的头节点 head，请判断该链表是否为回文结构。要求如果链表长度为 N，时间复杂度达到 O(N)，额外空间复杂度达到 O(1)。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">15</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">15</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure><p>单链表结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node next;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空间复杂度-O-n-做法"><a href="#空间复杂度-O-n-做法" class="headerlink" title="空间复杂度 O(n) 做法"></a>空间复杂度 O(n) 做法</h4><p>回文链表具有前后两半部分逆序的特点，与栈先进后出的特性相吻合。因此可以借助栈来解决此问题。遍历链表，将结点依次压入栈中。然后从头遍历链表，依次与栈弹出的结点相比较。如果每一步结点值都相等，则为回文结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome1</span><span class="hljs-params">(Node head)</span> &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>stack.push(cur);<br>cur = cur.next;<br>&#125;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>head = head.next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空间复杂度-O-n-x2F-2-做法"><a href="#空间复杂度-O-n-x2F-2-做法" class="headerlink" title="空间复杂度 O(n&#x2F;2) 做法"></a>空间复杂度 O(n&#x2F;2) 做法</h4><p>因为回文链表前后两部分逆序，因此可以省下一半的空间。即将链表中间结点之后的结点依次压入栈中，然后从链表头结点开始遍历链表的前半部分，将遍历的结点与栈弹出的结点相比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome2</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> head.next;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>right = right.next;<br>cur = cur.next.next;<br>&#125;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br><span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>) &#123;<br>stack.push(right);<br>right = right.next;<br>&#125;<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br><span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>head = head.next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="空间复杂度-O-1-做法——双指针"><a href="#空间复杂度-O-1-做法——双指针" class="headerlink" title="空间复杂度 O(1) 做法——双指针"></a>空间复杂度 O(1) 做法——双指针</h4><p>利用两个指针，快指针每次走两步，慢指针每次走一步。当快指针走完的时候，慢指针来到中点位置。然后将单链表右半部分逆序。然后利用 L 和 R 指针分别从链表头和尾出发，向中间推进，一一比较。为了不破坏原始数据结构，最后再将单链表恢复到原状态，即将右半部分逆序回来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome3</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//慢指针</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//快指针</span><br>        <span class="hljs-comment">//找到中间结点</span><br><span class="hljs-keyword">while</span> (n2.next != <span class="hljs-literal">null</span> &amp;&amp; n2.next.next != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// find mid node</span><br>n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span><br>n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span><br>&#125;<br>n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span><br>n1.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (n2 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// right part convert</span><br>n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span><br>n2.next = n1; <span class="hljs-comment">// next of right node convert</span><br>n1 = n2; <span class="hljs-comment">// n1 move</span><br>n2 = n3; <span class="hljs-comment">// n2 move</span><br>&#125;<br>n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span><br>n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (n1 != <span class="hljs-literal">null</span> &amp;&amp; n2 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// check palindrome</span><br><span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;<br>res = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>n1 = n1.next; <span class="hljs-comment">// left to mid</span><br>n2 = n2.next; <span class="hljs-comment">// right to mid</span><br>&#125;<br>n1 = n3.next;<br>n3.next = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (n1 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// recover list</span><br>n2 = n1.next;<br>n1.next = n3;<br>n3 = n1;<br>n1 = n2;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题"><a href="#4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题" class="headerlink" title="4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题"></a>4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题</h3><p>给定一个单链表的头节点 head，节点的值类型是整型，再给定一个整数 pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。</p><p>单链表结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node next;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="借助数组"><a href="#借助数组" class="headerlink" title="借助数组"></a>借助数组</h4><p>将链表中的所有结点放入一个数组中，那么就转换成了荷兰国旗问题，进行<code>partition</code> 过程，最后再将数组中的结点重新连接起来。但这种做法会使用 O(N) 的额外空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> pivot)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (head == null) &#123;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>Node cur = head;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur != null) &#123;<br>i++;<br>cur = cur.next;<br>&#125;<br>Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];<br>i = <span class="hljs-number">0</span>;<br>cur = head;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;<br>nodeArr[i] = cur;<br>cur = cur.next;<br>&#125;<br><span class="hljs-built_in">arrPartition</span>(nodeArr, pivot);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;<br>nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];<br>&#125;<br>nodeArr[i - <span class="hljs-number">1</span>].next = null;<br><span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-type">int</span> pivot)</span> </span>&#123;<br><span class="hljs-type">int</span> small = <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> big = nodeArr.length;<br><span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (index != big) &#123;<br><span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;<br><span class="hljs-built_in">swap</span>(nodeArr, ++small, index++);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;<br>index++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">swap</span>(nodeArr, --big, index);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>Node tmp = nodeArr[a];<br>nodeArr[a] = nodeArr[b];<br>nodeArr[b] = tmp;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>在实现原问题功能的基础上增加如下的要求：</p><ul><li>调整后所有小于 pivot 的节点之间的相对顺序和调整前一样；</li><li>调整后所有等于 pivot 的节点之间的相对顺序和调整前一样；</li><li>调整后所有大于pivot 的节点之间的相对顺序和调整前一样；</li><li>时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)。</li></ul><p>思路：分出逻辑上的 small,equal,big 三个区域，用六个变量，即 small 区域的头和尾，equal 区域的头和尾，big 区域的头和尾表示。遍历链表结点将其添加到对应的区域中，最后再将这三个区域连起来。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095806.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> pivot)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">sH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// small head</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">sT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// small tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">eH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// equal head</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">eT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// equal tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// big head</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">mT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// big tail</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// save next node</span><br><span class="hljs-comment">// every node distributed to three lists</span><br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>next = head.next;<br>head.next = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;<br><span class="hljs-keyword">if</span> (sH == <span class="hljs-literal">null</span>) &#123;<br>sH = head;<br>sT = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sT.next = head;<br>sT = head;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;<br><span class="hljs-keyword">if</span> (eH == <span class="hljs-literal">null</span>) &#123;<br>eH = head;<br>eT = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>eT.next = head;<br>eT = head;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (mH == <span class="hljs-literal">null</span>) &#123;<br>mH = head;<br>mT = head;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mT.next = head;<br>mT = head;<br>&#125;<br>&#125;<br>head = next;<br>&#125;<br><span class="hljs-comment">// small and equal reconnect</span><br><span class="hljs-keyword">if</span> (sT != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span><br>sT.next = eH;<br>eT = eT == <span class="hljs-literal">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span><br>&#125;<br><span class="hljs-comment">// 上面的if，不管跑了没有，et</span><br><span class="hljs-comment">// all reconnect</span><br><span class="hljs-keyword">if</span> (eT != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span><br>eT.next = mH;<br>&#125;<br><span class="hljs-keyword">return</span> sH != <span class="hljs-literal">null</span> ? sH : (eH != <span class="hljs-literal">null</span> ? eH : mH);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）复制含有随机指针节点的链表——深度拷贝"><a href="#5）复制含有随机指针节点的链表——深度拷贝" class="headerlink" title="5）复制含有随机指针节点的链表——深度拷贝"></a>5）复制含有随机指针节点的链表——深度拷贝</h3><p>一种特殊的单链表节点类描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> value;<br>Node next;<br>Node rand;<br>Node(<span class="hljs-type">int</span> val) &#123;<br>value = val;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>rand 指针是单链表节点结构中新增的指针，rand 可能指向链表中的任意一个节点，也可能指向null。给定一个由 Node 节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。要求时间复杂度 O(N)，额外空间复杂度 O(1)。</p><h4 id="借助哈希表"><a href="#借助哈希表" class="headerlink" title="借助哈希表"></a>借助哈希表</h4><p>遍历链表，建立一张 Hashmap，将链表的所有结点复制一份，存储到哈希表中（key 为原链表的结点，value 为新链表的结点，即复制结点）。再遍历原链表，借助哈希表查表的方式拷贝 next 和 random 指针，如下图所示。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724102716.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">copyListWithRand1</span><span class="hljs-params">(Node head)</span> &#123;<br>HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Node, Node&gt;();<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>map.put(cur, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.value));<br>cur = cur.next;<br>&#125;<br>cur = head;<br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// cur 老</span><br><span class="hljs-comment">// map.get(cur) 新</span><br>map.get(cur).next = map.get(cur.next);<br>map.get(cur).rand = map.get(cur.rand);<br>cur = cur.next;<br>&#125;<br><span class="hljs-keyword">return</span> map.get(head);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进阶——额外空间-O-1"><a href="#进阶——额外空间-O-1" class="headerlink" title="进阶——额外空间 O(1)"></a>进阶——额外空间 O(1)</h4><p>将复制结点追加到对应源结点之后，建立复制结点的 random 指针域，最后将复制结点从该链表中分离出来。即利用结点的位置摆放关系代替了哈希表的作用。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724104322.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">copyListWithRand2</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// copy node and link to every node</span><br><span class="hljs-comment">// 1 -&gt; 2</span><br><span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span><br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>next = cur.next;<br>cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.value);<br>cur.next.next = next;<br>cur = next;<br>&#125;<br>cur = head;<br><span class="hljs-type">Node</span> <span class="hljs-variable">curCopy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// set copy node rand</span><br><span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span><br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>next = cur.next.next;<br>curCopy = cur.next;<br>curCopy.rand = cur.rand != <span class="hljs-literal">null</span> ? cur.rand.next : <span class="hljs-literal">null</span>;<br>cur = next;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.next;<br>cur = head;<br><span class="hljs-comment">// split</span><br><span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>next = cur.next.next;<br>curCopy = cur.next;<br>cur.next = next;<br>curCopy.next = next != <span class="hljs-literal">null</span> ? next.next : <span class="hljs-literal">null</span>;<br>cur = next;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6）两个单链表相交的一系列问题"><a href="#6）两个单链表相交的一系列问题" class="headerlink" title="6）两个单链表相交的一系列问题"></a>6）两个单链表相交的一系列问题</h3><p>给定两个可能有环也可能无环的单链表，头节点 head1 和 head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回 null。要求如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)。</p><p>单链表结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node next;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上问题可以分解为三个子问题：</p><h4 id="判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空"><a href="#判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空" class="headerlink" title="判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空"></a>判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空</h4><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141346.jpeg"></p><h5 id="借助-hashset"><a href="#借助-hashset" class="headerlink" title="借助 hashset"></a>借助 hashset</h5><p>遍历链表，如果链表结点不在 hashset 中，就添加进去。如果链表有环，则第一个重复的结点即为入环结点，如果无环，则会遍历到空。</p><h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>准备快慢指针，快指针从第三个结点出发，每次走两步，慢指针从第二个结点出发，每次走一步。当快指针遍历到空时，链表无环，否则快慢指针必会在环上相遇。当快慢指针相遇时，快指针回到链表头节点，每次走一步，慢指针停在相遇的位置，每次走一步。当快慢指针再次相遇的时候，则相遇结点为入环结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLoopNode</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> head.next; <span class="hljs-comment">// n1 -&gt; slow</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span><br><span class="hljs-keyword">while</span> (n1 != n2) &#123;<br><span class="hljs-keyword">if</span> (n2.next == <span class="hljs-literal">null</span> || n2.next.next == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>n2 = n2.next.next;<br>n1 = n1.next;<br>&#125;<br>n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span><br><span class="hljs-keyword">while</span> (n1 != n2) &#123;<br>n1 = n1.next;<br>n2 = n2.next;<br>&#125;<br><span class="hljs-keyword">return</span> n1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回两个无环链表的第一个相交结点"><a href="#返回两个无环链表的第一个相交结点" class="headerlink" title="返回两个无环链表的第一个相交结点"></a>返回两个无环链表的第一个相交结点</h4><h5 id="借助-hashset-1"><a href="#借助-hashset-1" class="headerlink" title="借助 hashset"></a>借助 hashset</h5><p>遍历第一个链表，全部加到 hashset 中，然后遍历第二个链表，检查其结点是否在 hashset 中，遇到的第一个重复的结点即为相交结点。</p><h5 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>遍历第一个链表和第二个链表，记下链表的长度 len1、len2 和尾节点 end1、end2。如果 end1!&#x3D;end2，则两链表不相交，如果 end1&#x3D;&#x3D;end2，则两链表相交。此时，让长链表先走 |len1-len2| 步，然后两个指针一起走，相遇的结点即为第一个相交结点。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141353.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br><span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">null</span> || head2 == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> head1;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> head2;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-literal">null</span>) &#123;<br>n++;<br>cur1 = cur1.next;<br>&#125;<br><span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-literal">null</span>) &#123;<br>n--;<br>cur2 = cur2.next;<br>&#125;<br><span class="hljs-keyword">if</span> (cur1 != cur2) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span><br>cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span><br>cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span><br>n = Math.abs(n);<br><span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>n--;<br>cur1 = cur1.next;<br>&#125;<br><span class="hljs-keyword">while</span> (cur1 != cur2) &#123;<br>cur1 = cur1.next;<br>cur2 = cur2.next;<br>&#125;<br><span class="hljs-keyword">return</span> cur1;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回两个有环链表的第一个相交结点"><a href="#返回两个有环链表的第一个相交结点" class="headerlink" title="返回两个有环链表的第一个相交结点"></a>返回两个有环链表的第一个相交结点</h4><p>总共有三种情况：</p><ul><li><p>两个有环链表不相交，此时 loop1!&#x3D;loop2；</p></li><li><p>两个有环链表在入环前相交，此时 loop1&#x3D;loop2，变回了两个无环链表的相交问题，只是把 loop1&#x2F;loop2 当作终止结点；</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141402.jpeg"></p></li><li><p>两个有环链表在环上相交，入环接入点不一样，即 loop1!&#x3D;loop2。与第一种情况区分的方法是让 loop1 继续往下走，如果转回自己都没有遇上 loop2 则为第一种情况。如果遇上了 loop2 则为第三种情况，且 loop1、loop2 都为第一个相交结点。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141409.jpeg"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不相交返回null</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (loop1 == loop2) &#123; <span class="hljs-comment">//第二种情况，与无环链表相交相同</span><br>cur1 = head1;<br>cur2 = head2;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (cur1 != loop1) &#123;<br>n++;<br>cur1 = cur1.next;<br>&#125;<br><span class="hljs-keyword">while</span> (cur2 != loop2) &#123;<br>n--;<br>cur2 = cur2.next;<br>&#125;<br>cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;<br>cur2 = cur1 == head1 ? head2 : head1;<br>n = Math.abs(n);<br><span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>n--;<br>cur1 = cur1.next;<br>&#125;<br><span class="hljs-keyword">while</span> (cur1 != cur2) &#123;<br>cur1 = cur1.next;<br>cur2 = cur2.next;<br>&#125;<br><span class="hljs-keyword">return</span> cur1;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cur1 = loop1.next;<br><span class="hljs-keyword">while</span> (cur1 != loop1) &#123;<br><span class="hljs-keyword">if</span> (cur1 == loop2) &#123; <span class="hljs-comment">//第三种情况</span><br><span class="hljs-keyword">return</span> loop1;<br>&#125;<br>cur1 = cur1.next;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//第一种情况</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="一个链表有环，一个链表无环，不可能相交"><a href="#一个链表有环，一个链表无环，不可能相交" class="headerlink" title="一个链表有环，一个链表无环，不可能相交"></a>一个链表有环，一个链表无环，不可能相交</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，两单链表若相交，要么都无环，要么都有环。主方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br><span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">null</span> || head2 == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">loop1</span> <span class="hljs-operator">=</span> getLoopNode(head1);<br><span class="hljs-type">Node</span> <span class="hljs-variable">loop2</span> <span class="hljs-operator">=</span> getLoopNode(head2);<br><span class="hljs-keyword">if</span> (loop1 == <span class="hljs-literal">null</span> &amp;&amp; loop2 == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> noLoop(head1, head2);<br>&#125;<br><span class="hljs-keyword">if</span> (loop1 != <span class="hljs-literal">null</span> &amp;&amp; loop2 != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="1）用数组结构实现大小固定的队列和栈"><a href="#1）用数组结构实现大小固定的队列和栈" class="headerlink" title="1）用数组结构实现大小固定的队列和栈"></a>1）用数组结构实现大小固定的队列和栈</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>准备一个变量 index，表示如果新来一个数，把新来的数放在哪个位置。加完数之后 index++，减数则 index–。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102420.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;<br><span class="hljs-keyword">private</span> Integer[] arr;<br><span class="hljs-keyword">private</span> Integer index;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> initSize)</span> &#123;<br><span class="hljs-keyword">if</span> (initSize &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The init size is less than 0&quot;</span>);<br>&#125;<br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[initSize];<br>index = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> arr[index - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> obj)</span> &#123;<br><span class="hljs-keyword">if</span> (index == arr.length) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is full&quot;</span>);<br>&#125;<br>arr[index++] = obj;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is empty&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> arr[--index];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>准备两个变量 start 和 end，end 表示如果新加一个数，该填到哪个位置上，start 表示如果拿去一个数，需要从哪个位置拿给用户。一开始 start 和 end 都指向 0。再准备一个变量 size 来约束 start 和 end 的行为。如果 size 没有超过数组大小，就把新给的数填到 end 上去。同时，如果 size 不为 0，用户需要数的时候，总把 start 指向的数给用户。start 和 end 之间是解耦的，即两者是独立的。加数时 end++，size++；取数时 start++，size–；当 end 到底后，回到开头位置，start 不断地追 end 位置。能不能继续加数或者取数取决于 size 的值，循环利用数组。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815140644.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br><span class="hljs-keyword">private</span> Integer[] arr;<br><span class="hljs-keyword">private</span> Integer size;<br><span class="hljs-keyword">private</span> Integer start;<br><span class="hljs-keyword">private</span> Integer end;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initSize)</span> &#123;<br><span class="hljs-keyword">if</span> (initSize &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The init size is less than 0&quot;</span>);<br>&#125;<br>arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[initSize];<br>size = <span class="hljs-number">0</span>;<br>start = <span class="hljs-number">0</span>;<br>end = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> arr[start];<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> obj)</span> &#123;<br><span class="hljs-keyword">if</span> (size == arr.length) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is full&quot;</span>);<br>&#125;<br>size++;<br>arr[end] = obj;<br>            <span class="hljs-comment">//如果end来到底部位置，则跳回到0，如果没有end++</span><br>end = end == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : end + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is empty&quot;</span>);<br>&#125;<br>size--;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> start;<br>            <span class="hljs-comment">//如果start来到底部位置，则跳回到0，如果没有start++</span><br>start = start == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : start + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> arr[tmp];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2）取栈中最小元素"><a href="#2）取栈中最小元素" class="headerlink" title="2）取栈中最小元素"></a>2）取栈中最小元素</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作<code>getMin</code>，要求如下：</p><ul><li><code>pop</code>、<code>push</code>、<code>getMin</code>操作的时间复杂度都是<code>O(1)</code>。</li><li>设计的栈类型可以使用现成的栈结构。</li></ul><p>思路：由于每次<code>push</code>之后都会可能导致栈中已有元素的最小值发生变化，因此需要一个容器与该栈联动（记录每次<code>push</code>产生的栈中最小值），我们可以借助一个辅助栈，即总共有两个栈，数据栈和最小值栈。</p><p>然后有两种设计方法：</p><ol><li><p>数据栈<code>push</code>第一个元素时，将其也<code>push</code>到最小值栈，此后每次向数据栈<code>push</code>元素的同时将其和最小值栈的栈顶元素比较，如果小，则将其也<code>push</code>到最小值栈，否则取最小值栈的栈顶元素<code>push</code>到最小值栈，即重复压入栈顶。最小值栈的栈顶始终是所有加入的数的最小值。（数据栈正常<code>push</code>、<code>pop</code>数据，而最小值栈<code>push</code>每次数据栈<code>push</code>后产生的栈中最小值；但数据栈<code>pop</code>时，最小值栈也只需简单的<code>pop</code>即可，保持同步）</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815142439.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack1</span> &#123;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack1</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.stackData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><span class="hljs-built_in">this</span>.stackMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> newNum)</span> &#123;<br>            <span class="hljs-comment">//min栈的更新</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-built_in">this</span>.getmin()) &#123;<br><span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">newMin</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br><span class="hljs-built_in">this</span>.stackMin.push(newMin);<br>&#125;<br>            <span class="hljs-comment">//data栈的更新</span><br><span class="hljs-built_in">this</span>.stackData.push(newNum);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackData.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>&#125;<br><span class="hljs-built_in">this</span>.stackMin.pop();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackData.pop();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>第二种设计方法也是使用两个栈，与方法一不同的是<code>stackMin</code>保存最小值的策略不同，体现在入栈和出栈操作中。</p><ul><li>入栈：如果 stackMin 为空，将 x 压入 stackMin 中。如果 stackMin 不为空，只有当 x 小于等于 stackMin.top() 时，才将 x 压入 stackMin。</li><li>出栈：如果 stackMin 不为空，且 stackData 出栈的元素与 stackMin 栈顶元素相等，则 stackMin 将栈顶元素弹出。</li></ul><p>栈的对应关系如下图，一次压入3、4、5、1、2、1。</p><p><img src="https://github.com/chenBright/leetcode/raw/master/155-%E6%9C%80%E5%B0%8F%E6%A0%88/MinStack2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack2</span> &#123;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack2</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.stackData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br><span class="hljs-built_in">this</span>.stackMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> newNum)</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br><span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-built_in">this</span>.getmin()) &#123;<br><span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>&#125;<br><span class="hljs-built_in">this</span>.stackData.push(newNum);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackData.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stackData.pop();<br><span class="hljs-keyword">if</span> (value == <span class="hljs-built_in">this</span>.getmin()) &#123;<br><span class="hljs-built_in">this</span>.stackMin.pop();<br>&#125;<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3）仅用队列结构实现栈结构"><a href="#3）仅用队列结构实现栈结构" class="headerlink" title="3）仅用队列结构实现栈结构"></a>3）仅用队列结构实现栈结构</h3><p>思路：只要将关注点放在 <strong>后进先出</strong> 这个特性就不难实现了。使用一个数据队列和辅助队列，当放入数据时使用队列的操作正常向数据队列中放，但出队元素时，需将数据队列的前 n-1 个数入队辅助队列，而将数据队列的队尾元素弹出来，最后数据队列和辅助队列交换角色。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150328.png" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoQueuesStack</span> &#123;<br><span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br><span class="hljs-keyword">private</span> Queue&lt;Integer&gt; help;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoQueuesStack</span><span class="hljs-params">()</span> &#123;<br>queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> pushInt)</span> &#123;<br>queue.add(pushInt);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>&#125;<br><span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">1</span>) &#123;<br>help.add(queue.poll());<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> queue.poll();<br>help.add(res);<br>swap();<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>&#125;<br>            <span class="hljs-comment">//前n-1个数入辅助队列</span><br><span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>) &#123;<br>help.add(queue.poll());<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">//数据队列和辅助队列交换角色</span><br>swap();<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">()</span> &#123;<br>Queue&lt;Integer&gt; tmp = help;<br>help = queue;<br>queue = tmp;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4）仅用栈结构实现队列结构"><a href="#4）仅用栈结构实现队列结构" class="headerlink" title="4）仅用栈结构实现队列结构"></a>4）仅用栈结构实现队列结构</h3><p>思路：使用两个栈，一个栈<code>stackPush</code>用来放数据，一个栈<code>stackPop</code>用来取数据。取数据时，如果<code>stackPop</code>为空则需要将<code>stackPush</code>中的<strong>所有元素</strong>一次性依次<code>pop</code>并放入<code>stackPop</code>。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150836.png" style="zoom: 50%;" /><p>特别要注意的是这个<strong>倒数据</strong>的原则：</p><ul><li>只有当<code>stackPop</code>为空时才能往里倒；</li><li><strong>倒数据</strong>时必须一次性将<code>stackPush</code>中的数据倒完。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoStacksQueue</span> &#123;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPush;<br><span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoStacksQueue</span><span class="hljs-params">()</span> &#123;<br>stackPush = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>stackPop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> pushInt)</span> &#123;<br>stackPush.push(pushInt);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stackPop.empty()) &#123;<br><span class="hljs-keyword">while</span> (!stackPush.empty()) &#123;<br>stackPop.push(stackPush.pop());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stackPop.pop();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stackPop.empty()) &#123;<br><span class="hljs-keyword">while</span> (!stackPush.empty()) &#123;<br>stackPop.push(stackPush.pop());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stackPop.peek();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）猫狗队列"><a href="#5）猫狗队列" class="headerlink" title="5）猫狗队列"></a>5）猫狗队列</h3><p>宠物、狗和猫的类如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>;<br>public <span class="hljs-type">Pet</span>(<span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">type</span>) </span>&#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span> = <span class="hljs-class"><span class="hljs-keyword">type</span></span>; &#125;<br>public <span class="hljs-type">String</span> getPetType() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>; &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pet</span> </span>&#123; public <span class="hljs-type">Dog</span>() &#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;dog&quot;</span>); &#125; &#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pet</span> </span>&#123; public <span class="hljs-type">Cat</span>() &#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;cat&quot;</span>); &#125; &#125;<br></code></pre></td></tr></table></figure><p>实现一种狗猫队列的结构，要求如下： 用户可以调用 add 方法将 cat 类或 dog 类的实例放入队列中； 用户可以调用 pollAll 方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用 pollDog 方法，将队列中 dog 类的实例按照进队列的先后顺序依次弹出； 用户可以调用 pollCat 方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用 isEmpty 方法，检查队列中是否还有dog或cat的实例； 用户可以调用 isDogEmpty 方法，检查队列中是否有dog类的实例； 用户可以调用 isCatEmpty 方法，检查队列中是否有 cat 类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span> &#123;<br><span class="hljs-keyword">private</span> String type;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Pet</span><span class="hljs-params">(String type)</span> &#123;<br><span class="hljs-built_in">this</span>.type = type;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPetType</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.type;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;dog&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;cat&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PetEnterQueue</span> &#123;<br><span class="hljs-keyword">private</span> Pet pet;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> count;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PetEnterQueue</span><span class="hljs-params">(Pet pet, <span class="hljs-type">long</span> count)</span> &#123;<br><span class="hljs-built_in">this</span>.pet = pet;<br><span class="hljs-built_in">this</span>.count = count;<br>&#125;<br><br><span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">getPet</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pet;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEnterPetType</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pet.getPetType();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogCatQueue</span> &#123;<br><span class="hljs-keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQ;<br><span class="hljs-keyword">private</span> Queue&lt;PetEnterQueue&gt; catQ;<br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> count;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DogCatQueue</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.dogQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;PetEnterQueue&gt;();<br><span class="hljs-built_in">this</span>.catQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;PetEnterQueue&gt;();<br><span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pet pet)</span> &#123;<br><span class="hljs-keyword">if</span> (pet.getPetType().equals(<span class="hljs-string">&quot;dog&quot;</span>)) &#123;<br><span class="hljs-built_in">this</span>.dogQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetEnterQueue</span>(pet, <span class="hljs-built_in">this</span>.count++));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pet.getPetType().equals(<span class="hljs-string">&quot;cat&quot;</span>)) &#123;<br><span class="hljs-built_in">this</span>.catQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetEnterQueue</span>(pet, <span class="hljs-built_in">this</span>.count++));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;err, not dog or cat&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">pollAll</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.dogQ.isEmpty() &amp;&amp; !<span class="hljs-built_in">this</span>.catQ.isEmpty()) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dogQ.peek().getCount() &lt; <span class="hljs-built_in">this</span>.catQ.peek().getCount()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.dogQ.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.catQ.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;err, queue is empty!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">pollDog</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isDogQueueEmpty()) &#123;<br><span class="hljs-keyword">return</span> (Dog) <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Dog queue is empty!&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">pollCat</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isCatQueueEmpty()) &#123;<br><span class="hljs-keyword">return</span> (Cat) <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>&#125; <span class="hljs-keyword">else</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Cat queue is empty!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.isEmpty() &amp;&amp; <span class="hljs-built_in">this</span>.catQ.isEmpty();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDogQueueEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.isEmpty();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCatQueueEmpty</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.isEmpty();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node left;<br><span class="hljs-keyword">public</span> Node right;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>preOrderRecur(head.left); <br>preOrderRecur(head.right);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>inOrderRecur(head.left);<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>inOrderRecur(head.right);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>posOrderRecur(head.left);<br>posOrderRecur(head.right);<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以先序遍历二叉树为例，可以发现递归方式首先尝试打印当前结点的值，随后尝试打印左子树，打印完左子树后尝试打印右子树，递归过程的<code>base case</code>是当某个结点为空时停止子过程的展开。这种递归尝试是由二叉树本身的结构所决定的，因为二叉树上的任意结点都可看做一棵二叉树的根结点（即使是叶子结点，也可以看做是一棵左右子树为空的二叉树根结点）。</p><h5 id="二叉树的递归序"><a href="#二叉树的递归序" class="headerlink" title="二叉树的递归序"></a>二叉树的递归序</h5><p>观察先序、中序、后序三个递归方法你会发现，不同点在于打印当前结点的值这一操作的时机。<strong>你会发现每个结点会被访问三次</strong>：进入方法时算一次、递归处理左子树完成之后返回时算一次、递归处理右子树完成之后返回时算一次。因此在<code>preOrderRecur</code>中将打印语句放到方法开始时就产生了先序遍历；在<code>inOrderRecur</code>中，将打印语句放到递归处理左子树完成之后就产生了中序遍历；在<code>posOrderRecur</code>中，将打印语句放到递归处理左右子树都完成之后就产生了后序遍历。</p><p>例如下列二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>其递归序为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">4</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，<span class="hljs-number">5</span>，<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">6</span>，<span class="hljs-number">6</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>，<span class="hljs-number">7</span>，<span class="hljs-number">7</span>，<span class="hljs-number">7</span>，<span class="hljs-number">3</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>打印第一次出现的顺序即为先序（中左右）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">3</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>打印第二次出现的顺序即为中序（左中右）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，<span class="hljs-number">1</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>，<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>打印打三次出现的顺序即为后序（左右中）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">3</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>准备一个栈，先将根节点压栈。循环：从栈顶弹出当前结点并打印其值，再将当前节点的非空右孩子、非空左孩子依次压栈。当栈为空时停止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>stack.add(head);<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>head = stack.pop();<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head.right);<br>&#125;<br><span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head.left);<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>你会发现压栈的顺序和打印的顺序是相反的，压栈是先根结点，然后有右孩子就压右孩子、有左孩子就压左孩子，这是利用栈的后进先出。每次获取到一棵子树的根节点之后就可以获取其左右孩子，因此无需保留其信息，直接弹出并打印，然后保留其左右孩子到栈中即可。</p><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ol><li>阶段一：子树整条左边界，依次进栈，如没有左边界，进入阶段二。</li><li>阶段二：栈中弹出结点 cur 并打印，cur 的右孩子重复阶段一。</li></ol><p>即对于一棵树，将该树的左边界全部压栈，<code>head</code>的走向是只要左孩子不为空就走向左孩子。当左孩子为空时弹出栈顶结点（此时该结点是一棵左子树为空的树的根结点，根据中序遍历可以直接打印该结点，然后中序遍历该结点的右子树）打印，如果该结点的右孩子非空（说明有右子树），那么将其右孩子压栈，这个右孩子又可能是一棵子树的根节点，因此将这棵子树的左边界压栈，这时回到了开头，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br><span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head);<br>head = head.left;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>head = stack.pop();<br>System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>head = head.right;<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>一颗二叉树是可以只由左边界或者右边界分解掉的。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200728123002.png"></p><p>对于整条左边界来说，压栈顺序是先中再左<code>d,c,b,a</code>，因此弹出顺序为先左再中<code>a,b,c,d</code>，在弹出 a 之后，中途加入 a 的右子树重复这个行为，在弹出 b 之后，中途加入 b 的右子树重复这个行为，以此类推。对于 b 来说，整颗左树先执行了打印，对于 c 和 d 来说也是这样。因此每个结点都是先执行其左子树，再打印自己，再执行其右子树。</p><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>思路一：先序得到的序列是<code>中-左-右</code>，如果压栈的时候先压左孩子，再压右孩子，则可以得到<code>中-右-左</code>，再将这个顺序逆序，则可以得到<code>左-右-中</code>，即为后序遍历。因此准备两个栈，一个栈用来保存遍历时的结点信息，另一个栈用来排列后序（根节点先进栈，右孩子再进，左孩子最后进）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderUnRecur1</span><span class="hljs-params">(Node head)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>s1.push(head);<br><span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;<br>head = s1.pop();<br>s2.push(head);<br><span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>s1.push(head.left);<br>&#125;<br><span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>s1.push(head.right);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;<br>System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>思路二：只用一个栈。借助两个变量<code>h</code>和<code>c</code>，<code>h</code>代表最近一次打印过的结点，<code>c</code>代表栈顶结点。首先将根结点压栈，此后栈非空循环，令<code>c</code>等于栈顶元素（<code>c=stack.peek()</code>）执行以下三个分支：</p><ol><li><code>c</code>的左右孩子是否与<code>h</code>相等，如果都不相等，说明<code>c</code>的左右孩子都不是最近打印过的结点，由于左右孩子是左右子树的根节点，根据后根遍历的特点，左右子树肯定都没打印过，那么将左孩子压栈（打印左子树）。</li><li>分支1没有执行说明<code>c</code>的左孩子要么不存在；要么左子树刚打印过了；要么右子树刚打印过了。这时如果是前两种情况中的一种，那就轮到打印右子树了，因此如果<code>c</code>的右孩子非空就压栈。</li><li>如果前两个分支都没执行，说明<code>c</code>的左右子树都打印完了，因此弹出并打印<code>c</code>结点，更新一下<code>h</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderUnRecur2</span><span class="hljs-params">(Node h)</span> &#123;<br>System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br><span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span>) &#123;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>stack.push(h);<br><span class="hljs-type">Node</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>c = stack.peek();<br><span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;<br>stack.push(c.left);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) &#123;<br>stack.push(c.right);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>h = c;<br>&#125;<br>&#125;<br>&#125;<br>System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的层序遍历及其扩展"><a href="#二叉树的层序遍历及其扩展" class="headerlink" title="二叉树的层序遍历及其扩展"></a>二叉树的层序遍历及其扩展</h3><h4 id="层序（宽度优先）遍历"><a href="#层序（宽度优先）遍历" class="headerlink" title="层序（宽度优先）遍历"></a>层序（宽度优先）遍历</h4><p>准备一个队列，先把头节点加入，弹出结点并打印，然后先进入其左节点，再进入其右节点，周而复始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node head)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Queue&lt;Node&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(head);<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        Node cur=queue.poll();<br>        System.out.println(cur.value+<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span>(cur.left!=<span class="hljs-literal">null</span>)&#123;<br>            queue.add(cur.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur.right!=<span class="hljs-literal">null</span>)&#123;<br>            queue.add(cur.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="层序遍历扩展"><a href="#层序遍历扩展" class="headerlink" title="层序遍历扩展"></a>层序遍历扩展</h4><h5 id="1）求一棵二叉树的最大宽度"><a href="#1）求一棵二叉树的最大宽度" class="headerlink" title="1）求一棵二叉树的最大宽度"></a>1）求一棵二叉树的最大宽度</h5><p>准备一个 HashMap 记录结点的层数，每个结点进队列时设置其层数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">w</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.add(head);<br>HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>levelMap.put(head, <span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">curLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">curLevelNodes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br><span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-type">int</span> <span class="hljs-variable">curNodeLevel</span> <span class="hljs-operator">=</span> levelMap.get(cur);<br><span class="hljs-keyword">if</span>(curNodeLevel == curLevel) &#123;<br>curLevelNodes++;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//level!=curLevel</span><br>max = Math.max(max, curLevelNodes);<br>curLevel++;<br>curLevelNodes = <span class="hljs-number">1</span>; <span class="hljs-comment">//已经进入了下一层，为下一层的第一个结点</span><br>&#125;<br><span class="hljs-keyword">if</span>(cur.left !=<span class="hljs-literal">null</span>) &#123;<br>levelMap.put(cur.left, curNodeLevel+<span class="hljs-number">1</span>);<br>queue.add(cur.left);<br>&#125;<br><span class="hljs-keyword">if</span>(cur.right !=<span class="hljs-literal">null</span>) &#123;<br>levelMap.put(cur.right, curNodeLevel+<span class="hljs-number">1</span>);<br>queue.add(cur.right);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）判断一颗二叉树是否是完全二叉树"><a href="#2）判断一颗二叉树是否是完全二叉树" class="headerlink" title="2）判断一颗二叉树是否是完全二叉树"></a>2）判断一颗二叉树是否是完全二叉树</h5><p>整体是宽度优先遍历。在遍历的过程中，需要满足以下条件：</p><ul><li><p>遍历的任何一个节点，不能有右孩子而没有左孩子；</p></li><li><p>在上述条件满足的情况下，一旦遇到孩子不双全的节点，后续遇到节点，必须是叶节点。如下图 2 之后的节点都必须是叶子节点。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094945.png"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCBT</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isMeet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>queue.add(head);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>head = queue.poll();<br>l = head.left;<br>r = head.right;<br><span class="hljs-keyword">if</span> (<br><span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span><br>(isMeet &amp;&amp; !(l == <span class="hljs-literal">null</span> &amp;&amp; r == <span class="hljs-literal">null</span>)) <br>|| <br>(l == <span class="hljs-literal">null</span> &amp;&amp; r != <span class="hljs-literal">null</span>)<br>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (l != <span class="hljs-literal">null</span>) &#123;<br>queue.add(l);<br>&#125;<br><span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>queue.add(r);<br>&#125;<br><span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> || r == <span class="hljs-literal">null</span>) &#123;<br>isMeet = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h3><p>出发点：先思考，以任意一个节点 X 为头部的子树的情况下，答案是什么。假设可以问自己的左右子树信息的情况下，则么列出答案的可能性。</p><h4 id="1）判断一颗二叉树是否是搜索二叉树"><a href="#1）判断一颗二叉树是否是搜索二叉树" class="headerlink" title="1）判断一颗二叉树是否是搜索二叉树"></a>1）判断一颗二叉树是否是搜索二叉树</h4><blockquote><p>搜索二叉树的定义：对于二叉树的任意一棵子树，其左子树上的所有结点的值小于该子树的根节点的值，而其右子树上的所有结点的值大于该子树的根结点的值，并且整棵树上任意两个结点的值不同。</p></blockquote><p>不使用递归时的解法，写出该二叉树的中序遍历序列，如果该序列是递增的，则为搜索二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br><span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>stack.push(head);<br>head = head.left;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>head = stack.pop();<br><span class="hljs-keyword">if</span> (head.value &lt;= pre) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>pre = head.value;<br>head = head.right;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归套路：思考以 X 为头的子树是否是搜索二叉树，假设可以问左右子树要信息的情况，整理答案的可能性，即以左右子树的信息构建答案。</p><p>判断以 x 为头的子树为搜索二叉树需要满足以x下三个条件：</p><ul><li>左子树整体是搜索二叉树</li><li>右子树整体是搜索二叉树</li><li>左子树 max&lt; x &lt; 右子树min</li></ul><p>所以需要问左子树的信息为：1）是否是 BST；2）max。问右子树的信息为：1）是否是 BST；2）min。由于是递归函数，所以对于左右子树的要求和本身节点的要求是一样的，所以需要整合一下。即需要返回三个信息：1）整棵树是否为 BST；2）整棵树的 max；3）整棵树的 min。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBST;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> min;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">boolean</span> is, <span class="hljs-type">int</span> mi, <span class="hljs-type">int</span> ma)</span> &#123;<br>isBST = is;<br>min = mi;<br>max = ma;<br>&#125;<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBSTtest</span><span class="hljs-params">(Node head)</span>&#123;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-keyword">return</span> info.isBST;<br>   &#125;<br><br>   <span class="hljs-comment">//以x为头的树，返回info（3个信息）</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Info</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br><span class="hljs-type">Info</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br>       <span class="hljs-comment">//整合x的三个信息</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> x.value;<br><span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x.value;<br><span class="hljs-keyword">if</span>(leftData!=<span class="hljs-literal">null</span>) &#123;<br>min = Math.min(min, leftData.min);<br>max = Math.max(max, leftData.max);<br>&#125;<br><span class="hljs-keyword">if</span>(rightData!=<span class="hljs-literal">null</span>) &#123;<br>min = Math.min(min, rightData.min);<br>max = Math.max(max, rightData.max);<br>&#125;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isBST</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span>(<br>(leftData != <span class="hljs-literal">null</span> ? (leftData.isBST  &amp;&amp;  leftData.max &lt; x.value) : <span class="hljs-literal">true</span>)<br>  &amp;&amp;<br>(rightData !=<span class="hljs-literal">null</span> ? (rightData.isBST  &amp;&amp; rightData.min &gt; x.value) : <span class="hljs-literal">true</span>)  <br>) &#123;<br>isBST = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(isBST, min, max);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）判断一颗二叉树是否是满二叉树"><a href="#2）判断一颗二叉树是否是满二叉树" class="headerlink" title="2）判断一颗二叉树是否是满二叉树"></a>2）判断一颗二叉树是否是满二叉树</h4><blockquote><p>满二叉树的条件：如果一棵树的高度为 h，则节点数 N&#x3D;2^h-1。</p></blockquote><p>递归套路：整理以 x 为头的子树需要返回的信息：1）节点数 N；2）最大高度 h。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> nodes;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> n)</span> &#123;<br>height = h;<br>nodes = n;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br><span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">Info</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br><span class="hljs-type">Info</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br><span class="hljs-type">int</span> <span class="hljs-variable">height</span>  <span class="hljs-operator">=</span> Math.max(leftData.height,rightData.height)+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">nodes</span> <span class="hljs-operator">=</span> leftData.nodes + rightData.nodes + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(height, nodes);<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> info.nodes;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">H</span> <span class="hljs-operator">=</span> info.height;<br><span class="hljs-type">return</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span>= (<span class="hljs-number">1</span> &lt;&lt; H) - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）判断一颗二叉树是否是平衡二叉树"><a href="#3）判断一颗二叉树是否是平衡二叉树" class="headerlink" title="3）判断一颗二叉树是否是平衡二叉树"></a>3）判断一颗二叉树是否是平衡二叉树</h4><blockquote><p>平衡二叉树的定义：当二叉树的任意一棵子树的左子树的高度和右子树的高度相差不超过1时，该二叉树为平衡二叉树。</p></blockquote><p>满足二叉树是平衡二叉树的条件：</p><ul><li>左子树是平衡的；</li><li>右子树是平衡的；</li><li>左子树和右子树的高度差不超过 1。</li></ul><p>递归套路：整理以 x 为头的子树需要返回的信息：1）是否平衡；2）子树的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnType</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBalanced;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReturnType</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isB, <span class="hljs-type">int</span> hei)</span> &#123;<br>isBalanced = isB;<br>height = hei;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReturnType <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br><span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">ReturnType</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br><span class="hljs-type">ReturnType</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br><span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(leftData.height, rightData.height) + <span class="hljs-number">1</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isBalanced</span> <span class="hljs-operator">=</span> leftData.isBalanced &amp;&amp; rightData.isBalanced<br>&amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(isBalanced, height);<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-type">ReturnType</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-keyword">return</span> info.isBalanced;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）给定两个二叉树的节点-node1-和-node2，找到他们的最低公共祖先节点"><a href="#4）给定两个二叉树的节点-node1-和-node2，找到他们的最低公共祖先节点" class="headerlink" title="4）给定两个二叉树的节点 node1 和 node2，找到他们的最低公共祖先节点"></a>4）给定两个二叉树的节点 node1 和 node2，找到他们的最低公共祖先节点</h4><p>如下图所示，节点 5 和 8 的最低公共祖先是 1，节点 8 和 9 的最低公共祖先是 3。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094958.png"  /><p>分析以 x 为头的子树的可能性：</p><ul><li>既无 o1，也无 o2，则 x 树上不存在最低公共祖先；</li><li>o1 和 o2 存在一个，则 x 树上不存在最低公共祖先，但可以记下 o1、o2 的存在状态；</li><li>o1 和 o2 都在 x 树上，需要再分情况：<ul><li>如果左子树含有一个，右子树含有另一个，则 x 为最低公共祖先；</li><li>如果 o1 和 o2 都在左子树上，则左子树上得到的最低公共祖先是 x 树的答案；</li><li>如果 o1 和 o2 都在右子树上，则右子树上得到的最低公共祖先是 x 树的答案；</li></ul></li></ul><p>递归套路：整理以 x 为头的子树需要返回的信息：1）是否发现了 o1 和 o2 的最低公共祖先，如果发现了，低共不等于空，如果发现了，低共等于空；2）整棵树上是否发现了 o1；3）整棵树上是否发现了 o2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findO1;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findO2;<br>       <span class="hljs-keyword">public</span> Node findAns;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">boolean</span> f1, <span class="hljs-type">boolean</span> f2,Node f)</span> &#123;<br>           findO1 = f1;<br>           findO2 = f2;<br>           findAns = f;<br>&#125;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x,Node o1,Node o2)</span>&#123;<br>       <span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>       &#125;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">leftInfo</span> <span class="hljs-operator">=</span> process(x.left,o1,o2);<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">rightInfo</span> <span class="hljs-operator">=</span> process(x.right,o1,o2);<br>       <span class="hljs-comment">// 两个if只会有一个成立，或者都不成立</span><br>       <span class="hljs-keyword">if</span>(leftInfo.findAns != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,leftInfo.findAns)<br>       &#125;<br>       <span class="hljs-keyword">if</span>(rightInfo.findAns != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,rightInfo.findAns)<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没有发现最低公共祖先</span><br>       <span class="hljs-keyword">if</span>(leftInfo.findO1 &amp;&amp; rightInfo.findO2)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO2 &amp;&amp; rightInfo.findO1)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没有发现最低公共祖先，而且最低公共祖先不在x处交汇</span><br>       <span class="hljs-comment">// 左右两树只包含o1，或只包含o2，或什么都没发现</span><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">findO1</span> <span class="hljs-operator">=</span> x == o1;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">findO2</span> <span class="hljs-operator">=</span> x == o2;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO1 || rightInfo.findO1)&#123;<br>           <span class="hljs-keyword">if</span>(findO2)&#123;<span class="hljs-comment">//x为o2</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO2 || rightInfo.findO2)&#123;<br>           <span class="hljs-keyword">if</span>(findO1)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没发现o1，或o2</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(findO1,findO2,<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">lowestCommon</span><span class="hljs-params">(Node head,Node o1,Node o2)</span>&#123;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head,o1,o2);<br>       <span class="hljs-keyword">return</span> info.findAns;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树扩展"><a href="#二叉树扩展" class="headerlink" title="二叉树扩展"></a>二叉树扩展</h3><h4 id="1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0-N-，N为这棵树的节点个数"><a href="#1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0-N-，N为这棵树的节点个数" class="headerlink" title="1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0(N)，N为这棵树的节点个数"></a>1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0(N)，N为这棵树的节点个数</h4><p>如果我们遍历二叉树的每个结点来计算结点个数，那么时间复杂度将是<code>O(N)</code>，我们可以log利用满二叉树的结点个数为<code>2^h-1</code>（h为树的层数）来加速这个过程。</p><p>首先遍历树的左边界，可以得到树的层数 h，代价是<code>O(logN)</code>。然后遍历右子树的左边界，看是否到达最后一层。</p><ul><li><p>如果到达了最后一层，则左子树为满二叉树，且左子树的高度为<code>h-1</code>，右子树为完全二叉树，递归求解右子树。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095011.png" style="zoom: 50%;" /></li><li><p>如果没到达最后一层，则右子树为满二叉树，且高度为<code>h-2</code>，左子树为完全二叉树，递归求解左子树。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095019.png"  style="zoom: 50%;" /></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nodeNum</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> bs(head, <span class="hljs-number">1</span>, mostLeftLevel(head, <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// level为当前node的层数，h为整棵树的高度，返回以node为头的整棵树的节点个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bs</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> h)</span> &#123;<br><span class="hljs-keyword">if</span> (level == h) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (mostLeftLevel(node.right, level + <span class="hljs-number">1</span>) == h) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; (h - level)) + bs(node.right, level + <span class="hljs-number">1</span>, h);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; (h - level - <span class="hljs-number">1</span>)) + bs(node.left, level + <span class="hljs-number">1</span>, h);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostLeftLevel</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level)</span> &#123;<br><span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>level++;<br>node = node.left;<br>&#125;<br><span class="hljs-keyword">return</span> level - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法每层只会遍历一个节点，当遍历该节点时，会计算右子树的左边界，所以时间复杂度为<code>O((logN)^2)</code>。</p><h4 id="2）在二叉树中找到一个节点的后继节点"><a href="#2）在二叉树中找到一个节点的后继节点" class="headerlink" title="2）在二叉树中找到一个节点的后继节点"></a>2）在二叉树中找到一个节点的后继节点</h4><p>现在有一种新的二叉树节点类型如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node left;<br><span class="hljs-keyword">public</span> Node right;<br><span class="hljs-keyword">public</span> Node parent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该结构比普通二叉树节点结构多了一个指向父节点的 parent 指针。假设有一棵 Node 类型的节点组成的二叉树，树中每个节点的 parent 指针都正确地指向自己的父节点，头节点的 parent 指向null。只给一个在二叉树中的某个节点 node，请实现返回 node 的后继节点的函数。</p><blockquote><p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点，node的前一个节点叫作node的前驱节点。</p></blockquote><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808122511.png" style="zoom:67%;" /><p>如图二叉树的中序遍历顺序为 4,2,5,1,6,3,7。</p><p>当然可以将二叉树中序遍历以下，在遍历到该结点的时候标记一下，那么下一个要打印的节点就是该结点的后继节点。其时间复杂度为 O(N)，需要完整遍历整棵二叉树。</p><p>使用一种策略利用 parent 指针直接去找节点的后继节点：</p><ul><li>当前节点 X 有右孩子时，后继节点为右子树上的最左的节点。图中 1 节点的后继为 6 节点。</li><li>当前节点 X 无右孩子时，不断往上寻找，直到找到一个节点 Z 是其父节点 S 的左孩子时停止，则父节点 S 是 节点 X 的后继。如果找不到，则没有后继节点。图中 5 节点的后继为 1 节点。</li></ul><p>这里当前节点的右孩子为空的情况比较难分析，我们可以借助一个指针<code>parent</code>，当前来到的结点<code>node</code>和其父结点<code>parent</code>的<code>parent.left</code>比较，如果相同则直接返回<code>parent</code>，否则<code>node</code>来到<code>parent</code>的位置，<code>parent</code>则继续向上追溯，直到<code>parent</code>到达根节点为止。若<code>node</code>还是不等于<code>parent</code>的左孩子，则返回<code>null</code>表明给出的结点没有后继结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getSuccessorNode</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> getLeftMost(node.right);<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> node.parent;<br><span class="hljs-keyword">while</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span><br>node = parent;<br>parent = node.parent;<br>&#125;<br><span class="hljs-keyword">return</span> parent;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLeftMost</span><span class="hljs-params">(Node node)</span> &#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br><span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>node = node.left;<br>&#125;<br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）"><a href="#3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）" class="headerlink" title="3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）"></a>3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）</h4><p>就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树。</p><h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>二叉树的序列化要注意的两个点如下：</p><ul><li>每序列化一个结点数值之后都应该加上一个结束符表示一个结点序列化的终止，如<code>_</code>。</li><li>不能忽视空结点的存在，可以使用一个占位符如<code>#</code>表示空结点的序列化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以head为头的树，请序列化成字符串返回</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialByPre</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#_&quot;</span>;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.value + <span class="hljs-string">&quot;_&quot;</span>;<br>res += serialByPre(head.left);<br>res += serialByPre(head.right);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>反序列化：</p><p>怎么序列化的，就怎么反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconByPreString</span><span class="hljs-params">(String preStr)</span> &#123;<br>String[] values = preStr.split(<span class="hljs-string">&quot;_&quot;</span>);<br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != values.length; i++) &#123;<br>queue.add(values[i]);<br>&#125;<br><span class="hljs-keyword">return</span> reconPreOrder(queue);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconPreOrder</span><span class="hljs-params">(Queue&lt;String&gt; queue)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> queue.poll();<br><span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(value));<br>head.left = reconPreOrder(queue);<br>head.right = reconPreOrder(queue);<br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h5><p>序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialByLevel</span><span class="hljs-params">(Node head)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#_&quot;</span>;<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.value + <span class="hljs-string">&quot;_&quot;</span>;<br>Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Node&gt;();<br>queue.add(head);<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>head = queue.poll();<br><span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>res += head.left.value + <span class="hljs-string">&quot;_&quot;</span>;<br>queue.add(head.left);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res += <span class="hljs-string">&quot;#_&quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>res += head.right.value + <span class="hljs-string">&quot;_&quot;</span>;<br>queue.add(head.right);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>res += <span class="hljs-string">&quot;#_&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconByLevelString</span><span class="hljs-params">(String levelStr)</span> &#123;<br>String[] values = levelStr.split(<span class="hljs-string">&quot;_&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> generateNodeByString(values[index++]);<br>Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Node&gt;();<br><span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>queue.add(head);<br>&#125;<br><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>node = queue.poll();<br>node.left = generateNodeByString(values[index++]);<br>node.right = generateNodeByString(values[index++]);<br><span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>queue.add(node.left);<br>&#125;<br><span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>queue.add(node.right);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">generateNodeByString</span><span class="hljs-params">(String val)</span> &#123;<br><span class="hljs-keyword">if</span> (val.equals(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(val));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）折纸问题"><a href="#4）折纸问题" class="headerlink" title="4）折纸问题"></a>4）折纸问题</h4><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是凹折痕、凹折痕和凸折痕。<br>给定一个输入参数 N，代表纸条都从下边向上方连续对折 N 次。请从上到下打印所有折痕的方向。例如:N&#x3D;1时，打印: 凹；N&#x3D;2时，打印: 凹 凹 凸。</p><p>将 3 次对折的结果依次画出，如图所示：</p><ul><li>头节点为凹折痕</li><li>左孩子为凹折痕</li><li>右孩子为凸折痕</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141314.png" style="zoom:67%;" /><p>而最后纸带上的结果为二叉树的中序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllFolds</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">// 递归过程，来到了某一个节点，</span><br><span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> N, <span class="hljs-type">boolean</span> down)</span> &#123;<br><span class="hljs-keyword">if</span> (i &gt; N) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);<br>printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">false</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>左子树的递归过程如图所示。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141900.png" style="zoom:67%;" /><blockquote><p>本题的本质是要建立对于问题的敏感度。</p></blockquote><h2 id="前缀树（字典树）"><a href="#前缀树（字典树）" class="headerlink" title="前缀树（字典树）"></a>前缀树（字典树）</h2><h3 id="前缀树的介绍"><a href="#前缀树的介绍" class="headerlink" title="前缀树的介绍"></a>前缀树的介绍</h3><p>前缀树是一种存储字符串的高效容器，基于此结构的操作有：</p><ul><li><code>insert</code>插入一个字符串到容器中。</li><li><code>search</code>容器中是否存在某字符串，返回该字符串进入到容器的次数，没有则返回0。</li><li><code>delete</code>将某个字符串进入到容器的次数减1。</li><li><code>prefixNumber</code>返回所有插入操作中，以某个串为前缀的字符串出现的次数。</li></ul><p>设计思路：该结构的重点实现在于存储。前缀树以字符为存储单位，将其存储在结点之间的树枝上而非结点上，如插入字符串<code>abc</code>之后前缀树如下：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103725.jpeg"></p><p>每次插入串都要从头结点开始，遍历串中的字符依次向下“铺路”，如上图中的<code>abc</code>3条路。对于每个结点而言，它可以向下铺<code>a~z</code>26条不同的路，假如来到某个结点后，它要向下铺的路（取决于遍历到哪个字符来了）被之前插入串的过程铺过了那么就可以直接走这条路去往下一个结点，否则就要先铺路再去往下一个结点。如再插入串<code>abde</code>和<code>bcd</code>的前缀树将如下所示：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103730.jpeg"></p><p>除了需要在路上存储字符以外，在每次字符串的铺路过程中，还需要在结点中存储两个参数：<code>pass</code> 和 <code>end</code>，前者表示经过该节点的次数，后者表示以该结点结束的次数。有了这两个参数，可以很方便的进行前缀树的<code>search</code>和<code>prefixNumber</code>操作。如插入下列字符串后的完整前缀树将如下所示：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103736.png"></p><p>因此加入一个新字符串的过程为：总是从头节点出发，沿着每一个字符往下走，路存在就复用，不存在就新建，每个结点存储自己的数据项，沿途结点<code>pass++</code> ，最后一个结点 <code>end++</code>。</p><h3 id="前缀树的实现"><a href="#前缀树的实现" class="headerlink" title="前缀树的实现"></a>前缀树的实现</h3><h4 id="结点数据结构"><a href="#结点数据结构" class="headerlink" title="结点数据结构"></a>结点数据结构</h4><p>后续的路可以由数组实现，也可以由<code>HashMap</code>或者<code>TreeMap</code> 实现，这里用数组形式表达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pass;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><span class="hljs-comment">// HashMap&lt;Char, Node&gt; nexts;</span><br><span class="hljs-comment">// TreeMap&lt;Char, Node&gt; nexts;</span><br><span class="hljs-keyword">public</span> TrieNode[] nexts;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>pass = <span class="hljs-number">0</span>;<br>end = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// nexts[0] == null 没有走向‘a’的路</span><br><span class="hljs-comment">// nexts[0] != null 有走向‘a’的路</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// nexts[25] != null 有走向‘z’的路</span><br>nexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="前缀树结构"><a href="#前缀树结构" class="headerlink" title="前缀树结构"></a>前缀树结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span> TrieNode root;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br><span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">char</span>[] chs = word.toCharArray();<br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>node.pass++;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span><br>index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span><br><span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//没有路就新建</span><br>node.nexts[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>&#125;<br>node = node.nexts[index];<span class="hljs-comment">// node来到下级结点</span><br>node.pass++;<br>&#125;<br>node.end++;<br>&#125;<br><br>    <span class="hljs-comment">// delete需要处理pass减成0的特殊情况，此时需要将pass为0之后的结点删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String word)</span> &#123;<br><span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 确定树中确实加入过word，才删除</span><br><span class="hljs-type">char</span>[] chs = word.toCharArray();<br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>node.pass--;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// java实现（JVM自动释放空间） C++ 要遍历到底去析构</span><br>node.nexts[index] = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>node = node.nexts[index];<br>&#125;<br>node.end--;<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">//delete的cpp实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCPP</span><span class="hljs-params">(String word)</span> &#123;<br><span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 确定树中确实加入过word，才删除</span><br><span class="hljs-type">char</span>[] chs = word.toCharArray();<br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>node.pass--;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">deleteIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>HashSet&lt;TrieNode&gt; deleteSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;<br>a = a == <span class="hljs-literal">null</span> ? node : a;<br>deleteIndex = deleteIndex == -<span class="hljs-number">1</span> ? index : deleteIndex;<br><br>deleteSet.add(node.nexts[index]);<br>&#125;<br>node = node.nexts[index];<br>&#125;<br>node.end--;<br><br>a.nexts[deleteIndex] = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// deleteSet ... 析构</span><br><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 计算word这个单词之前加入过几次</span><br>    <span class="hljs-comment">// 则么插入就则么查找</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br><span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">char</span>[] chs = word.toCharArray();<br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//提前没路说明之前没有加入过word</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>node = node.nexts[index];<br>&#125;<br><span class="hljs-keyword">return</span> node.end;<br>&#125;<br><br><span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefixNumber</span><span class="hljs-params">(String pre)</span> &#123;<br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">char</span>[] chs = pre.toCharArray();<br><span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>node = node.nexts[index];<br>&#125;<br><span class="hljs-keyword">return</span> node.pass;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀树的相关问题"><a href="#前缀树的相关问题" class="headerlink" title="前缀树的相关问题"></a>前缀树的相关问题</h3><p>一个字符串类型的数组 arr1，另一个字符串类型的数组 arr2：</p><ul><li>arr2 中有哪些字符，是 arr1 中出现的？请打印</li><li>arr2 中有哪些字符，是作为 arr1 中某个字符串前缀出现的？请打印</li><li>arr2 中有哪些字符，是作为 arr1 中某个字符串前缀出现的？请打印 arr2 中出现次数最大的前缀。</li></ul><h2 id="哈希表简单介绍"><a href="#哈希表简单介绍" class="headerlink" title="哈希表简单介绍"></a>哈希表简单介绍</h2><ol><li>哈希表在使用层面上可以理解为一种集合结构；</li><li>如果只有 key，没有伴随数据 value，可以使用 HashSet 结构(C++中叫 unordered_set );</li><li>如果既有 key，又有伴随数据 value，可以使用 HashMap 结构(C++中叫 unordered_map);</li><li>有无伴随数据，是 HashMap 和 HashSet 唯一的区别，底层的实际结构是一回事；</li><li>使用哈希表增(put) 、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大；</li><li>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小；</li><li>放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地<br>址的大小。</li></ol><h2 id="有序表简单介绍"><a href="#有序表简单介绍" class="headerlink" title="有序表简单介绍"></a>有序表简单介绍</h2><ol><li>有序表在使用层面上可以理解为一种集合结构；</li><li>如果只有 key，没有伴随数据 value，可以使用 TreeSet 结构(C++中叫 Set )；</li><li>如果既有 key，又有伴随数据 value，可以使用 TreeMap 结构(C++中叫 Map )；</li><li>有无伴随数据，是 TreeSet 和 TreeMap 唯一的区别，底层的实际结构是一回事；</li><li>有序表和哈希表的区别是，有序表把 key 按照顺序组织起来，而哈希表完全不组织；</li><li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现<br>不同；</li><li>放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小；</li><li>放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占<br>用是这个东西内存地址的大小；</li><li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复<br>杂度。<ul><li>void put(K key, V value)：将一个（key，value）记录加入到表中，或者将 key 的记录<br>更新成 value。</li><li>V get(K key)：根据给定的 key，查询 value 并返回。</li><li>void remove(K key)：移除 key 的记录。</li><li>boolean containsKey(K key)：询问是否有关于 key 的记录。</li><li>K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。</li><li>K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。</li><li>K floorKey(K key)：如果表中存入过 key，返回 key；否则返回所有键值的排序结果中，<br>key的前一个。</li><li>K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个</li><li>以上所有操作时间复杂度都是 <code>O(logN)</code>，N 为有序表含有的记录数。</li></ul></li></ol><h1 id="矩阵打印和查找问题"><a href="#矩阵打印和查找问题" class="headerlink" title="矩阵打印和查找问题"></a>矩阵打印和查找问题</h1><h2 id="1）转圈打印矩阵"><a href="#1）转圈打印矩阵" class="headerlink" title="1）转圈打印矩阵"></a>1）转圈打印矩阵</h2><p>给定一个整型矩阵matrix，请按照转圈的方式打印它。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg"></p><p>打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span> <span class="hljs-number">13</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>思路：这类问题需要将思维打开，从宏观的层面去找出问题存在的共性从而求解。如果你的思维局限在1是如何变到2的、4是怎么变到8的、11之后为什么时10、它们之间有什么关联，那么你就陷入死胡同了。</p><p>从宏观的层面找共性，其实转圈打印的过程就是不断顺时针打印外围元素的过程，只要给你一个左上角的点（如<code>(0,0)</code>）和右下角的点（如<code>(3,3)</code>），你就能够打印出<code>1 2 3 4 8 12 16 15 14 13 9 5</code>；同样，给你<code>(1,1)</code>和<code>(2,2)</code>，你就能打印出<code>6 7 11 10</code>。这个根据两点打印正方形上元素的过程可以抽取出来，整个问题也就迎刃而解了。</p><p>打印一个矩阵某个正方形上的点的逻辑如下：</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141429.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spiralOrderPrint</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;<br>printEdge(matrix, tR++, tC++, dR--, dC--);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC)</span> &#123;<br><span class="hljs-keyword">if</span> (tR == dR) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tC; i &lt;= dC; i++) &#123;<br>System.out.print(m[tR][i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tC == dC) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tR; i &lt;= dR; i++) &#123;<br>System.out.print(m[i][tC] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">curC</span> <span class="hljs-operator">=</span> tC;<br><span class="hljs-type">int</span> <span class="hljs-variable">curR</span> <span class="hljs-operator">=</span> tR;<br><span class="hljs-keyword">while</span> (curC != dC) &#123;<br>System.out.print(m[tR][curC] + <span class="hljs-string">&quot; &quot;</span>);<br>curC++;<br>&#125;<br><span class="hljs-keyword">while</span> (curR != dR) &#123;<br>System.out.print(m[curR][dC] + <span class="hljs-string">&quot; &quot;</span>);<br>curR++;<br>&#125;<br><span class="hljs-keyword">while</span> (curC != tC) &#123;<br>System.out.print(m[dR][curC] + <span class="hljs-string">&quot; &quot;</span>);<br>curC--;<br>&#125;<br><span class="hljs-keyword">while</span> (curR != tR) &#123;<br>System.out.print(m[curR][tC] + <span class="hljs-string">&quot; &quot;</span>);<br>curR--;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2）旋转正方形矩阵"><a href="#2）旋转正方形矩阵" class="headerlink" title="2）旋转正方形矩阵"></a>2）旋转正方形矩阵</h2><p>给定一个整型正方形矩阵 matrix，请把该矩阵调整成顺时针旋转 90 度的样子，要求额外空间复杂度为 O(1)。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141435.jpeg"></p><p>思路：拿上图举例，首先选取矩阵四个角上的点<code>1,3,9,7</code>，按顺时针的方向<code>1</code>到<code>3</code>的位置（<code>1-&gt;3</code>）、<code>3-&gt;9</code>、<code>9-&gt;7</code>、<code>7-&gt;1</code>，这样对于旋转后的矩阵而言，这四个点已经调整好了。接下来只需调整<code>2,6,8,4</code>的位置，调整方法是一样的。只需对矩阵第一行的前 n-1 个点采用同样的方法进行调整、对矩阵第二行的前前n-3个点……，那么调整 n 阶矩阵就容易了。</p><p>这也是在宏观上观察数据变动的一般规律，找到以不变应万变的通解（给定一个点，确定矩阵上以该点为角的正方形，将该正方形旋转90°），整个问题就不攻自破了。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141443.jpeg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (tR &lt; dR) &#123;<br>rotateEdge(matrix, tR++, tC++, dR--, dC--);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> dC - tC; <br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != times; i++) &#123;<br>tmp = m[tR][tC + i];<br>m[tR][tC + i] = m[dR - i][tC];<br>m[dR - i][tC] = m[dR][dC - i];<br>m[dR][dC - i] = m[tR + i][dC];<br>m[tR + i][dC] = tmp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3）“之”字形打印矩阵"><a href="#3）“之”字形打印矩阵" class="headerlink" title="3）“之”字形打印矩阵"></a>3）“之”字形打印矩阵</h2><p>给定一个矩阵 matrix，按照“之”字形的方式打印这个矩阵。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141454.jpeg"></p><p>对如上矩阵的打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">13</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">11</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">12</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>思路：此题也是需要从宏观上找出一个共性：给你两个，你能否将该两点连成的45°斜线上的点按给定的打印方向打印出来。拿上图举例，给出<code>(2,0)</code>、<code>(0,2)</code>和<code>turnUp=true</code>，应该打印出<code>13,8,3</code>。那么整个问题就变成了两点的走向问题了，开始时两点均为<code>(0,0)</code>，然后一个点往下走，另一个点往右走（如<code>1-&gt;7</code>，<code>1-&gt;2</code>）；当往下走的点是边界点时就往右走（如<code>13-&gt;14</code>），当往右走的点到边界时就往下走（如<code>6-&gt;12</code>）。每次两点走一步，并打印两点连线上的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMatrixZigZag</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">endR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">endC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">fromUp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (tR != endR + <span class="hljs-number">1</span>) &#123;<br>printLevel(matrix, tR, tC, dR, dC, fromUp);<br>tR = tC == endC ? tR + <span class="hljs-number">1</span> : tR;<br>tC = tC == endC ? tC : tC + <span class="hljs-number">1</span>;<br>dC = dR == endR ? dC + <span class="hljs-number">1</span> : dC;<br>dR = dR == endR ? dR : dR + <span class="hljs-number">1</span>;<br>fromUp = !fromUp;<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC,</span><br><span class="hljs-params"><span class="hljs-type">boolean</span> f)</span> &#123;<br><span class="hljs-keyword">if</span> (f) &#123;<br><span class="hljs-keyword">while</span> (tR != dR + <span class="hljs-number">1</span>) &#123;<br>System.out.print(m[tR++][tC--] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">while</span> (dR != tR - <span class="hljs-number">1</span>) &#123;<br>System.out.print(m[dR--][dC++] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4）在行列都排好序的矩阵中找数"><a href="#4）在行列都排好序的矩阵中找数" class="headerlink" title="4）在行列都排好序的矩阵中找数"></a>4）在行列都排好序的矩阵中找数</h2><p>给定一个有 N*M 的整型矩阵 matrix 和一个整数 K，matrix 的每一行和每一 列都是排好序的。实现一个函数，判断 K 是否在 matrix 中。 例如：0 1 2 5 2 3 4 7 44 4 8 5 7 7 9 如果 K 为7，返回true；如果 K 为 6，返回false。要求时间复杂度为O(N+M)，额外空间复杂度为 O(1)。</p><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141502.jpeg"></p><p>思路：从矩阵右上角的点开始取点与该数比较，如果大于该数，那么说明这个点所在的列都不存在该数，将这个点左移；如果这个点上的数小于该数，那么说明这个点所在的行不存在该数，将这个点下移。直到找到与该数相等的点为止。最坏的情况是，该数只有一个且在矩阵左下角上，那么时间复杂度为<code>O(M-1+N-1)=O(M+N)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContains</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> K)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt; -<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (matrix[row][col] == K) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; K) &#123;<br>col--;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>row++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二分法的详解与扩展"><a href="#二分法的详解与扩展" class="headerlink" title="二分法的详解与扩展"></a>二分法的详解与扩展</h1><h2 id="1）在一个有序数组中，找某个数是否存在"><a href="#1）在一个有序数组中，找某个数是否存在" class="headerlink" title="1）在一个有序数组中，找某个数是否存在"></a>1）在一个有序数组中，找某个数是否存在</h2><p><strong>在一个有序序列中查找一个元素可以使用二分法（也称折半法）</strong>。原理就是将查找的元素与序列的中位数进行比较，如果小于则去掉中位数及其之后的序列，如果大于则去掉中位数及其之前的序列，如果等于则找到了。如果不等于那么再将其与剩下的序列继续比较直到找到或剩下的序列为空为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sortedArr, <span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-literal">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> sortedArr.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// L..R</span><br><span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span><br><span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;<br>R = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>L = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sortedArr[L] == num;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的时间复杂度为<code>O(logn)</code>（如果没有特别说明，log均以2为底），每次砍掉一半。</p><h2 id="2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置"></a>2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nearestIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> value)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span><br><span class="hljs-keyword">while</span> (L &lt;= R) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;<br>index = mid;<br>R = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>L = mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3）局部最小值问题"><a href="#3）局部最小值问题" class="headerlink" title="3）局部最小值问题"></a>3）局部最小值问题</h2><p>局部最小的概念：</p><ul><li>[0] &lt; [i]，0是局部最小</li><li>[N-1] &lt; [N-2]，N-1 是局部最小</li><li>[i-1] &gt; [i] &lt; [i+1]，i 是局部最小</li></ul><p>要求：在一个无序数组（相邻位置的数据不相等）上返回任意一个局部最小值的位置。</p><p>思路：</p><p>1）比较是否 [0] &lt; [1] ，若是，直接返回0；</p><p>2）比较是否 [N-1] &lt; [N-2] ，若是，直接返回 N-1；</p><ol start="3"><li>若以上均不是，则 [0]-&gt;[1] 呈下降趋势，[N-2]-&gt;[N-1] 呈上升趋势，[0] 到 [N-1] 上必存在局部最小，必有拐点。然后寻找  [0] 和 [N-1] 的中间位置 M ，比较 [M-1] , [M] , [M+1] 的大小。若 [M] 最小，直接返回；若 [M] 大于 [M-1] ，则 [0] 到 [M] 上必存在局部最小；若 [M] 大于 [M+1] ，则 [M] 到 [N-1] 上必存在局部最小，以此类推。</li></ol><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102118.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLessIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span><br>&#125;<br><span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;<br><span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>mid = (left + right) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结论：</p><ul><li>不一定是有序数组才能用二分法</li><li>优化算法有两个方式：数据状况和问题性质</li></ul></blockquote><h1 id="异或运算的性质与扩展"><a href="#异或运算的性质与扩展" class="headerlink" title="异或运算的性质与扩展"></a>异或运算的性质与扩展</h1><h2 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h2><p>异或运算：相异为1，相同为0，即<strong>无进位加法</strong>。</p><p>性质：</p><ul><li>0^N &#x3D;&#x3D; N  </li><li>N^N &#x3D;&#x3D; 0</li><li>异或运算满足交换律和结合率</li></ul><h2 id="1）不用额外变量交换两个数"><a href="#1）不用额外变量交换两个数" class="headerlink" title="1）不用额外变量交换两个数"></a>1）不用额外变量交换两个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交换arr的i和j位置上的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-comment">//一种异或操作来交换两数的位置</span><br>    <span class="hljs-comment">//假设arr[i]=a,arr[j]=b</span><br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b,arr[j]=b</span><br>arr[j] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b,arr[j]=a^b^b=a</span><br>arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b^a=b,arr[j]=a</span><br>    <span class="hljs-comment">//int tmp = arr[i];</span><br><span class="hljs-comment">//arr[i] = arr[j];</span><br><span class="hljs-comment">//arr[j] = tmp;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数"><a href="#2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数" class="headerlink" title="2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数"></a>2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数</h2><p>思路：设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">eor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : arr) &#123;<br>eor ^= cur;<br>&#125;<br>System.out.println(eor);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数"><a href="#3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数" class="headerlink" title="3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数"></a>3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</h2><p>思路：</p><ol><li>设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的两种数的异或结果，即 a^b，eor !&#x3D; 0。</li><li>eor 不为 0，其数值必然有一个位置上是1，提取 eor 最右的1，假设为第 n 位，a 和 b 在第 n 位不同。</li><li>将数组中的数与提取的结果相与，将数分为两类，即第 n 位为 1 的数和第 n 位不为 1 的数，a 和 b 不在同一类。</li><li>设置 eor’ （onlyOne）为 0 ，将两类中的一类与 eor’ 进行异或，最后的值即为其中一个出现了奇数次的数。</li><li>将  eor’ 和 eor 进行异或，则得到另一个出现了奇数次的数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">eor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;<br>eor ^= arr[i];<br>&#125;<br><span class="hljs-comment">// eor = a ^ b</span><br><span class="hljs-comment">// eor != 0</span><br><span class="hljs-comment">// eor必然有一个位置上是1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">rightOne</span> <span class="hljs-operator">=</span> eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">onlyOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : arr) &#123;<br><span class="hljs-keyword">if</span> ((cur &amp; rightOne) == <span class="hljs-number">1</span>) &#123;<br>onlyOne ^= cur;<br>&#125;<br>&#125;<br>System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h1><h2 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h2><blockquote><p>贪心算法：</p><p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到<br>一个答案的算法。</p><p>也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。</p><p>贪心策略：局部最优 -?-&gt; 整体最优</p><p>需找到是局部最优同时也是整体最优的结果。</p></blockquote><p>贪心策略在实现时，经常使用到的技巧：</p><ul><li>根据某标准建立一个比较器来排序。</li><li>根据某标准建立一个比较器来组成堆。</li></ul><h2 id="贪心算法在笔试时的解题套路"><a href="#贪心算法在笔试时的解题套路" class="headerlink" title="贪心算法在笔试时的解题套路"></a>贪心算法在笔试时的解题套路</h2><ol><li>实现一个不依靠贪心策略的正确解法 X，可以用最暴力的尝试；</li><li>脑补出贪心策略 A、贪心策略 B、贪心策略 C…</li><li>用解法 X 和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确；</li><li>不要去纠结贪心策略的证明（贪心策略的证明非常难）。</li></ol><h2 id="1）拼接最小字典序"><a href="#1）拼接最小字典序" class="headerlink" title="1）拼接最小字典序"></a>1）拼接最小字典序</h2><p>给定一个字符串类型的数组 strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最小的字典序。</p><p>可以提出的贪心策略：（需注意：提出的贪心策略需具有正确性，在此题中表现为排序方式需要具有传递性，“剪刀石头布”就是一种不具有传递性的排序方式。）</p><ul><li><p>把数组按照字典序排序，然后从头到尾连接。</p><blockquote><p>str1，str2，谁字典序低，谁在前。</p></blockquote><p>但这很容易证明是错的，比如 [“b”,”ba”] 的排序结果是 [“b”,”ba”]，拼接结果是 “bba”，但 “bab” 的字典序更小。 </p></li><li><p>正确策略：将有序字符串数组从头到尾两两拼接时，应取两两拼接的拼接结果中字典序较小的那个。</p><blockquote><p>如果令.代表拼接符号，str1.str2&lt;&#x3D;str2.str1，str1 在前，否则，str2 在前。</p></blockquote><p>证明如下：</p><blockquote><p>即如果 str1.str2 &lt; str2.str2 且 str2.str3 &lt; str3.str2，那么一定有str1.str3 &lt; str3.str1。这可以使用数学归纳法来证明。如果将 a<del>z 对应到0</del>25，比较两个字符串的字典序的过程，其实就是比较两个 26 进制数大小的过程。str1.str2 拼接的过程可以看做两个 26 进制数拼接的过程。若将两字符串解析成数字 int1 和 int2，那么拼接就对应 int1 * 26^(str2的长度) + int2，那么证明过程就变成了两个整数不等式递推另一个不等式了。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> &#123;<br><span class="hljs-keyword">return</span> (a + b).compareTo(b + a);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">lowestString</span><span class="hljs-params">(String[] strs)</span> &#123;<br><span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br>Arrays.sort(strs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>());<br><span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>res += strs[i];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2）金条和铜板"><a href="#2）金条和铜板" class="headerlink" title="2）金条和铜板"></a>2）金条和铜板</h2><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为 20 的金条，不管切成长度多大的两半，都要花费 20 个铜板。一群人想整分整块金条，怎么分最省铜板?</p><p>例如，给定数组 {10,20,30}，代表一共三个人，整块金条长度为 10+20+30&#x3D;60。金条要分成 10,20,30 三个部分。 如果先把长度 60 的金条分成 10 和 50，花费 60；再把长度 50 的金条分成 20 和 30，花费 50；一共花费 110 铜板。但是如果先把长度 60 的金条分成 30 和 30，花费 60；再把长度 30 金条分成 10 和 20，花费 30；一共花费 90 铜板。</p><p>输入一个数组，返回分割的最小代价。</p><p>贪心策略：先把两个小的合在一起，依次逆着过去。</p><p>具体操作：将给定的数组中的元素扔进小根堆，每次从小根堆中先后弹出两个元素，这两个元素的和就是某次分割得到的这两个元素的花费，再将这个和扔进小根堆。周而复始，直到小根堆中只有一个元素为止。合的顺序反过来即是切的顺序。这样做即可得到最小代价。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102221702.png" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lessMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// PriorityQueue是Java语言对堆结构的一个实现，默认将按自然顺序的最小元素放在堆顶</span><br>PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>pQ.add(arr[i]);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;<br>cur = pQ.poll() + pQ.poll();<br>sum += cur;<br>pQ.add(cur);<br>&#125;<br><span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>本质上都是按照某一种标准排序之后依次处理。</p></blockquote><h2 id="3）会议室项目宣讲"><a href="#3）会议室项目宣讲" class="headerlink" title="3）会议室项目宣讲"></a>3）会议室项目宣讲</h2><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次。</p><p>可以提出的贪心策略： </p><ul><li>开始时间最早的项目先安排。反例：开始时间最早，但持续时间占了一整天，其他项目无法安排。 </li><li>持续时间最短的项目先安排。反例：这样安排会导致结束时间在此期间和开始时间在此期间的所有项目不能安排。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220220.png" style="zoom: 67%;" /><ul><li>最优策略：最先结束的项目先安排。</li></ul><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220310.png" style="zoom: 67%;" /><p>最优策略实现思路：</p><ol><li>从项目集合选择一个项目 x，这个 x 是在当前所有项目中结束最早的（end 最小）。</li><li>把所有与 x 时间冲突的项目从项目集合中删除。</li><li>重复步骤 1 和 2，直到项目集合为空为止。之前选出的那些 x 就是最多的项目宣讲场次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Program</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br><span class="hljs-built_in">this</span>.start = start;<br><span class="hljs-built_in">this</span>.end = end;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Program&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Program o1, Program o2)</span> &#123;<br><span class="hljs-keyword">return</span> o1.end - o2.end;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// timePoint 此时来到的时间点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bestArrange</span><span class="hljs-params">(Program[] programs, <span class="hljs-type">int</span> timePoint)</span> &#123;<br>Arrays.sort(programs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgramComparator</span>());<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 从左往右依次遍历所有的会议</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;<br><span class="hljs-keyword">if</span> (timePoint &lt;= programs[i].start) &#123;<br>result++;<br>timePoint = programs[i].end;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4）IPO"><a href="#4）IPO" class="headerlink" title="4）IPO"></a>4）IPO</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：正数数组 costs、正数数组 profits、正数 k、正数 m。<br>含义：costs<span class="hljs-selector-attr">[i]</span> 表示 <span class="hljs-selector-tag">i</span> 号项目的花费、profits<span class="hljs-selector-attr">[i]</span> 表示 <span class="hljs-selector-tag">i</span> 号项目在扣除花费之后还能挣到的钱（利润）、k 表示你只能串行的最多做 k 个项目、m 表示你初始的资金。<br>说明：你每做完一个项目，马上获得的收益（纯利润），可以支持你去做下一个项目。<br>输出：你最后获得的最大钱数。<br></code></pre></td></tr></table></figure><p>贪心策略：借助两个堆，一个是存放各个项目花费的小根堆、另一个是存放各个项目利润的大根堆。首先将所有项目放入小根堆而大根堆为空，对于手头上现有的资金（本金），将能做的项目（成本低于现有资金）从小根堆依次弹出并放入到大根堆，再弹出大根堆堆顶项目来完成，完成后根据利润更新本金。本金更新后，再将小根堆中能做的项目弹出加入到大根堆中，再弹出大根堆中的堆顶项目来做，重复此操作，直到某次本金更新和两个堆更新后大根堆无项目可做或者完成的项目个数已达 k 个为止。</p><p>下图为图示例子做完三个项目后的结果。</p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145756.png" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> p;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> c;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> c)</span> &#123;<br><span class="hljs-built_in">this</span>.p = p;<br><span class="hljs-built_in">this</span>.c = c;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;<br><span class="hljs-keyword">return</span> o1.c - o2.c; <span class="hljs-comment">// 升序，由此构造的堆将把花费最小项目的放到堆顶</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt; &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;<br><span class="hljs-keyword">return</span> o2.p - o1.p;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> W, <span class="hljs-type">int</span>[] Profits, <span class="hljs-type">int</span>[] Capital)</span> &#123;<br>PriorityQueue&lt;Node&gt; minCostQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MinCostComparator</span>());<br>PriorityQueue&lt;Node&gt; maxProfitQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxProfitComparator</span>());<br><span class="hljs-comment">// 所有项目扔到被锁池中, 花费组织的小根堆</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;<br>minCostQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Profits[i], Capital[i]));<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 进行K轮</span><br><span class="hljs-comment">// 能力所及的项目，全解锁</span><br><span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;<br>maxProfitQ.add(minCostQ.poll());<br>&#125;<br>        <span class="hljs-comment">// 无法继续解锁项目，做不完K个项目提前返回</span><br><span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;<br><span class="hljs-keyword">return</span> W;<br>&#125;<br>W += maxProfitQ.poll().p;<br>&#125;<br><span class="hljs-keyword">return</span> W;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>经验：贪心策略相关的问题，累积经验就好，不必花费大量精力去证明。解题的时候要么找相似点，要么脑补策略然后用对数器、测试用例去证。</p></blockquote><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h2><ol><li>对于一个你想要测的方法a</li><li>实现功能与该算法相同但绝对正确、复杂度不好但是容易实现的方法b</li><li>实现一个随机样本产生器</li><li>实现比对：把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。</li><li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b</li><li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</li></ol><p>对数器使用案例——对于选择排序进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.有一个自写的算法，但不知其健壮性（是否会有特殊情况使程序异常中断甚至崩溃）和正确性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span><br>minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<br>&#125;<br>swap(arr, i, minIndex);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>arr[i] = arr[j];<br>arr[j] = tmp;<br>&#125;<br><br><span class="hljs-comment">//2、实现一个功能相同、绝对正确但复杂度不好的算法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">comparator</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>Arrays.sort(arr);<br>&#125;<br><br><span class="hljs-comment">//3、实现一个能够产生随机简短样本的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] generateRandomArray(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue) &#123;<br><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[(<span class="hljs-type">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>arr[i] = (<span class="hljs-type">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random()) - (<span class="hljs-type">int</span>) (maxValue * Math.random());<br>&#125;<br><span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyArray(<span class="hljs-type">int</span>[] arr) &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>res[i] = arr[i];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//4、实现一个比对测试算法和正确算法运算结果的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEqual</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2)</span> &#123;<br><span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-literal">null</span> &amp;&amp; arr2 != <span class="hljs-literal">null</span>) || (arr1 != <span class="hljs-literal">null</span> &amp;&amp; arr2 == <span class="hljs-literal">null</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (arr1 == <span class="hljs-literal">null</span> &amp;&amp; arr2 == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br><span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br><span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-comment">// for test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">testTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">500000</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">succeed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br><span class="hljs-type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);<br><span class="hljs-type">int</span>[] arr2 = copyArray(arr1);<br>selectionSort(arr1);<br>comparator(arr2);<br><span class="hljs-comment">//5、比对两个算法，只要有一个样本没通过就终止，并打印原始样本</span><br><span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;<br>succeed = <span class="hljs-literal">false</span>;<br>printArray(arr1);<br>printArray(arr2);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//6、测试全部通过，该算法大概率上正确</span><br>System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);<br><br><span class="hljs-type">int</span>[] arr = generateRandomArray(maxSize, maxValue);<br>printArray(arr);<br>selectionSort(arr);<br>printArray(arr);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归的实质和Master公式"><a href="#递归的实质和Master公式" class="headerlink" title="递归的实质和Master公式"></a>递归的实质和Master公式</h2><h3 id="递归的实质"><a href="#递归的实质" class="headerlink" title="递归的实质"></a>递归的实质</h3><p>递归的实质就是系统在帮我们压栈。首先让我们来看一个递归求阶乘的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>  <span class="hljs-keyword">return</span> n*<span class="hljs-built_in">fun</span>(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>课上老师一般告诉我们递归就是函数自己调用自己。但这听起来很玄学。事实上，在函数执行过程中如果调用了其他函数，那么当前函数的执行状态（执行到了第几行，有几个变量，各个变量的值是什么等等）会被保存起来压进栈（先进后出的存储结构，一般称为函数调用栈）中，转而执行子过程（调用的其他函数，当然也可以是当前函数）。若子过程中又调用了函数，那么调用前子过程的执行状态也会被保存起来压进栈中，转而执行子过程的子过程……以此类推，直到有一个子过程没有调用函数、能顺序执行完毕时会从函数调用栈依次弹出栈顶被保存起来的未执行完的函数（恢复现场）继续执行，直到函数调用栈中的函数都执行完毕，整个递归过程结束。</p><p>例如，在<code>main</code>中执行<code>fun(3)</code>，其递归过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141518"></p><p>很多时候我们分析递归时都喜欢在心中模拟代码执行，去追溯、还原整个递归调用过程。但事实上没有必要这样做，因为每相邻的两个步骤执行的逻辑都是相同的，因此我们只需要分析第一步到第二步是如何执行的以及递归的终点在哪里就可以了。</p><p><strong>一切的递归算法都可以转化为非递归</strong>，因为我们完全可以自己压栈。只是说递归的写法更加简洁。在实际工程中，递归的使用是极少的，因为递归创建子函数的开销很大并且存在安全问题（stack overflow）。</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><p>包含递归的算法的时间复杂度有时很难通过算法表面分析出来， 比如 <strong>归并排序</strong>。这时Master公式就粉墨登场了，当某递归算法的时间复杂度符合<code>T(n)=aT(n/b)+O(n^d)</code>形式时可以直接求出该算法的直接复杂度：</p><ul><li>当（以b为底a的对数）<code>log(b,a) &gt; d</code>时，时间复杂度为<code>O(n^log(b,a))</code></li><li>当<code>log(b,a) = d</code>时，时间复杂度为<code>O(n^d * logn)</code></li><li>当<code>log(b,a) &lt; d</code>时，时间复杂度为<code>O(n^d)</code></li></ul><p>其中，<code>n</code>为样本规模，<code>n/b</code>为子过程的样本规模（暗含<strong>子过程的样本规模必须相同</strong>，且相加之和等于总样本规模），<code>a</code>为子过程的执行次数，<code>O(n^d)</code>为除子过程之后的操作的时间复杂度。</p><p>以归并排序为例，函数本体先对左右两半部分进行归并排序，样本规模被分为了左右各<code>n/2</code>即<code>b=2</code>，左右各归并排序了一次，子过程执行次数为<code>2</code>即<code>a=2</code>，并入操作的时间复杂度为<code>O(n+n)=O(n)</code>即<code>d=1</code>，因此<code>T(n)=2T(n/2)+O(n)</code>，符合<code>log(b,a)=d=1</code>，因此<strong>归并排序的时间复杂度</strong>为<code>O(n^1*logn)=O(nlogn)</code>。</p><h2 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h2><p>有时我们不确定二叉树中是否有指针连空了或者连错了，这时需要将二叉树具有层次感地打印出来，下面就提供了这样一个工具。你可以将你的头逆时针旋转90度看打印结果。<code>v</code>表示该结点的头结点是左下方距离该结点最近的一个结点，<code>^</code>表示该结点的头结点是左上方距离该结点最近的一个结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> Node left;<br><span class="hljs-keyword">public</span> Node right;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br><span class="hljs-built_in">this</span>.value = data;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(Node head)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);<br>printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);<br>System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> height, String to, <span class="hljs-type">int</span> len)</span> &#123;<br><span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);<br><span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> to + head.value + to;<br><span class="hljs-type">int</span> <span class="hljs-variable">lenM</span> <span class="hljs-operator">=</span> val.length();<br><span class="hljs-type">int</span> <span class="hljs-variable">lenL</span> <span class="hljs-operator">=</span> (len - lenM) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">lenR</span> <span class="hljs-operator">=</span> len - lenM - lenL;<br>val = getSpace(lenL) + val + getSpace(lenR);<br>System.out.println(getSpace(height * len) + val);<br>printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSpace</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>buf.append(space);<br>&#125;<br><span class="hljs-keyword">return</span> buf.toString();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">222222222</span>);<br>head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.MIN_VALUE);<br>head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">55555555</span>);<br>head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">66</span>);<br>head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">777</span>);<br>printTree(head);<br><br>head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br>head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br>head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br>printTree(head);<br><br>head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>printTree(head);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
