

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="《Effective C++——改善程序与设计的55个具体做法》是 Scott Meyers 大师的巨作。本篇记录下自己的阅读笔记，在记录过程中，参考了 @arkingc 的仓库，在此表示感谢！">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++ 阅读笔记">
<meta property="og:url" content="https://simpleforever.github.io/2021/01/08/Effective%20C++_Scott%20Meyers/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="《Effective C++——改善程序与设计的55个具体做法》是 Scott Meyers 大师的巨作。本篇记录下自己的阅读笔记，在记录过程中，参考了 @arkingc 的仓库，在此表示感谢！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160045.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160131.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160230.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160411.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160438.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160513.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160539.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160646.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160727.png">
<meta property="article:published_time" content="2021-01-07T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-27T06:16:47.691Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Effective C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160045.png">
  
  
  <title>Effective C++ 阅读笔记 - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Effective C++ 阅读笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-08 00:00" pubdate>
        2021年1月8日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      65k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      539 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Effective C++ 阅读笔记</h1>
            
            <div class="markdown-body">
              <p>《Effective C++——改善程序与设计的55个具体做法》是 Scott Meyers 大师的巨作。本篇记录下自己的阅读笔记，在记录过程中，参考了 @<a target="_blank" rel="noopener" href="https://github.com/arkingc">arkingc</a> 的仓库，在此表示感谢！</p>
<span id="more"></span>

<h1 id="一-让自己习惯C"><a href="#一-让自己习惯C" class="headerlink" title="一.让自己习惯C++"></a>一.让自己习惯C++</h1><h2 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h2><ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<br>

<h2 id="条款02：尽量以const-enum-inline替换-define"><a href="#条款02：尽量以const-enum-inline替换-define" class="headerlink" title="条款02：尽量以const,enum,inline替换#define"></a>条款02：尽量以const,enum,inline替换#define</h2><p><strong>这个条款或许改为“宁可以编译器替换预处理器”比较好</strong></p>
<h3 id="1）以const替换-define"><a href="#1）以const替换-define" class="headerlink" title="1）以const替换#define"></a>1）以const替换#define</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br>替换为：<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> AspectRatio = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>调试的需要</strong>：#define的记号会被预处理器移走，记号名称可能没进入记号表内。因此当#define的宏名称获得一个编译错误时，会引起困惑，浪费大量时间追踪错误。而AspectRatio肯定会被编译器看到</li>
<li><strong>更小的代码量</strong>：对浮点数而言，使用常量可能比使用#define导致较小量的代码，因为预处理器“盲目地将ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653</li>
</ul>
<p>但是，以常量替换#define时要注意：</p>
<ul>
<li><p><strong>定义常量指针时：由于常量定义式通常被定义在头文件内，因此有必要将指针声明为const</strong>。如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>class专属常量</strong>：class专属常量需要声明在class内部，并且被class使用，而为确保此常量至多只有一份实体，须让它成为一个static成员：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>; <span class="hljs-comment">//常量声明式</span><br>    <span class="hljs-type">int</span> scores[NumTurns];          <span class="hljs-comment">//使用该常量</span><br>&#125;;<br><span class="hljs-comment">//通常定义出现在头文件中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns;    <span class="hljs-comment">//NumTurns的定义</span><br></code></pre></td></tr></table></figure>
<p>  对于static修饰的class专属整形常量，如果需要对该常量取地址或编译器坚持要看到一个定义式。那么必须提供类外定义。如果类内声明时提供了初始值，类外定义就不能再设初值。</p>
</li>
</ul>
<h3 id="2）以enum替换-define"><a href="#2）以enum替换-define" class="headerlink" title="2）以enum替换#define"></a>2）以enum替换#define</h3><p>某些编译器不允许“static整数型class常量”完成“in class 初值设定”，可改用”<strong>the enum hack</strong>“补偿做法，理论基础是“一个属于枚举类型的数值可权充ints被使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br>    <span class="hljs-keyword">enum</span> &#123;NumTurns = <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> scores[NumTurns];   <span class="hljs-comment">//这就没问题了</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>enum hack</strong>的行为比较像#define而不像const。例如取一个const的地址时合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。</p>
<h3 id="3）以inline替换-define"><a href="#3）以inline替换-define" class="headerlink" title="3）以inline替换#define"></a>3）以inline替换#define</h3><p>以#define实现宏看起来像函数，并且不会导致函数调用带来的开销，但是可能引发错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ?  (a) : (b))</span><br><br><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>,b = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b);       <span class="hljs-comment">//a被累加2次</span><br><span class="hljs-built_in">CALL_WITH_MAX</span>(++a,b + <span class="hljs-number">10</span>);  <span class="hljs-comment">//a被累加1次</span><br></code></pre></td></tr></table></figure>

<p>使用inline函数可以减轻为参数加上括号以及参数被核算多次等问题。同时，inline可以实现一个“类内的private inline函数”，但一般而言宏无法完成此事。</p>
<br>

<h2 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h2><h3 id="1）const修饰变量"><a href="#1）const修饰变量" class="headerlink" title="1）const修饰变量"></a>1）const修饰变量</h3><p>如果变量本身不应该被修改，应该使用const修饰。这样编译器可以进行保护，确保这个变量不会被修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> greeting[] = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">char</span> *p = greeting;                    <span class="hljs-comment">// non-const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *p = greeting;              <span class="hljs-comment">// non-const pointer, const data</span><br><span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;             <span class="hljs-comment">// const pointer, non-const data</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> p = greeting;       <span class="hljs-comment">// const pointer, const data </span><br></code></pre></td></tr></table></figure>

<ul>
<li>如果关键字const出现在星号左边，表示被指物是常量</li>
<li>如果出现在星号右边，表示指针自身是常量</li>
</ul>
<h3 id="2）const修饰函数"><a href="#2）const修饰函数" class="headerlink" title="2）const修饰函数"></a>2）const修饰函数</h3><ul>
<li>修饰参数时，和修饰一般变量相同</li>
<li><strong>修饰返回值，可以降低因客户错误而造成的意外</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Rational a, b, c;<br>...<br><span class="hljs-keyword">if</span> (a * b = c)&#123; <span class="hljs-comment">//其实是想做一个比较动作，使用const修饰返回值可以避免这种错误</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果a和b都是内置类型。这样的代码直截了当就是不合法。而一个“良好的用户自定义类型”的特征是他们避免与内置类型不兼容。因此对operator*的定义应该如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure>

<h3 id="3）const修饰成员函数"><a href="#3）const修饰成员函数" class="headerlink" title="3）const修饰成员函数"></a>3）const修饰成员函数</h3><p>const修饰成员函数有2个好处：</p>
<ol>
<li><strong>可读性</strong>：使得接口容易被理解，可以知道哪个函数可以改动对象哪个函数不行</li>
<li><strong>const修饰的成员函数可以作用于const对象</strong></li>
</ol>
<p>但是，使用const修饰成员函数时需要注意，C++对常量性的定义是bitwise constness，即函数const成员函数不应该修改对象的任何成员变量。因此，如果成员变量是一个指针，那么不修改指针而修改指针所指之物，也符合bitwise constness，因此如果不是从bitwise constness的角度，这样也是修改了对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>   <span class="hljs-comment">// bitwise constness声明</span><br>  &#123; <span class="hljs-keyword">return</span> pText[position]; &#125;                    <span class="hljs-comment">// 但其实不恰当</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">char</span>* pText;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>; <span class="hljs-comment">//声明一个常量对象</span><br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];            <span class="hljs-comment">//调用const operator[]取得一个指针，</span><br>                                <span class="hljs-comment">//指向cctb的数据</span><br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>;                      <span class="hljs-comment">//cctb现在有了“Jello”这样的内容</span><br></code></pre></td></tr></table></figure>

<p>还有一种logical constness：一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 最近一次计算的文本区块长度</span><br>  <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 目前的长度是否有效</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//错误！在const成员函数内不能复制给</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//textLength和lengthIsValid</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，C++对常量性的定义是bitwise constness的，所以这样的操作非法。解决办法是使用mutable，mutable释放掉non-static成员变量的bitwise constness约束：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText;<br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength;         <span class="hljs-comment">// 这些成员变量可能总是会被更改</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;             <span class="hljs-comment">// 即使在const成员函数内</span><br>&#125;;                                     <br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">CTextBlock::length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">if</span> (!lengthIsValid) &#123;                 <br>    textLength = std::<span class="hljs-built_in">strlen</span>(pText);    <span class="hljs-comment">//现在可以这样</span><br>    lengthIsValid = <span class="hljs-literal">true</span>;               <span class="hljs-comment">//也可以这样</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> textLength;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总的来说，上面提到了2种“修改”const成员函数中修改对象（修改const对象）的方法。</p>
<p>最后，const和non-const版本的函数可能含有重复的代码，如果抽离出来单独成为一个成员函数还是有重复。如果希望去重，可以使用“运用const成员函数实现出其non-const孪生兄弟”的技术：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>&#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock&amp;&gt;(*<span class="hljs-keyword">this</span>)<br>                [pos]   <br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<br>

<h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p><strong>读取未初始化对象的后果</strong>：读取未被初始化的值会导致不明确的行为。在某些平台上，仅仅只是读取未初始化的值就可能让程序终止，更可能的情况是读入一些“半随机”bits，污染了正在进行读取动作的那个对象，最终导致不可预知的程序行为，以及许多令人不愉快的调试过程。</p>
<p>按对象的类型划分：</p>
<ul>
<li><strong>对于内置类型的对象</strong>：永远在使用前初始化</li>
<li><strong>类类型的对象</strong>：初始化责任落在构造函数身上<ul>
<li><strong>效率上的问题</strong>：<ul>
<li>类类型成员的初始化动作发生在构造函数本体之前。比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数比较高效。因此，善用初始化列表有助于提升效率</li>
<li>内置类型成员的初始化不一定发生在赋值动作的的时间点之前。对于内置类型成员，一般为了保持一致也在初始化列表中给出初始值</li>
</ul>
</li>
<li><strong>初始化顺序</strong>：成员的初始化顺序与类内声明顺序相同</li>
</ul>
</li>
</ul>
<p> 按对象的作用域与生命周期划分</p>
<ul>
<li><strong>static对象</strong><ul>
<li><strong>non-local static对象</strong>：C++对“定义于不同的编译单元内的non-local static对象”的初始化相对次序并无明确定义<ul>
<li>global对象</li>
<li>定义于namespace作用域内的对象</li>
<li>classes内、file作用域内被声明为static的对象</li>
</ul>
</li>
<li><strong>local static对象</strong>：函数内的local static对象会在“该函数被调用期间、首次遇上该对象的定义式”时被初始化<ul>
<li>函数内被声明为static的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，如果一个non-local static对象的初始化依赖于另外一个non-local static的初始化，那么可能造成错误。解决方法是使用local static对象替换non-local static对象（参考单例模式）。</p>
<br>
<br>

<h1 id="二-构造-x2F-析构-x2F-赋值运算"><a href="#二-构造-x2F-析构-x2F-赋值运算" class="headerlink" title="二.构造&#x2F;析构&#x2F;赋值运算"></a>二.构造&#x2F;析构&#x2F;赋值运算</h1><h2 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h2><p>一般情况下，编译器会为类合成下列函数：</p>
<ul>
<li><strong>default构造函数</strong></li>
<li><strong>copy构造函数</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li>
<li><strong>copy assignment操作符</strong>：编译器生成的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象</li>
<li><strong>析构函数</strong>：编译器生成的版本是<strong>non-virtual</strong>的</li>
</ul>
<p>更深层次的理解：深度探索C++对象模型（第2章、第5章）</p>
<p>以下情况编译器不会合成<strong>copy assignment操作符</strong>：</p>
<ul>
<li><strong>含有引用成员</strong>：原因在于这种情况下，赋值的目的不明确。是修改引用还是修改引用的对象？如果是修改引用，这是被禁止的。因此编译器干脆拒绝这样的赋值行为</li>
<li><strong>含有const成员</strong>：const对象不应该修改</li>
<li><strong>父类的copy assignment操作符被声明为private</strong>：无法处理基类子对象，因此也就无法合成</li>
</ul>
<br>

<h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p><strong>为什么要拒绝</strong>？比如，房产应该是独一无二的，这种情况下应该拒绝对象拷贝动作</p>
<p>一般情况下，不声明相应函数即可拒绝。但是编译器会为类合成一些函数，因此需要显式拒绝</p>
<p>还是以拒绝对象拷贝为例子，拒绝方法包括：</p>
<ol>
<li><p><strong>将copy构造函数或copy assignment操作符声明为private，并且不实现</strong>（这被用于C++ iostream程序库中）</p>
<ul>
<li><p>这种情况下member函数和friend函数还是可以调用，如果member函数或friend函数中执行了复制，会引发<strong>链接错误</strong></p>
</li>
<li><p>可以使用一个基类，在基类中将copy构造函数或copy assignment操作符声明为private，并且继承这个基类。这样可以将<strong>链接错误</strong>移至<strong>编译期</strong>，因为尝试拷贝时，编译器会试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器合成版”会尝试调用其基类的对应兄弟，而那些调用会被编译器拒绝，因为base class的拷贝函数是private</p>
</li>
</ul>
</li>
<li><p><strong>使用delete</strong>（书中没有提到）</p>
</li>
</ol>
<br>

<h2 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h2><ul>
<li><strong>为基类声明virtual析构函数</strong>：当派生类对象经由一个基类指针被删除，而该基类带有一个non-virtual析构函数，结果未定义——实际执行时通常发生的是对象的derived成分没有销毁，即“局部销毁”，造成资源泄露（因为存在这个问题，所以不要继承一个不被用作基类的类）</li>
<li>给base classes一个 virtual析构函数”，这个规则只适用于polymorphic（带多态性质的）base classes身上。这种base classes的设计目的是为了用来“通过 base class 接口处理derived class 对象”。polymorphic（带多态性质的）base classes 应该声明一个virtual析构函数。如果 class 带有任何virtual函数，它就应该拥有一个virtual析构函数</li>
<li><strong>class不用作基类时，不要将析构函数声明为virtual</strong>：Classes的设计目的如果不是作为base classes 用，或不是为了具备多态性，就不该声 virtual析构函数。virtual会引入虚函数指针，这会增加空间开销，并且使得类无法被C函数使用，从而不再具有移植性</li>
<li><strong>析构函数可以为pure virtual函数</strong>：抽象class总是企图被当作一个base class来用，又由于base class应该有个virtual析构函数，因此为成为抽象的那个class声明一个pure virtual析构函数</li>
</ul>
<br>

<h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p><strong>C++并不禁止析构函数吐出异常，但是并不鼓励这样做</strong></p>
<h3 id="1）原因"><a href="#1）原因" class="headerlink" title="1）原因"></a>1）原因</h3><p>如果析构函数吐出异常，程序可能过早结束（比如某个函数调用发生异常，在回溯寻找catch过程中，每离开一个函数，这个函数内的局部对象会被析构，如果此时析构函数又抛出异常，前一个异常还没得到处理又来一个，因此一般会引起程序过早结束）。异常从析构函数中传播出去，可能会导致不明确的行为</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28592504">知乎相关描述</a></p>
<h3 id="2）如何解决"><a href="#2）如何解决" class="headerlink" title="2）如何解决"></a>2）如何解决</h3><ol>
<li><strong>在析构函数中catch异常</strong>，然后调用<strong>abort终止</strong>程序。通过abort抢先置“不明确行为”于死地</li>
<li><strong>在析构函数中catch异常</strong>，然后记录该失败，即<strong>吞下异常</strong>（通常是个坏主意，因为这样压制了“某些动作失败”的重要信息。但是也比负担“草率结束程序”或”不明确行为带来的风险“好）</li>
<li>较佳策略是重新设计接口，让客户能够在析构前主动调用可能引起异常的函数，然后析构函数中使用一个bool变量，根据用户是否主动调用来决定析构函数中是否应该调用可能引起异常的函数，<strong>让客户拥有主动权</strong>（如果客户没有主动调用，那么当发生异常时也不应该抱怨，因为已经给出了客户自己处理异常的机会）。如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险</li>
</ol>
<br>

<h2 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h2><p>如果希望在继承体系中根据类型在构建对象时表现出不同行为，会想到在基类的构造函数中调用一个虚函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                           <span class="hljs-comment">//所有交易的基类</span><br><span class="hljs-keyword">public</span>:                                           <br>    <span class="hljs-built_in">Transaction</span>()&#123;           <br>        ...                           <br>        <span class="hljs-built_in">logTransaction</span>();                         <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//做出一份因类型不同而不同的日志记录</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;        <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">//派生类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>但是最终调用的virtual函数都是基类的版本。同时，因为是纯虚函数，除非定义该函数，否则将报链接错误。</p>
<p><strong>在base class构造期间，virtual函数绝不会下降到派生类阶层。取而代之的是，对象的作为就像隶属基类类型一样。即派生类对象的基类构造期间，对象的类型是基类而不是派生类。因此，若使用运行期类型信息</strong>（如dynamic_cast和typeid），也会把对象视为基类类型（这样对待是合理的：因为derived class部分尚未初始化，如果调用的是derived class的虚函数，通常会访问derived class成员变量，会引发安全问题）。</p>
<p><strong>相同道理也适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入base class析构函数后对象就成为一个base class对象</strong>。</p>
<p>如果希望实现最初的功能，即根据类型产生不同日志记录，那么可以将虚函数改为非虚函数，然后要求派生类构造函数在成员初始化列表中，向基类构造函数传递必要信息，基类构造函数根据这些信息，调用非虚函数，生成不同的日志记录。换句话说，由于无法使用虚函数从基类向下调用，在构造期间，可以藉由“令派生类将必要的构造信息向上传递至基类构造函数”替换之而加以弥补，另外，利用辅助函数创建一个值传给基类构造函数往往比较方便且可读。</p>
<br>

<h2 id="条款10：令operator-x3D-返回一个reference-to-this"><a href="#条款10：令operator-x3D-返回一个reference-to-this" class="headerlink" title="条款10：令operator&#x3D;返回一个reference to *this"></a>条款10：令operator&#x3D;返回一个reference to *this</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x,y,z;<br>x = y = z = <span class="hljs-number">15</span>; <span class="hljs-comment">//赋值连锁形式</span><br></code></pre></td></tr></table></figure>

<p>为了实现“连锁赋值”，赋值操作符必须返回一个reference指向操作符的左侧实参。这个协议除了适用于operator&#x3D;，还适用于+&#x3D;、-&#x3D;、*&#x3D;等所有赋值相关运算。</p>
<blockquote>
<p>这只是个协议，并无强制性，如果不遵循，代码一样可通过编译。</p>
</blockquote>
<br>

<h2 id="条款11：在operater-x3D-中处理“自我赋值”"><a href="#条款11：在operater-x3D-中处理“自我赋值”" class="headerlink" title="条款11：在operater&#x3D;中处理“自我赋值”"></a>条款11：在operater&#x3D;中处理“自我赋值”</h2><p>考虑如下Widget类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Bitmap *pb;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>下面的operator&#x3D;实现是一份不安全的实现，在自赋值时会出现问题，也不具备异常安全性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; <br>Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>要处理自赋值，可以有以下几种方式：</p>
<ol>
<li><p><strong>在开头添加“证同测试”</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 证同测试</span><br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p> 这样做虽然能处理自赋值，但不是异常安全的，如果new时发生异常，对象会持有一个指针指向一块被删除的内存</p>
</li>
<li><p>精心周到的语句顺序，<strong>通过确保异常安全来获得自赋值安全的回报</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    Bitmap *pOrig = pb;               <span class="hljs-comment">// remember original pb</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// make pb point to a copy of *pb</span><br>    <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// delete the original pb</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 现在，如果new失败，pb会保持原状。同时也能处理自赋值。如果担心效率可以在开头加上“证同测试”。但是if判断也会引入开销，因此需要权衡自赋值发生的频率</p>
</li>
<li><p><strong>使用copy and swap技术</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <span class="hljs-comment">// 交换*this和rhs的数据，见item29</span><br><span class="hljs-comment">//参数为pass by reference</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)<br>&#123;<br>    Widget <span class="hljs-built_in">temp</span>(rhs);       <br>    <span class="hljs-built_in">swap</span>(temp);               <span class="hljs-comment">// swap *this&#x27;s data with the copy&#x27;s</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;             <br>&#125;<br><span class="hljs-comment">//参数为pass by value</span><br><span class="hljs-comment">//这种方式的缺点是代码不够清晰，但是将“copying动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码</span><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(Widget rhs) <span class="hljs-comment">//rhs是被传对象的一份复件（副本）</span><br>&#123;<br>    <span class="hljs-built_in">swap</span>(rhs);                <span class="hljs-comment">// swap *this&#x27;s data with the copy&#x27;s</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;            <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<br>

<h2 id="条款12：复制对象时勿忘其每一个成分"><a href="#条款12：复制对象时勿忘其每一个成分" class="headerlink" title="条款12：复制对象时勿忘其每一个成分"></a>条款12：复制对象时勿忘其每一个成分</h2><p>如果声明自己的copying函数（copy构造函数和copy assignment操作符），意思就是告诉编译器你并不喜欢缺省实现中的某些行为。编译器仿佛被冒犯似的，会以一种奇怪的方式回敬：如果你自己写出的copying函数代码不完全，它也不会告诉你，具体表现为：</p>
<ul>
<li><strong>非继承中</strong>：当为类添加一个新成员变量时，须同时修改copying函数，为新成员添加拷贝代码（也需要修改class的所有构造函数以及任何非标准形式的operator&#x3D;）。否则会调用新成员的默认构造函数初始化新成员</li>
<li><strong>继承中</strong>：在派生类的copying函数中，不要忘记调用相应的base class函数拷贝基类部分。否则会调用基类的默认构造函数初始化基类部分</li>
</ul>
<p>当编写一个copying函数，请确保：</p>
<ul>
<li>复制所有local成员变量</li>
<li>调用所有base class内的适当的copying函数</li>
</ul>
<p>如果copy构造函数和copy assignment操作符有相近的代码，不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</p>
<br>
<br>

<h1 id="三-资源管理"><a href="#三-资源管理" class="headerlink" title="三.资源管理"></a>三.资源管理</h1><h2 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h2><p>当程序申请资源，例如一块动态内存时，可能会发生资源泄漏：</p>
<ul>
<li><strong>忘记delete</strong></li>
<li><strong>有delete，但是delete之前跳出控制流</strong>：在代码的维护过程中，动态分配内存和delete之间可能会加入return之类的控制流变更语句，或者是可能引发异常的代码，这样可能会使程序执行不到delete从而造成资源泄露</li>
</ul>
<p><strong>总结起来就是，手工delete一个是需要时刻记住delete，增加编码负担，另一个是即使明确delete，在delete之前控制流可能发生改变从而还是会造成资源泄露</strong>。</p>
<p>为确保返回的资源总是被释放，需要将资源放进对象内，当控制流离开时，该对象的析构函数会自动释放那些资源，即把资源放进对象内，便可依赖C++的“析构函数自动调用机制”确保资源被释放。</p>
<p>“以对象管理资源”的两个关键想法：</p>
<ul>
<li><strong>获得资源后立刻放进管理对象内</strong>：“以对象管理资源”的观念常被称为“资源取得时机便是初始化时机”(Resource Acquisition Is Initialization;<strong>RAII</strong>)。几乎总是在获得一笔资源后于同一语句内以它初始化某个管理对象，或者获得的资源被拿来赋值某个管理对象</li>
<li><strong>管理对象运用析构函数确保资源被释放</strong></li>
</ul>
<p>一个对象管理资源的例子是auto_ptr:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pIntv</span><span class="hljs-params">(createInvestment())</span></span>;    <br>    ...     <br>&#125;           <span class="hljs-comment">//经由auto_ptr的析构函数自动删除pInv</span><br></code></pre></td></tr></table></figure>

<p>对于<strong>对象管理资源，需要注意对象的复制行为</strong>：auto_ptr被销毁时会自动删除它所指之物，所以要注意别让auto_ptr同时指向同一对象。如果是那样，对象会被删除一次以上，程序产生“未定义行为”。为预防这个问题，auto_ptrs有一个性质：<strong>若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权</strong>。</p>
<p>auto_ptr的替代方案是“引用计数型智慧指针”（RCSP），持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源，一个例子是shared_ptr。RCSPs的缺点是无法打破环状引用（例如两个其实已经没被使用的对象彼此互指，因而好像还处在“被使用”状态）。</p>
<p>auto_ptr和shared_ptr两者都在其析构函数内做delete而不是delete[]动作，意味着在动态分配而得的array身上使用auto_ptr或shared_ptr是个馊主意。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::auto_ptr&lt;std::string&gt; <span class="hljs-title">aps</span><span class="hljs-params">(<span class="hljs-keyword">new</span> std::string[<span class="hljs-number">10</span>])</span></span>; <span class="hljs-comment">// 馊主意！</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>没有特别针对“C++动态分配数组”而设计的类似auto_ptr或tr1::shared_ptr那样的东西，甚至TR1中也没有。那是因为vector和string几乎总是可以取代动态分配而得的数组。因此当需要动态分配数组时，提倡使用vector（[可以使用unique_ptr管理动态数组](C++Primer_Stanley B. Lippman.md#23-unique_ptr)）。</p>
</blockquote>
<br>

<h2 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h2><p>并非所有资源都是动态内存，除此之外还有锁等资源，也应该通过“对象管理资源”来确保获取资源后能够正确的释放，<strong>根据资源的类型，和不同的需求，可能需要定义不同的RAII对象copy行为</strong>：</p>
<ol>
<li><strong>禁止复制</strong>：比方说锁资源，管理锁资源的对象复制通常并不合理。因此应该禁止这类对象的复制，可以通过继承一个copying操作被声明为private的基类来禁止复制，这点在条款06中有提到</li>
<li><strong>对底层资源使用“引用计数法”</strong>：如果希望保有资源，直到它的最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的“被引用数”递增。tr1::shared_ptr便是如此。当资源引用计数减为0时，如果不希望删除资源（缺省行为），比方说锁资源想要的释放动作是解除锁定而非删除，可以指定shared_ptr的“删除器”（一个函数或函数对象，当引用次数为0时被调用，此机能并不存在于auto_ptr——它总是将其指针删除）</li>
<li><strong>复制底部资源</strong>：在此情况下复制管理资源对象，应该同时也复制其所包覆的资源。也就是说，复制资源管理对象时，进行的是“深度拷贝”</li>
<li><strong>转移底部资源的拥有权</strong>：如果希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物，原RAII对象拥有的资源设为null（auto_ptr奉行的复制意义）</li>
</ol>
<br>

<h2 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h2><p><strong>APIs往往要求访问原始资源（即被RAII对象管理的资源，而不是直接访问RAII对象），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法</strong>。</p>
<p>取得RAII对象所管理资源的办法可以通过显式转换或隐式转换：</p>
<ul>
<li>**显式转换(比较安全，但不易用)**：如shared_ptr和auto_ptr的get成员函数，返回智能指针内部的原始指针（的复件）</li>
<li>**隐式转换(对客户比较方便，但不安全)**：如shared_ptr和auto_ptr重载了指针取值操作符（operator*和operator-&gt;），允许隐式转换至底部原始指针</li>
</ul>
<p>如果通过实现隐式转换（比如，实现operator()）来提供对原始资源的访问，可能不安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//以下，Font是一个RAII对象，FontHandle是一个原始资源</span><br><br><span class="hljs-function">Font <span class="hljs-title">f1</span><span class="hljs-params">(getFont())</span></span>;  <br>...<br>FontHandle f2 = f1; <span class="hljs-comment">//原意是想使用Font，复制一个RAII对象</span><br></code></pre></td></tr></table></figure>

<p>在上面的例子中，如果实现了隐式转换，底层资源会被复制，如果f1销毁，f2会成为“虚吊的”（dangle）</p>
<p>是否该提供一个显式转换函数将RAII class转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAII class被设计执行的特定工作，以及它被使用的情况。</p>
<br>

<h2 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h2><p>当使用new和delete时，发生2件事：</p>
<ul>
<li>new<ul>
<li>内存被分配出来（通过名为operator new的函数）</li>
<li>针对此内存会有一个（或更多）构造函数被调用</li>
</ul>
</li>
<li>delete<ul>
<li>针对此内存会有一个（或更多）析构函数被调用</li>
<li>内存被释放（通过名为operator delete的函数）</li>
</ul>
</li>
</ul>
<p>单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的记录，以便delete知道需要调用多少次析构函数，布局可能像下面这个样子：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160045.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>当对着一个指针使用delete时，唯一能够让delete知道内存中是否存在一个“数组大小记录”的办法是：由你来告诉它。即加上[]，delete便认定指针指向一个数组，否则它便认为指针指向单一对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string* stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string* stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1; <span class="hljs-comment">//删除一个对象</span><br><span class="hljs-keyword">delete</span> [] stringPtr2; <span class="hljs-comment">//删除一个由对象组成的数组</span><br></code></pre></td></tr></table></figure>

<ul>
<li>如果对stringPtr1使用“delete []”形式，结果未定义，但不太可能让人愉快。假设内存布局如上，delete会读取若干内存并将它解释为“数组大小”，然后开始多次调用析构函数，浑然不知它所处理的那块内存不但不是个数组，也或许并未持有它正忙着销毁的那种类型的对象</li>
<li>如果没有对stringPtr2使用“delete []”形式，结果亦未定义，但可以猜想可能导致太少的析构函数被调用。犹有进者，这对内置类型如int者亦未定义，即使这类类型并没有析构函数</li>
</ul>
<p>因此，**如果调用new时使用了[]，必须在对应调用delete时也使用[]；如果调用new时没使用[]，那么也不该在对应调用delete时使用[]**。</p>
<p>这点在typedef中尤其需要注意：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> std::string AddressLines[<span class="hljs-number">4</span>];  <span class="hljs-comment">//每个人的地址有4行，每行是一个string</span><br><br>std::string *pa1 = <span class="hljs-keyword">new</span> AddressLines;  <span class="hljs-comment">//返回一个string*，就像new string[4]一样</span><br><br><span class="hljs-keyword">delete</span> pa1;             <span class="hljs-comment">//错误！行为未定义</span><br><span class="hljs-keyword">delete</span> [] pa1;          <span class="hljs-comment">//很好</span><br></code></pre></td></tr></table></figure>

<p>为避免这类错误，最好尽量不要对数组形式做typedefs动作。</p>
<br>

<h2 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h2><p>考虑如下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">func1</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类),<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure>

<p>在调用func1之前，编译器必须创建代码，做以下3件事</p>
<ul>
<li>执行func2</li>
<li>执行”new 原始资源类”创建一个原始资源</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>但是执行顺序弹性很大。如果执行顺序如下；</p>
<ol>
<li>执行”new 原始资源类”创建一个原始资源</li>
<li>执行func2</li>
<li>调用tr1::shared_ptr构造函数</li>
</ol>
<p>现在，如果2发生异常，那么因为1创建的资源未被置入tr1::shared_ptr内，因此会发生内存泄露。也就是说，在“资源被创建”和“资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰。为避免这类问题，应该使用独立语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;原始资源类&gt;(<span class="hljs-keyword">new</span> 原始资源类) p; <span class="hljs-comment">//单独语句</span><br><br><span class="hljs-built_in">func1</span>(p,<span class="hljs-built_in">func2</span>());<br></code></pre></td></tr></table></figure>

<p>编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度）。</p>
<br>
<br>

<h1 id="四-设计与声明"><a href="#四-设计与声明" class="headerlink" title="四.设计与声明"></a>四.设计与声明</h1><h2 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h2><ol>
<li><p><strong>通过引入新类型来防止误用</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month,<span class="hljs-type">int</span> day,<span class="hljs-type">int</span> year);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 上面日期类的构造函数中，年月日都是int，那么很容易传入顺序错误的参数。可以导入3个表示年月日的新类：Year、Month、Day来区分，从而防止这种问题。更进一步，为了使得传入的数据有效，比如月份，可以设计生成12个月份对象的static成员函数，并将构造函数声明为explicit强制要求通过调用static成员函数得到月份对象。使用enums没有那么安全，enums可被拿来当作一个ints使用（条款02）</p>
<p> 预防客户错误的另一个办法是，限制类型内什么事可做，什么事不能做。常见的限制是加上const</p>
</li>
<li><p><strong>除非有好理由，否则应该尽量让你的types的行为与内置类型一致</strong>：如<code>if(a * b = c)</code>对内置类型来说不合法，那么你的type在实现operator*时就应该返回一个const对象</p>
</li>
<li><p><strong>提供行为一致的接口</strong>：如C++ STL容器都提供size()返回容器大小，但是Java和.Net对于不同容器大小接口可能不同，这会增加使用负担</p>
</li>
<li><p><strong>返回“资源管理对象”而不是原始资源</strong>：如用shared_ptr管理资源时，客户可能会忘记使用智能指针，从而开启了忘记释放和重复释放的大门。通过修改接口的返回类型为智能指针（有需要时还可绑定“删除器”），从而确保元素资源处于“资源管理对象”的掌控之中（可防范潜在的客户错误：“cross-DLL problem”）</p>
</li>
</ol>
<br>

<h2 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h2><p>在设计class时，对下列问题的回答将导致你的class设计规范：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新type的对象如果被passed by value，意味着什么？</li>
<li>什么是新type的“合法值”？</li>
<li>你的新type需要配合某个继承图系吗？</li>
<li>你的新type需要什么样的转换？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新type的成员？</li>
<li>什么是新type的“未声明接口”？</li>
<li>你的新type有多么一般化？</li>
<li>你真的需要一个新type吗？</li>
</ul>
<br>

<h2 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h2><p>pass-by-reference-to-const有下列好处：</p>
<ul>
<li><strong>更高的效率</strong>：如果一个类处于继承体系的底部，并且包含大量成员，pass-by-value会导致大量的构造函数被调用，在函数调用完成后，又有大量的析构函数被调用</li>
<li><strong>防止继承中的对象切割问题</strong>：当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用，传入的derived class对象会被切割，只保有base class对象的部分，从而无法表现多态</li>
<li><strong>const是重要的</strong>，可以阻止传入的参数被修改</li>
</ul>
<p>references往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此，对于<strong>内置类型</strong>，pass by value往往比pass by reference的效率高些。pass by value同样适用于<strong>STL的迭代器</strong>和<strong>函数对象</strong>。</p>
<p>并不是所有小型对象都是pass-by-value的合格候选者：</p>
<ul>
<li>对象小并不意味着copy构造函数不昂贵。许多对象——包括大多数STL容器——内含的东西比一个指针多一些，但是复制这种对象却需承担“复制那些指针所指的每一样东西”，那将非常昂贵</li>
<li>即使copy构造函数不昂贵，还是可能有效率上的争议。某些编译器对待“内置类型”和“用户自定义类型”的态度截然不同，纵使两者拥有相同的底层表述，“用户自定义类型”也不会被编译器放入缓存器，因此pass by reference更适合</li>
</ul>
<blockquote>
<p>可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。其它任何东西，尽量以pass-by-reference-to-const替换pass-by-value</p>
</blockquote>
<br>

<h2 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h2><p>必须返回对象的最常见例子是运算符函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs);<br></code></pre></td></tr></table></figure>

<p>在必须返回对象时，不要企图返回reference，可以通过反面来说，也就是如果返回reference会是什么情况？</p>
<ul>
<li><p><strong>使用stack构造一个局部对象，返回局部对象的reference</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n,lhs.d * rhs.d)</span></span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  注意！使用reference的本意是避免构造新对象，但是一个新的对象result还是经由构造函数构造。更严重的是，result是个local对象，而local对象在函数退出前被销毁了，reference将指向一个被销毁的对象。任何函数如果返回一个reference指向某个local对象，都将一败涂地（如果函数返回指针指向一个local对象，也是一样）。</p>
</li>
<li><p><strong>在heap内构造一个局部对象，返回这个对象的reference</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>    <span class="hljs-keyword">return</span> *result;<br>&#125;<br>Rational w,x,y,z;<br>w = x * y *z;<br></code></pre></td></tr></table></figure>
<p>  这样虽然reference不再引用一个被销毁的对象，但还是必须付出一个“构造函数调用”代价，并且谁该对new出来的对象实施delete也成为问题。同时，在上面的连乘例子中，会多次动态分配内存，但是只返回最后一次的指针，因此会导致资源泄露。</p>
</li>
<li><p><strong>构造一个static局部对象，每次计算结果保存在这个对象中，返回其reference</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-type">static</span> Rational result<br>    result = ...;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br>Rational w,x,y,z;<br><span class="hljs-keyword">if</span>((w * x) == (y * z))&#123;...&#125;<br></code></pre></td></tr></table></figure>
<p>  首先，显而易见的问题是这个函数在多线程情况下是不安全的，多个线程会修改相同的static对象；除此之外，在上面的if判断中，不管传入的w,x,y,z是什么，由于operator*传回的reference都指向同一个static对象，因此上面的判断永远都会为true（由于返回reference，调用端看到的永远是static对象的“现值”）。</p>
</li>
</ul>
<p>一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n,lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>请记住：绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</p>
</blockquote>
<br>

<h2 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h2><h3 id="1）为什么不能是public"><a href="#1）为什么不能是public" class="headerlink" title="1）为什么不能是public"></a>1）为什么不能是public</h3><p>3个原因：</p>
<ol>
<li><p><strong>语法一致性</strong>：如果成员变量和成员函数一样，都是public，那么调用时会困惑于该不该使用括号。如果想获取大小时使用size，但是这到底是一个成员变量还是一个成员函数？</p>
</li>
<li><p><strong>细微划分之访问控制</strong>：通过将成员变量声明为private，通过成员函数提供访问，可以实现更精准的访问控制</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccessLevels</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadOnly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   </span>&#123;<span class="hljs-keyword">return</span> readOnly;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadWrite</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>    </span>&#123;readWrite = value;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getReadWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>    </span>&#123;<span class="hljs-keyword">return</span> readWrite;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteOnly</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>    </span>&#123;writeOnly = value;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> noAccess;   <span class="hljs-comment">//对此int无访问动作</span><br>    <span class="hljs-type">int</span> readOnly;   <span class="hljs-comment">//对此int做只读访问</span><br>    <span class="hljs-type">int</span> readWrite;  <span class="hljs-comment">//对此int做读写访问</span><br>    <span class="hljs-type">int</span> writeOnly;  <span class="hljs-comment">//对此int做只写访问</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
<li><p>**封装(主要)**：private将成员变量封装，如果通过public暴露，在需要改成员变量的大量实现代码中，会直接使用。当这个成员变量被修改或删除时，所有直接访问该成员变量的代码将会变得不可用</p>
</li>
</ol>
<h3 id="2）那么protected行不行"><a href="#2）那么protected行不行" class="headerlink" title="2）那么protected行不行"></a>2）那么protected行不行</h3><p>protected成员变量和public成员变量的论点十分相同。“语法一致性”和“细微划分的访问控制”等理由也适用于protected数据。同时，protected也并不比public更具封装性。</p>
<p>假设有一个public成员变量，而我们最终取消了它。所有使用它的客户代码都会被破坏。因此，public成员变量完全没有封装性。假设有一个protected变量，而我们最终取消了它，所有使用它的派生类都会被破坏。因此，protected成员变量也缺乏封装性。</p>
<p>从封装的角度观之，只有两种访问权限：private（提供封装）和其他（不提供封装）。</p>
<br>

<h2 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h2><p>假设有个浏览器类，包含一些功能用来清除下载元素高速缓冲区、清除访问过的URLs的历史记录、以及移除系统中的所有cookies：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCookies</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>此时，如果想整个执行所有这些动作，那么有两种选择，一种实现成member函数，一种实现成non-member函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//实现成成员函数，能访问private成员</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">clearCache</span>();<br>    <span class="hljs-built_in">clearCookies</span>();<br>    <span class="hljs-built_in">clearHistory</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">//或者实现成非成员函数，不能访问private成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearCookies</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题是应该如何选择？这个问题主要在于<strong>封装性</strong>。</p>
<p>如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。越少人看到它，就有越大的弹性去变化它，因为我们的改变仅仅直接影响看到改变的那些人事物。</p>
<p>因此，对于对象内的代码。越少代码可以看到数据（也就是访问它），越多的数据可被封装，我们也就越能自由地改变对象数据。作为一种粗糙的测量，越多函数可访问它，数据的封装性就越低。</p>
<p>条款22所说，成员变量应该是private。能够访问private成员变量的函数只有class的member函数加上friend函数而已。<strong>如果要在一个member函数和一个non-member，non-friend函数之间做选择，而且两者提供相同机能，那么，导致较大封装性的是non-member，non-friend函数</strong>，因为它并不增加“能够访问class内之private成分”的函数数量。也就是本条款这样选择的原因。这个论述只适用于non-member non-friend函数。friends函数对class private成员的访问权力和member函数相同。</p>
<p>一个扩展性的问题是——这些non-member，non-friend函数应该实现于何处?</p>
<p>自然做法是位于同一个namespace内。</p>
<p>一个像WebBrowser这样的class可能拥有大量便利函数，某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…通常客户只对其中某些感兴趣。没道理一个只对书签相关便利函数感兴趣的客户却与一个cookie相关便利函数发生编译相依关系。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关…以此类推：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160131.png" srcset="/img/loading.gif" lazyload></p>
<p>这正是C++标准库的组织方式。标准库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间内的每一样东西，而是有数十个头文件（&lt;vector&gt;,&lt;algorithm&gt;,…），每个头文件声明std的某些机能。客户可以根据需要使用的机能选择性的包含头文件。</p>
<p>将所有便利函数放在多个头文件内但隶属于同一个命名空间，意味客户可以轻松扩展这一组便利函数。这是class无法提供的另一个性质，因为class定义式对客户而言是不能扩展的。</p>
<br>

<h2 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h2><p>令class支持隐式类型转换不是个好主意，但是在建立数值类型时颇为合理。考虑有理数和内置整形之间的相乘运算。具有如下有理数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>); <span class="hljs-comment">//构造函数刻意不为explicit，提供了Int-to-Rational的隐式转换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">//分子的访问函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//分母的访问函数</span><br><span class="hljs-keyword">private</span>:<br>...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在，有理数提供了Int-to-Rational的隐式转换方式，那么operator*应该实现成member，还是non-member？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-comment">//实现为member</span><br>    <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span>;<br>&#125;<br><br><span class="hljs-comment">//实现为non-member</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br></code></pre></td></tr></table></figure>

<p>问题发生在混合运算上。如果实现成member，那么下面的混合运算只有一半行得通：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">result = oneHalf * <span class="hljs-number">2</span>;                  <span class="hljs-comment">// OK</span><br>result = <span class="hljs-number">2</span> * oneHalf;                  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure>

<p>因为内置类型int并没有相应的class，也就没有operator*成员函数。所以后者会出错。但是当实现为non-member时，具有2个参数，都能通过int隐式转换为Rational，所以上面2行代码都能运行。因此，如果需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，请为此采用non-member函数。</p>
<br>

<h2 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h2><p>“以指针指向一个对象，内含真正数据”。这种设计的常见表现形式是所谓的“pimpl手法”（“pointer to implementation”）。如下，WidgetImpl包含了Widget的真正数据，而Widget只包含一个WidgetImpl类型的指针，指向一个WidgetImpl对象。这种设计特点，决定了Widget的copying行为应该表现出一种“深拷贝”的行为：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160201.png" srcset="/img/loading.gif" lazyload></p>
<p>因此，如果使用标准库的swap交换2个Widget对象，会引起WidgetImpl对象的拷贝，由于其内含有Widget的大量数据，因此效率可能十分低。实际上这种情况下，交换2个指针就可以了。为此，我们可能实现出下图右边上方的swap特化版来提升效率，但是由于其内直接访问Widget的private成员，因此无法通过编译。所以我们采用下图右边下方的方案，在Widget类内实现一个public的swap函数，然后特化版的swap调用这个public的swap函数：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160230.png" srcset="/img/loading.gif" lazyload></p>
<p>当问题更进一步发展时，即Widget和WidgetImpl为class template时，可能会将相同的思想迁移过来，实现出下图上方的偏特化版本。但是问题是：<strong>C++只允许偏特化class templates，而不允许偏特化function templates</strong>。所以行不通，因此可以使用下图右下角的重载方式，但是<strong>客户可以全特化std内的模板，但是不能添加新的模板到std内</strong>，因此正确的做法是下图左下角：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160304.png" srcset="/img/loading.gif" lazyload></p>
<p>如果想让你的“class 专属版”swap在尽可能多的语境下被调用，需要同时在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。</p>
<p>从客户的观点看，应写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(T&amp; obj1,T&amp; obj2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap; <span class="hljs-comment">//令std::swap在此函数内可用</span><br>    ...<br>    <span class="hljs-built_in">swap</span>(obj1,obj2); <span class="hljs-comment">//为T型对象调用最佳swap版本</span><br>    ...<br>&#125;<br><br>std::<span class="hljs-built_in">swap</span>(obj1,obj2); <span class="hljs-comment">//这是错误的swap调用方式，强迫编译器只认std内的swap版本</span><br></code></pre></td></tr></table></figure>

<p>总结起来就是：</p>
<ul>
<li>首先，如果swap的缺省实现对你的class或class template提供可接受的效率，不需要额外做任何事</li>
<li>其次，如果swap的缺省实现效率不足（那几乎总是意味着你的class或template使用了某种pimpl手法），试着做以下事情：<ul>
<li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象值（<strong>这个public swap成员函数绝不可抛出异常。这个约束不可施行于非成员版，因为swap缺省版本是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定义版本的swap，往往提供的不只是高效置换对象值的方法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效的swaps几乎总是基于对内置类型的操作，而内置类型上的操作绝对不会抛出异常</strong>）</li>
<li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数</li>
<li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它调用你的swap成员函数</li>
</ul>
</li>
<li>最后，如果你调用swap，请确定包含一个using声明，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符地调用swap</li>
</ul>
<br>
<br>

<h1 id="五-实现"><a href="#五-实现" class="headerlink" title="五.实现"></a>五.实现</h1><h2 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h2><p>只要定义了一个变量而其类型带有一个构造函数或析构函数，那么</p>
<ul>
<li>当程序的控制流到达这个变量定义式时，你便得承受构造成本</li>
<li>当这个变量离开作用域时，你便得承受析构成本</li>
</ul>
<p>即使这个变量最终并未被使用，仍需耗费这些成本，所以你应尽可能避免这种情形，即延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p>
<p>当考虑循环时，有下列2种情况：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160331.png" srcset="/img/loading.gif" lazyload></p>
<p>两种写法的成本如下；</p>
<ul>
<li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B：n个构造函数 + n个析构函数</li>
</ul>
<p><strong>从效率上看</strong>：如果class的一个赋值成本低于一组构成+析构成本，做法A大体而言比较高效，尤其当n比较大时。否则做法B或许更好。</p>
<p><strong>从可理解性和维护性上看</strong>：A造成名称w的作用域比做法B更大，可理解性和维护性相对较差。</p>
<p>因此，除非</p>
<ol>
<li>你知道赋值成本比“构造 + 析构”成本低</li>
<li>你正在处理代码中效率高度敏感的部分</li>
</ol>
<p>否则，应该使用做法B。</p>
<br>

<h2 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h2><p>转型分类：</p>
<ul>
<li>旧式转型  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C风格的转型</span><br>(T)expression   <span class="hljs-comment">//将expression转型为T</span><br><span class="hljs-comment">//函数风格的转型</span><br><span class="hljs-built_in">T</span>(expression)   <span class="hljs-comment">//将expression转型为T</span><br></code></pre></td></tr></table></figure></li>
<li>C++提供的新式转型（new-style或C++-style casts）  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>const_cast</strong>：通常被用来将对象的常量性转除。只能改变底层const，例如指向const的指针(指向的对象不一定是常量，但是无法通过指针修改)​，如果指向的对象是常量，则这种转换在修改对象时，结果未定义</li>
<li><strong>dynamic_cast</strong>：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。一种动态类型识别。转换的目标类型，即type，是指针或者左右值引用，主要用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如果转换失败，返回0（转换目标类型为指针类型时）或抛出bad_cast异常（转换目标类型为引用类型时）</li>
<li><strong>reinterpret_cast</strong>：意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。通常为算术对象的位模式提供较低层次上的重新解释。如将int*转换成char*。很危险！</li>
<li><strong>static_cast</strong>：用来强迫隐式转换，例如将non-const对象转换为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换。但它无法将const转为non-const（只有const_cast才办得到）</li>
</ul>
</li>
</ul>
<p>应该尽可能使用新式转型：</p>
<ol>
<li>它们很容易在代码中被辨别出来（无论是人工还是使用工具如grep），因而得以简化“找出类型系统在哪个地点被破坏”的过程</li>
<li>各转型动作的目标越窄化，编译器越可能诊断出错误的运用</li>
</ol>
<p><strong>尽量少做转型</strong>：</p>
<ol>
<li><p><strong>转型不只是告诉编译器把某种类型视为另一种类型这么简单。任何一个类型转换（显式或隐式）往往令编译器编译出运行期间执行的代码</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//示例一</span><br><span class="hljs-type">int</span> x,y;<br>...<br><span class="hljs-type">double</span> d = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(x)/y;<br><span class="hljs-comment">//示例二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;...&#125;;<br>Derived d;<br>Base *pd = &amp;d;  <span class="hljs-comment">//隐式地将Derived*转换为Base*</span><br></code></pre></td></tr></table></figure>
<ul>
<li>在示例一中：int转型为double几乎肯定会产生一些代码，因为在大部分体系结构中，int的底层表述不同于double的底层表述</li>
<li>在示例二中：会有个偏移量在运行期被施行于Derived*指针身上，用以取得正确的Base*指针值</li>
</ul>
</li>
<li><p><strong>很容易写出似是而非的代码</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;...&#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//错误的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();  <br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br><span class="hljs-comment">//正确的做法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span></span>&#123;<br>        Window::<span class="hljs-built_in">onResize</span>();  <span class="hljs-comment">//调用Window::onResize作用于*this身上</span><br>        ...  <span class="hljs-comment">//这里进行SpecialWindow专属行为</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 上面的例子中，派生类的虚函数可能希望调用基类虚函数的版本执行一些固定操作，然后再执行一些专属行为。在前面的做法中，转型并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。而是在“当前对象的base class成分”的副本上调用Window::onResize，然后在当前对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容，当前对象其实没被改动，改动的是副本。如果专属动作也修改对象，那么当前对象真的会被改动，进而进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分的更改倒是落实了。</p>
<p> 解决之道是拿掉转型动作，代之以真正想说的话，即后面的做法。</p>
</li>
<li><p><strong>继承中的类型转换效率低</strong></p>
<ul>
<li>C++通过dynamic_cast实现继承中的类型转换，dynamic_cast的大多数实现版本执行速度都是相当慢的。因此，应该避免继承中的类型转换。之所以需要dynamic_cast，通常是因为想在一个认定为derived class对象身上执行derived class操作函数，但是只有一个“指向base”的指针或引用。这种情况下有两个一般性做法可以避免这个问题：<ul>
<li><strong>使用容器并在其中存储直接指向derived class对象的指针</strong>：这种做法无法在同一个容器内存储指针“指向所有可能之各种派生类”。如果真要处理多种类型，可能需要多个容器，它们都必须具备类型安全性</li>
<li><strong>将derived class中的操作上升到base class内，成为virtual函数，base class提供一份缺省实现</strong>：缺省实现代码可能是个馊主意，条款34中有分析，但是也比使用dynamic_cast来转型要好</li>
</ul>
</li>
<li>绝对必须避免的一件事是所谓的“连串dynamic_casts”</li>
</ul>
</li>
<li><p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内</p>
</li>
</ol>
<br>

<h2 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h2><blockquote>
<p>References、指针和迭代器统统都是所谓的handles（号码牌，用来取得某个对象）。</p>
</blockquote>
<p>如果返回一个“代表对象内部数据”的handle，会造成以下结果：</p>
<ul>
<li><p>降低对象封装性</p>
<p>成员变量的封装性最多只等于“返回其reference”的函数的访问级别。如果public成员函数返回handles，那么相当于成员变量的封装性从private上升到public。这与<a href="#%E6%9D%A1%E6%AC%BE22%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%BAprivate">条款22</a>相悖</p>
</li>
<li><p>导致“虽然调用const成员函数却造成对象状态被更改”</p>
<p>如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是bitwise constness的附带结果：在<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>提到过“pimpl手法”，即：“以指针指向一个对象，内含真正数据”，也就是对象只包含指针成员，实际数据通过这个指针指向。而在<a href="#%E6%9D%A1%E6%AC%BE03%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款3</a>中也提到，C++对const成员函数的要求是，符合bitwise constness。因此，const成员函数返回一个这个指针所指对象的引用，并不会造成指针被修改，也就符合bitwise constness，但是通过这个引用却可以改变对象实际的数据</p>
</li>
</ul>
<p>如果返回的是指针或迭代器，相同情况也会发生，原因也相同。</p>
<p>不被公开使用的成员函数（被声明为protected或private）也是对象“内部”的一部分，因此也应该留心不要返回它们的handles。</p>
<p>解决方法是<strong>对它们的返回类型加上const</strong>：有了这样的改变，客户可以读取数据，但不能涂写。</p>
<p>即使如此，还是返回了“代表对象内部”的handles，有可能在其他场合带来问题：</p>
<ul>
<li><p>可能导致dangling handles（空悬的号码牌）：这种handles所指东西（的所属对象）不复存在</p>
<p>最常见的来源是函数返回值。如果返回的handles指向一个临时对象，那么返回后临时对象被销毁，handles会成为“虚吊的”。只要handle被传出去，就暴露在“handle比其所指对象更长寿”的风险下</p>
</li>
</ul>
<br>

<h2 id="条款29：为“异常安全”而努力是值得的"><a href="#条款29：为“异常安全”而努力是值得的" class="headerlink" title="条款29：为“异常安全”而努力是值得的"></a>条款29：为“异常安全”而努力是值得的</h2><p>考虑下面例子，有一个菜单类，changeBg函数可以改变它的背景，切换背景计数，同时提供线程安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    Mutex mutex;            <span class="hljs-comment">//提供多线程互斥访问</span><br>    Image *bg;          <span class="hljs-comment">//背景图片</span><br>    <span class="hljs-type">int</span> changeCount;    <span class="hljs-comment">//切换背景计数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBg</span><span class="hljs-params">(istream&amp; sr)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-built_in">lock</span>(&amp;mutex);<br>    <span class="hljs-keyword">delete</span> bg;<br>    ++changeCount;<br>    bg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src);<br>    <span class="hljs-built_in">unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1）异常安全的2个条件"><a href="#1）异常安全的2个条件" class="headerlink" title="1）异常安全的2个条件"></a>1）异常安全的2个条件</h3><ol>
<li><strong>不泄露任何资源</strong>：即发生异常时，异常发生之前获得的资源都应该释放，不会因为异常而泄露。在上面的例子中，如果new Image发生异常，那么unlock就不会调用，因此锁资源会泄露</li>
<li><strong>不允许数据败坏</strong>：上面的例子也不符合，如果new Image抛出异常，背景图片会被删除，计数也会改变。但是新背景并未设置成功</li>
</ol>
<p><strong>对于资源泄露</strong>，<a href="">条款13</a>讨论过如何以对象管理资源。锁资源也可以为shared_ptr指定“删除器”，当引用为0时，即异常发生，管理所资源的对象被销毁后，删除器会调用unlock</p>
<p><strong>对于数据败坏</strong>：见下文</p>
<h3 id="2）异常安全函数的3个保证"><a href="#2）异常安全函数的3个保证" class="headerlink" title="2）异常安全函数的3个保证"></a>2）异常安全函数的3个保证</h3><ol>
<li><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。然而程序的现实状态不可预料，不确定处于哪个状态（对于前面的例子，可以撰写如果发生异常，PrettyMenu可以继续拥有原背景图像，或是令它拥有某个“缺省”的背景图像，但客户无法预期哪一种情况）</li>
<li><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态</li>
<li><strong>不抛掷保证</strong>：这是最强的保证，承诺绝不抛出异常，函数总是能完成它们原先承诺的功能（作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础）</li>
</ol>
<p>异常安全码必须提供上述三种保证之一，否则不具备异常安全性。</p>
<p>对于前面的PrettyMenu对象，可以通过使用智能指针管理资源，以及重排changeBg内的语句次序来满足“强烈保证”：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    shared_ptr&lt;Image&gt; bg;<br>    ...<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Menu::changeBg</span><span class="hljs-params">(istream&amp; src)</span></span>&#123;<br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;    <span class="hljs-comment">//Lock以对象管理资源</span><br>    bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src));<br>    ++changeCount;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，上述实现只能为PrettyMenu对象提供“强烈保证”，不能提供完美（即全局状态）的“强烈保证”。比如Image构造函数抛出异常，有可能istream&amp; src的读取记号已被移走，那么系统还是处于一个被改变的状态。 这是一种对整个系统的副作用，类似的副作用还包括数据库操作，因为没有通用的办法可以撤销数据库操作。 不过这一点可以忽略，我们暂且认为它提供了完美的强烈保证。</p>
<p><strong>copy and swap策略</strong>：</p>
<p>“copy and swap”设计策略通常能够<strong>为对象</strong>提供异常安全的“强烈保证”。其原则：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换（swap）。关于swap的详细讨论可以参见<a href="#%E6%9D%A1%E6%AC%BE25%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25</a>。</p>
<p>实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象（即副本）——pimpl idiom手法，详见<a href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E5%B0%86%E8%87%B3%E6%9C%80%E4%BD%8E">条款31</a>。</p>
<p>这种策略用在前面的例子中会像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span>&#123;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    Mutex mutex;<br>    std::shared_ptr&lt;MenuImpl&gt; pImpl;<br>&#125;;<br>Menu::<span class="hljs-built_in">changeBg</span>(std::istream&amp; src)&#123;<br>    <span class="hljs-keyword">using</span> std::swap;            <span class="hljs-comment">// 见 Item 25</span><br>    <span class="hljs-function">Lock <span class="hljs-title">m1</span><span class="hljs-params">(&amp;mutex)</span></span>;            <span class="hljs-comment">// 获得mutex的副本数据</span><br><br>    <span class="hljs-function">std::shared_ptr&lt;MenuImpl&gt; <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MenuImpl(*pImpl))</span></span>;<br>    copy-&gt;bg.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(src)); <span class="hljs-comment">//修改副本数据</span><br>    ++copy-&gt;changeCount;<br><br>    <span class="hljs-built_in">swap</span>(pImpl, copy);              <span class="hljs-comment">//置换数据，释放mutex</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>copy and swap策略是对对象状态做出“全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性。也就是说，如果某个函数使用copy and swap策略为某个对象提供了异常安全的“强烈保证”。但是这个函数可能调用其它函数，而这些函数可能改变一些全局状态（如数据库状态），那么“整个函数”就不是“强烈保证”。</p>
<blockquote>
<p>函数提供的“异常安全保证”通常最高只等于其所调用的各个函数的“异常安全保证”中的最弱者。</p>
</blockquote>
<p>除此之外，copy and swap必须为每一个即将被改动的对象作出一个副本，从而可能造成时间和空间上的问题。</p>
<h3 id="3）最终目标是什么"><a href="#3）最终目标是什么" class="headerlink" title="3）最终目标是什么"></a>3）最终目标是什么</h3><p>当“强烈保证”不切实际时（比如前面提到的全局状态改变难以保证，或者效率问题），就必须提供“基本保证”。现实中你或许会发现，可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，“异常安全性的基本保证”是一个绝对同情达理的选择。</p>
<p>总的来说就是，应该为自己的函数努力实现尽可能高级别的异常安全，但是由于种种原因并不是说一定需要实现最高级别的异常安全，而是应该以此为目标而努力。</p>
<br>

<h2 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h2><p><strong>inline的优劣</strong>：</p>
<ul>
<li><strong>优</strong>：<ul>
<li>较少函数调用的开销</li>
<li>编译器对inline的优化</li>
</ul>
</li>
<li><strong>劣</strong>：<ul>
<li>目标码大小的增加，程序体积增大，导致额外的换页行为，降低指令高速缓存装置的命中率</li>
</ul>
</li>
</ul>
<blockquote>
<p>inline只是对编译器的一个申请，不是强制命令。</p>
</blockquote>
<p>inline提出方式包括2种：1）显式提出（在定义式前加上关键字inline）；2）隐喻提出（将函数定义于class定义式内）。</p>
<p>inline在大多数C++程序中是<strong>编译期行为</strong>。大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给出一个警告。</p>
<p>不要只因为function templates出现在头文件中，就将它们声明为inline。Template的具现化与inlining无关。除非正在写一个template而认为所有根据此template具现出来的函数都应该inlined，才声明为inline，否则应该避免。inlining需要成本。</p>
<p><strong>对virtual函数的调用也都会使inlining落空。因为virtual意味着“等待，直到运行期才确定调用哪个函数”，而inline意味着“执行前，先将调用动作替换为被调用函数的本体</strong>”。</p>
<p>如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outlined函数本体。毕竟编译器没有能力提出一个指针指向并不存在的函数。与此并提，编译器通常不对“通过函数指针而进行的调用”实施inlining。</p>
<p><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>。C++对于“对象被创建和被销毁时发生什么事”做了各式各样的保证。在对象构造期间如果抛出异常，该对象已经构造好的部分会被自动销毁等。<strong>程序内一定有某些代码让那些事情发生</strong>。对于下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string bm1,bm2;    <span class="hljs-comment">//base成员1和2</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()  &#123;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string dm1,dm2,dm3; <span class="hljs-comment">//derived成员1-3</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>虽然看上去Derived的构造函数为空，符合一个函数成为inline的的特性。但是为了确保C++对于“对象被创建和被销毁时发生什么事”做出的各式各样的保证，编译器会在其中安插代码，因此实际的Derived构造函数可能是这个样子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">Derived::<span class="hljs-built_in">Derived</span>()<br>&#123;<br>    Base::<span class="hljs-built_in">Base</span>();<br>    <span class="hljs-keyword">try</span>&#123;dm1.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm2.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm1.std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;dm3.std::string::<span class="hljs-built_in">string</span>();&#125;<br>    <span class="hljs-built_in">catch</span>(...)&#123;<br>        dm2.std::string::~<span class="hljs-built_in">string</span>();<br>        dm1.std::string::~<span class="hljs-built_in">string</span>();<br>        Base::~<span class="hljs-built_in">Base</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大部分的调试器面对inline函数都束手无策。因为无法在一个不存在的函数内设立断点。因此，一个合乎逻辑的策略是，一开始先不要将任何函数声明为inline，或至少将inlining施行范围局限在那些“一定成为inline”或“十分平淡无奇”的函数身上。</p>
<br>

<h2 id="条款31：将文件间的编译依存关系将至最低"><a href="#条款31：将文件间的编译依存关系将至最低" class="headerlink" title="条款31：将文件间的编译依存关系将至最低"></a>条款31：将文件间的编译依存关系将至最低</h2><p>C++并没有把“将接口从实现中分离”这件事做得很好。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string theName;    <span class="hljs-comment">//实现细目</span><br>    Date    theBirthDate;   <span class="hljs-comment">//实现细目</span><br>    Address theAddress;     <span class="hljs-comment">//实现细目</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果没有前面3行引入头文件，那么编译无法通过。但是如此却<strong>会在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些文件所依赖的其它头文件有任何改变。那么每个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译</strong>。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p>
<p>你可能会想着将实现细目分开：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">string</span>;   <span class="hljs-comment">//前置声明，但不正确</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;         <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <span class="hljs-comment">//前置声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果可以这么做，Person的客户就只需要在Person接口被修改过时才重新编译。但是这种想法存在2个问题：</p>
<ul>
<li>string并不是个class，它是个typedef，上述前置声明不正确，正确的前置声明比较复杂</li>
<li>重点是，<strong>编译器必须在编译期间知道对象的大小</strong>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;           <span class="hljs-comment">//定义一个int</span><br>    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(...)</span></span>;   <span class="hljs-comment">//定义一个Person</span><br>&#125;<br></code></pre></td></tr></table></figure>
  这和Java，Smalltalk中不同，因为它们在定义对象时，编译器只分配足够空间给一个指针使用。也就是说，它们将上述代码视为这样：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x;          <span class="hljs-comment">//定义一个int</span><br>    Person* p;      <span class="hljs-comment">//定义一个指针指向Person对象</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>解决方法是<strong>将接口与实现分离</strong>。主要有两种方法：</p>
<ul>
<li><strong>Handle class</strong></li>
</ul>
<p>把Person分割为两个类：1）一个只提供接口(Person)；2）一个负责实现接口(PersonImpl)；使用“pimpl idiom(pointer to implementation)”设计：接口class中只包含一个负责实现接口的class的指针，因此任何改变都只是在负责实现接口的class中进行。那么Person的客户就完全与Date,Address,以及Person的实现细目分离了。那些classes的任何实现修改都不需要Person客户端重新编译。此外，由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目的代码”。这种情况下，像Person这样使用pimpl的classes往往被称为handle classes。它们的所有函数都转交给相应的实现类并由后者完成实际工作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(string&amp; name);<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    shared_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br>Person::<span class="hljs-built_in">Person</span>(string&amp; name): <span class="hljs-built_in">pImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PersonImpl</span>(name))&#123;&#125;<br><span class="hljs-function">string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：让头文件自我满足，万一做不到，则让它与其他头文件内的声明式（而非定义式）相依。其他每一件事都源自于这个简单的设计策略：</p>
<ol>
<li><p>如果使用object references或object pointers可以完成任务，就不要使用objects</p>
</li>
<li><p>如果能够，尽量以class声明式替换class定义式。当声明一个函数而它用到某个class时，并不需要该class的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;   <span class="hljs-comment">//class声明式</span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//这里并不需要</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>; <span class="hljs-comment">//Date的定义式</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>为声明式和定义式提供不同的头文件。为了促使这个准则，需要两个头文件：一个用于声明式，一个用于定义式。因此，上面的例子应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;datefwd.h&quot;</span>    <span class="hljs-comment">//包含了class Date的声明</span></span><br><span class="hljs-function">Date <span class="hljs-title">today</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//同前</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearAppointments</span><span class="hljs-params">(Date d)</span></span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>Interface class</strong></li>
</ul>
<p>另一个制作Handle class的办法是，令Person成为一种特殊的abstract base class，称为interface class。其目的是详细描述derived classes的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> string <span class="hljs-title">birthday</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>客户不能实例化它，只能使用它的引用和指针。然而客户一定需要某种方法来获得一个实例，比如factory（工厂）函数。它们返回指针（或智能指针），指向动态分配所得对象，而该对象支持Interface class的接口。这样的函数往往声明为static：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> shared_ptr&lt;Person&gt; <span class="hljs-title">create</span><span class="hljs-params">(string&amp; name)</span></span>;<br>&#125;;<br><span class="hljs-comment">// RealPerson为Person的具象派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPerson</span>:<span class="hljs-keyword">public</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealPerson</span>(<span class="hljs-type">const</span> string&amp; name)<br>        :<span class="hljs-built_in">theName</span>(name)<br>        &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RealPerson</span>() &#123;&#125;;<br>    <span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    string theName;<br>&#125;<br><span class="hljs-comment">//Person::create的实现</span><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">Person::create</span><span class="hljs-params">(string&amp; name)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;Person&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RealPerson</span>(name));<br>&#125;<br><span class="hljs-comment">//客户使用</span><br><span class="hljs-function">shared_ptr&lt;Person&gt; <span class="hljs-title">p</span><span class="hljs-params">(Person::create(name))</span></span>;<br></code></pre></td></tr></table></figure>

<p>Handle classes和Interface classes解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性，但也需要付出运行期速度和若干内存的代价。</p>
<br>
<br>

<h1 id="六-继承与面向对象设计"><a href="#六-继承与面向对象设计" class="headerlink" title="六.继承与面向对象设计"></a>六.继承与面向对象设计</h1><h2 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h2><p><strong>public继承隐含的寓意</strong>：每个派生类对象同时也是一个基类对象(反之不成立)，只不过基类比派生类表现出更一般化的概念，派生类比基类表现出更特殊化的概念。</p>
<p>可以举一个例子验证一下上面的说法。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;...&#125;;<br></code></pre></td></tr></table></figure>

<p>显然，每个学生都是人，但并非每个人都是学生。对人可以成立的每一件事对学生也都成立（例如每个人都有生日），但对学生都成立的每件事并不一定对每个人也成立(例如注册于某个学校)。</p>
<p>因此，C++中，任何函数如果期望获得一个类型为基类的实参，都也愿意接收一个派生类对象。但是反之不成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;p)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;s)</span></span>;<br>Person p;<br>Student s;<br><span class="hljs-built_in">eat</span>(p);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">eat</span>(s);     <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(s);   <span class="hljs-comment">//正确</span><br><span class="hljs-built_in">study</span>(p);   <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure>

<p>谨记<strong>public继承</strong>和<strong>is-a</strong>之间的等价关系以及背后隐藏的规则可以防止因为“经验主义”而使用不合理的public继承：</p>
<ul>
<li>从“经验主义”上看，企鹅也是鸟，如果为鸟定义了虚拟(virtual)的飞的方法，然后企鹅类以public继承鸟类，那么是不合理的方式。这种情况下，可以设计一个会飞的鸟的类，虚拟(virtual)的飞的方法声明在这个类中，而鸟类里面没有声明飞的方法。或者根本不声明飞的方法</li>
<li>从“经验主义”上看，正方形也是矩形，如果矩形有成员方法会修改长或宽，那么正方形以public继承矩形就显得不合理。某些可施行于矩形身上的事情却不可施行于正方形身上</li>
</ul>
<p>软件世界不同于现实世界。对于上面的鸟的设计，某些软件系统可能不需要区分会飞的鸟和不会飞的鸟。那么即使鸟类声明了飞的方法，然后企鹅类以public继承，也不会有多大问题。也就是说，不存在一个适用于所有软件的设计。最佳的设计取决于系统希望做什么事，包括现在和未来。如果程序对飞行一无所知，而且也不打算未来对飞行有所知，那么不去区分会飞的鸟和不会飞的鸟不失为一个完美而有效的设计。实际上可能比对两者做出区隔的设计更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。因此，<strong>应该根据实际软件需求，合理使用public</strong>。</p>
<blockquote>
<ul>
<li>“public继承”意味着is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。</li>
<li>private继承的意义与此完全不同（条款39）。</li>
</ul>
</blockquote>
<br>

<h2 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h2><h3 id="1）继承中的作用域嵌套"><a href="#1）继承中的作用域嵌套" class="headerlink" title="1）继承中的作用域嵌套"></a>1）继承中的作用域嵌套</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160411.png" srcset="/img/loading.gif" lazyload  />

<p>名字查找会从内层作用域向外层作用域延伸，仅与名称有关，和pure virtual，impure virtual和non-virtual等其他无关。</p>
<h3 id="2）名称遮掩会遮掩基类所有重载版本"><a href="#2）名称遮掩会遮掩基类所有重载版本" class="headerlink" title="2）名称遮掩会遮掩基类所有重载版本"></a>2）名称遮掩会遮掩基类所有重载版本</h3><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160438.png" srcset="/img/loading.gif" lazyload></p>
<p>派生类中同名的名称会遮掩基类中相同的名称，如果基类包含重载函数，所有重载函数都会被遮掩。即base class内所有mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉了。</p>
<p>如果正在使用public继承而又不继承那些重载函数，就是违反base和derived classes之间的<strong>is-a</strong>关系。几乎总是想要推翻C++对“继承而来的名称”的缺省遮掩行为。解决办法是使用using引入被遮掩的名字：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160513.png" srcset="/img/loading.gif" lazyload></p>
<p>意味着如果继承base class并加上重载函数，而又希望重新定义或覆写其中一部分，那么必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些希望继承的名称会被遮掩。</p>
<p>如果只想引入基类被遮掩函数中某个版本（注意，这种需求一般只在private继承中出现，因为如果只继承基类的部分操作，违反了<a href="#%E6%9D%A1%E6%AC%BE32%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32</a>）using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。我们需要不同的技术，可以直接定义一个同名同参的函数，然后在这个函数内调用基类的版本，做一个转调用（即转交函数）：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160539.png" srcset="/img/loading.gif" lazyload></p>
<br>

<h2 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h2><blockquote>
<p>pure virtual函数一般作为接口，基类一般不提供定义，但是基类可以为纯虚函数提供定义。派生类必须声明纯虚函数，如果想要使用纯虚函数，派生类必须提供一份定义，即使基类已经为该纯虚函数提供了定义。如果派生类不提供定义，仍然是一个抽象基类。</p>
</blockquote>
<p>函数接口继承和函数实现继承不同。在public继承之下，derived classes总是继承base class的成员函数的接口（条款32）。</p>
<ol>
<li><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口</strong></li>
<li><strong>声明(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现</strong></li>
<li><strong>声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现</strong></li>
</ol>
<h3 id="1）pure-virtual函数"><a href="#1）pure-virtual函数" class="headerlink" title="1）pure virtual函数"></a>1）pure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且没有相同的缺省实现，那么应该使用pure virtual函数，此时派生类只继承接口。此外，它可以实现一种机制，为impure virtual函数提供更平常更安全的缺省实现。</p>
<h3 id="2）impure-virtual函数"><a href="#2）impure-virtual函数" class="headerlink" title="2）impure virtual函数"></a>2）impure virtual函数</h3><p>如果某个操作不同派生类应该表现出不同行为，并且具有相同的缺省实现，那么应该使用impure virtual函数，此时派生类继承接口和缺省实现。</p>
<p><strong>但是，允许impure virtual函数同时指定函数声明和缺省行为，却可能造成危险：假设引入了一个新的派生类，但是缺省行为并不适用于新的派生类，而新的派生类忘记重新定义新的行为，那么调用该操作将表现出缺省行为，这是不合理的</strong>。</p>
<p>例如，某个航空公司有A,B两种类型的飞机，他们有相同的fly行为，这个fly行为在基类Airplane中声明为impure virtual函数，并且具有缺省的飞行实现。现在引入了一种新机型C，但是这个缺省的fly行为并不适合C，如果C忘记重新定义fly，那么它将按照A,B缺省的行为飞行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 缺省的fly代码</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane&#123;...&#125;;<br>Airplane* p = <span class="hljs-keyword">new</span> ModelC;<br>p-&gt;<span class="hljs-built_in">fly</span>();   <span class="hljs-comment">//调用Airplane::fly</span><br></code></pre></td></tr></table></figure>

<p>a）要避免这种错误，可以将fly改为pure virtual函数，并且将缺省的飞行行为实现为一个protected函数，且为non-virtual函数。若想使用缺省实现，可以在其fly函数中对defaultFly做一个inline调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//这是合理的，因为它是Airplane及其derived classes的实现细目。乘客应该只在意飞机能不能飞，不在意它怎么飞</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">//non-virtual函数，因为没有任何一个派生类应该重新定义缺省行为</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">defaultFly</span><span class="hljs-params">()</span></span>&#123;...&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-built_in">defaultFly</span>();&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此时，fly变成了pure virtual函数，ModelC class不可能意外继承不正确的fly实现代码了，因为飞机C必须声明fly函数，如果需要使用，必须为其定义。那么就可以防止因为忘记重新定义而引起的错误。</p>
<p>b）有些人反对以不同函数分别提供接口和缺省实现，像上面的fly和defaultFly。因为他们关心因过渡雷同函数名称而引起的class命名空间污染问题。可以利用“pure virtual函数必须在derived classes中重新声明，但它们也可以拥有自己的实现”这一事实，将缺省的行为定义在fly中，即为fly实现一份缺省的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">//pure virtual</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//pure virtual函数实现</span><br>    <span class="hljs-comment">// 缺省的fly代码</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>&#123;<br>        Airplane::<span class="hljs-built_in">fly</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>:<span class="hljs-keyword">public</span> Airplane&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//自己的实现</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在的fly被分割为两个基本要素：其声明部分表现的是接口（那是derived classes必须使用的），其定义部分则表现出缺省行为（那是derived classes可能使用的，但只有在它们明确提出申请时才是）。如果合并fly和defaultFly，就丧失了“让两个函数享有不同保护级别”的机会：被设为protected的函数（defaultFly）如今成了public（因为它在fly之中）。</p>
<h3 id="3）non-virtual函数"><a href="#3）non-virtual函数" class="headerlink" title="3）non-virtual函数"></a>3）non-virtual函数</h3><p>如果成员函数是个non-virtual函数，意味是它并不打算在derived classes中有不同的行为。实际上一个non-virtual成员函数所表现的不变性凌驾其特异性，因为它表示不论derived class变得多么特异化，它的行为都不可以改变。此时派生类继承接口和一份强制性实现。</p>
<br>

<h2 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h2><blockquote>
<p>在面向对象中，如果希望某个操作函数存在缺省行为，并且各派生类可以定制适合自己的操作。可以使用public virtual函数，这是最简单直白且容易想到的方法，但是除此之外，也存在其它可替代的方案。它们有各自的优缺点，应该将所有方案全部列入考虑。</p>
</blockquote>
<p>以一个例子来介绍其它几种可替代方案。在一个游戏人物的类中，存在一个健康值计算的函数，不同的角色可以提供不同的健康值计算方法，并且存在一个缺省实现。以传统的public virtual函数实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    <span class="hljs-comment">//健康值计算函数，派生类可以重新定义</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="1）藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#1）藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="1）藉由Non-Virtual Interface手法实现Template Method模式"></a>1）藉由Non-Virtual Interface手法实现Template Method模式</h3><p>这种方案的主要思想是：保留healthValue为public成员函数，但是让其成为non-virtual，并调用一个private(也可以是protected) virtual函数进行实际工作。即以public non-virtual成员函数包裹较低访问性（private或protected）的virtual函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//non-virtual函数，virtual函数的外覆器(wrapper)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...                             <span class="hljs-comment">//做一些事前工作</span><br>        <span class="hljs-type">int</span> retVal = <span class="hljs-built_in">doHealthValue</span>();   <span class="hljs-comment">//负责真正的健康值计算</span><br>        ...                             <span class="hljs-comment">//做一些事后工作</span><br>        <span class="hljs-keyword">return</span> retVal;<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">doHealthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">//派生类可以重新定义</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...     <span class="hljs-comment">//缺省的健康值计算方法，缺省算法</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>NVI（non-virtual interface）手法的一个优点是外覆器确保得以在一个virtual函数被调用之前设定好适当场景，并在调用结束之后清理场景。如“事前”进行一些锁的分配，日志记录。“事后”进行解锁等操作。NVI手法允许derived classes重新定义virtual函数，从而赋予它们“如何实现机能”的控制能力，但base class保留诉说“函数何时被调用”的权利。</p>
<h3 id="2）藉由Function-Pointers实现Strategy模式"><a href="#2）藉由Function-Pointers实现Strategy模式" class="headerlink" title="2）藉由Function Pointers实现Strategy模式"></a>2）藉由Function Pointers实现Strategy模式</h3><p>上面的方案本质还是使用virtual函数，人物的健康值计算(操作)还是与人物(类)相关。另一个设计主张“人物健康指数的计算与任务类型无关”，这样的计算完全不需要“人物”这个成分。例如可能要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际的计算：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*HealthCalcFunc)</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter&amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个做法提供了一些弹性：</p>
<ul>
<li>同一人物类型之不同实体可以有不同的健康计算函数</li>
<li>某已知人物之健康指数计算函数可在运行期变更</li>
</ul>
<h3 id="3）藉由tr1-function完成Strategy模式"><a href="#3）藉由tr1-function完成Strategy模式" class="headerlink" title="3）藉由tr1::function完成Strategy模式"></a>3）藉由tr1::function完成Strategy模式</h3><p>这种方案是前一种的加强，将函数指针改成任何可调用对象。因此允许使用任何与可调用声明相兼容(即可以通过类型转换与声明相符)的可调用物（也就是函数指针、函数对象、或成员函数指针）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-comment">//健康值计算的缺省函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">defaultHealthCalc</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//现在，类型HealthCalcFunc从函数指针变成了可调用物</span><br>    <span class="hljs-keyword">typedef</span> std::tr1::function&lt;<span class="hljs-type">int</span> (<span class="hljs-type">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">healthFunc</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc healthFunc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="4）古典的Stategy模式"><a href="#4）古典的Stategy模式" class="headerlink" title="4）古典的Stategy模式"></a>4）古典的Stategy模式</h3><p>传统的Stategy模式做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数，设计结果看起来像这样:</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160609.png" srcset="/img/loading.gif" lazyload></p>
<p>每一个GameCharacter对象都内含一个指针，指向一个来自HealthCalcFunc继承体系的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>;    <span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HealthCalcFunc</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">cacl</span><span class="hljs-params">(<span class="hljs-type">const</span> GameCharacter &amp;gc)</span> <span class="hljs-type">const</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br><span class="hljs-comment">//创建一个HealthCalcFunc对象，可以通过它调用缺省的健康值计算方法</span><br>HealthCalcFunc defaultHealthCalc;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameCharacter</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">GameCharacter</span><span class="hljs-params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">healthValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> pHealthCalc-&gt;<span class="hljs-built_in">cacl</span>(*<span class="hljs-keyword">this</span>);<br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    HealthCalcFunc *pHealthCalc;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个方案的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可。</p>
<br>

<h2 id="条款36：绝不重新定义继承而来的non-virtual函数"><a href="#条款36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36：绝不重新定义继承而来的non-virtual函数"></a>条款36：绝不重新定义继承而来的non-virtual函数</h2><p>从规范上说，<a href="#%E6%9D%A1%E6%AC%BE34%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34</a>提到，如果某个操作在整个继承体系应该是不变的，那么使用non-virtual函数，此时派生类从基类继承接口以及一份强制实现。如果派生类希望表现出不同行为，那么应该使用virtual函数。</p>
<p>另一方面，假设真的重新定义了继承而来的non-virtual函数，会表现出下列令人困惑的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//重新定义了继承而来的non-virtual函数</span><br>&#125;;<br><br>D x;<br>B *pB = &amp;x;<br>D *pD = &amp;x;<br><br>pB-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用B::mf</span><br>pD-&gt;<span class="hljs-built_in">mf</span>();       <span class="hljs-comment">//调用D::mf</span><br></code></pre></td></tr></table></figure>

<p>你可能会觉得因为pB和pD指向的是相同的对象，因此调用的non-virtual函数也应该相同，但是事实并非如此。因为<strong>non-virtual函数是静态绑定</strong>，因此实际上调用的函数决定因素不在对象自身，而在于“指向该对象之指针（或引用）”当初的声明类型。virtual函数才是动态绑定。</p>
<p>任何情况下都不该重新定义一个继承而来的non-virtual函数。</p>
<br>

<h2 id="条款37：绝不重新定义继承而来的缺省参数值"><a href="#条款37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37：绝不重新定义继承而来的缺省参数值"></a>条款37：绝不重新定义继承而来的缺省参数值</h2><p><a href="#%E6%9D%A1%E6%AC%BE36%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0">条款36</a>论述了non-virtual函数不应该被重新定义，那么non-virtual函数中的参数也就不存在被重新定义的机会。因此这里主要针对的是“继承一个缺省参数值的virtual函数”。</p>
<blockquote>
<ul>
<li>对象的所谓静态类型，就是它在程序中被声明时所采用的类型</li>
<li>对象的所谓动态类型则是指“目前所指对象的类型”</li>
</ul>
</blockquote>
<p>绝对不要重新定义一个继承而来的缺省参数值。<strong>原因就在于，virtual函数是动态绑定，而缺省参数值却是静态绑定</strong>。所以你可能调用了一个定义于派生类内的virtual函数的同时，却使用base class为它所指定的缺省参数值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br>Rectangle r;<br>Circle c;<br><br>r.<span class="hljs-built_in">draw</span>();           <span class="hljs-comment">//调用Rectangle::draw，静态类型为Rectangle，所以缺省参数为Shape::Green</span><br><span class="hljs-comment">//c.draw();         //调用Circle::draw，静态类型为Circle，没有缺省参数，因此错误，必须显式指定！</span><br><br>Shape *pr = &amp;r;<br>Shape *pc = &amp;c;<br><br><span class="hljs-comment">//以下为容易引起困惑的地方，函数与参数不一致</span><br>pr-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Rectangle::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br>pc-&gt;<span class="hljs-built_in">draw</span>();         <span class="hljs-comment">//调用Shape::draw，但是静态类型为Shape，所以缺省参数Shape::Red</span><br></code></pre></td></tr></table></figure>

<p>但是，即使派生类严格遵循基类的缺省参数，也存在问题：当基类的缺省参数发生变化时，派生类的所有缺省参数也需要跟着修改。因此，<strong>本质在于，不应该在virtual函数中使用缺省参数</strong>，如果有这样的需求，那么这种场景就适合使用<a href="#">条款35</a>中，public virtual函数的几种替代方案，比如NVI手法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123;Red,Green,Blue&#125;;<br>    <span class="hljs-comment">//此时，带缺省参数的已经不是virtual函数，是个non-virtual</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">doDraw</span>(color);  <span class="hljs-comment">//调用一个virtual</span><br>    &#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">//完成真正的工作</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//而完成真正工作的virtual函数已经不带缺省参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于non-virtual函数应该绝对不被derived classes覆写，这个设计使得draw函数的color缺省参数值总是为Red。</p>
<br>

<h2 id="条款38：通过复合塑模出has-a或“根据某物实现出”"><a href="#条款38：通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="条款38：通过复合塑模出has-a或“根据某物实现出”"></a>条款38：通过复合塑模出has-a或“根据某物实现出”</h2><blockquote>
<p>复合是类型间的一种关系，当某种类型的对象含有另一种类型的对象，便是这种关系</p>
</blockquote>
<p>在应用域，复合意味着has-a(有一个)。在实现域，复合意味着is-implemented-in-terms-of(根据某物实现出)。</p>
<ul>
<li><p>has-a：</p>
<p>  程序中的对象相当于所塑造的世界中的某些事物，例如人、汽车、视频画面等等。这样的对象属于应用域。下面的例子中，Person有一个名称，一个地址，以及语音和传真两笔电话号码。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>    Address address;<br>    PhoneNumber voiceNumber;<br>    PhoneNumber faxNumber;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据某物实现出：</p>
<p>  其他对象纯碎是实现细节上的人工制品，像是缓冲区、互斥器、查找树等。这些对象相当于软件的实现域。下面的例子中，由于每个栈只能从栈顶压入弹出元素，而队列不同，is-a的性质是所有对基类为true的操作，对派生类也应该为true。所以stack不应该通过public继承deque来实现。正确的做法是，stack对象可根据一个deque对象实现出来。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> = deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack &#123;<br>...<br><span class="hljs-keyword">protected</span>:<br>  Sequence c;   <span class="hljs-comment">//底层容器</span><br>...<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>上面两者情况都应该使用复合，而不是public继承。</p>
<br>

<h2 id="条款39：明智而审慎地使用private继承"><a href="#条款39：明智而审慎地使用private继承" class="headerlink" title="条款39：明智而审慎地使用private继承"></a>条款39：明智而审慎地使用private继承</h2><p><strong>private继承和public继承的不同之处</strong>：</p>
<ul>
<li><p>编译器不会自动将一个derived class对象（例如Student）转换为一个base对象（例如Person）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// private继承</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;                 <span class="hljs-comment">// 任何人都会吃</span><br>Person p;                                  <span class="hljs-comment">// p是人</span><br>Student s;                                 <span class="hljs-comment">// s是学生</span><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 没问题，p是人，会吃</span><br><span class="hljs-built_in">eat</span>(s);                                    <span class="hljs-comment">// 错误！难道学生不是人？！</span><br></code></pre></td></tr></table></figure>
<p>  如果使用public继承，编译器在必要的时候可以将Student隐式转换成Person，但是private继承时不会，所以eat(s)调用失败。从这个例子中表达了，private继承并不表现出is-a的关系。</p>
</li>
<li><p>由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性</p>
</li>
</ul>
<p><strong>private继承的意义</strong>：</p>
<p><strong>private继承意味implemented-in-terms-of（根据某物实现出）</strong>。如果让class D以private形式继承class B，用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在有任何观念上的关系。private继承纯碎只是一种实现技术。private继承意味只有实现部分被继承，接口部分应略去。如果D以private形式继承B，意思是D对象根据B对象实现而得，再没有其他意涵了。</p>
<p><a href="#%E6%9D%A1%E6%AC%BE38%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA">条款38</a>指出，复合也意味”is-implemented-in-terms-of”，那么如何取舍？</p>
<h3 id="1）private继承"><a href="#1）private继承" class="headerlink" title="1）private继承"></a>1）private继承</h3><p>假设Widget类需要执行周期性任务，于是希望继承Timer的实现。 因为Widget不是一个Timer，所以选择了private继承：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <span class="hljs-comment">// 每滴答一次，该函数就被自动调用一次</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 查看Widget的数据...等等</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在Widget中重写虚函数onTick，使得Widget可以周期性地执行某个任务。</p>
<p>通过private继承来表现”is-implemented-in-terms-of”关系实现非常简单，而且下列情况也只能使用这种方式：</p>
<ul>
<li>当Widget需要访问Timer的protected成员时。因为对象组合后只能访问public成员，而private继承后可以访问protected成员。</li>
<li>当Widget需要重写Timer的虚函数时。比如上面的例子中，需要重写onTick。单纯的复合是做不到的</li>
</ul>
<h3 id="2）复合"><a href="#2）复合" class="headerlink" title="2）复合"></a>2）复合</h3><p>如果使用复合，上面的例子可以这样实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    &#125;;<br>    WidgetTimer timer;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过复合来表现”is-implemented-in-terms-of”关系，实现较为复杂，但是具有下列优点：</p>
<ul>
<li>如果希望阻止Widget的子类重定义onTick。因为派生类无法访问私有的WidgetTimer类</li>
<li>可以减小Widget和Timer的编译依存性。如果是private继承，在定义Widget的文件中势必需要引入#include Timer.h。 但如果采用复合的方式，可以把WidgetTimer放到另一个文件中，Widget内含指针指向一个WidgetTimer，Widget可以只带一个WidgetTimer声明式</li>
</ul>
<h3 id="3）激进情况"><a href="#3）激进情况" class="headerlink" title="3）激进情况"></a>3）激进情况</h3><p>有一种激进情况设计空间最优化，促使选择“private继承”而不是“继承加复合”。这个特殊情况只适用于你所处理的class不带任何数据时。</p>
<p>所谓的empty classes：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;&#125;;  <span class="hljs-comment">//没有数据，所以其对象应该不使用任何内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldsAnInt</span>&#123;    <span class="hljs-comment">//应该只需要一个int空间</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    Empty e;    <span class="hljs-comment">//应该不需要任何内存</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然而<strong>C++裁定凡是独立（非附属）对象都必须有非零大小</strong>，通常安插一个char到空对象中。所以sizeof(HoldsAnInt)&gt;sizeof(int)。</p>
<p>这个约束不适用于derived class对象内的base class成分，因为它们并非独立（非附属）。如果继承Empty，而不是内含一个那种类型的对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HoldsAnInt</span>:<span class="hljs-keyword">private</span> Empty&#123;    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以确定sizeof(HoldsAnInt)&#x3D;&#x3D;sizeof(int)。这是所谓的EBO（empty base optimization；空白基类最优化）。EBO一般只在单一继承（而非多重继承）下才可行。</p>
<h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>总的来说，在需要表现”is-implemented-in-terms-of”关系时。如果一个类需要访问另一个的protected成员，或需要重新定义其一个或多个virtual函数，private继承极有可能成为正统设计策略。一个混合了public继承和复合的设计，往往能够释出你要的行为，尽管有较大的复杂度。“明智而审慎地使用private继承”意味，在考虑过所有其它方案后，如果仍然认为private继承是最佳办法，才使用它。</p>
<br>

<h2 id="条款40：明智而审慎地使用多重继承"><a href="#条款40：明智而审慎地使用多重继承" class="headerlink" title="条款40：明智而审慎地使用多重继承"></a>条款40：明智而审慎地使用多重继承</h2><p>使用多重继承时，程序可能从一个以上的base classes继承相同名称（如函数、typedef等等）。那会导致较多的歧义（即使一个名字public，另一个private）。</p>
<blockquote>
<p>在看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。</p>
</blockquote>
<p>一般有两种方式使用多重继承：</p>
<ul>
<li><p>一般的多重继承：缺省做法是执行复制</p>
<ul>
<li>如果某个基类到派生类之间存在多条路径，那么派生类会包含重复的基类成员。IOFile存在两份File数据</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160646.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>虚继承（此时基类是虚基类）</p>
<ul>
<li>某个基类到派生类之间存在多条路径，虚继承使得派生类只包含一份基类成员，但是这会带来额外开销<ul>
<li>为避免重复，编译器必须提供一些机制，后果就是virtual继承的那些classes所产生的对象往往比使用non-virtual继承的体积大，访问virtual base classes的成员变量时，速度也更慢</li>
<li>virtual base的初始化由继承体系中的最低层class负责，这暗示<ul>
<li>classes若派生自virtual bases而需要初始化，必须认知其virtual bases——无论那些bases距离多远</li>
<li>当一个新derived class加入继承体系中，它必须承担其virtual bases的初始化责任</li>
</ul>
</li>
</ul>
</li>
<li>如果virtual base classes不带任何数据，将是最具实用价值的情况</li>
</ul>
<p>  <img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210116160727.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<p>如果你有一个单一继承的设计方案，而它大约等价于一个多重继承方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候是完成任务的最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎的情况下使用它。</p>
<p>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。</p>
<br>
<br>

<h1 id="七-模板与泛型编程"><a href="#七-模板与泛型编程" class="headerlink" title="七.模板与泛型编程"></a>七.模板与泛型编程</h1><h2 id="条款41：了解隐式接口和编译器多态"><a href="#条款41：了解隐式接口和编译器多态" class="headerlink" title="条款41：了解隐式接口和编译器多态"></a>条款41：了解隐式接口和编译器多态</h2><blockquote>
<p>编译期多态：以不同的template参数具现化function templates会导致调用不同的函数。</p>
</blockquote>
<p>面向对象设计中的类（class）考虑的是显式接口（explicit interface）和运行时多态， 而模板编程中的<strong>模板（template）考虑的是隐式接口（implicit interface）和编译期多态</strong>。</p>
<ul>
<li>对类而言，显式接口是由函数签名（也就是函数名称、参数类型、返回类型）表征的，多态则是通过virtual函数发生于运行期</li>
<li>对模板参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期</li>
</ul>
<br>

<h2 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h2><p>声明template参数时，前缀关键字class和typename的意义完全相同，可互换。</p>
<p>以下代码中，typename和class等价：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;<br></code></pre></td></tr></table></figure>

<p>但是如果在template中，遇到嵌套从属名称，需要明确声明是一种类型时，必须使用typename。</p>
<blockquote>
<p>template内出现的名称如果相依于某个template参数，称之为从属名称。如果从属名称在class内呈嵌套状，称它为嵌套从属名称。</p>
</blockquote>
<p>嵌套从属名称有可能导致解析困难。</p>
<p>考虑如下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们认为C::const_iterator表示容器C的迭代器类型，因此上述代码定义一个该迭代器类型的指针。但是这是一种先入为主的思想。如果C::const_iterator不是一个类型呢？比如恰巧有个static成员变量被命名为const_iterator，或如果x碰巧是个global变量名称？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作。</p>
<p>C++有个规则可以解析这种歧义：如果解析器在template中遭遇一个嵌套从属名称，它<strong>便假设这名称不是个类型</strong>，除非你告诉它是。所以缺省情况下嵌套从属名称不是类型。那么怎么告诉它是一个类型，当然就是typename了，所以上述代码应该像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">typename</span> C::const_iterator *x;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>一般性规则是：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。</strong>（注意：typename只被用来验明嵌套从属类型名称，其他名称不该有它存在）。</p>
<p>上述规则有两个例外：</p>
<ol>
<li><strong>typename不可以出现在base classes list内的嵌套从属名称之前</strong></li>
<li><strong>typename也不可出现在成员初始值列表中作为base class修饰符</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested&#123; <span class="hljs-comment">//typename不可出现在此</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">explict <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //typename也不可出现在此</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;  <span class="hljs-comment">//嵌套从属类型名称，这里必须使用typename</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; container)</span></span>;  <span class="hljs-comment">//非嵌套从属类型，不允许使用typename</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>typename相关规则在不同的编译器上有不同的实践。某些编译器接收的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属类型名称”之间的互动，也许会在移植性方面给你带来一些麻烦。</p>
<br>

<h2 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h2><p>假设以下MsgSender类可以通过两种方式发送信息到各个公司：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//1.发送原始文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ...<br>        Company c;<br>        c.<span class="hljs-built_in">sendCleartext</span>(...);   <br>    &#125;<br>    <span class="hljs-comment">//2.发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>假设我们有时候想要在每次送出信息时志记(log)某些信息。因此有了以下派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);             <span class="hljs-comment">//调用base class函数，无法通过编译</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>问题在于，当编译器遭遇class template LoggingMsgSender定义式时，并不知道它继承什么样的class。Company是个template参数，不到后来无法确切知道它是什么。</p>
<p>假设有一个公司CompanyZ只支持加密传送，那么泛化的MsgSender就不适合，因此需要为其产生一个特化版的MsgSender：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">//特化版，所谓的模板全特化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//只支持发送加密后的文本</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(...)</span> </span>&#123;...&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当base class被指定为MsgSender<CompanyZ>时，其内不包含sendClear方法，那么derived class LoggingMsgSender的sendClearMsg方法就会调用不存在的sendClear。</p>
<p><strong>因此，正是因为知道base class templates有可能被特化，而那个特化版本可能不提供和一般性template相同的接口。因此C++往往拒绝在templatized base classes（模板化基类，本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear）</strong>。</p>
<p><strong>解决办法有3个，它们会通知编译器:进入base class作用域查找继承而来的名称</strong>：</p>
<ol>
<li><p>在base class函数调用动作之前加上<strong>this-&gt;</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>使用using</strong>声明式</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//告诉编译器，请它假设sendClear位于base class内</span><br>    <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        <span class="hljs-built_in">sendClear</span>(...);     <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>通过作用域符明确指出</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span> : <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt;&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将“传送前“的信息写至log；</span><br>        MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(...);  <span class="hljs-comment">//成立，假设sendClear将被继承</span><br>        <span class="hljs-comment">//将”传送后“的信息写至log；</span><br>    &#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p> 这种方法往往最不让人满意，因为如果被调用的是virtual函数，这样会关闭“virtual绑定行为”。</p>
</li>
</ol>
<p>上述每一种解法做的事情都相同：对编译器承诺“base class template的任何特化版本都将支持其一般（泛化）版本所提供的接口”。</p>
<p>要注意的是，它们只是通知编译器进去查找。如果找到了自然是没问题。但是如同上面的CompanyZ，如果基类还是不存在相应名称，编译器还是会报错。</p>
<br>

<h2 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h2><p>模板提供的是编译期的多态， 即使你的代码看起来非常简洁短小，生成的二进制文件也可能包含大量的冗余代码。 因为模板每次实例化都会生成一个完整的副本，所以其中与模板参数无关的部分会造成代码膨胀。</p>
<p>把模板中参数无关的代码重构到模板外便可以有效地控制模板产生的代码膨胀：</p>
<ul>
<li><p><strong>对于非类型模板参数造成的代码膨胀，以函数参数或class成员变量替换模板参数即可消除冗余</strong></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//非类型模板参数造成代码膨胀</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//求逆矩阵</span><br>&#125;;<br><span class="hljs-comment">//以下会实例化两个类：Square&lt;double, 5&gt;和Square&lt;double, 10&gt;</span><br><span class="hljs-comment">//会具现化两份invert。除了常量5和10，两个函数的其它部分完全相同</span><br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; s1;<br>Square&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; s2;<br>s1.<span class="hljs-built_in">invert</span>();<br>s2.<span class="hljs-built_in">invert</span>();<br><span class="hljs-comment">//以下，使用函数参数消除重复</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareBase</span>&#123;<br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-comment">//以下函数只是作为避免代码重复的方法，并不应该被外界调用，</span><br>    <span class="hljs-comment">//同时，该函数希望被子类调用，因此使用protected</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>:<span class="hljs-keyword">private</span> SquareBase&lt;T&gt;&#123;<span class="hljs-comment">//只要T相同，都会使用同一份父类实例，</span><br><span class="hljs-keyword">private</span>:                           <span class="hljs-comment">//因此，只有一份invert(int size)</span><br>    <span class="hljs-keyword">using</span> SquareBase&lt;T&gt;::invert; <span class="hljs-comment">//避免遮掩base版的invert</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//调用父类invert的代价为零，因为Square::invert是隐式的inline函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  最后是父类如何访问矩阵数据。原本这些数据在派生类中，但是因为invert核心代码转移到了父类，那么父类必须有办法访问这些数据。可以在调用SquareBase::invert时把内存地址也一起告知父类，但如果矩阵类中有很多函数都需要这些信息就需要为每个函数添加一个这样的参数。因此，可以把数据地址直接放在父类中。</p>
</li>
<li><p><strong>对于类型模板参数造成的代码膨胀，做法是让带有完全相同二进制表述的具体类型共享实现码</strong></p>
<ul>
<li>int和long在多数平台都是一样的底层实现，然而模板却会实例化为两份，因为它们类型不同</li>
<li>List&lt;int *&gt;, List&lt;const int *&gt;, List&lt;double *&gt;的底层实现也是一样的。但因为指针类型不同，也会实例化为多份模板类<br>  如果某些成员函数操作强型指针(T*)，应该令它们调用另一个操作无类型指针(void*)的函数，由后者完成实际工作。</li>
</ul>
</li>
</ul>
<br>

<h2 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h2><p>需要使用成员函数模板的一个例子是构造函数和copy赋值运算符。</p>
<p>例如，假设SmartPtr是一种智能指针，并且它是一个template class。现在有一个继承体系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span> : <span class="hljs-keyword">public</span> Top &#123;...&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span> : <span class="hljs-keyword">public</span> Middle &#123;...&#125;;<br></code></pre></td></tr></table></figure>

<p>现在希望通过一个SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;来初始化一个SmartPtr&lt;Top&gt;。如果是指针，即Middle*和Bottom*可以隐式转换成Top*，问题是：<strong>同一个template的不同具现体之间不存在什么与生俱来的固有关系，即使具现体之间具有继承关系</strong>。因此，SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;并不能隐式转化成SmartPtr&lt;Top&gt;。因此，我们需要一个构造函数模板（也称为泛化构造函数），来实现这种转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//构造函数模板</span><br>    <span class="hljs-comment">//意思是：对任何类型T和任何类型U，可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">    <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt; &amp;other)</span>  <span class="hljs-comment">//以other的heldPtr初始化this的heldPtr</span></span><br><span class="hljs-function">     : heldPtr(other.get()) &#123;</span>...&#125;<br>    <span class="hljs-comment">//原始指针为private成员，需要一个接口来获取</span><br>    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<span class="hljs-keyword">return</span> heldPtr;&#125;<br>    ...<br><span class="hljs-keyword">private</span>:<br>    T* heldPtr;   <span class="hljs-comment">//智能指针所持有的原始指针</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们当然不希望一个SmartPtr&lt;Top&gt;可以转化成SmartPtr&lt;Bottom&gt;或SmartPtr&lt;Middle&gt;，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs heldPtr(other.get())```为此提供了保证。这个行为只有当“存在某个隐式转换可将一个U\*指针转为一个T\*指针”时才能通过编译。"><br>最后需要指明的是：**member templates并不改变语言规则**，而语言规则说，如果程序需要一个copy构造函数，你却没声明它，编译器会为你暗自生成一个。因此，如果你想要控制copy构造的方方面面，你必须同时声明泛化的copy构造函数和“正常的”copy构造函数。相同规则也适用于赋值（assignment）操作。<br><br>&lt;br&gt;<br><br>## 条款46：需要类型转换时请为模板定义非成员函数<br><br>**template实参推导过程中从不将隐式类型转换函数纳入考虑**，下面的例子将[条款24](#条款24若所有参数皆需类型转换请为此采用non-member函数)中的Rational和operator\*改成了template，混合运算会编译错误：<br><br>```c++<br>template&lt;typename T&gt;<br>class Rational&#123;<br>public:<br>    Rational(const T &amp;numerator = 0, const T &amp;denominator = 1);<br>    const T numerator() const;<br>    const T denominator() const;<br>    ...<br>&#125;;<br><br>template&lt;typename T&gt;<br>const Rational&lt;T&gt; operator*(const Rational&lt;T&gt; &amp;lhs,const Rational&lt;T&gt; &amp;rhs)<br>&#123; ... &#125;<br><br>Rational&lt;int&gt; oneHalt(1,2);<br>Rational&lt;int&gt; result = oneHalf * 2   //编译错误<br></code></pre></td></tr></table></figure>

<p>将oneHalf传递给operator*时，它将T推断为int，因此期待第二个参数也为Rational，但是第二个参数为int，前面我们说了，template实参推导过程中从不将隐式类型转换函数纳入考虑。因此编译错误。</p>
<p>那么解决办法是什么？在class template将其声明为friend，从而具现化一个operator*，具现化后就可以不受template的限制了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-comment">//也可以是Rational&lt;T&gt;，但是省去&lt;T&gt;更简洁</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational &amp;lhs,<span class="hljs-type">const</span> Rational &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.numerator,<br>                         lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果上面只有函数声明，而函数定义在类外，那么会报链接错误。当传入第一个参数oneHalt时，会具现化Rational&lt;int&gt;，编译器也就知道了我们要调用传入两个Rational&lt;int&gt;的版本，但是那个函数只在类中进行了声明，并没有定义，不能依赖类外的operator* template提供定义，我们必须自己定义，所以会出现链接错误。解决方法就是像上面一样定义于类内。</p>
<p>这样看起来有点像是member函数，但是因为friend关键字，所以实际是non-member函数，如果去掉friend关键字，就成了member函数，但是此时参数也只能有1个，就不能让类型转换可能发生于所有实参身上。</p>
<p>上面的代码可能还有一个问题，虽然有friend，上述函数仍是隐式的inline。如果函数实体代码量较大，可以令operator*不做任何事，只调用一个定义于class外部的辅助函数（当然这里没必要，因为本身只有1行）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;<br><br><span class="hljs-comment">//helper template</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">friend</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs);<span class="hljs-comment">//令friend调用helper</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。</p>
<br>

<h2 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h2><ul>
<li>Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现</li>
<li>整合重载技术后，traits classes有可能在编译期对类型执行if…else测试</li>
</ul>
<p>详细实现可参考 STL源码分析 中对traits的介绍。</p>
<br>

<h2 id="条款48：认识template元编程"><a href="#条款48：认识template元编程" class="headerlink" title="条款48：认识template元编程"></a>条款48：认识template元编程</h2><ul>
<li>Template metaprogramming(TMP，模板元编程)是编写template-based C++程序并执行于编译期的过程</li>
<li>Template metaprogram(模板元程序)是以C++写成、执行于C++编译器内的程序</li>
</ul>
<p><strong>TMP的两个重要特点：1）基于template；2）编译期执行</strong></p>
<p>TMP有2个伟大的效力：</p>
<ol>
<li>它让某些事情更容易。如果没有它，那些事情将是困难的，甚至不可能的</li>
<li>执行于编译期，因此可将工作从运行期转移到编译期。会导致以下几个结果<ul>
<li>某些原本在运行期才能侦测到的错误现在可在编译期找出来</li>
<li>使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求</li>
<li>编译时间变长了</li>
</ul>
</li>
</ol>
<p>traits解法就是TMP，traits引发“编译器发生于类型身上的if…else计算”</p>
<p>另一个TMP的例子是循环，TMP并没有真正的循环构件，所以循环效果藉由递归完成。TMP的递归甚至不是正常种类，因为TMP循环并不涉及递归函数调用，而是涉及“递归模板具现化”。以在编译期计算阶乘为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&#123;    <span class="hljs-comment">//一般情况，Factorial&lt;n&gt;的值是n乘以Factorial&lt;n-1&gt;的值</span><br>    <span class="hljs-keyword">enum</span> &#123;value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value&#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt;&#123;    <span class="hljs-comment">//特殊情况：Factorial&lt;0&gt;的值是1</span><br>    <span class="hljs-keyword">enum</span> &#123;value = <span class="hljs-number">1</span>;&#125;<br>&#125;;<br><span class="hljs-comment">//可以这样使用Factorial</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value;    <span class="hljs-comment">//打印120</span><br>    std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;   <span class="hljs-comment">//打印3628800</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>TMP还有许多用途，可以达成以下三个目标（这部分可以等有实际需求了再去详细了解）：</p>
<ul>
<li>确保量度单位正确</li>
<li>优化矩阵运算</li>
<li>可以生成客户定制之设计模式实现品</li>
</ul>
<br>
<br>

<h1 id="八-定制new和delete"><a href="#八-定制new和delete" class="headerlink" title="八.定制new和delete"></a>八.定制new和delete</h1><ul>
<li>operator new和operator delete只适合用来分配单一对象</li>
<li>Arrays所用的内存由operator new[]分配出来，并由operator delete[]归还</li>
<li>STL容器所使用的heap内存是由容器所拥有的分配器对象（allocator objects）管理，不是被new和delete直接管理</li>
</ul>
<h2 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h2><p>当operator new无法满足某一内存分配需求时，它会抛出异常。当operator new抛出异常以反映一个未获满足的内存需求之前，会先调用一个客户指定的错误处理函数，一个所谓的new-handler。为了指定这个“用以处理内存不足”的函数，客户必须调用<code>std::set_new_handler()</code>，<code>std::set_new_handler()</code>声明在&lt;new&gt;中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*new_handler)</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>; <br>    <span class="hljs-comment">//以上，throw()是一个异常声明，括号内无任何内容，表示该函数不抛出任何异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。一个设计良好的new-handler函数必须做以下事情；</p>
<ul>
<li><strong>让更多内存可被使用</strong>：一个做法是程序一开始执行就分配一大块内存，而后当new-handler第一次被调用，将它们释还给程序使用。这便造成operator new内的下一次内存分配动作可能成功</li>
<li><strong>安装另一个new-handler</strong>：如果当前new-handler无法取得更多可用内存，可用安装另一个，下次operator new时会调用新的new-handler</li>
<li><strong>卸除new-handler</strong>：将null指针传给set_new_handler</li>
<li><strong>抛出bad_alloc(或派生自bad_alloc)的异常</strong>：这样的异常不会被operator new捕获，因此会被传播到内存索求处</li>
<li><strong>不返回</strong>：通常调用abort或exit（abort会设置程序非正常退出，exit会设置程序正常退出，当存在未处理异常时C++会调用terminate， 它会回调由std::set_terminate设置的处理函数，默认会调用abort）</li>
</ul>
<h3 id="实现class专属的new-handlers"><a href="#实现class专属的new-handlers" class="headerlink" title="实现class专属的new-handlers"></a>实现class专属的new-handlers</h3><p>这个设计的base class部分让derived class继承它们所需的set_new_handler和operator new，而template部分则确保每一个derived class获得一个实体互异的current成员变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerHolder</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">NewHandlerHolder</span><span class="hljs-params">(std::new_handler nh)</span>: handler(nh)&#123;</span>&#125; <span class="hljs-comment">//取得目前的new_handler</span><br>    ~<span class="hljs-built_in">NewHandlerHolder</span>()&#123; std::<span class="hljs-built_in">set_new_handler</span>(handler); &#125; <span class="hljs-comment">//释放它</span><br><span class="hljs-keyword">private</span>:<br>    std::new_handler handler;<br>    <span class="hljs-built_in">NewHandlerHolder</span>(<span class="hljs-type">const</span> HandlerHolder&amp;);     <span class="hljs-comment">// 禁用拷贝构造函数</span><br>    <span class="hljs-type">const</span> NewHandlerHolder&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NewHandlerHolder&amp;); <span class="hljs-comment">// 禁用赋值运算符</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <span class="hljs-comment">//“mixin”风格的base class，用以支持class专属的set_new_handler</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NewHandlerSupport</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> std::new_handler <span class="hljs-title">set_new_handler</span><span class="hljs-params">(std::new_handler p)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> std::new_handler current;   <span class="hljs-comment">//class专属的new-handlers</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::<span class="hljs-built_in">set_new_handler</span>(std::new_handler p) <span class="hljs-keyword">throw</span>()&#123;<br>    std::new_handler old = current;<br>    current = p;    <span class="hljs-comment">//将class专属的new-handlers设置为新的new_handler</span><br>    <span class="hljs-keyword">return</span> old;     <span class="hljs-comment">//返回旧的class专属的new-handlers</span><br>&#125;<br><br><span class="hljs-comment">//new时会调用该operator new</span><br><span class="hljs-comment">//它会设置全局的new-handlers为该class专属的new-handlers，然后调用全局operator new申请内存</span><br><span class="hljs-comment">//h对象销毁后，其析构函数会将全局new-handlers恢复为调用前的状态</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> * NewHandlerSupport&lt;T&gt;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>&#123;<br>    <span class="hljs-function">NewHandlerHolder <span class="hljs-title">h</span><span class="hljs-params">(std::set_new_handler(current))</span></span>;<br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);<br>&#125;<br><br><span class="hljs-comment">//以下将每一个current初始化为null</span><br><span class="hljs-comment">//class专属的new-handlers初始化为null</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::current = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>有了<code>NewHandlerSupport</code>这个模板基类后，给Widget添加set_new-handler支持只需要public继承即可:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> NewHandlerSupport&lt;Widget&gt;&#123; ... &#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>class。Template机制会自动为每一个T（NewHandlerSupport赖以具现化的根据）生成一份current，即使current为static成员变量。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs NewHandlerSupport```的实现和模板参数T完全无关，添加模板参数是因为handler是静态成员，这样编译器才能为每个类型生成一个handler实例。类型参数T只是用来区分不同的derived"><br>### nothrow new<br><br>1993年之前C++的operator new在失败时会返回null而不是抛出异常。如今的C++仍然支持这种nothrow的operator new<br><br>```c++<br>Widget *p1 = new Widget;    // 失败时抛出 bad_alloc 异常<br>if(p1 == 0) ...             // 这个测试一定失败<br><br>Widget *p2 = new (std::nothrow) Widget; //失败时返回0<br>if(p2 == 0) ...             // 这个测试可能成功<br></code></pre></td></tr></table></figure>

<p>nothrow new只能保证所调用的nothrow版的operator new不抛出异常，但是构造对象也属于表达式new的一个步骤，而它没法强制构造函数不抛出异常，所以并不能保证<code>new (std::nothrow) Widget</code>这样的表达式绝不导致异常。因此没有运用nothrow new的需要。</p>
<br>

<h2 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h2><p>一般出于下列原因可能想要替换编译器提供的operator new或operator delete：</p>
<ul>
<li>为了检测运用错误</li>
<li>为了收集动态分配内存之使用统计信息</li>
<li>为了增加分配和归还的速度</li>
<li>为了降低缺省内存管理器带来的空间额外开销</li>
<li>为了弥补缺省分配器中的非最佳齐位</li>
<li>为了将相关对象成簇集中</li>
<li>为了获得非传统的行为</li>
</ul>
<p>下面是一个为了检测运用错误（overruns，写入点在分配区块尾端之后，或underruns，写入点在分配区块起点之前）而实现的简单定制型operator new的例子，通过在首部和尾部插入一个签名，返回中间内存块给程序使用，如果程序在使用内存时发生过在区块前或区块后写入的行为，那么签名就会被修改，因此可以检测这种行为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> signature = <span class="hljs-number">0xDEADBEEF</span>;    <span class="hljs-comment">// 边界符</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Byte; <br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span> </span>&#123;<br>    <span class="hljs-comment">// 多申请一些内存来存放占位符 </span><br>    <span class="hljs-type">size_t</span> realSize = size + <span class="hljs-number">2</span> * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>); <br><br>    <span class="hljs-comment">// 申请内存</span><br>    <span class="hljs-type">void</span> *pMem = <span class="hljs-built_in">malloc</span>(realSize);<br>    <span class="hljs-keyword">if</span> (!pMem) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">bad_alloc</span>(); <br><br>    <span class="hljs-comment">// 将signature写入内存的最前段落和最后段落</span><br>    *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(<span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem)+realSize-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>))) <br>        = *(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(pMem)) = signature;<br><br>    <span class="hljs-comment">// 返回真正的内存区域，指向恰位于第一个signature之后的内存位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个例子主要是展示，它存在很多错误：</p>
<ol>
<li>所有的operator news都应该内含一个循环，反复调用某个new-handling函数，这里却没有</li>
<li>C++要求所有operator new返回的指针都有适当的对齐。这里malloc返回的指针是满足要求的，但是因为上述实现并不是直接返回malloc的结果，而是返回一个int偏移后的地址，因此无法保证它的安全</li>
</ol>
<br>

<h2 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h2><p>前一条款是解释什么时候会想实现自己的 operator new 和 operator delete，这个条款是解释当实现自己的 operator new 和 operator delete 时，必须遵守的规则。</p>
<h3 id="1）operator-new"><a href="#1）operator-new" class="headerlink" title="1）operator new"></a>1）operator new</h3><p>实现一致性的operator new必得返回正确的值，内存不足时必得调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p>
<blockquote>
<p>C++规定，即使客户要求0bytes，operator new也得返回一个合法指针。</p>
</blockquote>
<p>下面是non-member operator new的伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">//处理0-byte申请</span><br>        size = <span class="hljs-number">1</span>;           <span class="hljs-comment">//将它视为1-byte</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        尝试分配<span class="hljs-function">size bytes</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(分配成功)</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(一个指针，指向分配得来的内存)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-comment">//分配失败：找出目前的new-handling函数</span></span><br><span class="hljs-function">        new_handler globalHandler </span>= <span class="hljs-built_in">set_new_handler</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">set_new_handler</span>(globalHandler);<br>        <br>        <span class="hljs-keyword">if</span>(globalHandler) (*globalHandler)();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_alloc</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>operator new内含一个无穷循环，即while(true)，退出此循环的唯一办法是：内存被成功分配或new-handling函数做了一件描述于<a href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA">条款49</a>的事情。</p>
<p>写出定制型内存管理器的一个最常见理由是为针对某特定class的对象分配行为提供最优化，却不是为了该class的任何derived classes。也就是说，针对class X而设计的operator new，其行为很典型地只为大小刚好为sizeof(X)的对象而设计。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;<br>    ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base  <span class="hljs-comment">//假设Derived未声明operator new</span><br>&#123;...&#125;;<br><br>Derived *p = <span class="hljs-keyword">new</span> Derived;    <span class="hljs-comment">//这里调用的是Base::operator new</span><br></code></pre></td></tr></table></figure>

<p>如果Base class专属的operator new并非被设计用来对付上述情况（实际上往往如此），处理此情势的最佳做法是将“内存申请量错误”的调用行为改采标准operator new，像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))            <span class="hljs-comment">//如果大小错误</span><br>        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);    <span class="hljs-comment">//交给标准的operator new处理</span><br>    ...                                 <span class="hljs-comment">//否则在这里处理</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>size为0这份申请也会被转交到::operator new手上，因为sizeof(Base)不能为0（所有非附属&#x2F;独立式对象必须有非零大小）。</p>
<blockquote>
<p>非附属&#x2F;独立式对象，指的是不以“某对象之base class成分”存在的对象。</p>
</blockquote>
<p>operator new[]唯一需要做的事是分配一块非加工内存，因为无法对array之内迄今尚未存在的元素对象做任何事情。实际上甚至无法计算这个array将含有多少个元素对象。因此，不能在Base::operator new[]内假设array的每个元素对象的大小是sizeof(Base)，因为base class的operator new[]有可能经由继承被调用。此外，传递给operator new[]的size_t参数，其值有可能比“将被填以对象”的内存数量更多，因为动态分配的arrays可能包含额外空间用来存放元素个数。</p>
<h3 id="2）operator-delete"><a href="#2）operator-delete" class="headerlink" title="2）operator delete"></a>2）operator delete</h3><p>operator delete比起operator new更简单，需要记住的唯一事情就是C++保证“删除null指针永远安全”。下面是non-member operator delete的伪码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//如果将被删除的是个null指针，那就什么都不做</span><br>    现在，归还rawMemory所指的内存；<br>&#125;<br></code></pre></td></tr></table></figure>

<p>member版本也很简单，只需要多一个动作检查删除数量。万一class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> Base::<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* rawMemory,std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(rawMemory == <span class="hljs-number">0</span>)  <span class="hljs-keyword">return</span>;         <span class="hljs-comment">//检查null指针</span><br>    <span class="hljs-keyword">if</span>(size != <span class="hljs-built_in">sizeof</span>(Base))&#123;           <span class="hljs-comment">//如果大小错误，令标准版</span><br>        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(rawMemory)</span></span>;   <span class="hljs-comment">//operator delete处理此一申请</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    现在，归还rawMemory所指的内存<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果即将被删除的对象派生自某个base class，而后者欠缺virtual析构函数，那么C++传给operator delete的size_t数值可能不正确。这是“让你的base classes拥有virtual析构函数”的一个够好的理由。</p>
<br>

<h2 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h2><p>placement new是带有额外参数的operator new。众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”的operator new。这个版本被纳入了C++标准程序库，只要#include&lt;new&gt;就可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span>,<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>new会先调用operator new，然后调用构造函数构造对象。如果对象构造过程中发生异常，那么需要调用相应的operator delete来取消内存分配所得并恢复旧观，否则会发生内存泄露。而operator delete必须和相应的operator new匹配：</p>
<ul>
<li>对于正常版本的operator new，匹配的operator delete就是不带额外参数的版本</li>
<li>对于非正常版本的operator new(placement new)，匹配的operator delete是带相应参数的版本(placement delete)</li>
</ul>
<p>如果构造函数抛出异常，运行期系统寻找“参数个数和类型都与operator new相同的”某个operator delete。如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete，当么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。</p>
<p>此外，<strong>placement delete只有在“伴随placement new调用而触发的构造函数”出现异常时才会被调用。对着一个指针施行delete绝不会导致调用placement delete</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">delete</span> pw; <span class="hljs-comment">//调用正常的operator delete</span><br></code></pre></td></tr></table></figure>

<p>这意味着如果要对所有与placement new相关的内存泄露宣战，我们必须同时提供一个正常的operator delete（用于构造期间无任何异常被抛出）和一个placement版本（用于构造期间有异常被抛出）。后者的额外参数必须和operator new一样。只要这样做，就再也不会因为难以察觉的内存泄露而失眠。</p>
<p>另外，由于成员函数的名称会掩盖其外围作用域中的相同名称，需要注意名称掩盖的问题，必须小心避免让class专属的news掩盖客户期望的其他news（包括正常版本）：</p>
<ul>
<li>成员函数的名称会掩盖外围作用域中的相同名称</li>
<li>子类的名称会掩盖所有父类相同的名称</li>
</ul>
<p>一个比较好的方法是，建立一个base class，内含所有正常形式的new和delete。凡是想以自定义形式扩充标准形式的客户，可利用继承机制以及using声明式取得标准形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StandardNewDeleteForms</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//正常的 new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span><br><span class="hljs-function">    </span>&#123;<span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);&#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span>* pMemory)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>;&#125;<br><br>    <span class="hljs-comment">//placement new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, ptr); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">void</span> *ptr)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">delete</span>(pMemory, ptr); &#125;<br><br>    <span class="hljs-comment">// nothrow new/delete</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp; nt)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size, nt); &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, <span class="hljs-type">const</span> std::<span class="hljs-type">nothrow_t</span>&amp;)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123; ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(pMemory)</span></span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">public</span> StandardNewDeleteForms &#123;      <span class="hljs-comment">//继承标准形式</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>;     <span class="hljs-comment">//让这些形式可见</span><br>   <span class="hljs-keyword">using</span> StandardNewDeleteForms::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>;<br><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, std::ostream&amp; log)</span> <span class="hljs-title">throw</span><span class="hljs-params">(std::bad_alloc)</span></span>;    <span class="hljs-comment">// 自定义 placement new</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *pMemory, std::ostream&amp; logStream)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;            <span class="hljs-comment">// 对应的 placement delete</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<br>
<br>

<h1 id="九-杂项讨论"><a href="#九-杂项讨论" class="headerlink" title="九.杂项讨论"></a>九.杂项讨论</h1><h2 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h2><ul>
<li>严肃对待编译器发出的警告信息。努力在你的编译器的最高（最严苛）警告级别下争取“无任何警告”的荣誉</li>
<li>不要过度倚赖编译器的报警能力，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本倚赖的警告信息有可能消失</li>
</ul>
<br>

<h2 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h2><br>

<h2 id="条款55：让自己熟悉Boost"><a href="#条款55：让自己熟悉Boost" class="headerlink" title="条款55：让自己熟悉Boost"></a>条款55：让自己熟悉Boost</h2><p><a target="_blank" rel="noopener" href="https://www.boost.org/">Boost</a>是一个C++开发者集结的社群，也是一个可自由下载的C++程序库群。</p>
<br>

<hr>
<p>完结撒花~</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/CPP-kernal/">CPP_kernal</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Effective-C/">Effective C++</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/23/Leetcode%20Notes%E2%80%94%E2%80%94Dynamic%20Programming/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Dynamic Programming</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/03/Leetcode%20Notes%E2%80%94%E2%80%94Math/">
                        <span class="hidden-mobile">Leetcode Notes——Math</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
