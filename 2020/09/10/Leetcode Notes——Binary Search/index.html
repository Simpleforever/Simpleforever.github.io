

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为二分查找篇。部分内容搬运自 Leetcode-cn 大佬题解。思路、核心思想等搬运自 @liweiwei1419 提供的方法论。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Binary Search">
<meta property="og:url" content="https://simpleforever.github.io/2020/09/10/Leetcode%20Notes%E2%80%94%E2%80%94Binary%20Search/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为二分查找篇。部分内容搬运自 Leetcode-cn 大佬题解。思路、核心思想等搬运自 @liweiwei1419 提供的方法论。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115632.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115611.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115541.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115530.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918144041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145603.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145708.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111602.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111554.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111538.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111520.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111507.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111405.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111959.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173116.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200928111521.png">
<meta property="article:published_time" content="2020-09-09T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-30T12:27:56.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Binary Search">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115632.gif">
  
  
  <title>Leetcode Notes——Binary Search - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Binary Search">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-09-10 00:00" pubdate>
        2020年9月10日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      42k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      349 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Binary Search</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>二分查找</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。思路、核心思想等搬运自 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">liweiwei1419</a> 提供的方法论。</p>
<span id="more"></span>

<h1 id="二分查找思路"><a href="#二分查找思路" class="headerlink" title="二分查找思路"></a>二分查找思路</h1><ul>
<li>分析题意，挖掘题目中隐含的 <strong>单调性</strong>；</li>
<li><code>while(left &lt; right)</code>退出循环的时候有 <code>left == right</code> 成立，因此无需考虑返回 <code>left</code> 还是 <code>right</code>；</li>
<li>始终思考下一轮搜索区间是什么，如果是 <code>[mid, right]</code> 就对应 <code>left = mid</code> ，如果是 <code>[left, mid - 1]</code> 就对应 <code>right = mid - 1</code>，是保留 <code>mid</code>还是 +1、-1 就在这样的思考中完成；</li>
<li><strong>从一个元素什么时候不是解开始考虑下一轮搜索区间是什么</strong> ，把区间分为 2 个部分（一个部分肯定不存在目标元素，另一个部分有可能存在目标元素），问题会变得简单很多，这是一条 <strong>非常有用</strong> 的经验；</li>
<li>每一轮区间被划分成 2 部分，理解 <strong>区间划分</strong> 决定中间数取法（ <strong>无需记忆，需要练习 + 理解</strong> ），在调试的过程中理解 <strong>区间和中间数划分的配对关系</strong>：<ul>
<li>划分 <code>[left, mid]</code> 与 <code>[mid + 1, right]</code> ， <code>mid</code>被分到左边，对应 <code>int mid = left + (right - left) / 2</code>；</li>
<li>划分 <code>[left, mid - 1]</code> 与 <code>[mid, right]</code>， <code>mid</code> 被分到右边，对应 <code>int mid = left + (right - left + 1) / 2</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>至于为什么划分是这种对应关系，原因在于区间只有 2 个数的时候，如果中间数的取法不对，<strong>一旦进入的分支不能使得区间缩小</strong>，会出现 <strong>死循环</strong>。暂时不理解问题不大，需要在练习中进行调试；</p>
</blockquote>
<ul>
<li>退出循环的时候有 <code>left == right</code> 成立，此时如果能确定问题一定有解，返回 <code>left</code>即可，如果不能确定，需要单独判断一次。</li>
</ul>
<h1 id="二分查找的核心思想"><a href="#二分查找的核心思想" class="headerlink" title="二分查找的核心思想"></a>二分查找的核心思想</h1><p>二分查找的核心思想是「减而治之」，即「不断缩小问题规模」。</p>
<p><strong>二分查找的两种思路（请特别留意第 2 种思路，掌握它能思路清晰地解决「力扣」上的所有二分查找问题）</strong></p>
<h2 id="思路-1：在循环体内部查找元素"><a href="#思路-1：在循环体内部查找元素" class="headerlink" title="思路 1：在循环体内部查找元素"></a>思路 1：在循环体内部查找元素</h2><ul>
<li><code>while(left &lt;= right)</code>这种写法表示在循环体内部直接查找元素；</li>
<li>退出循环的时候 <code>left</code> 和 <code>right</code> 不重合，区间 <code>[left, right]</code>是空区间。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115632.gif" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<h2 id="思路-2：在循环体内部排除元素（重点）"><a href="#思路-2：在循环体内部排除元素（重点）" class="headerlink" title="思路 2：在循环体内部排除元素（重点）"></a>思路 2：在循环体内部排除元素（重点）</h2><ul>
<li><code>while(left &lt; right)</code>这种写法表示在循环体内部排除元素；</li>
<li>退出循环的时候 <code>left</code> 和 <code>right</code> 重合，区间 <code>[left, right]</code> 只剩下成 1 个元素，这个元素 <strong>有可能</strong> 就是我们要找的元素。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115611.gif" srcset="/img/loading.gif" lazyload  style="zoom: 67%;" />

<p>第 2 种思路可以归纳为「左右边界向中间走，两边夹」，这种思路在解决复杂问题的时候，可以使得思考的过程变得简单。</p>
<h1 id="为什么总是写不对「二分查找」"><a href="#为什么总是写不对「二分查找」" class="headerlink" title="为什么总是写不对「二分查找」"></a>为什么总是写不对「二分查找」</h1><p>二分查找不难，更多时候在考察是否细心。弄不清楚边界条件，有可能是在背模板，没有搞清楚二分查找的思想和里面非常细节的地方。</p>
<ul>
<li><p>经验是把区间定义成为：左闭右闭区间，两个变量向中间走，定义的左右边界理应是无差别的，<strong>定义成左闭右开，反而增加了解决问题的的复杂程度</strong>，因为还要去考虑右边界是否能够取到，即使定义成左闭右开区间 <code>[left, right)</code> 也一定对应一个等价的左闭右闭区间 <code>[left, right - 1]</code>；</p>
<blockquote>
<p>友情提示：这里所说的二分查找的左闭右闭区间的具体定义如下：<strong>在区间 [left, right] 里可能存在目标元素</strong>，在二分搜索的过程中需要保持这个定义。而「滑动窗口」问题，习惯性定义成左闭右开 [left, right)，这是因为滑动窗口问题的特点是，右指针先向右移动，左指针再向右移动，右指针主动，左指针被动，因此地位是不一样的，滑动窗口问题定义成左闭右开的好处有 2 点。第一，初始化的时候 left &#x3D; 0 和 right &#x3D; 0 这是相对自然的，第二，滑动窗口的长度为 right - left 不用加 1。</p>
</blockquote>
</li>
<li><p>明确 <code>int = left + (right - left) / 2</code> 这里除以 2 是下取整（想一想上取整可以吗，什么时候需要上取整，为什么是除以 2 ，其它整数行不行）；</p>
</li>
<li><p>明确 <code>while(left &lt;= right)</code> 和 <code>while(left &lt; right)</code>这两种写法在思路上有本质差别，里面的逻辑该怎么写，应该做到彻底理解；</p>
</li>
<li><p>始终在思考下一轮搜索区间是什么，这一点对应上面所说的：「始终将区间认为是 <strong>左闭右闭</strong> 区间」，这样就能帮助我们搞清楚边界是不是能取到，等于、+1 、−1 之类的细节；</p>
</li>
<li><p>思考清楚每一行代码背后的语义是什么，保证语义上清晰，也是写对代码，减少 bug 的一个非常有效的方法；</p>
</li>
<li><p>不能忽视一个很重要的方法是 <strong>调试</strong>。它不是什么很高超的技巧，就是把变量的值打印出来看一下，相信就能解决为什么写出的代码会造成死循环的问题，并得出解决方案。</p>
</li>
</ul>
<p>写对二分查找算法是基于我们的思考，并且认真对待遇到的二分查找问题，<strong>通过挖掘单调性，使得问题规模不断缩小</strong> 。</p>
<h1 id="二分查找的三种题型"><a href="#二分查找的三种题型" class="headerlink" title="二分查找的三种题型"></a>二分查找的三种题型</h1><h2 id="在一个数组里查找一个数，简称为「二分下标」"><a href="#在一个数组里查找一个数，简称为「二分下标」" class="headerlink" title="在一个数组里查找一个数，简称为「二分下标」"></a>在一个数组里查找一个数，简称为「二分下标」</h2><p>一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。</p>
<h2 id="查找一个有范围的整数，简称为「二分答案」"><a href="#查找一个有范围的整数，简称为「二分答案」" class="headerlink" title="查找一个有范围的整数，简称为「二分答案」"></a>查找一个有范围的整数，简称为「二分答案」</h2><p>如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。</p>
<h2 id="复杂的二分查找问题，「最大值最小化」"><a href="#复杂的二分查找问题，「最大值最小化」" class="headerlink" title="复杂的二分查找问题，「最大值最小化」"></a>复杂的二分查找问题，「最大值最小化」</h2><p>通过一个变量与另一个变量的相关关系，进而确定目标变量的值，统称为「复杂问题」，通常这一类问题的判别函数需要遍历整个数组。</p>
<p>目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。这一类问题可以统称为「 <strong>最大值极小化</strong> 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题。</p>
<p>解题的思路是这样的：</p>
<ul>
<li>分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；</li>
<li>分析出<strong>单调性</strong>，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果；</li>
<li>这一类问题的题目条件一定会给出<strong>连续、正整数</strong>这样的关键字，如果没有，问题场景也一定蕴含了这两个关键信息。</li>
</ul>
<h1 id="题型一：在数组中查找符合条件的元素的下标"><a href="#题型一：在数组中查找符合条件的元素的下标" class="headerlink" title="题型一：在数组中查找符合条件的元素的下标"></a>题型一：在数组中查找符合条件的元素的下标</h1><h2 id="35-搜索插入位置-easy"><a href="#35-搜索插入位置-easy" class="headerlink" title="35. 搜索插入位置[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a>[easy]</h2><h3 id="解法一：暴力循环搜索"><a href="#解法一：暴力循环搜索" class="headerlink" title="解法一：暴力循环搜索"></a>解法一：暴力循环搜索</h3><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;=target)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>插入位置的下标是 <strong>大于等于</strong> <code>target</code> 的第 1 个元素的位置。因此，<strong>严格小于 <code>target</code> 的元素一定不是解</strong>，在循环体中将左右边界 <code>left</code> 和 <code>right</code> 逐渐向中间靠拢，最后 <code>left</code> 和 <code>right</code>相遇，则找到了插入元素的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 因为有可能数组的最后一个元素的位置的下一个是我们要找的，故右边界是 nums.size()</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 小于 target 的元素一定不是解</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索的区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是 [left, mid]</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(logN)，N 是数组的长度，每一次都将问题的规模缩减为原来的一半，因此时间复杂度是对数级别的。</li>
<li>空间复杂度：O(1)，使用到常数个临时变量。</li>
</ul>
<h2 id="704-二分查找-easy"><a href="#704-二分查找-easy" class="headerlink" title="704. 二分查找[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a>[easy]</h2><h3 id="解法：二分查找"><a href="#解法：二分查找" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><h4 id="while-left-lt-right-写法"><a href="#while-left-lt-right-写法" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束条件 left==right，此时 nums[left]还没看</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="while-left-lt-right-写法-1"><a href="#while-left-lt-right-写法-1" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束条件[right,left]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置-medium"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-medium" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a>[medium]</h2><h3 id="解法：二分查找-1"><a href="#解法：二分查找-1" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p><strong>查找 target 出现的第 1 个位置</strong></p>
<ul>
<li>如果当前看到的元素恰好等于<code>target</code>，那么当前元素有可能是 <code>target</code> 出现的第 1 个位置，因为我们要找第 1 个位置，此时应该向左边继续查找。</li>
<li>如果当前看到的元素严格大于<code>target</code>，那么当前元素一定不是要找的 <code>target</code> 出现的第 1 个位置，第 1 个位置肯定出现在 <code>mid</code> 的 <strong>左边</strong> ，因此就需要在 <code>[left, mid]</code>区间里继续查找。</li>
<li>如果当前看到的元素严格小于<code>target</code>，那么当前元素一定不是要找的<code>target</code>出现的第 1 个位置，第 1 个位置肯定出现在 <code>mid</code> 的 <strong>右边</strong> ，因此就需要在 <code>[mid + 1, right]</code>区间里继续查找。</li>
</ul>
<p><strong>查找 target 出现的最后 1 个位置</strong></p>
<p>与上述相似。</p>
<h4 id="while-left-lt-right-写法-2"><a href="#while-left-lt-right-写法-2" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> first=<span class="hljs-built_in">findFirstPosition</span>(nums,target);<br>        <span class="hljs-keyword">if</span>(first==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> last=<span class="hljs-built_in">findLastPosition</span>(nums,target);<br>        <span class="hljs-keyword">return</span> &#123;first,last&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirstPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                 <span class="hljs-comment">// 下一轮搜索区间是 [left, mid]</span><br>                right=mid;<br>            <span class="hljs-comment">// 小于一定不是解</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// nums[mid] &gt; target，下一轮搜索区间是 [left, mid - 1]</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断未搜索的元素</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLastPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 如果采用下取整会陷入死循环，因此采用上取整</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid, right]</span><br>                left=mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 下一轮搜索区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// nums[mid] &gt; target，下一轮搜索区间是 [left, mid - 1]</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 不用判断未搜索元素是因为主调函数中先搜索 first，如果 first 未找到则 last 不可能找到</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="while-left-lt-right-写法-3"><a href="#while-left-lt-right-写法-3" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> first=<span class="hljs-built_in">findFirstPosition</span>(nums,target);<br>         <span class="hljs-comment">// 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置</span><br>        <span class="hljs-keyword">if</span>(first==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> last=<span class="hljs-built_in">findLastPosition</span>(nums,target);<br>        <span class="hljs-keyword">return</span> &#123;first,last&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFirstPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// ①不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 此时 nums[mid] &gt; target，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置</span><br>        <span class="hljs-comment">// 因此还需要特别做一次判断</span><br>        <span class="hljs-keyword">if</span>(left!=nums.<span class="hljs-built_in">size</span>()&amp;&amp;nums[left]==target)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLastPosition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-comment">// 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;target)<br>                <span class="hljs-comment">// 应该继续向右边找，即 [mid + 1, right] 区间里找</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>   <br>                <span class="hljs-comment">// 此时 nums[mid] &gt; target，应该继续向左边找，即 [left, mid - 1] 区间里找</span><br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断</span><br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>寻找第 1 次出现的位置解释：</strong></p>
<p><code>nums[mid] == target</code> 的时候，在 <code>[left, mid - 1]</code> 区间里找，有没有可能 <code>nums[mid]</code> 就是第 1 次出现的位置，有可能，但不要紧，退出循环的时候 <code>right</code> 指针在左，<code>left</code> 在右。<strong>如果数组里存在 <code>target</code>，那么 <code>left</code> 一定位于 <code>target</code>出现的第 1 个位置</strong>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115555.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：</p>
<ul>
<li><p>target 很大，还是上面的例子</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115547.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>target 很小，还是上面的例子</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115541.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></li>
</ul>
<p>以上特殊例子，解释了为什么在 <code>while (left &lt;= right)</code> 退出循环以后，需要单独判断 <code>left</code> 是否越界，以及判断 <code>nums[left]</code>是不是目标元素的原因。</p>
<p><strong>寻找最后 1 次出现的位置解释：</strong></p>
<p>为什么返回 <code>right</code> 解释如下图：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913115530.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>这里注意：无需讨论不存在的情况。这是因为先执行了 <code>findFirstPosition()</code>方法，这个方法如果返回 -1，显然知道数组里不存在目标元素，可以直接返回 <code>[-1, -1]</code>。</p>
<h2 id="153-寻找旋转排序数组中的最小值-medium"><a href="#153-寻找旋转排序数组中的最小值-medium" class="headerlink" title="153. 寻找旋转排序数组中的最小值[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a>[medium]</h2><h3 id="解法一：暴力法遍历数组"><a href="#解法一：暴力法遍历数组" class="headerlink" title="解法一：暴力法遍历数组"></a>解法一：暴力法遍历数组</h3><p>遍历找最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num&lt;minNum)<br>                minNum=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过数组旋转后的特点找到最小值，即最小值比它前面的元素小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minNum=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(1)。</p>
<h3 id="解法二：二分查找-1"><a href="#解法二：二分查找-1" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>思路：看看当前搜索区间的 <strong>右边界</strong> 和「中间数」，是不是可以缩小搜索区间的范围。</p>
<ul>
<li><p>当中间数比右边界表示的数大的时候，中间数就一定不是目标数（旋转排序数组的最小值）。</p>
<p>例 ：<code>[7, 8, 9, 10, 11, 12, 1, 2, 3]</code></p>
<p>「中间数」 11 比右边界 3 大，因此中间数左边的数（包括中间数）都不是「旋转排序数组」的最小值，把左边界设置中间数位置 + 1，即 <code>left = mid + 1</code>。</p>
</li>
<li><p>当中间数比右边界表示的数小的时候，中间数就可能是目标数（旋转排序数组的最小值）。</p>
<p>例 ：<code>[7, 8, 1, 2, 3]</code></p>
<p>「中间数」 1 比右边界 3 小，说明，中间数到右边界是递增的，那么中间数右边的（不包括中间数）一定不是「旋转排序数组」的最小值，可以把它们排除，但中间数有可能是整个数组中的最小值，就如本例，因此把右边界设置为 <code>right = mid</code>。</p>
</li>
</ul>
<p>为什么比较  <code>mid</code> 和 <code>right</code> 查看 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">armeria</a> 题解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                <span class="hljs-comment">// 中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid </span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                <span class="hljs-comment">// 中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束，left == right</span><br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logn)，空间复杂度 O(1)。</p>
<h3 id="解法三：分治法"><a href="#解法三：分治法" class="headerlink" title="解法三：分治法"></a>解法三：分治法</h3><p>将原问题划分成若干与原问题同结构且规模更小的子问题，等到这些子问题解决了以后，原问题也得到了解决，思路基本与二分查找相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-comment">// 这一步是关键</span><br>        <span class="hljs-keyword">if</span>(nums[left]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>            <span class="hljs-comment">// 左边是顺序数组，[left + 1, mid] 这个区间里的元素可以不看</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            <span class="hljs-comment">// 右边是顺序数组，[mid + 1 , right] 这个区间里的元素可以不看</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,mid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logn)，空间复杂度 O(logn)。</p>
<h2 id="154-寻找旋转排序数组中的最小值-II-hard"><a href="#154-寻找旋转排序数组中的最小值-II-hard" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a>[hard]</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 的延伸题目，数组中可能存在重复的元素。</p>
<h3 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h3><p>和 153 题思路一样，还是比较中间数和右边界，与 153 题相比，多了一种可能性。</p>
<ul>
<li><p>当中间数与右边界表示的数相等的时候：</p>
<p>例 1：<code>[0, 1, 1, 1, 1, 1, 1]</code>，例2 ：<code>[1, 1, 1, 1, 0, 1, 1]</code></p>
<p>目标值可能在中间数的左边，也可能在中间数的右边，那么该怎么办呢？很简单，此时看到的是右边界，就只把右边界排除掉就好了。正是因为右边界和中间数相等，去掉了右边界，中间数还在，就让中间数在后面的循环中被发现。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                right=mid;<br>            <span class="hljs-keyword">else</span> <br>                right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logn)，空间复杂度 O(1)。</p>
<h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件，区间里只有 1 个元素的时候，返回这个元素</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-keyword">if</span>(nums[left]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> nums[left];<br>        <span class="hljs-comment">// 分治：设置分治的界限</span><br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,mid);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(nums,left,right<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logn)，空间复杂度 O(logn)。</p>
<h2 id="33-搜索旋转排序数组-medium"><a href="#33-搜索旋转排序数组-medium" class="headerlink" title="33. 搜索旋转排序数组[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a>[medium]</h2><h3 id="解法一：将-「旋转数组查找目标值」-转化成-「有序数组查找目标值」"><a href="#解法一：将-「旋转数组查找目标值」-转化成-「有序数组查找目标值」" class="headerlink" title="解法一：将 「旋转数组查找目标值」 转化成 「有序数组查找目标值」"></a>解法一：将 「旋转数组查找目标值」 转化成 「有序数组查找目标值」</h3><ul>
<li>使用 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 的方法找出最小值的索引，将数组分成两个有序数组。</li>
<li>根据 <code>nums[0]</code> 与 <code>target</code> 的关系判断 <code>target</code> 在左段还是右段，再对升序数组进行二分查找。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-built_in">findMin</span>(nums,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(minIndex==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>,target);<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;target)<br>            <span class="hljs-comment">// 目标值在右段</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,minIndex,length<span class="hljs-number">-1</span>,target);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 目标值在左段</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,minIndex<span class="hljs-number">-1</span>,target);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 153.寻找旋转排序数组中的最小值 稍作修改，改成返回最小值索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[right])<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 有序数组查找目标值（704. 二分查找）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：直接对旋转数组进行二分查找"><a href="#解法二：直接对旋转数组进行二分查找" class="headerlink" title="解法二：直接对旋转数组进行二分查找"></a>解法二：直接对旋转数组进行二分查找</h3><p>将待搜索区间从中间一分为二，**<code>mid</code> 一定会落在其中一个有序区间里**。即中间元素把待搜索区间分成了两部分，两部分具有的性质是至少有一部分是有序的。</p>
<h4 id="while-left-lt-right-写法-4"><a href="#while-left-lt-right-写法-4" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><h5 id="讨论中间元素和右边界的关系"><a href="#讨论中间元素和右边界的关系" class="headerlink" title="讨论中间元素和右边界的关系"></a>讨论中间元素和右边界的关系</h5><p>因为不存在重复元素，所以它们的关系不是大于就是小于。</p>
<ol>
<li><p>情况 1：<code>nums[mid] &lt; nums[right]</code>，当中间元素的数值严格小于右边界的数值时候</p>
<ul>
<li><p>此时区间 <code>[mid, right]</code> 一定是有序的。</p>
</li>
<li><p><code>target</code> 要么在有序区间 <code>[mid, right]</code> 里，要么在另一个区间 <code>[left, mid - 1]</code> 里。</p>
<ul>
<li><code>target</code> 落在有序区间 <code>[mid, right]</code>，即：<code>nums[mid] &lt;= target &lt;= nums[right]</code>，此时设置 <code>left = mid</code>；</li>
<li>落在另一个区间 <code>[left, mid - 1]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>right = mid - 1</code>。</li>
</ul>
<p><strong>关键</strong>：把比较好些的判断（<code>target</code> 落在有序的那部分）放在 <code>if</code> 的开头考虑，把剩下的情况放在 <code>else</code> 里面。</p>
</li>
</ul>
</li>
<li><p>情况 2：<code>nums[mid] &gt; nums[right]</code>，当中间元素的数值严格大于右边界的数值时候</p>
<ul>
<li>此时区间 <code>[left, mid]</code> 内的元素一定是有序的。</li>
<li><code>target</code> 要么在有序区间 <code>[left, mid]</code> 里，要么在另一个区间 <code>[mid + 1, right]</code> 里。</li>
<li><code>target</code>落在有序区间 <code>[left, mid]</code> ，即：<code>nums[left] &lt;= target &lt;= nums[mid]</code>，此时设置 <code>right = mid</code>；</li>
<li>落在另一个区间 <code>[mid + 1, right]</code> 里的时候，就是上一个情况的反面，这种情况用 <code>else</code> 表示即可，此时设置 <code>left = mid + 1</code>。</li>
</ul>
</li>
<li><p>此时发现：情况 1 分支左右边界的收缩情况是：<code>left = mid</code> 与 <code>right = mid - 1</code>，情况 2 分支左右边的收缩情况是：<code>left = mid + 1</code> 与 <code>right = mid</code>，为了让二者一致，在情况 1 里强行只认为 <code>[mid+1, right]</code> 有序。这样左右边界的收缩情况就和情况 2 一样了。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 右半部分有序</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 后处理，有可能区间内不存在目标元素，因此还需做一次判断</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="讨论中间元素和左边界的关系"><a href="#讨论中间元素和左边界的关系" class="headerlink" title="讨论中间元素和左边界的关系"></a>讨论中间元素和左边界的关系</h5><p>与上述讨论思路相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 左半部分有序</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 右半部分有序</span><br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 后处理</span><br>        <span class="hljs-keyword">if</span>(nums[left]!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="while-left-lt-right-写法-5"><a href="#while-left-lt-right-写法-5" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><p>这种写法可以避免收缩情况不统一。</p>
<h5 id="讨论中间元素和左边界的关系-1"><a href="#讨论中间元素和左边界的关系-1" class="headerlink" title="讨论中间元素和左边界的关系"></a>讨论中间元素和左边界的关系</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-comment">// 这里是 &gt;= 而不是 &gt; 是为了最后只剩下两个数的时候，则么和逻辑匹配</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;=nums[left])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="讨论中间元素和右边界的关系-1"><a href="#讨论中间元素和右边界的关系-1" class="headerlink" title="讨论中间元素和右边界的关系"></a>讨论中间元素和右边界的关系</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-comment">// 这里是 &lt;</span><br>            <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[right])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(target&gt;=nums[left]&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="81-搜索旋转排序数组-II-medium"><a href="#81-搜索旋转排序数组-II-medium" class="headerlink" title="81. 搜索旋转排序数组 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a>[medium]</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 的延伸题目，数组中可能存在重复的元素。</p>
<h3 id="解法：二分查找-2"><a href="#解法：二分查找-2" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>和 33 题思路一样，还是讨论中间元素和左边界（或者有边界）的关系，只不过当中间元素等于边界的情况下，无法判断有序性，仅可排除掉边界，与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a> 思想一致。</p>
<h4 id="while-left-lt-right-写法-6"><a href="#while-left-lt-right-写法-6" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><p>这里仅讨论中间元素和左边界关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">// 落在前有序数组里</span><br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;=nums[mid])<br>                    right=mid;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&lt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">// 让分支和上面分支一样</span><br>                <span class="hljs-keyword">if</span>(nums[mid+<span class="hljs-number">1</span>]&lt;=target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 要排除掉左边界之前，先看一看左边界可以不可以排除</span><br>                <span class="hljs-keyword">if</span>(nums[left]==target)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span><br>                    left++;<br>            &#125;              <br>        &#125;<br>        <span class="hljs-comment">// 后处理</span><br>        <span class="hljs-keyword">if</span>(nums[left]==target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="while-left-lt-right-写法-7"><a href="#while-left-lt-right-写法-7" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><p>这里仅讨论中间元素和左边界关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==nums[left])<br>                left++;<br>            <span class="hljs-comment">//前半部分有序</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[left])<br>            &#123;<br>                <span class="hljs-comment">//target在前半部分</span><br>                <span class="hljs-keyword">if</span>(nums[left]&lt;=target&amp;&amp;target&lt;nums[mid])<br>                    right=mid<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span><br>                    left=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//后半部分有序</span><br>                <span class="hljs-comment">//target在后半部分</span><br>                <span class="hljs-keyword">if</span>(nums[mid]&lt;target&amp;&amp;target&lt;=nums[right])<br>                    left=mid+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    right=mid<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="162-寻找峰值-medium"><a href="#162-寻找峰值-medium" class="headerlink" title="162. 寻找峰值[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a>[medium]</h2><h3 id="解法：二分查找-3"><a href="#解法：二分查找-3" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><blockquote>
<p>寻找局部极大极小值问题。</p>
</blockquote>
<p>在题目描述中出现了 <code>nums[-1] = nums[n] = -∞</code>，这就代表着 <strong>只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值</strong>。比较 <code>nums[m]</code> 与  <code>nums[m+1]</code> 的值，如果 <code>nums[m]</code> 较大，则左侧存在峰值，<code>right=mid</code> ，如果 <code>nums[m+1]</code>  较大，则右侧存在峰值，<code>left=mid+1</code> 。</p>
<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,left,mid);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(nums,mid+<span class="hljs-number">1</span>,right); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(logN)。</p>
<h4 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]&gt;nums[mid+<span class="hljs-number">1</span>])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
<h2 id="852-山脉数组的峰顶索引-easy"><a href="#852-山脉数组的峰顶索引-easy" class="headerlink" title="852. 山脉数组的峰顶索引[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/">852. 山脉数组的峰顶索引</a>[easy]</h2><h3 id="解法：二分查找-4"><a href="#解法：二分查找-4" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-peak-element/">162. 寻找峰值</a> 思路相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=arr.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(arr[mid]&gt;arr[mid+<span class="hljs-number">1</span>])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1095-山脉数组中查找目标值-hard"><a href="#1095-山脉数组中查找目标值-hard" class="headerlink" title="1095. 山脉数组中查找目标值[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-in-mountain-array/">1095. 山脉数组中查找目标值</a>[hard]</h2><h3 id="解法：二分查找-5"><a href="#解法：二分查找-5" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><p>“山脉数组”可以分为两部分，一部分是前升序数组 ，另一部分是后降序数组。因此可以分为 3 步：</p>
<ol>
<li>找到山顶元素 <code>mountaintop</code> 所在的索引；</li>
<li>在前有序且升序数组中找 <code>target</code> 所在的索引，如果找到了，就返回，如果没有找到，就执行第 3 步；</li>
<li>如果步骤 2 找不到，就在后有序且降序数组中找 <code>target</code> 所在的索引。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the MountainArray&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * class MountainArray &#123;</span><br><span class="hljs-comment"> *   public:</span><br><span class="hljs-comment"> *     int get(int index);</span><br><span class="hljs-comment"> *     int length();</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findInMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span> target, MountainArray &amp;mountainArr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=mountainArr.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> mountaintop=<span class="hljs-built_in">findMountainTop</span>(mountainArr,<span class="hljs-number">0</span>,length<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> res=<span class="hljs-built_in">findFromFrontSortedArr</span>(mountainArr,<span class="hljs-number">0</span>,mountaintop,target);<br>        <span class="hljs-keyword">if</span>(res!=<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFromBackSortedArr</span>(mountainArr,mountaintop<br>        +<span class="hljs-number">1</span>,length<span class="hljs-number">-1</span>,target);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 返回山顶元素（162. 寻找峰值）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMountainTop</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;mountainArr.<span class="hljs-built_in">get</span>(mid+<span class="hljs-number">1</span>))<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 在前有序且升序数组中找 target 所在的索引（704. 二分查找）</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFromFrontSortedArr</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 后处理：因为不确定区间收缩成 1个数以后，这个数是不是要找的数，因此单独做一次判断</span><br>        <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(left)!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-comment">// 在后有序且降序数组中找 target 所在的索引</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFromBackSortedArr</span><span class="hljs-params">(MountainArray &amp;mountainArr,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)==target)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(mid)&gt;target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <br>                right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(mountainArr.<span class="hljs-built_in">get</span>(left)!=target)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4. 寻找两个正序数组的中位数[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a>[hard]</h2><h3 id="解法一：合并数组"><a href="#解法一：合并数组" class="headerlink" title="解法一：合并数组"></a>解法一：合并数组</h3><p>先将两个有序数组合并，然后根据数组长度是奇数还是偶数，返回中位数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> length2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(length1+length2)</span></span>;<br>        <span class="hljs-comment">// 合并两个有序数组</span><br>        <span class="hljs-type">int</span> p1=<span class="hljs-number">0</span>,p2=<span class="hljs-number">0</span>,p=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;length1&amp;&amp;p2&lt;length2)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums1[p1]&lt;=nums2[p2])<br>                nums[p++]=nums1[p1++];<br>            <span class="hljs-keyword">else</span><br>                nums[p++]=nums2[p2++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p1&lt;length1)<br>            nums[p++]=nums1[p1++];<br>        <span class="hljs-keyword">while</span>(p2&lt;length2)<br>            nums[p++]=nums2[p2++];<br>        <span class="hljs-comment">// 返回中位数</span><br>        <span class="hljs-type">int</span> length=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(length%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (nums[length/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+nums[length/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> nums[length/<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(m+n)，空间复杂度 O(m+n)。</p>
<h3 id="解法二：直接取中位数"><a href="#解法二：直接取中位数" class="headerlink" title="解法二：直接取中位数"></a>解法二：直接取中位数</h3><p>不需要将两个数组真的合并，只需要找到中位数在哪里。</p>
<p>首先是怎么将奇数和偶数的情况合并一下。用 <code>len</code> 表示合并后数组的长度，如果是奇数，需要知道第 <code>(len+1)/2</code>个数就可以了，如果遍历的话需要遍历 <code>len/2+1</code> 次。如果是偶数，需要知道第 <code>len/2</code>和 <code>len/2+1</code> 个数，也是需要遍历 <code>len/2+1</code> 次。所以遍历的话，奇数和偶数都是 <code>len/2+1</code> 次。</p>
<p>返回中位数的话，奇数需要最后一次遍历的结果就可以了，偶数需要最后一次和上一次遍历的结果。所以用两个变量 <code>left</code> 和 <code>right</code>， <code>right</code>保存当前循环的结果，在每次循环前将 <code>right</code>的值赋给 <code>left</code> 。这样在最后一次循环的时候， <code>left</code> 将得到 <code>right</code>的值，也就是上一次循环的结果，接下来 <code>right</code>更新为最后一次的结果。</p>
<p>循环中该怎么写，什么时候 <code>A</code> 数组后移，什么时候 <code>B</code> 数组后移。用 <code>aStart</code> 和 <code>bStart</code> 分别表示当前指向 <code>A</code> 数组和 <code>B</code> 数组的位置。如果 <code>aStart</code> 还没有到最后并且此时 <code>A</code> 位置的数字小于<code>B</code>位置的数组，那么就可以后移了。也就是<code>aStart&lt;len1&amp;&amp;A[aStart]&lt;=B[bStart]</code>。但如果 <code>B</code> 数组此刻已经没有数字了，继续取数字 <code>B[bStart]</code>，则会越界，所以判断下 <code>bStart</code> 是否大于数组长度了，这样 <code>||</code>后边的就不会执行了，也就不会导致错误了，所以增加为 <code>aStart&lt;len1&amp;&amp;(bStart&gt;=len2||A[aStart]&lt;=B[bStart]) </code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len=len1+len2;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> aStart=<span class="hljs-number">0</span>,bStart=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len/<span class="hljs-number">2</span>;++i)<br>        &#123;<br>            left=right;<br>            <span class="hljs-keyword">if</span>(aStart&lt;len1&amp;&amp;(bStart&gt;=len2||nums1[aStart]&lt;=nums2[bStart]))<br>                right=nums1[aStart++];<br>            <span class="hljs-keyword">else</span><br>                right=nums2[bStart++];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(len%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> (left+right)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(m+n)，空间复杂度 O(1)。</p>
<h3 id="解法三：查找第-K-小的数"><a href="#解法三：查找第-K-小的数" class="headerlink" title="解法三：查找第 K 小的数"></a>解法三：查找第 K 小的数</h3><p>上面的思路无法达到时间复杂度要求，看到 <code>log</code>需要使用二分才能达到，这里先用另一种思路，题目求中位数其实是求第 <code>k</code> 小数的一种特殊情况，而求第 <code>k</code>小数有一种算法。</p>
<p>解法二中，一次遍历就相当于去掉不可能是中位数的一个值，也就是一个一个排除。由于数列是有序的，完全可以一半儿一半儿的排除。假设要找第 <code>k</code> 小数，可以每次循环排除掉<code>k/2</code>个数。看下边一个例子。</p>
<p>假设要找第 7 小的数字。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918144041.png" srcset="/img/loading.gif" lazyload></p>
<p>比较两个数组的第<code>k/2</code>个数字，如果<code>k</code>是奇数，向下取整。也就是比较第 3 个数字，上边数组中的 4 和下边数组中的 3，如果哪个小，就表明该数组的前<code>k/2</code>个数字都不是第<code>k</code>小数字，所以可以排除。也就是 1,2,3 这三个数字不可能是第 7 小的数字，可以把它排除掉。将 1,3,4,9 和 4,5,6,7,8,9,10 两个数组作为新的数组进行比较。</p>
<p>更一般的情况 <code>A[1]</code> ，<code>A[2]</code> ，<code>A[3]</code>，<code>A[k/2]</code> … ，<code>B[1]</code>，<code>B[2]</code>，<code>B[3]</code>，<code>B[k/2]</code> … ，如果 <code>A[k/2]</code>&lt;<code>B[k/2]</code>，那么<code>A[1]</code>，<code>A[2]</code>，<code>A[3]</code>，<code>A[k/2]</code>都不可能是第<code>k</code>小的数字。<code>A</code> 数组中比 <code>A[k/2]</code> 小的数有 <code>k/2-1</code> 个，<code>B</code> 数组中，比<code>B[k/2]</code> 小的数有 <code>k/2-1</code> 个，现在<code>A[k/2]</code>&lt;<code>B[k/2]</code>，假设<code>B[k/2]</code> 前边的数字都比<code>A[k/2]</code> 小，也只有<code>k/2-1+k/2-1=k-2</code> 个，所以 <code>B[k/2]</code>  最多是第<code>k-1</code>小的数。而比 <code>A[k/2]</code> 小的数更不可能是第<code>k</code>小的数了，所以可以把它们排除。</p>
<p>橙色的部分表示已经去掉的数字。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145512.png" srcset="/img/loading.gif" lazyload></p>
<p>由于已经排除掉了 3 个数字，就是这 3 个数字一定在最前边，所以在两个新数组中，只需要找第 7 - 3 &#x3D; 4 小的数字就可以了，也就是 k &#x3D; 4。此时两个数组，比较第 2 个数字，3 &lt; 5，所以可以把小的那个数组中的 1,3 排除掉了。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145603.png" srcset="/img/loading.gif" lazyload></p>
<p>由于又排除掉 2 个数字，所以现在找第 4 - 2 &#x3D; 2 小的数字就可以了。此时比较两个数组中的第 k &#x2F; 2 &#x3D; 1 个数，4 &#x3D;&#x3D; 4，怎么办呢？由于两个数相等，所以无论去掉哪个数组中的都行，因为去掉 1 个总会保留 1 个的，所以没有影响。为了统一，假设 4 &gt; 4 吧，所以此时将下边的 4 去掉。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200918145708.png" srcset="/img/loading.gif" lazyload></p>
<p>由于又去掉 1 个数字，此时要找第 1 小的数字，所以只需判断两个数组中第一个数字哪个小就可以了，也就是 4。</p>
<p>所以第 7 小的数字是 4。</p>
<p>每次都是取<code>k/2</code>的数进行比较，有时候可能会遇到数组长度小于<code>k/2</code>的时候。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111608.png" srcset="/img/loading.gif" lazyload></p>
<p>此时 k &#x2F; 2 等于 3，而上边的数组长度是 2，此时将箭头指向它的末尾就可以了。这样的话，由于 2 &lt; 3，所以就会导致上边的数组 1，2 都被排除。造成下边的情况。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111602.png" srcset="/img/loading.gif" lazyload></p>
<p>由于 2 个元素被排除，所以此时 k &#x3D; 5，又由于上边的数组已经空了，只需要返回下边的数组的第 5 个数字就可以了。</p>
<p>从上边可以看到，无论是找第奇数个还是第偶数个数字，对算法并没有影响，而且在算法进行中，<code>k</code>的值都有可能从奇数变为偶数，最终都会变为 1 或者由于一个数组空了，直接返回结果。</p>
<p>所以采用递归的思路，为了防止数组长度小于<code>k/2</code>，所以每次比较<code>min(k/2,len(数组))</code>对应的数字，把小的那个对应的数组的数字排除，将两个新数组进入递归，并且<code>k</code>要减去排除的数字的个数。递归出口就是当 <code>k=1</code> 或者其中一个数字长度是 <code>0</code> 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len2=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=(len1+len2+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> right=(len1+len2+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">getKth</span>(nums1,<span class="hljs-number">0</span>,len1<span class="hljs-number">-1</span>,nums2,<span class="hljs-number">0</span>,len2<span class="hljs-number">-1</span>,left)+<span class="hljs-built_in">getKth</span>(nums1,<span class="hljs-number">0</span>,len1<span class="hljs-number">-1</span>,nums2,<span class="hljs-number">0</span>,len2<span class="hljs-number">-1</span>,right))/<span class="hljs-number">2.0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getKth</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1,<span class="hljs-type">int</span> start1,<span class="hljs-type">int</span> end1,vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2,<span class="hljs-type">int</span> start2,<span class="hljs-type">int</span> end2,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len1=end1-start1+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> len2=end2-start2+<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span><br>        <span class="hljs-keyword">if</span>(len1&gt;len2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums2,start2,end2,nums1,start1,end1,k);<br>        <span class="hljs-comment">// 两种 base case</span><br>        <span class="hljs-keyword">if</span>(len1==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> nums2[start2+k<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[start1],nums2[start2]);<br>        <span class="hljs-type">int</span> i=start1+<span class="hljs-built_in">min</span>(len1,k/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j=start2+<span class="hljs-built_in">min</span>(len2,k/<span class="hljs-number">2</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(nums1[i]&lt;nums2[j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums1,i+<span class="hljs-number">1</span>,end1,nums2,start2,end2,k-(i-start1+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getKth</span>(nums1,start1,end1,nums2,j+<span class="hljs-number">1</span>,end2,k-(j-start2+<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：每进行一次循环，就减少 k&#x2F;2 个元素，所以时间复杂度是 O(log(k)，而 k&#x3D;(m+n)&#x2F;2，所以最终的复杂是 O(log(m+n)。</li>
<li>空间复杂度：虽然用到了递归，但是可以看到这个递归属于尾递归，所以编译器不需要不停地堆栈，所以空间复杂度为 O(1)。</li>
</ul>
<h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><blockquote>
<p>中位数（中值），代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。</p>
</blockquote>
<p>所以只需要对数组进行切分。</p>
<p>一个长度为 m 的数组，有 0 到 m 总共 m + 1 个位置可以切。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111554.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>把数组 A 和数组 B 分别在 i 和 j 进行切割。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111547.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>将 i 的左边和 j 的左边组合成「左半部分」，将 i 的右边和 j 的右边组合成「右半部分」。</p>
<ul>
<li><p>当 A 数组和 B 数组的总长度是偶数时，如果能够保证</p>
<ul>
<li><p>左半部分的长度等于右半部分</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">i + j = m - i  + <span class="hljs-built_in">n</span> - j  , 也就是 j = ( m + <span class="hljs-built_in">n</span> ) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure>
</li>
<li><p>左半部分最大的值小于等于右半部分最小的值 </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">max ( A<span class="hljs-comment">[i-1]</span> , B<span class="hljs-comment">[j-1]</span> ) &lt;= min ( A<span class="hljs-comment">[i]</span> , B<span class="hljs-comment">[j]</span> )<br></code></pre></td></tr></table></figure></li>
</ul>
<p>那么，中位数就可以表示如下:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">(左半部分最大值 + 右半部分最小值)/ <span class="hljs-number">2</span>。<br>( max (<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i-1]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j-1]</span>) + min (<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j]</span>) ) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>当 A 数组和 B 数组的总长度是奇数时，如果能够保证</p>
<ul>
<li><p>左半部分的长度比右半部分大 1</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i</span> + j = m - i  + n - j  + <span class="hljs-number">1</span> , 也就是 j = ( m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure>
</li>
<li><p>左半部分最大的值小于等于右半部分最小的值 </p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">max ( A<span class="hljs-comment">[i-1]</span> , B<span class="hljs-comment">[j-1]</span> ) &lt;= min ( A<span class="hljs-comment">[i]</span> , B<span class="hljs-comment">[j]</span> )<br></code></pre></td></tr></table></figure></li>
</ul>
<p>那么，中位数就是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">左半部分最大值，也就是左半部比右半部分多出的那一个数。<br>max ( <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[i-1]</span> , <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[j-1]</span> )<br></code></pre></td></tr></table></figure></li>
</ul>
<p>上边的第一个条件可以合并为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">j</span> = ( m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i<br></code></pre></td></tr></table></figure>

<p>因为如果 m+n 是偶数，由于取的是 int 值，所以加 1 也不会影响结果。当然，由于 0&lt;&#x3D;i&lt;&#x3D;m ，为了保证 0&lt;&#x3D;j&lt;&#x3D;n，必须保证 m&lt;&#x3D;n。<br>$$<br>m≤n,i&lt;m,j&#x3D;(m+n+1)&#x2F;2−i≥(m+m+1)&#x2F;2−i&gt;(m+m+1)&#x2F;2−m&#x3D;0<br>$$</p>
<p>$$<br>m≤n,i&gt;0,j&#x3D;(m+n+1)&#x2F;2−i≤(n+n+1)&#x2F;2−i&lt;(n+n+1)&#x2F;2&#x3D;n<br>$$</p>
<p>最后一步由于是 int 间的运算，所以 1&#x2F;2&#x3D;0。</p>
<p>对于第二个条件，奇数和偶数的情况是一样的，进一步分析。为了保证 <code>max(A[i-1],B[j-1]) &lt;= min(A[i],B[j])</code>，因为 A 数组和 B 数组是有序的，所以 <code>A[i-1] &lt;= A[i], B[i-1] &lt;= B[i]</code> 这是天然的，所以只需要保证 <code>B[j-1] &lt;= A[i] 和 A[i-1] &lt;= B[j]</code> ，分两种情况讨论：</p>
<ul>
<li><p><code>B[j-1] &gt; A[i]</code>，并且为了不越界，要保证 <code> j != 0 , i != m</code></p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111538.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>此时需要增加 <code>i</code> ，为了数量的平衡还要减少 <code>j</code> ，幸运的是 <code>j = ( m + n + 1) / 2 - i</code>，<code>i</code>增大，<code>j</code> 自然会减少。</p>
</li>
<li><p><code>A[i-1] &gt; B[j]</code> ，并且为了不越界，要保证 <code>i != 0 , j != n</code></p>
<p>此时和上边的情况相反，需要减少 <code>i</code> ，增大<code>j</code> 。</p>
</li>
<li><p>当 <code>i=0</code> , 或者<code>j=0</code>，也就是切在了最前边</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111529.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>此时左半部分当 <code>i=0</code> 时 最大的值就是 <code>B[j-1]</code>；当 <code>j=0</code> 时，最大的值就是 <code>A[i-1]</code> 。右半部分最小值和之前一样。</p>
</li>
<li><p>当 <code>i=m</code> 或者 <code>j=n</code>，也就是切在了最后边。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111520.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>此时左半部分最大值和之前一样。右半部分当<code>i=m</code>时，最小值就是 <code>B[j]</code>；当<code>j=n</code>时，最小值就是 <code>A[i]</code>。</p>
</li>
</ul>
<p>所有的思路都理清了，最后一个问题，增加<code>i</code>的方式。当然用二分了。初始化<code>i</code>为中间的值，然后减半找中间的，减半找中间的，减半找中间的直到答案。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 保证 m &lt;= n</span><br>        <span class="hljs-keyword">if</span>(m&gt;n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2,nums1);<br>        <span class="hljs-type">int</span> iMin=<span class="hljs-number">0</span>,iMax=m;<br>        <span class="hljs-keyword">while</span>(iMin&lt;=iMax)<br>        &#123;<br>            <span class="hljs-type">int</span> i=iMin+(iMax-iMin)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> j=(m+n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>-i;<br>            <span class="hljs-keyword">if</span>(j!=<span class="hljs-number">0</span>&amp;&amp;i!=m&amp;&amp;nums2[j<span class="hljs-number">-1</span>]&gt;nums1[i])<br>                <span class="hljs-comment">// i 需要增大</span><br>                iMin=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>&amp;&amp;j!=n&amp;&amp;nums1[i<span class="hljs-number">-1</span>]&gt;nums2[j])<br>                <span class="hljs-comment">// i 需要减小</span><br>                iMax=i<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// 达到要求，并且将边界条件列出来单独考虑</span><br>                <span class="hljs-type">int</span> maxLeft=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)<br>                    maxLeft=nums2[j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    maxLeft=nums1[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">else</span><br>                    maxLeft=<span class="hljs-built_in">max</span>(nums1[i<span class="hljs-number">-1</span>],nums2[j<span class="hljs-number">-1</span>]);<br>                <span class="hljs-keyword">if</span>((m+n)%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-comment">// 奇数的话不需要考虑右半部分</span><br>                    <span class="hljs-keyword">return</span> maxLeft;<br>                <span class="hljs-type">int</span> minRight=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(i==m)<br>                    minRight=nums2[j];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j==n)<br>                    minRight=nums1[i];<br>                <span class="hljs-keyword">else</span><br>                    minRight=<span class="hljs-built_in">min</span>(nums1[i],nums2[j]);<br>                <span class="hljs-comment">//如果是偶数的话返回结果</span><br>                <span class="hljs-keyword">return</span> (maxLeft+minRight)/<span class="hljs-number">2.0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：对较短的数组进行了二分查找，时间复杂度是 O(log(min(m,n))。</li>
<li>空间复杂度：只有一些固定的变量，和数组长度无关，所以空间复杂度是 O(1)。</li>
</ul>
<h2 id="658-找到-K-个最接近的元素-medium"><a href="#658-找到-K-个最接近的元素-medium" class="headerlink" title="658. 找到 K 个最接近的元素[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a>[medium]</h2><h3 id="解法一：排除法（双指针）"><a href="#解法一：排除法（双指针）" class="headerlink" title="解法一：排除法（双指针）"></a>解法一：排除法（双指针）</h3><p>使用排除法删去元素，因为是有序数组，且返回的是连续升序子数组，所以每一次删除的元素一定是位于边界，可以使用双指针对撞的方式确定保留区间，即「最优区间」。</p>
<p>将 <code>x-arr[left]</code> 与 <code>arr[right]-x</code> 进行比较：</p>
<ul>
<li>如果 <code>x-arr[left]</code> 比较小，则将右边界删除，即 <code>right--</code>；</li>
<li>如果两者相等，因为优先选择数值较小的数，所以将右边界删除，<code>right--</code>；</li>
<li>如果 <code>arr[right]-x</code> 比较小，则将左边界删除，即 <code>left++</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findClosestElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=length<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> removeNums=length-k;<br>        <span class="hljs-keyword">while</span>(removeNums--&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x-arr[left]&lt;=arr[right]-x)<br>                right--;<br>            <span class="hljs-keyword">else</span><br>                left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>()+left,arr.<span class="hljs-built_in">begin</span>()+left+k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(N)，空间复杂度 O(1)。</p>
<h3 id="解法二：二分查找最优区间的左边界"><a href="#解法二：二分查找最优区间的左边界" class="headerlink" title="解法二：二分查找最优区间的左边界"></a>解法二：二分查找最优区间的左边界</h3><p>「最优区间的左边界」的下标的搜索区间为 <code>[0, size - k]</code>，从这个区间的任意一个位置（二分法为当前候选区间的中位数）开始，定位一个长度为 <code>(k + 1)</code> 的区间，根据这个区间是否包含 <code>x</code> 开展讨论。<code>left </code>、<code>right </code>是候选区间的左右边界的下标，根据上面的分析，初始时，<code>left = 0</code>，<code>right = size - k</code>。</p>
<p><strong>情况 1</strong>：如果区间不包含 <code>x</code>：</p>
<ul>
<li><p>区间的右端点在 <code>x</code>的左边，即 <code>x</code> 比 <code>arr</code>中最大的元素还要大，由于要去掉 1 个元素，显然去掉左端点，因此「最优区间的左边界」的下标至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>，<strong>因为区间不可能再往左边走了</strong>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111427.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>说明：极端情况是此时中位数位于索引 <code>size - k</code>，区间不能右移。</p>
</li>
<li><p>区间的左端点在 <code>x</code> 的左边，即 <code>x</code> 比 <code>arr</code> 中最小的元素还要小，当前的区间左端点的下标至多是 <code>mid</code>，此时 <code>right = mid</code>，<strong>因为区间不可能再往右偏了</strong>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111421.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>说明：极端情况是此时 <code>mid</code> 位于索引 <code>0</code>，区间不能左移。</p>
</li>
</ul>
<p><strong>情况 2</strong>：如果区间包含 <code>x</code>，尝试删掉一个元素，以便让区间发生移动，缩小搜索范围：</p>
<p>易知，需要比较长度为 <code>k + 1</code> 的区间的左右端点的数值与 <code>x</code> 的差值的绝对值。此时这个区间的左边界的下标是 <code>mid</code>，右边界的下标是 <code>mid + k</code>。根据解法一（排除法）的结论，分类讨论如下：</p>
<ul>
<li><p>如果右边界与 <code>x</code> 的差值的绝对值较小，左边界收缩，可以肯定的是「最优区间的左边界」的下标 <code>left</code> 至少是 <code>mid + 1</code>，即 <code>left = mid + 1</code>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111416.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>说明：「右边界与 <code>x</code> 的差值绝对值较小」同样适用于「情况 1.1」，因此它们二者可以合并。</p>
</li>
<li><p>如果左边界与 <code>x</code> 的差值的绝对值较小，右边界收缩，此时区间不移动，注意：此时有可能收缩以后的区间就是待求的区间，也有可能整个区间向左移动，这件事情叫做，<code>right = mid</code>，不能排除 <code>mid</code>（下一轮搜索区间是 <code>[left, mid]</code>）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111507.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>说明 1：这一点比较难想，但实际上也可以不想，根据「情况 2.1」的结论，左区间收缩的反面即是右区间不收缩，因此，这一分支的逻辑一定是 <code>right = mid</code>。</p>
<p>说明 2：「左边界与 <code>x</code> 的差的绝对值较小」同样适用于 「情况 1.2」，因此它们二者可以合并。</p>
</li>
<li><p>如果左、右边界与 <code>x</code> 的差的绝对值相等，删除右边界，结论同「情况 2.2」，也有 <code>right = mid</code>，可以合并到 「情况 2.2」。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findClosestElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=length-k;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 尝试从长度为 k + 1 的连续子区间删除一个元素，从而定位左区间端点的边界值</span><br>            <span class="hljs-keyword">if</span>(x-arr[mid]&gt;arr[mid+k]-x)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(arr.<span class="hljs-built_in">begin</span>()+left,arr.<span class="hljs-built_in">begin</span>()+left+k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(log N + K)，空间复杂度 O(1)。</p>
<h2 id="744-寻找比目标字母大的最小字母-easy"><a href="#744-寻找比目标字母大的最小字母-easy" class="headerlink" title="744. 寻找比目标字母大的最小字母[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a>[easy]</h2><h3 id="解法一：线性扫描"><a href="#解法一：线性扫描" class="headerlink" title="解法一：线性扫描"></a>解法一：线性扫描</h3><p>由于 <code>letters</code> 已经有序，当从左往右扫描找到比目标字母大则该字母就是答案。否则(<code>letters</code> 不为空)答案将是 <code>letters[0]</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, <span class="hljs-type">char</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter:letters)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(letter&gt;target)<br>                <span class="hljs-keyword">return</span> letter;<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(1)。</p>
<h3 id="解法二：二分查找-2"><a href="#解法二：二分查找-2" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>想要在有序数组中查找比目标字母大的最小字母，可以使用二分查找：找到最右边的位置将 <code>target</code> 插入 <code>letters</code> 中，以便它保持排序。如果插入位置是最后一个位置 <code>letters.size</code>，则返回 <code>letters[0]</code>。用模运算统一起来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; letters, <span class="hljs-type">char</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=letters.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(letters[mid]&lt;=target)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> letters[left%letters.<span class="hljs-built_in">size</span>()];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(logN)，空间复杂度 O(1)。</p>
<h2 id="278-第一个错误的版本-easy"><a href="#278-第一个错误的版本-easy" class="headerlink" title="278. 第一个错误的版本[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a>[easy]</h2><h3 id="解法：二分查找-6"><a href="#解法：二分查找-6" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// The API isBadVersion is defined for you.</span><br><span class="hljs-comment">// bool isBadVersion(int version);</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isBadVersion</span>(mid))<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="题型二：在一个有范围的区间里搜索一个整数"><a href="#题型二：在一个有范围的区间里搜索一个整数" class="headerlink" title="题型二：在一个有范围的区间里搜索一个整数"></a>题型二：在一个有范围的区间里搜索一个整数</h1><h2 id="69-x-的平方根-easy"><a href="#69-x-的平方根-easy" class="headerlink" title="69. x 的平方根[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a>[easy]</h2><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><p><code>i</code>从 0 开始递增，计算<code>i</code>的平方并与<code>x</code>比较大小，直到<code>i</code>平方大于<code>x</code>为止。此时，<code>i - 1</code>为所求值（注意，如果<code>i</code>是 int 类型，在某些测试用例下，<code>i</code>平方会溢出，因此采用 long 类型）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i*i&lt;=x)<br>            ++i;<br>        <span class="hljs-keyword">return</span> --i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：二分查找-3"><a href="#解法二：二分查找-3" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h3><p>对于一个非负数 <code>n</code>，它的平方根不会大于 <code>n/2+1</code>，因此可在 <code>[0,n/2+1]</code> 范围内进行二分查找。</p>
<p><code>while(left &lt;= right)</code>写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left=<span class="hljs-number">0</span>,right=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">long</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> square=mid*mid;<br>            <span class="hljs-keyword">if</span>(square==x)<br>                <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(square&gt;x)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// while 循环里没有找到符合的 mid ，此时 right&lt;left，返回 right 相当于取整</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><code>while(left &lt; right)</code>写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> left=<span class="hljs-number">0</span>,right=x/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 注意：这里取右中位数，如果取左中位数，代码会进入死循环</span><br>            <span class="hljs-type">long</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">long</span> square=mid*mid;<br>            <span class="hljs-keyword">if</span>(square&gt;x)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-comment">// 因为一定存在，因此无需后处理</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(log N)，空间复杂度 O(1)。</p>
<h3 id="解法三：牛顿迭代法"><a href="#解法三：牛顿迭代法" class="headerlink" title="解法三：牛顿迭代法"></a>解法三：牛顿迭代法</h3><blockquote>
<p>牛顿法：在迭代过程中，<strong>以直线代替曲线</strong>，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 <em>x</em> 轴的交点，重复这个过程直到收敛。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111405.gif" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>可以参考知乎问答<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20690553">《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》</a>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200924111959.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>求根号 a 的近似值：首先随便猜一个近似值 <em>x</em>，然后不断令 x 等于 x 和 a&#x2F;x 的平均数，迭代几次后 x 的值就相当精确了。</p>
<p>例如，想求根号 2 等于多少。假如猜测的结果为 4，虽然错的离谱，但可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">( <span class="hljs-number">4</span> + <span class="hljs-number">2</span><span class="hljs-regexp">/ 4 ) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">2.25</span><br>( <span class="hljs-number">2.25</span> + <span class="hljs-number">2</span><span class="hljs-regexp">/ 2.25 ) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.56944</span>..<br>( <span class="hljs-number">1.56944</span>..+ <span class="hljs-number">2</span><span class="hljs-regexp">/1.56944..) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.42189</span>..<br>( <span class="hljs-number">1.42189</span>..+ <span class="hljs-number">2</span><span class="hljs-regexp">/1.42189..) /</span> <span class="hljs-number">2</span> = <span class="hljs-number">1.41423</span>..<br>….<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">long</span> res=x;<br>        <span class="hljs-keyword">while</span>(res*res&gt;x)<br>            res=(res+x/res)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="287-寻找重复数-medium"><a href="#287-寻找重复数-medium" class="headerlink" title="287. 寻找重复数[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a>[medium]</h2><p>思路注意题目的限制：</p>
<ol>
<li>不能更改原数组（假设数组是只读的）。</li>
<li>只能使用额外的 <code>O(1)</code> 的空间。</li>
</ol>
<blockquote>
<p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。</p>
</blockquote>
<h3 id="解法一：用二分法查找一个有范围的整数"><a href="#解法一：用二分法查找一个有范围的整数" class="headerlink" title="解法一：用二分法查找一个有范围的整数"></a>解法一：用二分法查找一个有范围的整数</h3><p>详细思路解释参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/">liweiwei1419</a> 题解。</p>
<p>二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>），然后统计原始数组中<strong>小于等于</strong>这个中间数的元素的个数 <code>cnt</code>，如果 <code>cnt</code> <strong>严格大于</strong> <code>mid</code>，（注意加了着重号的部分「小于等于」、「严格大于」）。根据抽屉原理，重复元素就在区间 <code>[left, mid]</code> 里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:nums)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(num&lt;=mid)<br>                    cnt++;<br>            &#125;<br>            <span class="hljs-comment">// 根据抽屉原理，小于等于 4 的数的个数如果严格大于 4 个，</span><br>            <span class="hljs-comment">// 此时重复元素一定出现在 [1, 4] 区间里</span><br>            <span class="hljs-keyword">if</span>(cnt&gt;mid)<br>                <span class="hljs-comment">// 重复的元素一定出现在 [left, mid] 区间里</span><br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span><br>                <span class="hljs-comment">// [mid + 1, right]</span><br>                <span class="hljs-comment">// 注意：此时需要调整中位数的取法为上取整</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//循环结束条件即left=right，区间只剩下一个元素，即重复值</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(NlogN)，二分法的时间复杂度为 O(logN)，在二分法的内部，执行了一次 for 循环，时间复杂度为 O(N)，故时间复杂度为 O(NlogN)。</li>
<li>空间复杂度：O(1)，使用了一个 cnt 变量，因此空间复杂度为 O(1)。</li>
</ul>
<h3 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h3><p><strong>数组形式的链表</strong></p>
<p>题目设定的问题是 <code>n+1</code> 个元素都在 <code>[1,n]</code> 这个范围内。可以将这个题目给的特殊的数组当作一个链表来看，数组的下标就是指向元素的指针，把数组的元素也看作指针。如 0 是指针，**指向 <code>nums[0]</code>，而 <code>nums[0]</code> 也是指针，指向 <code>nums[nums[0]]</code>**。</p>
<p>这样就可以有以下操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> point = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    point = nums[point]; <span class="hljs-comment">// 等同于 next = next-&gt;next; </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>链表中的环</strong></p>
<p>假设有这样一个样例：[1,2,3,4,5,6,7,8,9,5]。如果按照上面的循环下去就会得到这样一个路径: 1 2 3 4  [5 6 7 8 9] [5 6 7 8 9] [5 6 7 8 9] . . .这样就有了一个环，也就是5 6 7 8 9。point 会一直在环中循环的前进。于是就可以使用双指针寻找环形链表的入环节点，即题目 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>，参见<a href="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-medium">题解</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fast=<span class="hljs-number">0</span>,slow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            fast=nums[nums[fast]];<br>            slow=nums[slow];<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>            &#123;<br>                fast=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(fast!=slow)<br>                &#123;<br>                    fast=nums[fast];<br>                    slow=nums[slow];<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="374-猜数字大小-easy"><a href="#374-猜数字大小-easy" class="headerlink" title="374. 猜数字大小[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a>[easy]</h2><h3 id="解法：二分查找-7"><a href="#解法：二分查找-7" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><h4 id="while-left-lt-right-写法-8"><a href="#while-left-lt-right-写法-8" class="headerlink" title="while(left &lt;= right)写法"></a><code>while(left &lt;= right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Forward declaration of guess API.</span><br><span class="hljs-comment"> * @param  num   your guess</span><br><span class="hljs-comment"> * @return 	     -1 if num is lower than the guess number</span><br><span class="hljs-comment"> *			      1 if num is higher than the guess number</span><br><span class="hljs-comment"> *               otherwise return 0</span><br><span class="hljs-comment"> * int guess(int num);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guessNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">-1</span>)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="while-left-lt-right-写法-9"><a href="#while-left-lt-right-写法-9" class="headerlink" title="while(left &lt; right)写法"></a><code>while(left &lt; right)</code>写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">guessNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=n;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数，如果取左中位数，代码会进入死循环</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">guess</span>(mid)==<span class="hljs-number">-1</span>)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-comment">// 最后剩下的数一定是所求，无需后处理</span><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1300-转变数组后最接近目标值的数组和-medium"><a href="#1300-转变数组后最接近目标值的数组和-medium" class="headerlink" title="1300. 转变数组后最接近目标值的数组和[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">1300. 转变数组后最接近目标值的数组和</a>[medium]</h2><h3 id="解法：二分查找-8"><a href="#解法：二分查找-8" class="headerlink" title="解法：二分查找"></a>解法：二分查找</h3><ul>
<li><p>这道题比较麻烦的是求和以后可能不等于 target ，所以让求「最接近的方案」。而这个烦人的根源是 value 的取值一定得是整数。正是因为题目说 value 是整数，并且「答案不一定是 arr 中的数字」，因此依然可以使用二分查找法确定这个整数值。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173054.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>做题的时候，会发现判别条件很不好写，因为「怎么衡量接近」，度量这个「最接近」的量不好选。因此需要考虑别的方案；</p>
</li>
<li><p>最接近的情况是：选定了一个 value 求和以后，恰恰好等于 target。不过更有可能出现的情况是：value 选得小了，「接近程度」变大，而 value 选得大了，「接近程度」变小，反过来也是有可能的。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200925173116.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>解决方案是：<strong>把边界的上下方的可能的 <code>value</code> 值（一共就两个）都拿出来进行一次比较即可</strong>。</p>
</li>
</ul>
<h4 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a><strong>写法一</strong></h4><p>如果选择一个阈值 <code>value</code> ，使得它对应的 <code>sum</code> 是第 1 个大于等于 <code>target</code> 的，那么目标值可能在 <code>value</code> 也可能在 <code>value - 1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            right=<span class="hljs-built_in">max</span>(num,right);<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-built_in">calculateSum</span>(arr,mid);<br>            <span class="hljs-comment">// 计算第 1 个使得转变后数组的和大于等于 target 的阈值</span><br>            <span class="hljs-keyword">if</span>(sum&gt;target)<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;              <br>        &#125;<br>        <span class="hljs-comment">// 比较阈值线分别定在 left - 1 和 left 的时候与 target 的接近程度</span><br>        <span class="hljs-type">int</span> sum1=<span class="hljs-built_in">calculateSum</span>(arr,left<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> sum2=<span class="hljs-built_in">calculateSum</span>(arr,left);<br>        <span class="hljs-keyword">if</span>(target-sum1&lt;=sum2-target)<br>            <span class="hljs-keyword">return</span> left<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            sum+=<span class="hljs-built_in">min</span>(num,value);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a><strong>写法二</strong></h4><p>如果选择一个阈值 <code>value</code> ，使得它对应的 <code>sum</code> 是最后 1 个小于等于 <code>target</code> 的阈值，那么目标值可能在 <code>value</code> 也可能在 <code>value + 1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBestValue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            right=<span class="hljs-built_in">max</span>(num,right);<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> sum=<span class="hljs-built_in">calculateSum</span>(arr,mid);<br>            <span class="hljs-comment">// 计算最后 1 个使得转变以后数组的和小于等于 target 的阈值</span><br>            <span class="hljs-keyword">if</span>(sum&gt;target)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;              <br>        &#125;<br>        <span class="hljs-comment">// 比较阈值线分别定在 left 和 left + 1 的时候与 target 的接近程度</span><br>        <span class="hljs-type">int</span> sum1=<span class="hljs-built_in">calculateSum</span>(arr,left);<br>        <span class="hljs-type">int</span> sum2=<span class="hljs-built_in">calculateSum</span>(arr,left+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 注意：这里必须加绝对值，因为有可能出现 sum1 == sum2 &lt; target 的情况</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(target-sum1)&lt;=<span class="hljs-built_in">abs</span>(sum2-target))<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> left+<span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:arr)<br>            sum+=<span class="hljs-built_in">min</span>(num,value);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(NlogN)，N 是输入数组的长度，二分的时间复杂度是 O(logN)，每一次 <code>calculateSum</code>的时间复杂度是 O(N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="题型三：复杂的二分查找问题（最大值最小化）"><a href="#题型三：复杂的二分查找问题（最大值最小化）" class="headerlink" title="题型三：复杂的二分查找问题（最大值最小化）"></a>题型三：复杂的二分查找问题（最大值最小化）</h1><h2 id="410-分割数组的最大值-hard"><a href="#410-分割数组的最大值-hard" class="headerlink" title="410. 分割数组的最大值[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a>[hard]</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>&#x3D;&#x3D;#todo&#x3D;&#x3D;（留着以后填坑）</p>
<h3 id="解法二：二分查找-贪心"><a href="#解法二：二分查找-贪心" class="headerlink" title="解法二：二分查找+贪心"></a>解法二：二分查找+贪心</h3><p>注意题目中给出的这 3 个条件：</p>
<ul>
<li>数组中的元素均是「非负整数」；</li>
<li>子数组的特点是：「非空」且「连续」；</li>
<li>恰好分成 m 个非空「非空连续子数组」。</li>
</ul>
<p>题目中还给出了一个概念：「连续子数组各自和的最大值」，用一个变量 <code>maxIntervalSum</code> 表示。不难知道：</p>
<ul>
<li>每一个「非空连续子数组」如果包含的元素个数越多，那么<code>maxIntervalSum</code> 就可能越大（非负整数保证）；</li>
<li>一个<code>maxIntervalSum</code> 的数值就唯一对应了一个分出的「非空连续子数组」的组数 <strong><code>M</code></strong> ，它们是函数关系（一一对应），<code>maxIntervalSum</code>是自变量，**<code>M</code>**是因变量，可以写成：M &#x3D; function(maxIntervalSum)</li>
</ul>
<p>如何找到一个<code>maxIntervalSum</code>，使得它对应的**<code>M</code><strong>恰好等于题目给出的</strong><code>m</code>**。容易分析出，这个函数是一个单调递减的函数：</p>
<ul>
<li>如果 <code>maxIntervalSum</code> 越小，分出的「非空连续子数组」的组数**<code>M</code>**就越大；</li>
<li>如果 <code>maxIntervalSum</code>  越大，分出的「非空连续子数组」的组数**<code>M</code>**就越小。</li>
</ul>
<p>因此这个函数是单调不增的函数。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200928111521.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>原因就在于上面强调的题目中给出的 2 个条件：非负整数和非空连续子数组，**由于这种单调性，可以使用二分查找，找到与 <code>m</code> 对应的 <code>maxIntervalSum</code>**。</p>
<p><strong>重点理解：</strong></p>
<ol>
<li><strong>大于的时候舍弃，小于等于的时候保留，这样左右向中间逼近能找到 <code>M</code> 的最小值</strong>；</li>
<li>理解贪心算法的应用，在从左向右划分组的时候，尽量让一个组有更多的元素，直至超过了设定的临界值。</li>
</ol>
<p><strong>代码细节：</strong></p>
<ul>
<li>**只要连续加起来的数值超过了 <code>maxIntervalSum</code>**，就新产生一个新的连续子数组；</li>
<li><code>maxIntervalSum</code>的最小值是这个数组中的最大值，这是因为<code>max(nums)</code>一定会被分到其中一组；</li>
<li><code>maxIntervalSum</code>的最大值是这个数组中所有元素的和，极端情况就是题目中给出**<code>m=1</code>**的时候。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算「子数组各自的和的最大值」的上下界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:nums)<br>        &#123;<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-comment">// 使用「二分查找」确定一个恰当的「子数组各自的和的最大值」，使得它对应的「子数组的分割数」恰好等于 m</span><br>        <span class="hljs-type">int</span> left=maxNum;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> splits=<span class="hljs-built_in">split</span>(nums,mid);<br>            <span class="hljs-keyword">if</span>(splits&gt;m)<br>                <span class="hljs-comment">// 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是 [mid + 1, right]</span><br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 下一轮搜索的区间是上一轮的反面区间 [left, mid]</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * @param nums 原始数组</span><br><span class="hljs-comment">     * @param maxIntervalSum 子数组各自的和的最大值</span><br><span class="hljs-comment">     * @return 满足不超过「子数组各自的和的最大值」的分割数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">split</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> maxIntervalSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 至少是一个分割</span><br>        <span class="hljs-type">int</span> splits=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 当前区间的和</span><br>        <span class="hljs-type">int</span> curIntervalSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:nums)<br>        &#123;<br>            <span class="hljs-comment">// 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起炉灶</span><br>            <span class="hljs-keyword">if</span>(curIntervalSum+num&gt;maxIntervalSum)<br>            &#123;<br>                curIntervalSum=<span class="hljs-number">0</span>;<br>                splits++;<br>            &#125;<br>            curIntervalSum+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> splits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(Nlog∑nums)，N 表示输入数组的长度，∑nums 表示输入数组的和，代码在 [max(nums),∑nums] 区间里使用二分查找找到目标元素，而每一次判断分支需要遍历一遍数组，时间复杂度为 O(N)；</li>
<li>空间复杂度：O(1) ，只使用到常数个临时变量。</li>
</ul>
<h2 id="1011-在-D-天内送达包裹的能力-medium"><a href="#1011-在-D-天内送达包裹的能力-medium" class="headerlink" title="1011. 在 D 天内送达包裹的能力[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a>[medium]</h2><h3 id="解法：二分查找-贪心"><a href="#解法：二分查找-贪心" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, <span class="hljs-type">int</span> D)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:weights)<br>        &#123;<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>            sum+=num;<br>        &#125;<br>        <span class="hljs-type">int</span> left=maxNum;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> days=<span class="hljs-built_in">day</span>(weights,mid);<br>            <span class="hljs-keyword">if</span>(days&gt;D)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights,<span class="hljs-type">int</span> maxIntervalSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> days=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> curIntervalSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:weights)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(curIntervalSum+num&gt;maxIntervalSum)<br>            &#123;<br>                curIntervalSum=<span class="hljs-number">0</span>;<br>                days++;<br>            &#125;<br>            curIntervalSum+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="875-爱吃香蕉的珂珂-medium"><a href="#875-爱吃香蕉的珂珂-medium" class="headerlink" title="875. 爱吃香蕉的珂珂[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a>[medium]</h2><h3 id="解法：二分查找-贪心-1"><a href="#解法：二分查找-贪心-1" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p>
<ul>
<li>珂珂吃香蕉的速度越小，耗时越多。反之，速度越大，耗时越少，这是这个问题的<strong>单调性</strong>；</li>
<li>搜索的是速度。因为题目限制了珂珂一个小时之内只能选择一堆香蕉吃，因此速度最大值就是这几堆香蕉中，数量最多的那一堆。速度的最小值是 1，其实还可以再分析一下下界是多少，由于二分搜索的时间复杂度很低，严格的分析不是很有必要；</li>
<li>还是因为珂珂一个小时之内只能选择一堆香蕉吃，因此：<strong>每堆香蕉吃完的耗时 &#x3D; 这堆香蕉的数量 &#x2F; 珂珂一小时吃香蕉的数量</strong>，这里的 &#x2F; 在不能整除的时候，需要<strong>上取整</strong>。</li>
<li><strong>注意</strong>：当目前的速度恰好使得珂珂在规定的时间内吃完香蕉的时候，还应该去尝试更小的速度是不是还可以保证在规定的时间内吃完香蕉。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> H)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxNum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:piles)<br>            maxNum=<span class="hljs-built_in">max</span>(maxNum,num);<br>        <span class="hljs-comment">// 速度最小的时候，耗时最长</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 速度最大的时候，耗时最短</span><br>        <span class="hljs-type">int</span> right=maxNum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> hours=<span class="hljs-built_in">hour</span>(piles,mid);<br>            <span class="hljs-comment">// 耗时太多，说明速度太慢了，下一轮搜索区间在 [mid + 1, right]</span><br>            <span class="hljs-keyword">if</span>(hours&gt;H)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果返回的小时数严格大于 H，就不符合题意</span><br><span class="hljs-comment">     * @param piles</span><br><span class="hljs-comment">     * @param speed</span><br><span class="hljs-comment">     * @return 需要的小时数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hour</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> speed)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> hours=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:piles)<br>            <span class="hljs-comment">// 上取整</span><br>            hours+=(num+speed<span class="hljs-number">-1</span>)/speed;<br>        <span class="hljs-keyword">return</span> hours;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>关于上取整：</strong></p>
<p>写成 <code>hours += num / speed</code> 是下取整，为了把下取整改成上取整（根据题目要求需要上取整）。</p>
<p>因此，需要在分子加上「分母的值 - 1」，这样就可以改变默认 <code>/</code> 下取整的行为。</p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(Nlogmax(piles))，N 表示数组 piles 的长度。在 [1,max(piles)] 里使用二分查找定位最小速度，而每一次执行判别函数的时间复杂度是 O(N)。</li>
<li>空间复杂度：O(1)，算法只使用了常数个临时变量。</li>
</ul>
<h2 id="LCP-12-小张刷题计划-medium"><a href="#LCP-12-小张刷题计划-medium" class="headerlink" title="LCP 12. 小张刷题计划[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/">LCP 12. 小张刷题计划</a>[medium]</h2><h3 id="解法：二分查找-贪心-2"><a href="#解法：二分查找-贪心-2" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似，区别就只在于这个问题的场景，提示使用贪心算法，贪心的点是「每一天把耗时最多的问题交给小杨去做」。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minTime</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; time, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//获取一天最多耗时是多少</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:time)<br>            sum+=num;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=sum;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<span class="hljs-comment">//T</span><br>            <span class="hljs-comment">// 计算需要的天数</span><br>            <span class="hljs-type">int</span> days=<span class="hljs-built_in">day</span>(time,mid);<br>            <span class="hljs-keyword">if</span>(days&gt;m)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">day</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; time,<span class="hljs-type">int</span> maxTime)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> days=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> curMax=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curTime=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; num:time)<br>        &#123;<br>            curMax=<span class="hljs-built_in">max</span>(curMax,num);<br>            <span class="hljs-comment">// 每一天把耗时最多的问题交给小杨去做，这是贪心的思想，即 -curMax</span><br>            <span class="hljs-comment">// 当耗时超过 maxTime 时就重新换一天</span><br>            <span class="hljs-keyword">if</span>(curTime+num-curMax&gt;maxTime)<br>            &#123;<br>                curMax=num;<br>                curTime=<span class="hljs-number">0</span>;<br>                days++;<br>            &#125;<br>            curTime+=num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> days;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1482-制作-m-束花所需的最少天数-medium"><a href="#1482-制作-m-束花所需的最少天数-medium" class="headerlink" title="1482. 制作 m 束花所需的最少天数[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a>[medium]</h2><h3 id="解法：二分查找-贪心-3"><a href="#解法：二分查找-贪心-3" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bloomDay, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> flowerSum=bloomDay.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 总花数小于制作花束需要的花的数量</span><br>        <span class="hljs-keyword">if</span>(m*k&gt;flowerSum)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 计算最大等待天数</span><br>        <span class="hljs-type">int</span> maxDays=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day:bloomDay)<br>            maxDays=<span class="hljs-built_in">max</span>(maxDays,day);<br>        <span class="hljs-comment">// 二分等待天数 waitDays</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right=maxDays;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 制作的花束的数量</span><br>            <span class="hljs-type">int</span> bouquetNum=<span class="hljs-built_in">bouquet</span>(bloomDay,mid,k);<br>            <span class="hljs-comment">// 制作的花束数量太少，需要等待更多天</span><br>            <span class="hljs-keyword">if</span>(bouquetNum&lt;m)<br>                left=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 可以制作多少束花</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bouquet</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bloomDay,<span class="hljs-type">int</span> Waitdays,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> bouquetNum=<span class="hljs-number">0</span>;<span class="hljs-comment">//花束数量</span><br>        <span class="hljs-type">int</span> flowerNum=<span class="hljs-number">0</span>;<span class="hljs-comment">//花数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; day:bloomDay)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(day&lt;=Waitdays)<br>            &#123;<br>                flowerNum++;<br>                <span class="hljs-comment">//相邻的花的数量达到了制作花束的要求</span><br>                <span class="hljs-keyword">if</span>(flowerNum==k)<br>                &#123;<br>                    bouquetNum++;<br>                    flowerNum=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 因为花需要相邻，因此置 0</span><br>            <span class="hljs-keyword">else</span><br>                flowerNum=<span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bouquetNum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1552-两球之间的磁力-medium"><a href="#1552-两球之间的磁力-medium" class="headerlink" title="1552. 两球之间的磁力[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a>[medium]</h2><h3 id="解法：二分查找-贪心-4"><a href="#解法：二分查找-贪心-4" class="headerlink" title="解法：二分查找+贪心"></a>解法：二分查找+贪心</h3><p>总体思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-array-largest-sum/">410. 分割数组的最大值</a> 解法二相似。</p>
<p>首先要找到二分搜索的边界，根据题意，要返回的是最小磁力，所以第一步要找到最小磁力的最小可能取值和最大可能取值。</p>
<ul>
<li>对于最小可能取值，是给定数组中距离最近的两个位置之间的磁力，所以对数组进行排序，并遍历数组找到相邻两个位置的最小距离。在这里直接初始化为 0，并不会增加多少次二分查找。</li>
<li>对于最大可能取值，一共有 m 个球，所以有 m - 1 个间隔，最大的可能取值便是最平均的取值，所以根据给定数组最大值与最小值之差与间隔数的比值计算出平均距离，就是给定的最大可能取值。</li>
</ul>
<p>确定好了边界后，每次二分搜索时需要判断当前计算值是否满足条件，这里引入 ball 函数，计算当前最小磁力时能放置的球数。计算过程使用贪心算法，遍历数组，若找到两位置之间距离大于等于最小磁力，则计数值加 1。在计算出能放置的球数 m 后，进行二分搜索边界的缩减。当球数小于 m 时，说明此时的最小磁力太大，放置不了 m 个球，因此需要减小，即将右边界左移，看稍小的数值是否满足条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; position, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// 排序以便计算初始左右边界</span><br>        <span class="hljs-built_in">sort</span>(position.<span class="hljs-built_in">begin</span>(),position.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 初始右边界</span><br>        <span class="hljs-type">int</span> right=(position.<span class="hljs-built_in">back</span>()-position.<span class="hljs-built_in">front</span>())/(m<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">// 对最小磁力进行二分搜索</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-comment">// 取右中位数</span><br>            <span class="hljs-type">int</span> mid=left+(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">// 计算当前最小磁力下能放置的球数</span><br>            <span class="hljs-type">int</span> balls=<span class="hljs-built_in">ball</span>(position,mid);<br>            <span class="hljs-comment">// 当前磁力无法放置 m 个球，需要减小磁力，右边界左移</span><br>            <span class="hljs-keyword">if</span>(balls&lt;m)<br>                right=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                left=mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 返回当前最小磁力能放置的球数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ball</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; position,<span class="hljs-type">int</span> minDistance)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> balls=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始为 1 个球</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;position.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(position[j]-position[i]&gt;=minDistance)<br>            &#123;<br>                balls++;<br>                i=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> balls;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Binary-Search/">Binary Search</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/09/29/Leetcode%20Notes%E2%80%94%E2%80%94Two%20Pointers/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Two Pointers</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/30/Leetcode%20Notes%E2%80%94%E2%80%94Array%20and%20Matrix/">
                        <span class="hidden-mobile">Leetcode Notes——Array and Matrix</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
