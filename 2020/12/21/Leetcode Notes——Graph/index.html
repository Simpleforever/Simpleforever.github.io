

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为图篇。部分内容搬运自 Leetcode-cn 大佬题解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Graph">
<meta property="og:url" content="https://simpleforever.github.io/2020/12/21/Leetcode%20Notes%E2%80%94%E2%80%94Graph/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为图篇。部分内容搬运自 Leetcode-cn 大佬题解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210105213709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110842.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110953.png">
<meta property="article:published_time" content="2020-12-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-21T14:48:16.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Graph">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210105213709.png">
  
  
  <title>Leetcode Notes——Graph - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://w.wallhaven.cc/full/3z/wallhaven-3zj7ey.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Graph">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-21 00:00" pubdate>
        2020年12月21日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      31k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      260 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Graph</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>图</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p>
<span id="more"></span>

<h1 id="133-克隆图-medium"><a href="#133-克隆图-medium" class="headerlink" title="133. 克隆图[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a>[medium]</h1><p>详细思路解释查看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/">官方题解</a>。</p>
<h2 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><p>使用<code>HashMap</code>记录原图中的结点和新生成的克隆图中的结点。</p>
<ul>
<li>如果结点为空，则返回<code>NULL</code>。</li>
<li>如果当前结点在<code>HashMap</code>中，即当前结点已经被克隆过，则直接返回其映射结点。</li>
<li>否则，克隆当前结点，并在<code>HashMap</code>中建立映射，然后遍历当前结点的所有<code>neighbor</code>结点，调用递归函数并且加到克隆结点的<code>neighbors</code>数组中。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*,Node*&gt; visited;<span class="hljs-comment">// 新旧结点 Map</span><br>    <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> node;<br>        <span class="hljs-comment">// 如果该节点已经被访问过了，则直接从哈希表中取出对应的克隆节点返回</span><br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> visited[node];<br>        <span class="hljs-comment">// 克隆节点，为了深拷贝不会克隆它的邻居的列表</span><br>        Node *cloneNode=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>        <span class="hljs-comment">// 哈希表存储</span><br>        visited[node]=cloneNode;<br>        <span class="hljs-comment">// 遍历该节点的邻居并更新克隆节点的邻居列表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neighbor:node-&gt;neighbors)<br>            cloneNode-&gt;neighbors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">cloneGraph</span>(neighbor));<br>        <span class="hljs-keyword">return</span> cloneNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h2><p>除了使用<code>HashMap</code>记录原图中的结点和新生成的克隆图中的结点，还需要队列<code>queue</code>来辅助图的遍历。</p>
<ul>
<li>先克隆当前结点，然后建立映射，并加入<code>queue</code>中，进行循环。</li>
<li>在循环中，取出队首结点，遍历其所有<code>neighbor</code>结点，若不在<code>HashMap</code>中，根据<code>neighbor</code>结点值克隆一个新<code>neighbor</code>结点，建立映射，并且放入<code>queue</code>中。然后将<code>neighbor</code>结点在<code>HashMap</code>中的映射结点加入到克隆结点的<code>neighbors</code>数组中。</li>
<li>循环直到队列为空为止。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> node;<br>        unordered_map&lt;Node*,Node*&gt; visited;<br>        queue&lt;Node*&gt; q;<br>        <span class="hljs-comment">// 克隆第一个节点并存储到哈希表中</span><br>        Node *cloneNode=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>        visited[node]=cloneNode;<br>        <span class="hljs-comment">// 将题目给定的节点添加到队列</span><br>        q.<span class="hljs-built_in">push</span>(node);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 取出队列的头节点</span><br>            <span class="hljs-keyword">auto</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// 遍历该节点的邻居</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;neighbor:cur-&gt;neighbors)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(neighbor)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将邻居节点加入队列中</span><br>                    q.<span class="hljs-built_in">push</span>(neighbor);<br>                    <span class="hljs-comment">// 如果没有被访问过，就克隆并存储在哈希表中</span><br>                    visited[neighbor]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(neighbor-&gt;val);<br>                &#125;<br>                <span class="hljs-comment">// 更新当前节点的邻居列表</span><br>                visited[cur]-&gt;neighbors.<span class="hljs-built_in">push_back</span>(visited[neighbor]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneNode;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="841-钥匙和房间-medium"><a href="#841-钥匙和房间-medium" class="headerlink" title="841. 钥匙和房间[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/keys-and-rooms/">841. 钥匙和房间</a>[medium]</h1><h2 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><ul>
<li>首先找到 0 号房间，把所有 ０ 号房间的钥匙都开一遍；</li>
<li>进入刚刚开过的房间，再把它们房间里的钥匙再开一遍；</li>
<li>重复以往，层层递进，直到找不到符合要求的节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<span class="hljs-comment">// 标记房间是否被访问过</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-comment">//  0 号房间开始</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        visited.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> room=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; keys=rooms[room];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;key:keys)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(key)==<span class="hljs-number">0</span>)<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(key);<br>                    visited.<span class="hljs-built_in">insert</span>(key);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 检查房间是不是都遍历过了</span><br>        <span class="hljs-keyword">return</span> visited.<span class="hljs-built_in">size</span>()==rooms.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><ul>
<li>先找第 ０ 个房间的第一个钥匙；</li>
<li>进入那个房间，再找它的第一个钥匙；</li>
<li>重复以往，直到没钥匙了，那么退回刚刚的房间；</li>
<li>找刚刚房间的第二把钥匙；</li>
<li>重复以往。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canVisitAllRooms</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;      <br>        <span class="hljs-built_in">dfs</span>(rooms,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 检查房间是不是都遍历过了</span><br>        <span class="hljs-keyword">return</span> visited.<span class="hljs-built_in">size</span>()==rooms.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;rooms,<span class="hljs-type">int</span> room)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(room)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        visited.<span class="hljs-built_in">insert</span>(room);<br>        vector&lt;<span class="hljs-type">int</span>&gt; keys=rooms[room];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;key:keys)<br>            <span class="hljs-built_in">dfs</span>(rooms,key);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="207-课程表-medium"><a href="#207-课程表-medium" class="headerlink" title="207. 课程表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a>[medium]</h1><h2 id="解法一：拓扑排序（Kahn-算法，其实就是广度优先遍历的思路）"><a href="#解法一：拓扑排序（Kahn-算法，其实就是广度优先遍历的思路）" class="headerlink" title="解法一：拓扑排序（Kahn 算法，其实就是广度优先遍历的思路）"></a>解法一：拓扑排序（Kahn 算法，其实就是广度优先遍历的思路）</h2><blockquote>
<ul>
<li><p>拓扑排序本质是<strong>广度优先遍历+贪心算法</strong>；</p>
</li>
<li><p>拓扑排序是广度优先遍历和贪心算法应用于有向图的一个专有名词；</p>
</li>
<li><p>应用场景：任务调度计划、课程安排，例：《机器学习》课程的先导课程为《高等数学》；</p>
</li>
<li><p>拓扑排序的作用：</p>
<ul>
<li><p>得到一个拓扑序，拓扑序不唯一；</p>
</li>
<li><p>检测有向图是否存在环。</p>
<p>补充：无向图中检测是否有环，使用的数据结构是并查集。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>拓扑排序实际上应用的是<strong>贪心算法</strong>。贪心算法简而言之：每一步最优，全局就最优。</p>
<p>具体到拓扑排序，每一次都从图中删除没有前驱的顶点，这里并不需要真正的做删除操作，可以设置一个入度数组，每一轮都输出入度为 0 的结点，并移除它、修改它指向的结点的入度（-1即可），依次得到的结点序列就是拓扑排序的结点序列。如果图中还有结点没有被移除，则说明“不能完成所有课程的学习”。</p>
<p>拓扑排序保证了每个活动（在这题中是“课程”）的所有前驱活动都排在该活动的前面，并且可以完成所有活动。拓扑排序的结果不唯一。</p>
<p><strong>算法流程</strong>：</p>
<ul>
<li>在开始排序前，扫描对应的存储空间（使用邻接表），将入度为 0 的结点放入队列。</li>
<li>只要队列非空，就从队首取出入度为 0 的结点，将这个结点输出到结果集中，并且将这个结点的所有邻接结点（它指向的结点）的入度减 1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</li>
<li>当队列为空的时候，检查结果集中的顶点个数是否和课程数相等即可。</li>
</ul>
<p>在代码具体实现的时候，除了保存入度为 0 的队列，还需要两个辅助的数据结构：</p>
<ul>
<li>邻接表：通过结点的索引，能够得到这个结点的后继结点；</li>
<li>入度数组：通过结点的索引，能够得到指向这个结点的结点个数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 邻接表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 各结点的入度</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 入度为 0 的结点队列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++indegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            adj[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 首先加入入度为 0 的结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(indegrees[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 记录已经出队的课程数量</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ++cnt;<br>            <span class="hljs-comment">// 遍历当前出队结点的所有后继结点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[cur])<br>            &#123;<br>                --indegrees[successor];<br>                <span class="hljs-comment">// 检测该结点的入度是否为 0，如果为 0，加入队列</span><br>                <span class="hljs-keyword">if</span>(indegrees[successor]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(successor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt==numCourses;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：深度优先遍历"><a href="#解法二：深度优先遍历" class="headerlink" title="解法二：深度优先遍历"></a>解法二：深度优先遍历</h2><p>深度优先遍历的思路有 2 个。</p>
<ul>
<li>首先检测是否存在环，然后使用「深度优先遍历」，在「后序」的部分把课程添加到结果集，然后再逆序，就是「拓扑排序」的结果（没有提供参考代码）；</li>
<li>在深度优先遍历的过程中，设置个别有特殊意义的变量，通过这些变量得到「拓扑排序」的结果（下面提供了参考代码）。</li>
</ul>
<p>这里要使用逆邻接表。其实就是检测这个有向图中有没有环，只要存在环，这些课程就不能按要求学完。</p>
<p>具体方法是：</p>
<ol>
<li>构建逆邻接表；</li>
<li>递归处理每一个还没有被访问的结点，具体做法很简单：对于一个结点来说，先输出指向它的所有顶点，再输出自己。</li>
<li>如果这个顶点还没有被遍历过，就递归遍历它，把所有指向它的结点都输出了，再输出自己。注意：当访问一个结点的时候，应当先递归访问它的前驱结点，直至前驱结点没有前驱结点为止。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flags</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>            adj[prerequisites[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i,adj,flags))<br>                <span class="hljs-comment">// 注意方法的语义，如果图中存在环，表示课程任务不能完成，应该返回 false</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在遍历的过程中，一直 dfs 都没有遇到已经重复访问的结点，就表示有向图中没有环</span><br>        <span class="hljs-comment">// 所有课程任务可以完成，应该返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// flags 如果 == 1 表示正在访问中，如果 == 2 表示已经访问完了</span><br>    <span class="hljs-comment">// return true 表示图中存在环，false 表示访问过了，不用再访问了</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;adj,vector&lt;<span class="hljs-type">int</span>&gt; &amp;flags)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 从正在访问中，到正在访问中，表示遇到了环</span><br>        <span class="hljs-keyword">if</span>(flags[i]==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 表示在访问的过程中没有遇到环，这个节点访问过了</span><br>        <span class="hljs-keyword">if</span>(flags[i]==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 走到这里，是因为初始化 flags[i] == 0</span><br>        <span class="hljs-comment">// 表示正在访问中</span><br>        flags[i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 遍历后继结点的集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(successor,adj,flags))<br>                <span class="hljs-comment">// 层层递归返回 true ，表示图中存在环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// i 的所有后继结点都访问完了，都没有存在环，则这个结点就可以被标记为已经访问结束</span><br>        <span class="hljs-comment">// 状态设置为 2</span><br>        flags[i]=<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// false 表示图中不存在环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="210-课程表-II-medium"><a href="#210-课程表-II-medium" class="headerlink" title="210. 课程表 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a>[medium]</h1><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a> 相同，这里仅给出广度优先遍历解法代码。</p>
<h2 id="解法：拓扑排序（Kahn-算法、类似广度优先遍历的思路）"><a href="#解法：拓扑排序（Kahn-算法、类似广度优先遍历的思路）" class="headerlink" title="解法：拓扑排序（Kahn 算法、类似广度优先遍历的思路）"></a>解法：拓扑排序（Kahn 算法、类似广度优先遍历的思路）</h2><p>拓扑序不唯一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 邻接表</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegrees</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 各结点的入度</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 入度为 0 的结点队列</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(numCourses,<span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            ++indegrees[prerequisites[i][<span class="hljs-number">0</span>]];<br>            adj[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 首先加入入度为 0 的结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(indegrees[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-comment">// 记录已经出队的课程数量，正好可以作为结果下标</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            res[cnt]=cur;<br>            ++cnt;<br>            <span class="hljs-comment">// 遍历当前出队结点的所有后继结点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;successor:adj[cur])<br>            &#123;<br>                --indegrees[successor];<br>                <span class="hljs-comment">// 检测该结点的入度是否为 0，如果为 0，加入队列</span><br>                <span class="hljs-keyword">if</span>(indegrees[successor]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(successor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==numCourses)<br>            <span class="hljs-keyword">return</span> res;<br>         <span class="hljs-comment">// 如果结果集中的数量不等于结点的数量，就不能完成课程任务，这一点是拓扑排序的结论</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="802-找到最终的安全状态-medium"><a href="#802-找到最终的安全状态-medium" class="headerlink" title="802. 找到最终的安全状态[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-eventual-safe-states/">802. 找到最终的安全状态</a>[medium]</h1><h2 id="解法：拓扑排序"><a href="#解法：拓扑排序" class="headerlink" title="解法：拓扑排序"></a>解法：拓扑排序</h2><p>定义安全的点：路径终点，也就是出度为 0 的点。</p>
<p>定义最终安全的点：从起始节点开始，可以沿某个路径到达终点，那么起始节点就是最终安全的点。</p>
<p>思路：从出度为 0 的弧尾反向拓扑到弧头。</p>
<ul>
<li>找到出度为 0 的顶点，这些点是安全的点；</li>
<li>逆向删除以出度为 0 的顶点为弧头的边，弧尾的出度减一；</li>
<li>重复上面两步，直到不存在出度为 0 的顶点。</li>
</ul>
<p>由于需要回推边，所以建立逆向邻接图。此外，题目要求返回的节点有序，因此最后将结果数组排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">eventualSafeNodes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outDegree</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 维护出度</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">revGraph</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            outDegree[i]=graph[i].<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;end:graph[i])<br>                revGraph[end].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(outDegree[i]==<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;start:revGraph[cur])<br>            &#123;<br>                --outDegree[start];<br>                <span class="hljs-keyword">if</span>(outDegree[start]==<span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(start);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 保证结果有序</span><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="990-等式方程的可满足性-medium"><a href="#990-等式方程的可满足性-medium" class="headerlink" title="990. 等式方程的可满足性[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990. 等式方程的可满足性</a>[medium]</h1><h2 id="解法：并查集"><a href="#解法：并查集" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>并查集模板参考 <a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo">Union-Find 算法详解</a>。</p>
<p>由于等式相等具有传递性，比较容易想到使用并查集。为此设计算法如下：</p>
<ul>
<li>扫描所有等式，将等式两边的顶点进行合并；</li>
<li>再扫描所有不等式，检查每一个不等式的两个顶点是不是在一个连通分量里，如果在，则返回 <code>false</code> 表示等式方程有矛盾。如果所有检查都没有矛盾，返回 <code>true</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;eq:equations)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(eq[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;=&#x27;</span>)<br>                uf.<span class="hljs-built_in">unionTree</span>(eq[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>,eq[<span class="hljs-number">3</span>]-<span class="hljs-string">&#x27;a&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;eq:equations)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(eq[<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;!&#x27;</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(eq[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>,eq[<span class="hljs-number">3</span>]-<span class="hljs-string">&#x27;a&#x27;</span>))<br>                    <span class="hljs-comment">// 如果合并失败，表示等式有矛盾，根据题意，返回 false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果检查了所有不等式，都没有发现矛盾，返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="684-冗余连接-medium"><a href="#684-冗余连接-medium" class="headerlink" title="684. 冗余连接[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a>[medium]</h1><h2 id="解法：并查集-1"><a href="#解法：并查集-1" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>判断节点第一次出现环的边 edge 进行返回，如下图，当 1 的根节点是 4 的时候，从 1-&gt;2-&gt;3-&gt;4 出现一条路径，大概 [1,4] 这个 edge 进来后，发现 1 可以直接指向 4，这时候出现了环，这条边是冗余边。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210105213709.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>在这条边出现之前，图中没有环。这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边。然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边。</p>
<p>具体实现：</p>
<p>改写 union 方法，第一次当 p 与 q 没有联通时，将其设置联通关系，返回 ture，第二次 p 和 q 的跟节点发现一致时，他们已经联通了，返回 false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=edges.<span class="hljs-built_in">size</span>()+<span class="hljs-number">1</span>;<span class="hljs-comment">//注意此处下标多放一个</span><br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;edge:edges)<br>        &#123;<br>            <span class="hljs-type">int</span> x=edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> y=edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">unionTree</span>(x,y))<br>                <span class="hljs-comment">// 第二次出现了联通的边时，表示已经找到了</span><br>                <span class="hljs-keyword">return</span> edge;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="1319-连通网络的操作次数-medium"><a href="#1319-连通网络的操作次数-medium" class="headerlink" title="1319. 连通网络的操作次数[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319. 连通网络的操作次数</a>[medium]</h1><h2 id="解法：并查集-2"><a href="#解法：并查集-2" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><p>将<strong>互相连通</strong>的电脑压缩成<strong>一个点</strong>，若最后存在 N 个点，通过观察可以发现只需要 <code>N - 1</code> 条线就可以进行相连。那接下来的问题就是如何去寻找这 <code>N - 1</code> 条线。考虑每一条线，如果线的两头已经连通，则这条线是多余的，可以拿去当做 <code>N - 1</code>条线的其中一条。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">// 记录连通分量个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 多余的线缆数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:connections)<br>        &#123;<br>            <span class="hljs-type">int</span> l=c[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> r=c[<span class="hljs-number">1</span>];<br>            <span class="hljs-comment">// 两个点已经连通，不需要这个线缆</span><br>            <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(l,r))<br>            &#123;<br>                ++cnt;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            uf.<span class="hljs-built_in">unionTree</span>(l,r);<br>        &#125;<br>        <span class="hljs-comment">// 所需要的线缆数量</span><br>        <span class="hljs-type">int</span> cnt2=uf.<span class="hljs-built_in">getCount</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> cnt&lt;cnt2?<span class="hljs-number">-1</span>:cnt2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="685-冗余连接-II-hard"><a href="#685-冗余连接-II-hard" class="headerlink" title="685. 冗余连接 II[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection-ii/">685. 冗余连接 II</a>[hard]</h1><h2 id="解法：并查集-拓扑排序"><a href="#解法：并查集-拓扑排序" class="headerlink" title="解法：并查集+拓扑排序"></a>解法：并查集+拓扑排序</h2><p>这个问题与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a> 的区别是：</p>
<ul>
<li>第 684 题基于<strong>无向图</strong>，在无向图中判断是否有环，使用<strong>并查集</strong>；</li>
<li>第 685 题基于<strong>有向图</strong>，在有向图中判断是是否有环，使用<strong>拓扑排序</strong>。</li>
</ul>
<p>第 685 题需要返回多余的一条边。拓扑排序主要回答拓扑序，顺便回答了图中是否有环，对于这个问题来说，使用拓扑排序找到多余的一条边是相对麻烦的。但是拓扑排序中的重要概念<strong>结点的入度</strong>可以帮助解决这个问题。</p>
<p><strong>什么是有根树</strong>：</p>
<p>有根树指满足以下条件的<strong>有向图</strong>。该树<strong>只有</strong>一个根结点，<strong>所有其他结点都是该根结点的后继</strong>。每一个结点<strong>只有</strong> 一个父结点，除了根结点没有父结点。</p>
<p>树区别与图的特点是：没有环（不论是对于有向边还是无向边）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110842.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<p>由此，可以归纳出，有根树的特点：</p>
<ul>
<li>只有唯一的一个入度为 0 的结点，它是根结点；</li>
<li>不是根结点的其它所有的结点入度为 1；</li>
<li>不可能存在入度为 2 的结点。</li>
</ul>
<p><strong>结合示例分析</strong>：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20210108110953.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>根据示例 1 ，不能有入度为 2 的结点；<br>根据示例 2 ，在不能有入度为 2 的结点的前提下，不能形成回路。</p>
<p>为此设计算法如下：</p>
<ul>
<li>先统计每一个结点的入度，如果有入度为 2 的结点，考虑删除一条边（根据题目意思，删除的是输入的边的列表中最后出现的），剩下的<strong>有向边</strong>是否形成回路（形成环）。如果不能形成环，就应该删除这条边；</li>
<li>在没有入度为 2 的结点的前提下，尝试删除形成入度为 1 的<strong>有向边</strong>（不能删除入度为 0 的有向边），判断剩下的<strong>有向边</strong>是否形成环。</li>
</ul>
<p>说明：在没有入度为 2 的结点的情况下（结合示例 2 来理解），判断有向图是否形成回路，可以把有向图当成无向图来看，因此可以使用<strong>并查集</strong>。</p>
<p><strong>编码说明</strong>：</p>
<ul>
<li>这个问题里，题目输入的边的条数等于结点的个数，因为就是刚刚好多了 1 条边，题目才让删，3 个顶点的有根树只可能有 2 条边，注意代码中 +1 是因为从 1 开始计算；</li>
<li>题目要求，有多个结果的时候，返回 <code>edges</code> 里最后出现的边，因此<strong>从后向前遍历</strong>，删除某条边的意思是：不把它加入并查集。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantDirectedConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        <span class="hljs-comment">// 边的条数（在这个问题里等于结点个数）</span><br>        <span class="hljs-type">int</span> len=edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 步骤 1：预处理入度数组（记录指向某个结点的边的条数）</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;edge:edges)<br>            ++inDegree[edge[<span class="hljs-number">1</span>]];<br>        <span class="hljs-comment">// 步骤 2：先尝试删除构成入度为 2 的边，看看是否形成环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-comment">// 如果不构成环，这条边就是要去掉的那条边</span><br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judgeCircle</span>(edges,len,i))<br>                    <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 步骤 3：再尝试删除构成入度为 1 的边，看看是否形成环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[edges[i][<span class="hljs-number">1</span>]]==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-comment">// 如果不构成环，这条边就是要去掉的那条边</span><br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judgeCircle</span>(edges,len,i))<br>                    <span class="hljs-keyword">return</span> edges[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 removeEdgeIndex 去掉以后，剩下的有向边是否构成环</span><br>    <span class="hljs-comment">// len：结点总数（从 1 开始，因此初始化的时候 + 1）</span><br>    <span class="hljs-comment">// removeEdgeIndex：删除的边的下标</span><br>    <span class="hljs-comment">// 构成环，返回 true</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeCircle</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;edges,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> removeEdgeIndex)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(len+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i==removeEdgeIndex)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 合并失败，表示 edges[i][0] 和 edges[i][1] 在一个连通分量里，即构成了环</span><br>            <span class="hljs-keyword">if</span>(!uf.<span class="hljs-built_in">unionTree</span>(edges[i][<span class="hljs-number">0</span>],edges[i][<span class="hljs-number">1</span>]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="399-除法求值-medium"><a href="#399-除法求值-medium" class="headerlink" title="399. 除法求值[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a>[medium]</h1><h2 id="解法：并查集-3"><a href="#解法：并查集-3" class="headerlink" title="解法：并查集"></a>解法：并查集</h2><blockquote>
<p>由于 <strong>变量之间的倍数关系具有传递性</strong>，处理有传递性关系的问题，可以使用「并查集」，需要在并查集的「合并」与「查询」操作中 <strong>维护这些变量之间的倍数关系</strong>。</p>
</blockquote>
<p>详细思路参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/">官方解答</a>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; weight;<span class="hljs-comment">//指向的父结点的权值</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            weight.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1.0</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x!=parent[x])<br>        &#123;<br>            <span class="hljs-type">int</span> origin=parent[x];<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=<span class="hljs-built_in">find</span>(parent[x]);<br>            weight[x]*=weight[origin];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q,<span class="hljs-type">double</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        parent[rootP]=rootQ;<br>        weight[rootP]=weight[q]*value/weight[p];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span> weight[p]/weight[q];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-type">int</span> equationSize=equations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(<span class="hljs-number">2</span>*equationSize)</span></span>;<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码</span><br>        unordered_map&lt;string,<span class="hljs-type">int</span>&gt; dict;<br>        <span class="hljs-type">int</span> id=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;equationSize;++i)<br>        &#123;<br>            string var1=equations[i][<span class="hljs-number">0</span>];<br>            string var2=equations[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var1)==<span class="hljs-number">0</span>)<br>            &#123;<br>                dict[var1]=id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var2)==<span class="hljs-number">0</span>)<br>            &#123;<br>                dict[var2]=id;<br>                ++id;<br>            &#125;<br>            uf.<span class="hljs-built_in">unionTree</span>(dict[var1],dict[var2],values[i]);<br>        &#125;<br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        vector&lt;<span class="hljs-type">double</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;queries.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            string var1=queries[i][<span class="hljs-number">0</span>];<br>            string var2=queries[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(dict.<span class="hljs-built_in">count</span>(var1)==<span class="hljs-number">0</span>||dict.<span class="hljs-built_in">count</span>(var2)==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1.0</span>);<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(uf.<span class="hljs-built_in">isConnected</span>(dict[var1],dict[var2]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="785-判断二分图-medium"><a href="#785-判断二分图-medium" class="headerlink" title="785. 判断二分图[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a>[medium]</h1><blockquote>
<p>染色问题。</p>
</blockquote>
<h2 id="解法一：BFS-1"><a href="#解法一：BFS-1" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><p>使用图搜索算法从各个连通域的任一顶点开始遍历整个连通域，遍历的过程中用两种不同的颜色对顶点进行染色，相邻顶点染成相反的颜色。这个过程中倘若发现相邻的顶点被染成了相同的颜色，说明它不是二分图；反之，如果所有的连通域都染色成功，说明它是二分图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-comment">// 因为图中可能含有多个连通域，所以需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 bfs 染色</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            visited[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 每出队一个顶点，将其所有邻接点染成相反的颜色并入队</span><br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>                &#123;<br>                    <span class="hljs-comment">// 如果当前顶点的某个邻接点已经被染过色了，且颜色和当前顶点相同，说明此无向图无法被正确染色，返回 false</span><br>                    <span class="hljs-keyword">if</span>(visited[neighbour]==visited[cur])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(visited[neighbour]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        visited[neighbour]=-visited[cur];<br>                        q.<span class="hljs-built_in">push</span>(neighbour);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：DFS-1"><a href="#解法二：DFS-1" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><p>思路与 BFS 相同，只是搜索方式不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 因为图中可能含有多个连通域，所以需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 dfs 染色</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(visited[i]==<span class="hljs-number">0</span>&amp;&amp;!<span class="hljs-built_in">dfs</span>(graph,visited,i,<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;graph,vector&lt;<span class="hljs-type">int</span>&gt; &amp;visited,<span class="hljs-type">int</span> cur,<span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果要对某顶点染色时，发现它已经被染色了，则判断它的颜色是否与本次要染的颜色相同，如果矛盾，说明此无向图无法被正确染色，返回 false</span><br>        <span class="hljs-keyword">if</span>(visited[cur]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> visited[cur]==color;<br>        <span class="hljs-comment">// 对当前顶点进行染色，并将当前顶点的所有邻接点染成相反的颜色</span><br>        visited[cur]=color;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(graph,visited,neighbour,-color))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法三：并查集"><a href="#解法三：并查集" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h2><p>如果是二分图的话，那么图中每个顶点的所有邻接点都应该属于同一集合，且不与顶点处于同一集合。因此可以使用并查集来解决这个问题：遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点已经和当前顶点处于同一个集合中了，若是，则说明不是二分图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=graph.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-comment">// 遍历每个顶点，将当前顶点的所有邻接点进行合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[i])<br>            &#123;<br>                <span class="hljs-comment">// 若某个邻接点与当前顶点已经在一个集合中了，说明不是二分图，返回 false</span><br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(neighbour,i))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                uf.<span class="hljs-built_in">unionTree</span>(graph[i][<span class="hljs-number">0</span>],neighbour);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="886-可能的二分法-medium"><a href="#886-可能的二分法-medium" class="headerlink" title="886. 可能的二分法[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a>[medium]</h1><blockquote>
<p>染色问题。</p>
</blockquote>
<h2 id="解法：BFS、DFS、并查集"><a href="#解法：BFS、DFS、并查集" class="headerlink" title="解法：BFS、DFS、并查集"></a>解法：BFS、DFS、并查集</h2><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a> 相似。那道题给的是建好的邻接表，但是本质上和这道题是一样的，同一条边上的两点是不能在同一个集合中的，那么这就相当于本题中的 dislike 的关系，也可以把每个 dislike 看作是一条边，那么两端的两个人不能在同一个集合中。跟之前的题相比，这里唯一不同的就是邻接表没有建好，需要自己去建。这里只给出 BFS 代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">possibleBipartition</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;<br>        <span class="hljs-comment">// 编号从1开始</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(N+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 建立无向邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;dislike:dislikes)<br>        &#123;<br>            graph[dislike[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(dislike[<span class="hljs-number">1</span>]);<br>            graph[dislike[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(dislike[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">colors</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(colors[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            q.<span class="hljs-built_in">push</span>(i);<br>            colors[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;neighbour:graph[cur])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(colors[neighbour]==colors[cur])<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span>(colors[neighbour]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        colors[neighbour]=-colors[cur];<br>                        q.<span class="hljs-built_in">push</span>(neighbour);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="1042-不邻接植花-medium"><a href="#1042-不邻接植花-medium" class="headerlink" title="1042. 不邻接植花[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/">1042. 不邻接植花</a>[medium]</h1><h2 id="解法：染色问题"><a href="#解法：染色问题" class="headerlink" title="解法：染色问题"></a>解法：染色问题</h2><ol>
<li>根据 paths 建立邻接表；</li>
<li>默认所有的花园先不染色，即染 0；</li>
<li>从第一个花园开始走，把与它邻接的花园的颜色从 color{1,2,3,4} 这个颜色集中删除；</li>
<li>删完了所有与它相邻的颜色，就可以把集合中剩下的颜色随机选一个给它了，为了简单，将集合中的第一个颜色赋给当前花园；</li>
<li>循环 3 和 4 到最后一个花园。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">gardenNoAdj</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;<br>        <span class="hljs-comment">// 编号从1开始</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 建立无向邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;path:paths)<br>        &#123;<br>            graph[path[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(path[<span class="hljs-number">1</span>]);<br>            graph[path[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(path[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-comment">// 初始化全部未染色</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            set&lt;<span class="hljs-type">int</span>&gt; color&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br>            <span class="hljs-comment">// 把已染过色的去除</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> neighbour:graph[i])<br>                color.<span class="hljs-built_in">erase</span>(res[neighbour<span class="hljs-number">-1</span>]);<br>            <span class="hljs-comment">// 染色</span><br>            res[i<span class="hljs-number">-1</span>]=*color.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="997-找到小镇的法官-easy"><a href="#997-找到小镇的法官-easy" class="headerlink" title="997. 找到小镇的法官[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a>[easy]</h1><h2 id="解法：入度和出度"><a href="#解法：入度和出度" class="headerlink" title="解法：入度和出度"></a>解法：入度和出度</h2><h3 id="思路一：两个数组"><a href="#思路一：两个数组" class="headerlink" title="思路一：两个数组"></a>思路一：两个数组</h3><p>有向图问题。法官实际上就是出度为 0，入度为 N - 1 的节点。因此一个思路就是统计所有人的入度和出度信息，将满足条件的节点输出。用两个数组 inDegree 和 outDegree 分别记录入度和出度的信息，为了简单起见，初始化的数组长度为 N + 1，而不是 N。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inDegree</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">outDegree</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:trust)<br>        &#123;<br>            ++inDegree[elem[<span class="hljs-number">1</span>]];<br>            ++outDegree[elem[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inDegree[i]==N<span class="hljs-number">-1</span>&amp;&amp;outDegree[i]==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="思路二：一个数组"><a href="#思路二：一个数组" class="headerlink" title="思路二：一个数组"></a>思路二：一个数组</h3><p>换个角度来思考，<strong>法官同样是 入度 - 出度 &#x3D;&#x3D; N - 1 的点</strong>，并且不是法官的人不可能是。这样无需同时维护入度和出度的信息，转而维护 <code>入读和出度的差值</code> 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findJudge</span><span class="hljs-params">(<span class="hljs-type">int</span> N, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:trust)<br>        &#123;<br>            ++cnt[elem[<span class="hljs-number">1</span>]];<br>            --cnt[elem[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;N+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt[i]==N<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="433-最小基因变化-medium"><a href="#433-最小基因变化-medium" class="headerlink" title="433. 最小基因变化[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化</a>[medium]</h1><p>整体思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a> 相似。</p>
<h2 id="解法一：BFS-2"><a href="#解法一：BFS-2" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h2><p>具体步骤如下：</p>
<ul>
<li>把 begin 放入队列中；</li>
<li>出队一个元素，修改这个元素上第一字母，修改值在这四个字母中选择<code>&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;</code>，四个字母都遍历一遍，如果和最后一个元素匹配，那么就退出，返回当前的层级（step）加一，如果修改后元素的在 bank 中出现，那么就放入队列中，同时删除 bank 中的相同的元素；</li>
<li>然后把第一个元素还原原先的字母，然后开始修改第二个字母。执行和第2步一致。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">bankset</span><span class="hljs-params">(bank.begin(),bank.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(end)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        queue&lt;string&gt; q;<br>        vector&lt;<span class="hljs-type">char</span>&gt; str&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        q.<span class="hljs-built_in">push</span>(start);<br>        bankset.<span class="hljs-built_in">erase</span>(start);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                string cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cur.<span class="hljs-built_in">size</span>();++j)<br>                &#123;<br>                    <span class="hljs-type">char</span> old=cur[j];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>                    &#123;<br>                        cur[j]=str[k];<br>                        <span class="hljs-keyword">if</span>(cur==end)<br>                            <span class="hljs-keyword">return</span> steps+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                        &#123;<br>                            q.<span class="hljs-built_in">push</span>(cur);<br>                            bankset.<span class="hljs-built_in">erase</span>(cur);<br>                        &#125;<br>                    &#125;<br>                    cur[j]=old;<br>                &#125;<br>            &#125;<br>            ++steps;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：双向BFS"><a href="#解法二：双向BFS" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h2><p>用两个 set 从两个方向来进行 BFS。具体走过的路径会比较少，一般来说会减少一倍的路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMutation</span><span class="hljs-params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">bankset</span><span class="hljs-params">(bank.begin(),bank.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(end)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;<span class="hljs-type">char</span>&gt; str=&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;G&#x27;</span>,<span class="hljs-string">&#x27;T&#x27;</span>&#125;;<br>        unordered_set&lt;string&gt; left&#123;start&#125;;<br>        unordered_set&lt;string&gt; right&#123;end&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>()&amp;&amp;!right.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//优先选择小的哈希表进行扩散</span><br>            <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">size</span>()&gt;right.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                unordered_set&lt;string&gt; temp=left;<br>                left=right;<br>                right=temp;<br>            &#125;<br>            unordered_set&lt;string&gt; nextLevel;<br>            <span class="hljs-keyword">for</span>(string item:left)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;item.<span class="hljs-built_in">size</span>();++i)<br>                &#123;<br>                    <span class="hljs-type">char</span> old=item[i];<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                    &#123;<br>                        item[i]=str[j];<br>                        <span class="hljs-keyword">if</span>(right.<span class="hljs-built_in">count</span>(item)!=<span class="hljs-number">0</span>)<br>                            <span class="hljs-keyword">return</span> steps+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bankset.<span class="hljs-built_in">count</span>(item)!=<span class="hljs-number">0</span>)<br>                        &#123;<br>                            bankset.<span class="hljs-built_in">erase</span>(item);<br>                            nextLevel.<span class="hljs-built_in">insert</span>(item);<br>                        &#125;<br>                    &#125;<br>                    item[i]=old;<br>                &#125;<br>            &#125;<br>            left=nextLevel;<br>            ++steps;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="863-二叉树中所有距离为-K-的结点-medium"><a href="#863-二叉树中所有距离为-K-的结点-medium" class="headerlink" title="863. 二叉树中所有距离为 K 的结点[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a>[medium]</h1><h2 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h2><p>这道题让返回所有跟目标结点 target 相距 K 的结点。在子树中寻找距离为 K 的结点很容易，只需要一层一层的向下遍历即可，难点就在于符合题意的结点有可能是祖先结点，或者是在旁边的兄弟子树中，这就比较麻烦了，因为二叉树只有从父结点到子结点的路径，反过来就不行。既然没有，就手动创建这样的反向连接，这样树的遍历问题就转为了图的遍历（树也是一种特殊的图）。建立反向连接就是用一个 HashMap 来建立每个结点和其父结点之间的映射，使用先序遍历建立好所有的反向连接，然后再开始查找和目标结点距离 K 的所有结点，这里需要一个 HashSet 来记录所有已经访问过了的结点。</p>
<p>在递归函数中，首先判断当前结点是否已经访问过，是的话直接返回，否则就加入到 visited 中。再判断此时 K 是否为 0，是的话说明当前结点已经是距离目标结点为 K 的点了，将其加入结果 res 中，然后直接返回。否则分别对当前结点的左右子结点调用递归函数，注意此时带入 K-1，这两步是对子树进行查找。之前说了，还得对父结点，以及兄弟子树进行查找，这是就体现出建立的反向连接 HashMap 的作用了，若当前结点的父结点存在，也要对其父结点调用递归函数，并同样带入 K-1，这样就能正确的找到所有满足题意的点了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;TreeNode*,TreeNode*&gt; parent;<br>        unordered_set&lt;TreeNode*&gt; visited;<br>        <span class="hljs-built_in">findparent</span>(root,parent);<br>        <span class="hljs-built_in">dfs</span>(target,K,parent,visited,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findparent</span><span class="hljs-params">(TreeNode* node,unordered_map&lt;TreeNode*,TreeNode*&gt; &amp;parent)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>            parent[node-&gt;left]=node;<br>        <span class="hljs-keyword">if</span>(node-&gt;right)<br>            parent[node-&gt;right]=node;<br>        <span class="hljs-built_in">findparent</span>(node-&gt;left,parent);<br>        <span class="hljs-built_in">findparent</span>(node-&gt;right,parent);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> K,unordered_map&lt;TreeNode*,TreeNode*&gt; &amp;parent,unordered_set&lt;TreeNode*&gt; &amp;visited,vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        visited.<span class="hljs-built_in">insert</span>(node);<br>        <span class="hljs-keyword">if</span>(K==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node-&gt;left)<br>            <span class="hljs-built_in">dfs</span>(node-&gt;left,K<span class="hljs-number">-1</span>,parent,visited,res);<br>        <span class="hljs-keyword">if</span>(node-&gt;right)<br>            <span class="hljs-built_in">dfs</span>(node-&gt;right,K<span class="hljs-number">-1</span>,parent,visited,res);<br>        <span class="hljs-keyword">if</span>(parent[node])<br>            <span class="hljs-built_in">dfs</span>(parent[node],K<span class="hljs-number">-1</span>,parent,visited,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>解法二：BFS</p>
<p>既然是图的遍历，也可以使用 BFS 。为了方便起见，直接建立一个邻接链表，即每个结点最多有三个跟其相连的结点，左右子结点和父结点，使用一个 HashMap 来建立每个结点和其相邻的结点数组之间的映射，这样就几乎完全将其当作图来对待了，建立好邻接链表之后，原来的树的结构都不需要用了。既然是 BFS 进行层序遍历，就要使用队列 queue，还要一个 HashSet 来记录访问过的结点。在 while 循环中，若 K 为 0 了，说明当前这层的结点都是符合题意的，就把当前队列中所有的结点加入结果 res，并返回即可。否则就进行层序遍历，取出当前层的每个结点，并在邻接链表中找到和其相邻的结点，若没有访问过，就加入 visited 和 queue 中。每层遍历完成之后，K 自减 1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;TreeNode*,vector&lt;TreeNode*&gt;&gt; graph;<br>        <span class="hljs-built_in">findparent</span>(root,<span class="hljs-literal">nullptr</span>,graph);<br>        queue&lt;TreeNode*&gt; q;<br>        unordered_set&lt;TreeNode*&gt; visited;<br>        q.<span class="hljs-built_in">push</span>(target);<br>        visited.<span class="hljs-built_in">insert</span>(target);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">if</span>(K==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">front</span>()-&gt;val);<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;node:graph[cur])<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(node)!=<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    visited.<span class="hljs-built_in">insert</span>(node);<br>                    q.<span class="hljs-built_in">push</span>(node);<br>                &#125;<br>            &#125;<br>            --K;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findparent</span><span class="hljs-params">(TreeNode* node,TreeNode* pre,unordered_map&lt;TreeNode*,vector&lt;TreeNode*&gt;&gt; &amp;graph)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            graph[node].<span class="hljs-built_in">push_back</span>(pre);<br>            graph[pre].<span class="hljs-built_in">push_back</span>(node);<br>        &#125;<br>        <span class="hljs-built_in">findparent</span>(node-&gt;left,node,graph);<br>        <span class="hljs-built_in">findparent</span>(node-&gt;right,node,graph);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="743-网络延迟时间-medium"><a href="#743-网络延迟时间-medium" class="headerlink" title="743. 网络延迟时间[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>[medium]</h1><h2 id="解法：最短路径问题"><a href="#解法：最短路径问题" class="headerlink" title="解法：最短路径问题"></a>解法：最短路径问题</h2><p>最短路算法的分类：</p>
<ul>
<li>单源最短路<ul>
<li>所有边权都是正数<ul>
<li>朴素的Dijkstra算法 O(n^2) 适合稠密图</li>
<li>堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图</li>
</ul>
</li>
<li>存在负权边<ul>
<li>Bellman-Ford O(nm)</li>
<li>spfa 一般O(m),最坏O(nm)</li>
</ul>
</li>
</ul>
</li>
<li>多源汇最短路 Floyd算法 O(n^3)</li>
</ul>
<p>模版及思路参考 <a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/405/">y总算法基础课——常用代码模板3——搜索与图论</a>。</p>
<h3 id="实现一：朴素Dijkstra算法"><a href="#实现一：朴素Dijkstra算法" class="headerlink" title="实现一：朴素Dijkstra算法"></a>实现一：朴素Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n+<span class="hljs-number">1</span>,INF));<span class="hljs-comment">// 存储每条边</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INF)</span></span>;<span class="hljs-comment">// 距离起始点的最短距离</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;time:times)<br>            graph[time[<span class="hljs-number">0</span>]][time[<span class="hljs-number">1</span>]]=time[<span class="hljs-number">2</span>];<br>        dist[k]=<span class="hljs-number">0</span>;<span class="hljs-comment">// 起始点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> t=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>            &#123;<br>                <span class="hljs-comment">// 在还未确定最短路的点中，寻找到起始点距离最小的点</span><br>                <span class="hljs-keyword">if</span>(!visited[j]&amp;&amp;(t==<span class="hljs-number">-1</span>||dist[j]&lt;dist[t]))<br>                    t=j;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>                <span class="hljs-comment">// 用t更新其他点的距离</span><br>                dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+graph[t][j]);<br>            visited[t]=<span class="hljs-literal">true</span>;<span class="hljs-comment">// t号点的最短路已经确定</span><br>        &#125;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dist[i]==INF)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            res=<span class="hljs-built_in">max</span>(res,dist[i]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="实现二：堆优化版Dijkstra算法"><a href="#实现二：堆优化版Dijkstra算法" class="headerlink" title="实现二：堆优化版Dijkstra算法"></a>实现二：堆优化版Dijkstra算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; times, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,INF)</span></span>;<span class="hljs-comment">// 距离起始点的最短距离</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br>        <span class="hljs-keyword">using</span> PII=pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;;<br>        unordered_map&lt;<span class="hljs-type">int</span>,vector&lt;PII&gt;&gt; graph;<span class="hljs-comment">// 邻接表；u-&gt;v,权重w</span><br>        priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">// 小顶堆；维护到起始点的最短距离和点</span><br>        <span class="hljs-comment">// 初始化邻接表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;time:times)<br>            graph[time[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(time[<span class="hljs-number">1</span>],time[<span class="hljs-number">2</span>]));<br>        <span class="hljs-comment">// first存储距离，second存储节点编号</span><br>        heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,k&#125;);<br>        dist[k]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!heap.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t=heap.<span class="hljs-built_in">top</span>();<br>            heap.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> ver=t.second,distance=t.first;<br>            <span class="hljs-keyword">if</span>(visited[ver])<br>                <span class="hljs-comment">// 之前更新过，是冗余备份</span><br>                <span class="hljs-keyword">continue</span>;<br>            visited[ver]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 用t去更新其他点到起始点的最短距离</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;point:graph[ver])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(dist[point.first]&gt;distance+point.second)<br>                &#123;<br>                    dist[point.first]=distance+point.second;<br>                    heap.<span class="hljs-built_in">push</span>(&#123;dist[point.first],point.first&#125;);<br>                &#125;<br>            &#125;<br>        &#125;        <br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(dist[i]==INF)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            res=<span class="hljs-built_in">max</span>(res,dist[i]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="787-K-站中转内最便宜的航班-medium"><a href="#787-K-站中转内最便宜的航班-medium" class="headerlink" title="787. K 站中转内最便宜的航班[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">787. K 站中转内最便宜的航班[medium]</a></h1><h2 id="解法：最短路径问题-1"><a href="#解法：最短路径问题-1" class="headerlink" title="解法：最短路径问题"></a>解法：最短路径问题</h2><blockquote>
<p>有边数限制的最短路径问题使用Bellman-Ford算法较方便。</p>
</blockquote>
<p>模版及思路参考 <a target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/405/">y总算法基础课——常用代码模板3——搜索与图论</a>。</p>
<h3 id="实现：Bellman-Ford算法"><a href="#实现：Bellman-Ford算法" class="headerlink" title="实现：Bellman-Ford算法"></a>实现：Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; flights, <span class="hljs-type">int</span> src, <span class="hljs-type">int</span> dst, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> INF=<span class="hljs-number">0x3f3f3f</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n,INF)</span></span>;<br>        dist[src]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">backup</span><span class="hljs-params">(dist)</span></span>;<span class="hljs-comment">// backup数组为了防止串联</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;flight:flights)<br>                dist[flight[<span class="hljs-number">1</span>]]=<span class="hljs-built_in">min</span>(dist[flight[<span class="hljs-number">1</span>]],backup[flight[<span class="hljs-number">0</span>]]+flight[<span class="hljs-number">2</span>]);<span class="hljs-comment">// 仅用上一次迭代的结果来更新当前距离就不会发生串联</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(dist[dst]&gt;INF/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> dist[dst];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="332-重新安排行程-medium"><a href="#332-重新安排行程-medium" class="headerlink" title="332. 重新安排行程[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reconstruct-itinerary/">332. 重新安排行程</a>[medium]</h1><h2 id="解法：欧拉路径"><a href="#解法：欧拉路径" class="headerlink" title="解法：欧拉路径"></a>解法：欧拉路径</h2><blockquote>
<p>如果在一张图中，从一个点出发可以走完所有的边，则这个遍历走过的路径就叫欧拉路径。<br>可以理解为：一张图可以一笔画出来。</p>
</blockquote>
<p>Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：</p>
<ul>
<li>从起点出发，进行深度优先搜索。</li>
<li>每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。</li>
<li>如果没有可移动的路径，则将所在节点加入到栈中，并返回。</li>
</ul>
<p>实际是关于有向图的边的遍历，每张机票都是有向图的一条边。首先把图建立起来，通过邻接链表来建立。由于题目要求解法按字母顺序小的，那么考虑用multiset，可以自动排序。等图建立好了以后，从节点JFK开始遍历，只要当前节点映射的multiset里有节点，就取出这个节点，将其在multiset里删掉，然后继续递归遍历这个节点。由于题目中限定了一定会有解，那么等图中所有的multiset中都没有节点的时候，把当前节点存入结果中，然后再一层层回溯回去，将当前节点都存入结果，那么最后结果中存的顺序和需要的是相反的，再翻转一下即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        unordered_map&lt;string,multiset&lt;string&gt;&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;elem:tickets)<br>            m[elem[<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(elem[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">dfs</span>(m,<span class="hljs-string">&quot;JFK&quot;</span>,res);<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;string,multiset&lt;string&gt;&gt; &amp;m,string s,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(m[s].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            string tmp=*m[s].<span class="hljs-built_in">begin</span>();<br>            m[s].<span class="hljs-built_in">erase</span>(m[s].<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-built_in">dfs</span>(m,tmp,res);<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(s);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Graph/">Graph</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/03/Leetcode%20Notes%E2%80%94%E2%80%94Math/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Math</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/15/Leetcode%20Notes%E2%80%94%E2%80%94Divide%20and%20Conquer/">
                        <span class="hidden-mobile">Leetcode Notes——Divide and Conquer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
