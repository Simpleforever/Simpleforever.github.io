

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己剑指 offer 的刷题记录。部分内容搬运自 cyc2018 、Jack-Cherish、light-city 博客以及 Leetcode-cn 部分大佬题解，其中特别鸣谢 Krahets 大佬提供了非常清晰、详细的解答过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer题解">
<meta property="og:url" content="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己剑指 offer 的刷题记录。部分内容搬运自 cyc2018 、Jack-Cherish、light-city 博客以及 Leetcode-cn 部分大佬题解，其中特别鸣谢 Krahets 大佬提供了非常清晰、详细的解答过程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221222.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221536.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221356.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221512.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221710.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221823.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221939.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095922.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095932.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095941.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095953.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100001.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100007.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100015.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100021.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100028.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100036.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100048.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100055.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100109.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100121.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100126.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100135.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100152.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100211.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724101030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100238.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100348.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100356.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100404.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100418.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100449.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100521.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100530.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110816.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110721.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105552.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105514.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105313.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105128.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105054.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104621.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104527.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104349.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104257.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104152.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104034.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103829.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103637.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103608.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103555.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103545.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103304.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103253.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200727104447.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103157.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103058.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102529.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102515.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102447.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102432.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102413.gif">
<meta property="article:published_time" content="2020-07-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-27T12:50:38.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221222.gif">
  
  
  <title>剑指offer题解 - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://w.wallhaven.cc/full/3z/wallhaven-3zj7ey.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="剑指offer题解">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-22 00:00" pubdate>
        2020年7月22日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      101k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      843 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">剑指offer题解</h1>
            
            <div class="markdown-body">
              <p>记录一下自己剑指 offer 的刷题记录。部分内容搬运自 <a target="_blank" rel="noopener" href="https://cyc2018.github.io/CS-Notes/#/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%951">cyc2018</a> 、<a target="_blank" rel="noopener" href="https://github.com/Jack-Cherish/LeetCode">Jack-Cherish</a>、<a target="_blank" rel="noopener" href="https://light-city.club/">light-city</a> 博客以及 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 部分大佬题解，其中特别鸣谢 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/jyd/">Krahets</a> 大佬提供了非常清晰、详细的解答过程。</p>
<span id="more"></span>

<h1 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1.二维数组中的查找"></a>1.二维数组中的查找</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs html">Consider the following matrix:<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br><br>Given target = 5, return true.<br>Given target = 20, return false.<br></code></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p>
<p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221222.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> row = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> col = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(row&lt;array.<span class="hljs-built_in">size</span>()&amp;&amp;col&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(array[row][col]==target)<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[row][col]&lt;target)<br>                row++;<br>            <span class="hljs-keyword">else</span><br>                col--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">Input:<br>&quot;We Are Happy&quot;<br><br>Output:<br>&quot;We%20Are%20Happy&quot;<br></code></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>最简单的方法就是从头到尾遍历，在每一次碰到空格字符的时候都做替换，并且由于是把 1 个字符替换成 3 个字符，那么每次替换一个空格后都需要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖。假设字符串的长度是 n 。对每个空格字符，需要移动后面 O(n) 个字符，因此对含有 O(n) 个空格字符的字符串而言总的时间复杂度是 O(n^2) 。</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。</p>
<p>② 准备两个指针，P1 和 P2 。令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），同时把 P2 向前移动三个位置，否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p>
<p>移动示意图：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221536.jpg" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<p>③ 当 P2 遇到 P1 时（P2 &lt;&#x3D; P1），或者遍历结束（P1 &lt; 0），退出。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221356.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>解法二的时间复杂度为 O(n)  级别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replaceSpace</span><span class="hljs-params">(<span class="hljs-type">char</span> *str,<span class="hljs-type">int</span> length)</span> </span>&#123;<br>        <span class="hljs-type">int</span> spacenum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            spacenum++;<br>        &#125;<br>        <span class="hljs-type">int</span> newlength=length+<span class="hljs-number">2</span>*spacenum;<br>        <span class="hljs-type">int</span> p1=length<span class="hljs-number">-1</span>,p2=newlength<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(p1&gt;=<span class="hljs-number">0</span>&amp;&amp;p2&gt;p1)<br>        &#123;<br>            <span class="hljs-type">char</span> c = str[p1--];<br>            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;<br>                str[p2--]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>                str[p2--]=<span class="hljs-string">&#x27;2&#x27;</span>;<br>                str[p2--]=<span class="hljs-string">&#x27;%&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                str[p2--]=c;<br>        &#125;          <br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221512.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用栈"><a href="#解法一：使用栈" class="headerlink" title="解法一：使用栈"></a>解法一：使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221710.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  struct ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        struct ListNode *next;</span><br><span class="hljs-comment">*        ListNode(int x) :</span><br><span class="hljs-comment">*              val(x), next(NULL) &#123;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*  &#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         vector &lt;<span class="hljs-type">int</span>&gt; result;<br>         stack&lt;<span class="hljs-type">int</span>&gt; node;<br>         ListNode* p=head;<br>         <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)<br>         &#123;<br>              node.<span class="hljs-built_in">push</span>(p-&gt;val);<br>              p=p-&gt;next;<br>         &#125;<br>         <span class="hljs-keyword">while</span>(!node.<span class="hljs-built_in">empty</span>())<br>         &#123;<br>           result.<span class="hljs-built_in">push_back</span>(node.<span class="hljs-built_in">top</span>());  <br>           node.<span class="hljs-built_in">pop</span>();<br>         &#125;<br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：使用递归"><a href="#解法二：使用递归" class="headerlink" title="解法二：使用递归"></a>解法二：使用递归</h3><p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>         ListNode* p=head;<br>         <span class="hljs-keyword">if</span>(p!=<span class="hljs-literal">NULL</span>)<br>         &#123;<br>             <span class="hljs-keyword">if</span>(p-&gt;next!=<span class="hljs-literal">NULL</span>)<br>                 <span class="hljs-built_in">printListFromTailToHead</span>(p-&gt;next);<br>             result.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>         &#125;<br>         <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：反转链表"><a href="#解法三：反转链表" class="headerlink" title="解法三：反转链表"></a>解法三：反转链表</h3><p>首先准备一个 pre 结点初始指向 nullptr ，表示正在反转结点的前一个结点，再准备一个 cur ，表示当前正在反转的结点，cur 初始化为head 。最后再准备一个 temp ，表示还未反转的第一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        ListNode* temp=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            temp=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=temp;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">while</span>(pre!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            result.<span class="hljs-built_in">push_back</span>(pre-&gt;val);<br>            pre=pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法四：使用头插法"><a href="#解法四：使用头插法" class="headerlink" title="解法四：使用头插法"></a>解法四：使用头插法</h3><p>头插法顾名思义是将节点插入到头部：在遍历原始链表时，将当前节点插入新链表的头部，使其成为第一个节点。</p>
<p>链表的操作需要维护后继关系，例如在某个节点 node1 之后插入一个节点 node2，我们可以通过修改后继关系来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">node3 = node1.next;<br>node2.next = node3;<br>node1.next = node2;<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221823.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>为了能将一个节点插入头部，引入了一个叫头结点的辅助节点，该节点不存储值，只是为了方便进行插入操作。不要将头结点与第一个节点混起来，第一个节点是链表中第一个真正存储值的节点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200722221939.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title function_">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> &#123;<br>    <span class="hljs-comment">// 头插法构建逆序链表</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (listNode != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">memo</span> <span class="hljs-operator">=</span> listNode.next;<br>        listNode.next = head.next;<br>        head.next = listNode;<br>        listNode = memo;<br>    &#125;<br>    <span class="hljs-comment">// 构建 ArrayList</span><br>    ArrayList&lt;Integer&gt; ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    head = head.next;<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        ret.add(head.val);<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095922.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>通常树有如下几种遍历方式：</p>
<ul>
<li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。</li>
<li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。</li>
<li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。</li>
</ul>
<p>本题为前序遍历和中序遍历，最少需要两种遍历方式，才能重建二叉树。</p>
<p>前序遍历序列的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095932.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pre,vector&lt;<span class="hljs-type">int</span>&gt; vin)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pre.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)  <span class="hljs-comment">//如果为空，返回NULL</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>         <span class="hljs-comment">//依次是先序遍历左子树，先序遍历右子树，中序遍历左子树，中序遍历右子树</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; left_pre,right_pre,left_vin,right_vin;<br>        <span class="hljs-comment">//先序遍历第一个节点一定为根节点</span><br>        TreeNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[<span class="hljs-number">0</span>]);<br>       <span class="hljs-comment">//找到中序遍历的根节点</span><br>        <span class="hljs-type">int</span> root=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vin.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vin[i]==pre[<span class="hljs-number">0</span>])<br>            &#123;<br>                root=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>         <span class="hljs-comment">//利用中序遍历的根节点，对二叉树节点进行归并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;root;i++)<br>        &#123;<br>            left_pre.<span class="hljs-built_in">push_back</span>(pre[i+<span class="hljs-number">1</span>]);<span class="hljs-comment">//先序遍历第一个为根节点</span><br>            left_vin.<span class="hljs-built_in">push_back</span>(vin[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=root+<span class="hljs-number">1</span>;i&lt;vin.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            right_pre.<span class="hljs-built_in">push_back</span>(pre[i]);<br>            right_vin.<span class="hljs-built_in">push_back</span>(vin[i]);<br>        &#125;<br>        <span class="hljs-comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span><br>        head-&gt;left=<span class="hljs-built_in">reConstructBinaryTree</span>(left_pre,left_vin);<br>        head-&gt;right=<span class="hljs-built_in">reConstructBinaryTree</span>(right_pre,right_vin);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h1><h2 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈（stack1）用来处理入栈（push）操作，out 栈（stack2）用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<p>因此整体思路为：当 out 栈不为空时， out 栈的栈顶元素是最先进入队列的元素，可以弹出。如果 out 栈为空，就把 in 栈中的元素全部弹出并压入 out 栈。由于先进入队列的元素被压到 in 栈的栈底，经过弹出和压入之后就处于 out 栈的栈顶，可以直接弹出。如果有新元素插入，直接把它压入 in 栈即可。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095941.gif" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> node)</span> </span>&#123;<br>        stack1.<span class="hljs-built_in">push</span>(node);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(!stack1.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                stack2.<span class="hljs-built_in">push</span>(stack1.<span class="hljs-built_in">top</span>());<br>                stack1.<span class="hljs-built_in">pop</span>();<br>            &#125;                <br>        &#125; <br>        <span class="hljs-type">int</span> node=stack2.<span class="hljs-built_in">top</span>();<br>        stack2.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack1;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack2;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><h2 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095947.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直观的解法是从头到尾遍历数组一次，轻轻松松就能找出最小的元素。这种思路的时间复杂度为O(n) 。</p>
<p>一般，O(n) 复杂度的优化是往二分查找这个思路上去考虑的。</p>
<p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)（为了方便，这里将 log2N 写为 logN）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095953.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p>
<p>通过修改二分查找算法进行求解（left 代表 low，mid 代表 mid，right 代表 high）：</p>
<ul>
<li>当 nums[mid] &lt;&#x3D; nums[right] 时，表示 [mid, right] 区间内的数组是非递减数组，[left, mid] 区间内的数组是旋转数组，此时令 right &#x3D; mid；</li>
<li>否则 [mid+ 1, right] 区间内的数组是旋转数组，令 left &#x3D; mid+ 1。</li>
</ul>
<p>如果数组元素允许重复，会出现一个特殊的情况：nums[left] &#x3D;&#x3D; nums[mid] &#x3D;&#x3D; nums[right]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，left、mid 和 right 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; rotateArray)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(rotateArray.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=rotateArray.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(rotateArray[left]==rotateArray[mid]&amp;&amp;rotateArray[mid]==rotateArray[right])<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">minNumber</span>(rotateArray,left,right);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rotateArray[mid]&lt;rotateArray[right])<br>                right=mid;<br>            <span class="hljs-keyword">else</span><br>                left=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rotateArray[left];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> min=nums[left];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left+<span class="hljs-number">1</span>;i&lt;right;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;min)<br>                min=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><h2 id="题目链接-6"><a href="#题目链接-6" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&&tqId=11160&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1），n&lt;&#x3D;39。即</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100001.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><h3 id="解法一：使用递归"><a href="#解法一：使用递归" class="headerlink" title="解法一：使用递归"></a>解法一：使用递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">Fibonacci</span>(n<span class="hljs-number">-2</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。而且重复的结点数会随着 n 的增加而急剧增加，这意味计算量会随着 n 的增加而急剧增大。其复杂度是指数级的，为$O(1.6180^n)$。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100007.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h3 id="解法二：记忆化搜索算法-x2F-动态规划法"><a href="#解法二：记忆化搜索算法-x2F-动态规划法" class="headerlink" title="解法二：记忆化搜索算法&#x2F;动态规划法"></a>解法二：记忆化搜索算法&#x2F;动态规划法</h3><p>记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。</p>
<p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>            dp[i]=dp[i<span class="hljs-number">-1</span>]+dp[i<span class="hljs-number">-2</span>];<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在时间复杂度为 O(n),空间复杂度为 O(n)。</p>
<h3 id="解法三：将空间复杂度降为O-1"><a href="#解法三：将空间复杂度降为O-1" class="headerlink" title="解法三：将空间复杂度降为O(1)"></a>解法三：将空间复杂度降为O(1)</h3><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> fib=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">0</span>,pre1=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        &#123;<br>            fib=pre2+pre1;<br>            pre2=pre1;<br>            pre1=fib;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fib;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><h2 id="题目链接-7"><a href="#题目链接-7" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100015.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n &#x3D; 1 时，只有一种跳法：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100021.png" srcset="/img/loading.gif" lazyload></p>
<p>当 n &#x3D; 2 时，有两种跳法：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100028.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100036.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloor</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">1</span>,pre1=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;i++)<br>        &#123;<br>            sum=pre2+pre1;<br>            pre2=pre1;<br>            pre1=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h1><h2 id="题目链接-8"><a href="#题目链接-8" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100048.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>下图来自灵魂画手@<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40662074/article/details/106573261">小鱼</a> 博客~</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100055.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h3 id="解法一：使用递归-1"><a href="#解法一：使用递归-1" class="headerlink" title="解法一：使用递归"></a>解法一：使用递归</h3><p>第 n 阶的小青蛙上一步可能来自于 0 到 n-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;i++)<br>                result+=<span class="hljs-built_in">jumpFloorII</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：数学推导"><a href="#解法二：数学推导" class="headerlink" title="解法二：数学推导"></a>解法二：数学推导</h3><p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去…，那么<br>$$<br>f(n-1) &#x3D; f(n-2) + f(n-3) + … + f(0)<br>$$<br>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去… ，那么<br>$$<br>f(n) &#x3D; f(n-1) + f(n-2) + … + f(0)<br>$$<br>综上可得<br>$$<br>f(n) - f(n-1) &#x3D; f(n-1)<br>$$<br>即<br>$$<br>f(n) &#x3D; 2*f(n-1)<br>$$<br>所以 f(n) 是一个等比数列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(--number)<br>            result*=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h1><h2 id="题目链接-9"><a href="#题目链接-9" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 $2<em>1$ 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 $2</em>1$ 的小矩形无重叠地覆盖一个 $2*n$ 的大矩形，总共有多少种方法？</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100109.gif" srcset="/img/loading.gif" lazyload></p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n 为 1 时，只有一种覆盖方法：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100115.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>当 n 为 2 时，有两种覆盖方法：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100121.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>要覆盖 $2<em>n$ 的大矩形，可以先覆盖 $2</em>1$ 的矩形，再覆盖 $2*(n-1)$ 的矩形；或者先覆盖 $2<em>2$ 的矩形，再覆盖 $2</em>(n-2)$ 的矩形。而覆盖 $2*(n-1)$ 和 $2*(n-2)$ 的矩形可以看成子问题。该问题的递推公式如下：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100126.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> number;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> pre2=<span class="hljs-number">1</span>,pre1=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;i++)<br>        &#123;<br>            sum=pre2+pre1;<br>            pre2=pre1;<br>            pre1=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="11-二进制中-1-的个数"><a href="#11-二进制中-1-的个数" class="headerlink" title="11.二进制中 1 的个数"></a>11.二进制中 1 的个数</h1><h2 id="题目链接-10"><a href="#题目链接-10" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一-1"><a href="#解法一-1" class="headerlink" title="解法一"></a>解法一</h3><p>将整数的每一位与 1 进行与运算，统计 1 的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>         <span class="hljs-type">int</span> num=<span class="hljs-number">1</span>;<br>         <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>         &#123;<br>             <span class="hljs-keyword">if</span>(n&amp;num)<br>                 count++;<br>             num&lt;&lt;=<span class="hljs-number">1</span>;<br>         &#125;<br>         <span class="hljs-keyword">return</span> count;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：n-amp-n-1"><a href="#解法二：n-amp-n-1" class="headerlink" title="解法二：n&amp;(n-1)"></a>解法二：n&amp;(n-1)</h3><p>如果一个整数不为 0，那么这个整数至少有一位是 1。如果把这个整数减 1，那么原来处在整数最右边的 1 就会变为 0，原来在1后面的所有的 0都会变成 1 (如果最右边的 1 后面还有 0 的话)。其余所有位将不会受到影响。</p>
<p>这个时候如果再把原来的整数和减去 1 之后的结果做与运算，从原来整数最右边一个 1 那一位开始所有位都会变成 0。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个 1 变成 0。即 n&amp;(n-1) 该位运算去除 n 的位级表示中最低的那一位。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">n</span>       : <span class="hljs-number">10110100</span><br><span class="hljs-attribute">n</span>-<span class="hljs-number">1</span>     : <span class="hljs-number">10110011</span><br><span class="hljs-attribute">n</span>&amp;(n-<span class="hljs-number">1</span>) : <span class="hljs-number">10110000</span><br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>         <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">while</span>(n!=<span class="hljs-number">0</span>)<br>         &#123;<br>            count++;<br>            n&amp;=(n<span class="hljs-number">-1</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> count;<br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>根据该方法的拓展得到， 判断一个数是否是2的幂：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">powerof2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> ((n &amp; (n<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><h2 id="题目链接-11"><a href="#题目链接-11" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。保证 base 和 exponent 不同时为 0。</p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归法（快速幂）"><a href="#解法一：递归法（快速幂）" class="headerlink" title="解法一：递归法（快速幂）"></a>解法一：递归法（快速幂）</h3><p>下面的讨论中 x 代表 base，n 代表 exponent。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100135.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>因为 $(x*x)^{n&#x2F;2}$ 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(exponent==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(exponent==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> base;<br>        <span class="hljs-type">bool</span> isNegative=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(exponent&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            exponent=-exponent;<br>            isNegative=<span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-type">double</span> pow=<span class="hljs-built_in">Power</span>(base*base,exponent/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(exponent%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)<br>            pow*=base;<br>        <span class="hljs-keyword">return</span> isNegative?<span class="hljs-number">1</span>/pow:pow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>空间复杂度：O(logn)，递归栈，因为要记住logn个变量。</p>
<h3 id="解法二：非递归的快速幂"><a href="#解法二：非递归的快速幂" class="headerlink" title="解法二：非递归的快速幂"></a>解法二：非递归的快速幂</h3><p>假设求$x^6$ ,已知6可以表示成二进制<code>110</code>，可以表示成 $6&#x3D;0<em>2^0+1</em>2^1+1<em>2^2$,所以$x^6$可以表示成$x^6&#x3D;x^{0</em>2^0+1<em>2^1+1</em>2^2}&#x3D;x^0<em>x^{1</em>2^1}<em>x^{1</em>2^2}$所以，对于二进制数，遇到位数是 1 的就乘到答案中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-type">double</span> base, <span class="hljs-type">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(exponent&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            base=<span class="hljs-number">1</span>/base;<br>            exponent=-exponent;<br>        &#125;<br>        <span class="hljs-type">double</span> x=base; <span class="hljs-comment">// 记录x^0, x^1, x^2 ...</span><br>        <span class="hljs-type">double</span> res=<span class="hljs-number">1.0</span>;<br>        <span class="hljs-keyword">while</span>(exponent)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(exponent&amp;<span class="hljs-number">1</span>)<br>                res*=x; <span class="hljs-comment">// 二进制位数是1的，乘进答案</span><br>            x*=x;<br>            exponent&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><h2 id="题目链接-12"><a href="#题目链接-12" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100144.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用辅助数组"><a href="#解法一：使用辅助数组" class="headerlink" title="解法一：使用辅助数组"></a>解法一：使用辅助数组</h3><p>创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> oddCnt=<span class="hljs-number">0</span>; <span class="hljs-comment">// 奇数个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:array)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                oddCnt++;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(array)</span></span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,j=oddCnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:copy)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                array[k++]=i;<br>            <span class="hljs-keyword">else</span><br>                array[j++]=i;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：稳定排序思想"><a href="#解法二：稳定排序思想" class="headerlink" title="解法二：稳定排序思想"></a>解法二：稳定排序思想</h3><p><strong>相对位置不变—&gt;保持稳定性；奇数位于前面，偶数位于后面 —&gt;存在判断，挪动元素位置；</strong>这些都和内部排序算法相似，考虑到具有稳定性的排序算法不多，例如冒泡排序，插入排序，归并排序等。</p>
<h4 id="冒泡排序思想"><a href="#冒泡排序思想" class="headerlink" title="冒泡排序思想"></a>冒泡排序思想</h4><p>使用冒泡思想，每次都将当前偶数上浮到当前最右边。时间复杂度 O(N^2)，空间复杂度 O(1)，时间换空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(array[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; array[j+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-built_in">swap</span>(array[j],array[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reOrderArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=array.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;length;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(array[j]%<span class="hljs-number">2</span>==<span class="hljs-number">0</span> &amp;&amp; array[j+<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>                    <span class="hljs-built_in">swap</span>(array[j],array[j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="14-链表中倒数第-K-个结点"><a href="#14-链表中倒数第-K-个结点" class="headerlink" title="14.链表中倒数第 K 个结点"></a>14.链表中倒数第 K 个结点</h1><h2 id="题目链接-13"><a href="#题目链接-13" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第 k 个结点。</p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100152.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pListHead, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* P1=pListHead, *P2=pListHead;<br>        <span class="hljs-keyword">while</span>(k--)<br>        &#123;<br>            <span class="hljs-comment">// 链表节点少于k</span><br>            <span class="hljs-keyword">if</span>(P1==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            P1=P1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(P1!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            P1=P1-&gt;next;<br>            P2=P2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> P2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><h2 id="题目链接-14"><a href="#题目链接-14" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead||!pHead-&gt;next)<br>            <span class="hljs-keyword">return</span> pHead;        <br>         <span class="hljs-comment">// 4-&gt;5-&gt;NULL   cur 5  head 4</span><br>        ListNode* head=<span class="hljs-built_in">ReverseList</span>(pHead-&gt;next);<br>        pHead-&gt;next-&gt;next=pHead; <span class="hljs-comment">// 5-&gt;4</span><br>        pHead-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 4-&gt;NULL</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>首先准备一个 pre 结点初始指向 NULL，表示正在反转结点的前一个结点，再准备一个 cur ，表示当前正在反转的结点，cur 初始化为head 。最后再准备一个 temp ，表示还未反转的第一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead||!pHead-&gt;next)<br>            <span class="hljs-keyword">return</span> pHead;<br>        ListNode* pre=<span class="hljs-literal">NULL</span>;<br>        ListNode* cur=pHead;<br>        ListNode* temp=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            temp=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h1><h2 id="题目链接-15"><a href="#题目链接-15" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100203.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。</p>
<p>两个链表都是排序好的，只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1) <span class="hljs-keyword">return</span> pHead2;<br>        <span class="hljs-keyword">if</span>(!pHead2) <span class="hljs-keyword">return</span> pHead1;<br>        <span class="hljs-keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)<br>        &#123;<br>            pHead1-&gt;next=<span class="hljs-built_in">Merge</span>(pHead1-&gt;next,pHead2);<br>            <span class="hljs-keyword">return</span> pHead1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            pHead2-&gt;next=<span class="hljs-built_in">Merge</span>(pHead1,pHead2-&gt;next);<br>            <span class="hljs-keyword">return</span> pHead2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)<br>空间复杂度：O(m+n),每一次递归，递归栈都会保存一个变量，最差情况会保存 (m+n) 个变量</p>
<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>使用归并排序思想。</p>
<blockquote>
<p>一般创建单链表，都会设一个虚拟头结点，也叫哨兵，因为这样每一个结点都有一个前驱结点。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode* pHead1, ListNode* pHead2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* vhead=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); <br>        ListNode* cur=vhead; <span class="hljs-comment">//设定虚拟头结点，也叫哨兵，前驱结点</span><br>        <span class="hljs-keyword">while</span>(pHead1!=<span class="hljs-literal">NULL</span> &amp;&amp; pHead2!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(pHead1-&gt;val&lt;=pHead2-&gt;val)<br>            &#123;<br>                cur-&gt;next=pHead1;<br>                pHead1=pHead1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;next=pHead2;<br>                pHead2=pHead2-&gt;next;<br>            &#125;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pHead1!=<span class="hljs-literal">NULL</span>)<br>            cur-&gt;next=pHead1;<br>        <span class="hljs-keyword">if</span>(pHead2!=<span class="hljs-literal">NULL</span>)<br>            cur-&gt;next=pHead2;<br>        cur=vhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> vhead;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n),m，n分别为两个单链表的长度<br>空间复杂度：O(1)</p>
<h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><h2 id="题目链接-16"><a href="#题目链接-16" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树 A，B，判断 B 是不是 A 的子结构（ps：我们约定空树不是任意一个树的子结构）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100211.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><p>要查找树 A 中是否存在和树 B 结构一样的子树，可以分为两步：第一步在树 A 中找到和 B 的根结点的值一样的结点 R，第二步再判断树 A 中以 R 为根节点的子树是不是包含和树 B 一样的结构。这里使用递归的方法即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-comment">// HasSubtree 寻找相同根节点：判断A、B根节点是否相同。相同就用 isSubTreeWithRoot 进一步判断；没找到就继续尝试A的左右子树。</span><br><span class="hljs-comment">//isSubTreeWithRoot 根节点相同的情况下，进一步判断：判断节点是否相同，相同则进一步比较左右树。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">bool</span> result=<span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//当Tree1和Tree2均不为空的时候</span><br>        <span class="hljs-keyword">if</span>(pRoot1!=<span class="hljs-literal">NULL</span> &amp;&amp; pRoot2!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-comment">//如果根节点相同，则进一步判断tree2是否为tree1的子树</span><br>            <span class="hljs-keyword">if</span>(pRoot1-&gt;val==pRoot2-&gt;val)<br>                result=<span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1,pRoot2);<br>            <span class="hljs-comment">//如果根节点不同，则去root的左子树中找</span><br>            <span class="hljs-keyword">if</span>(!result)<br>                result=<span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;left,pRoot2);<br>            <span class="hljs-comment">//如果左子树没找到，则去root的右子树中找</span><br>            <span class="hljs-keyword">if</span>(!result)<br>                result=<span class="hljs-built_in">HasSubtree</span>(pRoot1-&gt;right,pRoot2);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//如果根节点相同，进一步判断tree2是否为tree1的子树</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubTreeWithRoot</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//如果Tree2已经遍历完了都能对应的上，返回true</span><br>        <span class="hljs-keyword">if</span>(pRoot2==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span><br>        <span class="hljs-keyword">if</span>(pRoot1==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果其中有一个点没有对应上，返回false</span><br>        <span class="hljs-keyword">if</span>(pRoot1-&gt;val!=pRoot2-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;<span class="hljs-built_in">isSubTreeWithRoot</span>(pRoot1-&gt;right,pRoot2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><h2 id="题目链接-17"><a href="#题目链接-17" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724101030.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>把当前根节点的左右结点交换，然后以递归的方式进一步 mirror 左右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode *pTemp=pRoot-&gt;left;<br>        pRoot-&gt;left=pRoot-&gt;right;<br>        pRoot-&gt;right=pTemp;<br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;left);<br>        <span class="hljs-built_in">Mirror</span>(pRoot-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：非递归"><a href="#解法二：非递归" class="headerlink" title="解法二：非递归"></a>解法二：非递归</h3><h4 id="栈模拟二叉树的先序遍历"><a href="#栈模拟二叉树的先序遍历" class="headerlink" title="栈模拟二叉树的先序遍历"></a>栈模拟二叉树的先序遍历</h4><p>非递归版本，只需要模拟一次树遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(cur-&gt;left,cur-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="队列模拟二叉树的先序遍历"><a href="#队列模拟二叉树的先序遍历" class="headerlink" title="队列模拟二叉树的先序遍历"></a>队列模拟二叉树的先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Mirror</span><span class="hljs-params">(TreeNode *pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(cur-&gt;left,cur-&gt;right);<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><h2 id="题目链接-18"><a href="#题目链接-18" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下 4 * 4 矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg" srcset="/img/loading.gif" lazyload></p>
<h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>从左到右，再从上到下，再从右到左，最后从下到上遍历。打印一个矩阵某个正方形上的点的逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100238.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <span class="hljs-type">int</span> rows=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=cols<span class="hljs-number">-1</span>,top=<span class="hljs-number">0</span>,bottom=rows<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;=right&amp;&amp;top&lt;=bottom)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;=right;++i)<br>                result.<span class="hljs-built_in">push_back</span>(matrix[top][i]);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=top+<span class="hljs-number">1</span>;i&lt;=bottom;++i)<br>                result.<span class="hljs-built_in">push_back</span>(matrix[i][right]);<br>            <span class="hljs-keyword">if</span>(top!=bottom)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=right<span class="hljs-number">-1</span>;i&gt;=left;--i)<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[bottom][i]);<br>            <span class="hljs-keyword">if</span>(left!=right)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=bottom<span class="hljs-number">-1</span>;i&gt;top;--i)<br>                    result.<span class="hljs-built_in">push_back</span>(matrix[i][left]);<br>            left++,top++,right--,bottom--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="20-包含-min-函数的栈"><a href="#20-包含-min-函数的栈" class="headerlink" title="20.包含 min 函数的栈"></a>20.包含 min 函数的栈</h1><h2 id="题目链接-19"><a href="#题目链接-19" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 O(1）。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用 pop() 或者 min() 或者 top() 方法。</p>
<h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个 stack ，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。</p>
<p>（1）压入数据规则<br>假设当前数据为 value，先将其压入 dataStack。然后判断 dataStack 是否为空。<br>如果为空，则 value 也压入 minStack；如果不为空，则比较 value 和 minStack 的栈顶<br>元素中哪一个更小。<br>如果 value 更小或者两者相等，则 value 也压入 minStack；如果 minStack 中栈顶元素<br>小，则把 minStack 的栈顶元素重复压入 minStack ，即在栈顶元素上再压入一个栈顶元素。</p>
<p>举例：依次压入 3、4、5、1、2、1 的过程中，dataStack 和 minStack 的变化如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100328.png" srcset="/img/loading.gif" lazyload></p>
<p>（2）弹出数据规则<br>在 dataStack 中弹出数据，并弹出 minStack中的栈顶。</p>
<p>（3）获得栈顶元素</p>
<p>直接返回 dataStack 的栈顶元素。</p>
<p>（4）查询当前栈中的最小值操作<br>minStack 始终记录着 dataStack 中的最小值，所以 minStack 的栈顶元素始终是当前 dataStack  中的最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">if</span>(minStack.<span class="hljs-built_in">empty</span>())<br>            minStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(value&lt;=minStack.<span class="hljs-built_in">top</span>())<br>            minStack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-keyword">else</span><br>            minStack.<span class="hljs-built_in">push</span>(minStack.<span class="hljs-built_in">top</span>());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        dataStack.<span class="hljs-built_in">pop</span>();<br>        minStack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dataStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minStack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; dataStack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; minStack;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><h2 id="题目链接-20"><a href="#题目链接-20" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个辅助栈来模拟压入弹出操作。遍历压入序列，将 pushV 数组的元素入栈，碰到与 popV 数组相同的元素进行出栈并将弹出序列向后移动一位，等压入序列遍历完成，以 popV 数组元素是否访问完毕或者辅助栈是否为空判断是否是弹出序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; pushV,vector&lt;<span class="hljs-type">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;pushV.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            data.<span class="hljs-built_in">push</span>(pushV[i]);<br>            <span class="hljs-keyword">while</span>(j&lt;popV.<span class="hljs-built_in">size</span>()&amp;&amp;!data.<span class="hljs-built_in">empty</span>()&amp;&amp;data.<span class="hljs-built_in">top</span>()==popV[j])<br>            &#123;<br>                data.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><h2 id="题目链接-21"><a href="#题目链接-21" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100348.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><p>借助队列来进行层次遍历。每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都打印出来为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">NULL</span>)<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">NULL</span>)<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次。</li>
<li>空间复杂度 O(N) ： 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">levelOrder</span>(root,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:res)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> el:elem)<br>                result.<span class="hljs-built_in">push_back</span>(el);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> level,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==level)<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">levelOrder</span>(root-&gt;left,level+<span class="hljs-number">1</span>,res);<br>        <span class="hljs-built_in">levelOrder</span>(root-&gt;right,level+<span class="hljs-number">1</span>,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><h2 id="题目链接-22"><a href="#题目链接-22" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归分治"><a href="#解法一：递归分治" class="headerlink" title="解法一：递归分治"></a>解法一：递归分治</h3><p>举例说明：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100356.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>以 {5,7,6,9,11,10,8} 为例，后序遍历结果的最后一个数字 8 就是根结点的值。在这个数组中，前 3 个数字 5、7 和 6 都比 8 小，是值为 8 的结点的左子树结点；后 3 个数字 9、11 和 10 都比 8 大，是值为 8 的结点的右子树结点。</p>
<p>接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实就是一个递归的过程。对于序列 5、7、6，最后一个数字 6 是左子树的根结点的值。数字 5 比 6 小，是值为 6 的结点的左子结点，而 7 则是它的右子结点。同样，在序列 9、11、10 中，最后一个数字 10 是右子树的根结点，数字 9 比 10 小，是值为 10 的结点的左子结点，而 11 则是它的右子结点。</p>
<p>使用递归的方法，先判断数组的左子树和右子树的位置，然后再判断左子树、右子树是不是二叉搜索树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verify</span>(sequence,<span class="hljs-number">0</span>,sequence.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; seq,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;=end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 遍历左子树，找到右子树的第一个元素</span><br>        <span class="hljs-keyword">for</span>(i=start;i&lt;end;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(seq[i]&gt;seq[end])<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 左子树：[start,i-1] 右子树：[i,end-1]  根节点：end</span><br>		<span class="hljs-comment">// 遍历右子树，判断右树都大于根节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;end;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(seq[j]&lt;seq[end])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">verify</span>(seq,start,i<span class="hljs-number">-1</span>)&amp;&amp;<span class="hljs-built_in">verify</span>(seq,i,end<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：辅助单调栈"><a href="#解法二：辅助单调栈" class="headerlink" title="解法二：辅助单调栈"></a>解法二：辅助单调栈</h3><p>具体解法参考 Leetcode 上大佬 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/mian-shi-ti-33-er-cha-sou-suo-shu-de-hou-xu-bian-6/">Krahets</a> 、@<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/dan-diao-di-zeng-zhan-by-shi-huo-de-xia-tian/">失火的夏天</a> 的解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> root=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=sequence.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-comment">// 左子树大于上一步的栈顶元素，否则不满足二叉搜索树</span><br>            <span class="hljs-keyword">if</span>(sequence[i]&gt;root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>             <span class="hljs-comment">// 左子树节点小于递增栈栈顶元素，则出栈</span><br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;sequence[i]&lt;s.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                root=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// 更新栈中元素，入栈，保持递增</span><br>            s.<span class="hljs-built_in">push</span>(sequence[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><h2 id="题目链接-23"><a href="#题目链接-23" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100404.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>本问题是典型的二叉树方案搜索问题，使用回溯法解决，其包含 <strong>先序遍历 + 路径记录</strong> 两部分。</p>
</blockquote>
<p>深度优先搜索。使用前序遍历，使用两个全局变量 res 和 path，res 来存放最终结果，path 用来存放临时结果。</p>
<p>每次遍历，我们先把 root 的值压入 path，然后判断当前 root 是否同时满足：</p>
<ul>
<li>与目标值相减为0；</li>
<li>左子树为空；</li>
<li>右子树为空。</li>
</ul>
<p>如果满足条件，就将 path 压入 res 中，否则，依次遍历左右子树。向上回溯前，需要将当前节点从路径 path 中删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">FindPath</span>(TreeNode* root,<span class="hljs-type">int</span> expectNumber) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root,expectNumber,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> expectNumber,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        expectNumber-=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(expectNumber==<span class="hljs-number">0</span>&amp;&amp;root-&gt;left==<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">NULL</span>)<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,expectNumber,path,res);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,expectNumber,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><h2 id="题目链接-24"><a href="#题目链接-24" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针 random 指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100413.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS-amp-BFS"><a href="#解法一：DFS-amp-BFS" class="headerlink" title="解法一：DFS &amp; BFS"></a>解法一：DFS &amp; BFS</h3><p>图的基本单元是顶点，顶点之间的关联关系称为边，可以将此链表看成一个图：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100418.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>由于图的遍历方式有深度优先搜索和广度优先搜索，同样地，对于此链表也可以使用深度优先搜索和广度优先搜索两种方法进行遍历。</p>
<h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h4><ol>
<li>从头结点开始拷贝；</li>
<li>由于一个结点可能被多个指针指到，因此如果该结点已被拷贝，则不需要重复拷贝；</li>
<li>如果还没拷贝该结点，则创建一个新的结点进行拷贝，并将拷贝过的结点保存在哈希表中；</li>
<li>使用递归拷贝所有的 next 结点，再递归拷贝所有的 random 结点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    struct RandomListNode *next, *random;</span><br><span class="hljs-comment">    RandomListNode(int x) :</span><br><span class="hljs-comment">            label(x), next(NULL), random(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(pHead)&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> mp[pHead];<br>        RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(pHead-&gt;label);<br>        mp[pHead]=clone;<br>        clone-&gt;next=<span class="hljs-built_in">Clone</span>(pHead-&gt;next);<br>        clone-&gt;random=<span class="hljs-built_in">Clone</span>(pHead-&gt;random);<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度O(n)。</p>
<h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h4><p>使用一个队列，将本题看成树的层次遍历。</p>
<ol>
<li>创建哈希表保存已拷贝结点，格式 {原结点：拷贝结点}</li>
<li>创建队列，并将头结点入队；</li>
<li>当队列不为空时，弹出一个结点，如果该结点的 next 结点未被拷贝过，则拷贝 next 结点并加入队列；同理，如果该结点的 random 结点未被拷贝过，则拷贝 random 结点并加入队列。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        queue&lt;RandomListNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pHead);<br>        RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(pHead-&gt;label);<br>        mp[pHead]=clone;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            RandomListNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">// cur-&gt;next 并没有复制过</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;mp.<span class="hljs-built_in">count</span>(cur-&gt;next)==<span class="hljs-number">0</span>)<br>            &#123;<br>                mp[cur-&gt;next]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;next-&gt;label);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;next);<br>            &#125;<br>            <span class="hljs-comment">// cur-&gt;random 并没有复制过</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>&amp;&amp;mp.<span class="hljs-built_in">count</span>(cur-&gt;random)==<span class="hljs-number">0</span>)<br>            &#123;<br>                mp[cur-&gt;random]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;random-&gt;label);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;random);<br>            &#125;<br>            mp[cur]-&gt;next=mp[cur-&gt;next];<br>            mp[cur]-&gt;random=mp[cur-&gt;random];<br>        &#125;<br>        <span class="hljs-keyword">return</span> clone;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度O(n)。</p>
<h3 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>该方法的思路比较直接，对于一个结点，分别拷贝此结点、next 指针指向的结点、random 指针指向的结点，然后进行下一个结点…如果遇到已经出现的结点，那么不用拷贝该结点，只需将 next 或 random 指针指向该结点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        unordered_map&lt;RandomListNode*,RandomListNode*&gt; mp;<br>        RandomListNode* cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            mp[cur]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            cur=cur-&gt;next;<br>        &#125;<br>        cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>)<br>                mp[cur]-&gt;next=mp[cur-&gt;next];<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>)<br>                mp[cur]-&gt;random=mp[cur-&gt;random];<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp[pHead];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度O(n)。</p>
<h3 id="解法三：优化的迭代"><a href="#解法三：优化的迭代" class="headerlink" title="解法三：优化的迭代"></a>解法三：优化的迭代</h3><p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个节点后面添加原节点的拷贝。</p>
<p>第一步，在每个节点的后面插入复制的节点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>第二步，对复制节点的 random 链接进行赋值。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>第三步，拆分。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">RandomListNode* <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 插入新节点</span><br>        RandomListNode* cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RandomListNode</span>(cur-&gt;label);<br>            clone-&gt;next=cur-&gt;next;<br>            cur-&gt;next=clone;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 建立 random 链接</span><br>        cur=pHead;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* clone=cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">NULL</span>)<br>                clone-&gt;random=cur-&gt;random-&gt;next;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        cur=pHead;<br>        RandomListNode* pCloneHead=pHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            RandomListNode* next=cur-&gt;next;<br>            cur-&gt;next=next-&gt;next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pCloneHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度O(1)。</p>
<h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><h2 id="题目链接-25"><a href="#题目链接-25" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100449.jpeg" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>解题思路基于性质：二叉搜索树的中序遍历为<strong>递增序列</strong> 。</p>
</blockquote>
<p>将二叉搜索树转换成一个“排序的双向链表”，其中包含两个要素：</p>
<ul>
<li>排序链表： 节点应从小到大排序，因此应使用中序遍历“从小到大”访问树的节点；</li>
<li>双向链表： 在构建相邻节点（设前驱节点 pre ，当前节点 cur ）关系时，不仅应 pre-&gt;right &#x3D; cur，也应 cur-&gt;left &#x3D; pre。</li>
</ul>
<p>算法流程——递归法中序遍历：</p>
<ol>
<li><p>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；</p>
</li>
<li><p>递归左子树；</p>
</li>
<li><p>构建链表：</p>
<p>当 pre 为空时： 代表正在访问链表头节点，记为 head。<br>当 pre 不为空时： 修改双向节点引用，即 pre-&gt;right &#x3D; cur， cur-&gt;left &#x3D; pre ；<br>保存 cur： 更新 pre &#x3D; cur，即节点 cur 是后继节点的 pre ；</p>
</li>
<li><p>递归右子树；</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TreeNode* pre=<span class="hljs-literal">NULL</span>;<br>    TreeNode* head=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode* pRootOfTree)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRootOfTree==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">inOrder</span>(pRootOfTree);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* cur)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(cur-&gt;left);<br>        <span class="hljs-comment">// pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur</span><br>        <span class="hljs-keyword">if</span>(pre!=<span class="hljs-literal">NULL</span>)<br>            pre-&gt;right=cur;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点</span><br>            head=cur;<br>        <span class="hljs-comment">// pre是否为null对这句没有影响,且这句放在上面两句if else之前也是可以的</span><br>        cur-&gt;left=pre;<br>        <span class="hljs-comment">// pre指向当前的cur</span><br>        pre=cur;<br>        <span class="hljs-comment">// 全部迭代完成后，pre指向双向链表中的尾节点</span><br>        <span class="hljs-built_in">inOrder</span>(cur-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)： N 为二叉树的节点数，中序遍历需要访问所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。</li>
</ul>
<h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><h2 id="题目链接-26"><a href="#题目链接-26" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc,则打印出由字符 a,b,c 所能排列出来的所有字符串 abc,acb,bac,bca,cab 和 cba。</p>
<p>输入一个字符串,长度不超过 9 (可能有字符重复),字符只包括大小写字母。</p>
<h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>采用回溯法。</p>
</blockquote>
<p>排列方案数量： 对于一个长度为 n 的字符串（假设字符互不重复），其排列共有 $n \times (n-1) \times (n-2) … \times 2 \times 1n×(n−1)×(n−2)…×2×1$ 种方案。</p>
<p>排列方案的生成方法： 根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（ n 种情况）、再固定第 2 位字符（ n-1 种情况）、… 、最后固定第 n 位字符（ 1 种情况）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100459.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>重复方案与剪枝： 当字符串存在重复字符时，排列方案中也存在重复方案。为排除重复方案，采用 set 来保存，并且可以达到按字母顺序排序。</p>
<p>递归解析：</p>
<ol>
<li>终止条件： 当 x &#x3D; len(str) - 1 时，代表所有位已固定（最后一位只有 1 种情况），则将当前字符串加入 res，并返回；</li>
<li>递推参数： 当前固定位 x ；</li>
<li>递推工作： 将第 x 位字符与 i∈[x,len(str)] 字符分别交换，并进入下层递归，调用 dfs(x + 1)，即开始固定第 x + 1 个字符；</li>
<li>还原交换： 将字符 str[i]和 str[x] 交换（还原之前的交换）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        set&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(str,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;string&gt;(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string str,set&lt;string&gt; &amp;result,<span class="hljs-type">int</span> begin)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>        &#123;<br>            result.<span class="hljs-built_in">insert</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(str[i],str[begin]);<br>            <span class="hljs-built_in">dfs</span>(str,result,begin+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(str[i],str[begin]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>复杂度分析：<br>时间复杂度 O(N!) ： N 为字符串 str 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 $N \times (N-1) \times (N-2) … \times 2 \times 1N×(N−1)×(N−2)…×2×1$ ，因此复杂度为 O(N!) 。<br>空间复杂度 O(N^2)： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N)；递归中辅助 Set 累计存储的字符数量最多为 N + (N-1) + … + 2 + 1 &#x3D; (N+1)N&#x2F;2，即占用 O(N^2) 的额外空间。</p>
<h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><h2 id="题目链接-27"><a href="#题目链接-27" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组 {1,2,3,2,2,2,5,4,2} 。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2 。如果不存在则输出 0 。</p>
<h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>本题常见解法如下：</p>
<p>哈希表统计法： 遍历 numbers ，用 HashMap 统计各数字的数量，最终超过数组长度一半的数字则为众数。此方法时间和空间复杂度均为 O(N) 。<br>数组排序法： 将 numbers 排序，由于众数的数量超过数组长度一半，因此数组中点的元素一定为众数。此方法时间复杂度 O(Nlog N)​。<br>摩尔投票法： 核心理念为 “正负抵消” ；时间和空间复杂度分别为 O(N) 和 O(1) ；是本题的最佳解法。</p>
</blockquote>
<h3 id="解法一：使用-map-统计"><a href="#解法一：使用-map-统计" class="headerlink" title="解法一：使用 map 统计"></a>解法一：使用 map 统计</h3><p>key 为元素，value 为出现次数，当出现次数达到超过一半的时候，返回该元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-type">int</span> overhalf=numbers.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:numbers)<br>        &#123;<br>            mp[elem]++;<br>            <span class="hljs-keyword">if</span>(mp[elem]==overhalf)<br>                <span class="hljs-keyword">return</span> elem;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：摩尔投票法"><a href="#解法二：摩尔投票法" class="headerlink" title="解法二：摩尔投票法"></a>解法二：摩尔投票法</h3><p><strong>摩尔投票法：</strong></p>
<ul>
<li><p>票数和： 由于众数出现的次数超过数组长度的一半；若记众数的票数为 +1 ，非众数的票数为 -1，则一定有所有数字的票数和 &gt;0 。</p>
</li>
<li><p>票数正负抵消： 设数组 nums 中的众数为 x ，数组长度为 n 。若 nums 的前 a 个数字的 票数和 &#x3D;0 ，则数组后 (n-a) 个数字的票数和一定仍 &gt;0 （即后 (n−a) 个数字的众数仍为 x ）。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100511.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p><strong>算法原理：</strong></p>
<ul>
<li><p>为构建正负抵消，假设数组首个元素 n1 为众数，遍历统计票数，当发生正负抵消时，剩余数组的众数一定不变 ，这是因为（设真正的众数为 x ）：</p>
<ul>
<li>当 n1 &#x3D; x ： 抵消的所有数字中，有一半是众数 x 。</li>
<li>当 n1 !&#x3D; x： 抵消的所有数字中，少于或等于一半是众数 x 。</li>
</ul>
</li>
<li><p>利用此特性，每轮假设都可以缩小剩余数组区间 。当遍历完成时，最后一轮假设的数字即为众数（由于众数超过一半，最后一轮的票数和必为正数）。</p>
</li>
</ul>
<p><strong>算法流程:</strong></p>
<ol>
<li>初始化： 票数统计 votes &#x3D; 0， 众数 x；</li>
<li>循环抵消： 遍历数组 nums 中的每个数字 num ；<ul>
<li>当票数 votes 等于 0 ，则假设当前数字 num 为 众数 x ；</li>
<li>当 num &#x3D; x 时，票数 votes 自增 1 ；否则，票数 votes 自减 1 。</li>
</ul>
</li>
<li>验证环节：遍历数组 nums 统计 x 的数量。<ul>
<li>若 x 的数量超过数组长度一半，则返回 x ；</li>
<li>否则，返回 0 （这里根据不同题目的要求而定）。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,votes=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:numbers)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(votes==<span class="hljs-number">0</span>)<br>                x=elem;<br>            votes=elem==x?votes+<span class="hljs-number">1</span>:votes<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//验证x是否为众数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:numbers)<br>            <span class="hljs-keyword">if</span>(elem==x)<br>                count++;<br>        <span class="hljs-keyword">return</span> count&gt;numbers.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>?x:<span class="hljs-number">0</span>;<span class="hljs-comment">//当无众数时返回0</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong><br>时间复杂度 O(N) ： N 为数组 nums 长度。<br>空间复杂度 O(1)： votes 变量使用常数大小的额外空间。</p>
<h1 id="29-最小的-K-个数"><a href="#29-最小的-K-个数" class="headerlink" title="29.最小的 K 个数"></a>29.最小的 K 个数</h1><h2 id="题目链接-28"><a href="#题目链接-28" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4 。</p>
<h2 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>经典的 <strong>Top K 问题</strong>。Top K 问题有两种不同的解法，一种解法使用堆（优先队列），另一种解法使用类似快速排序的分治法。</p>
</blockquote>
<h3 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h3><p>使用堆数据结构来辅助得到最小的 k 个数。堆的性质是每次可以找出最大或最小的元素。可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，将堆顶元素与数组元素进行比较，若数组元素较小，则将堆顶元素弹出，数组元素入堆，若数组元素较大，直接丢弃。</p>
<p>这样，<strong>由于每次从堆顶弹出的数都是堆中最大的，最小的 k 个元素一定会留在堆里</strong>。这样，把数组中的元素全部入堆之后，堆中剩下的 k 个元素就是最小的 k 个数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k&gt;input.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// C++优先级队列默认大顶堆，若需要小顶堆，则声明priority_queue&lt;int，vector&lt;int&gt;,greater&lt;int&gt;&gt; que;</span><br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            que.<span class="hljs-built_in">push</span>(input[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=k;i&lt;input.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">top</span>()&gt;input[i])<br>            &#123;<br>                que.<span class="hljs-built_in">pop</span>();<br>                que.<span class="hljs-built_in">push</span>(input[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">top</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>由于使用了一个大小为 k 的堆，空间复杂度为 O(k)；</li>
<li>入堆和出堆操作的时间复杂度均为 O(logk)，最坏情况下数组的每个元素都需要进行一次入堆操作，故算法的时间复杂度为 O(nlogk)。</li>
</ul>
<h3 id="解法二：快排变形"><a href="#解法二：快排变形" class="headerlink" title="解法二：快排变形"></a>解法二：快排变形</h3><p>“查找第 k 大的元素”是一类算法问题，称为选择问题。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p>
<p>快速排序中有一步很重要的操作是 partition（划分），从数组中随机选取一个枢纽元素 v，然后原地移动数组中的元素，使得比 v 小的元素在 v 的左边，比 v 大的元素在 v 的右边，如下图所示：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100521.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>这个 partition 操作是原地进行的，需要 O(n) 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 k 个数是哪些，并不需要知道它们的顺序。</p>
<p>我们的目的是寻找最小的 k个数。假设经过一次 partition 操作，枢纽元素位于下标 m，也就是说，左侧的数组有 m 个元素，是原数组中最小的 m 个数。那么：</p>
<ul>
<li>若 k&#x3D;m，我们就找到了最小的 k 个数，就是左侧的数组；</li>
<li>若 k&lt;m ，则最小的 k 个数一定都在左侧数组中，我们只需要对左侧数组递归地 parition 即可；</li>
<li>若 k&gt;m，则左侧数组中的 m 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 k-m 个数，对右侧数组递归地 partition 即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; input, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>||k&gt;input.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">quickSelect</span>(input,<span class="hljs-number">0</span>,input.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);<br>        <span class="hljs-comment">// 数组的前 k 个数此时就是最小的 k 个数，将其存入结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            res.<span class="hljs-built_in">push_back</span>(input[i]);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; input,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 做一次partition操作</span><br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">partition</span>(input,lo,hi);<br>        <span class="hljs-comment">// 此时数组前m个数，就是最小的m个数</span><br>        <span class="hljs-keyword">if</span>(k==m)<br>            <span class="hljs-comment">// 正好找到最小的 k(m) 个数</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&lt;m)<br>            <span class="hljs-comment">// 最小的k个数一定在前m个数中，递归划分</span><br>            <span class="hljs-built_in">quickSelect</span>(input,lo,m<span class="hljs-number">-1</span>,k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 在右侧数组中寻找最小的k-m个数</span><br>            <span class="hljs-built_in">quickSelect</span>(input,m+<span class="hljs-number">1</span>,hi,k);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 快排的partition过程 </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr,<span class="hljs-type">int</span> lo,<span class="hljs-type">int</span> hi)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> less=lo<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> more=hi;<br>        <span class="hljs-keyword">while</span>(lo&lt;more)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(arr[lo]&lt;arr[hi])<br>                <span class="hljs-built_in">swap</span>(arr[++less],arr[lo++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[lo]&gt;arr[hi])<br>                <span class="hljs-built_in">swap</span>(arr[--more],arr[lo]);<br>            <span class="hljs-keyword">else</span><br>                lo++;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(arr[more],arr[hi]);<br>        <span class="hljs-keyword">return</span> less+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>空间复杂度期望为 O(logn)。递归调用的期望深度为 O(logn)，每层需要的空间为 O(1)，只有常数个变量。 最坏情况下的空间复杂度为 O(n)。最坏情况下需要划分 n 次，即函数递归调用最深 n−1 层，而每层由于需要 O(1) 的空间，所以一共需要 O(n) 的空间复杂度。</li>
<li>时间复杂度的分析方法和快速排序类似。由于快速选择只需要递归一边的数组，时间复杂度小于快速排序，期望时间复杂度为 O(n)，最坏情况下的时间复杂度为 O(n^2)。情况最差时，每次的划分点都是最大值或最小值，一共需要划分 n−1 次，而一次划分需要线性的时间复杂度，所以最坏情况下时间复杂度为 O(n^2)。</li>
</ul>
<h3 id="两种方法的优劣性比较"><a href="#两种方法的优劣性比较" class="headerlink" title="两种方法的优劣性比较"></a>两种方法的优劣性比较</h3><p>在面试中，常问的问题就是这两种方法有何优劣。看起来分治法的快速选择算法的时间、空间复杂度都优于使用堆的方法，但是要注意到快速选择算法的几点局限性：</p>
<ul>
<li>算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。</li>
<li>算法需要保存所有的数据。如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。</li>
</ul>
<h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><h2 id="题目链接-29"><a href="#题目链接-29" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如: {6,-3,-2,7,-15,1,2,2} ,连续子向量的最大和为 8 (从第 0 个开始,到第 3 个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是 1 )</p>
<h2 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：贪心法"><a href="#解法一：贪心法" class="headerlink" title="解法一：贪心法"></a>解法一：贪心法</h3><p>举例分析：下图是计算（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析发现，累加的子数组和，如果大于 0 ，那么继续累加，即将下一个数值加入和中；如果累加和小于 0 ，则需要剔除原来的累加和，从下一个数重新开始。同时，更新最大和的值。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100530.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> greatSum=INT_MIN;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> elem:array)<br>        &#123;<br>            curSum=curSum&lt;<span class="hljs-number">0</span>?elem:curSum+elem;<br>            greatSum=<span class="hljs-built_in">max</span>(greatSum,curSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> greatSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="解法二：分治法"><a href="#解法二：分治法" class="headerlink" title="解法二：分治法"></a>解法二：分治法</h3><p> 分治法模板： </p>
<ol>
<li>定义基本情况 </li>
<li>将问题分解为子问题并递归解决子问题 </li>
<li>合并子问题的解以获得原始问题的解</li>
</ol>
<p>将 array 中点 mid 分为三种情况： </p>
<ol>
<li>最大子串在左边 </li>
<li>最大子串在右边 </li>
<li>最大子串跨中点，左右都有</li>
</ol>
<p>当子串在左边或右边时，继续分中点递归分解到一个数为止，对于递归后横跨的子串，再分治为左侧和右侧求最大子串，可使用贪心算法求最大子串值，再合并为原始的最大子串值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(array,<span class="hljs-number">0</span>,array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 分解到一个值时返回该值</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> array[left];<br>        <span class="hljs-comment">// 求中点值</span><br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>         <span class="hljs-comment">// 中点左边的最大值</span><br>        <span class="hljs-type">int</span> leftSum=<span class="hljs-built_in">helper</span>(array,left,mid);<br>        <span class="hljs-comment">// 中点右边的最大值</span><br>        <span class="hljs-type">int</span> rightSum=<span class="hljs-built_in">helper</span>(array,mid+<span class="hljs-number">1</span>,right);<br>        <span class="hljs-comment">// 横跨中点的最大值</span><br>        <span class="hljs-type">int</span> croSum=<span class="hljs-built_in">crossSum</span>(array,left,right,mid);<br>        <span class="hljs-comment">// 返回以上三种情况中的最大值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(leftSum,rightSum),croSum);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">crossSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> mid)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 分解到一个值时返回该值</span><br>        <span class="hljs-keyword">if</span>(left==right)<br>            <span class="hljs-keyword">return</span> array[left];<br>         <span class="hljs-comment">// 贪心法求左边的最大值</span><br>        <span class="hljs-type">int</span> leftSubSum=INT_MIN;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid;i&gt;=left;--i)<br>        &#123;<br>            curSum+=array[i];<br>            leftSubSum=<span class="hljs-built_in">max</span>(leftSubSum,curSum);<br>        &#125;<br>        <span class="hljs-comment">// 贪心法求右边的最大值</span><br>        <span class="hljs-type">int</span> rightSubSum=INT_MIN;<br>        curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=right;++i)<br>        &#123;<br>            curSum+=array[i];<br>            rightSubSum=<span class="hljs-built_in">max</span>(rightSubSum,curSum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftSubSum+rightSubSum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(nlogn)。</li>
<li>空间复杂度：O(logn)。</li>
</ul>
<h3 id="解法三：动态规划——-Kadane算法"><a href="#解法三：动态规划——-Kadane算法" class="headerlink" title="解法三：动态规划—— Kadane算法"></a>解法三：动态规划—— Kadane算法</h3><blockquote>
<p>在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题，可通过动态规划(DP)在线性时间内解决。</p>
<p>两种标志 DP 适用于数组：</p>
<ul>
<li>常数空间，沿数组移动并在原数组修改；</li>
<li>线性空间，首先沿 left-&gt;right 方向移动，然后沿 right-&gt;left 方向移动，最后合并结果。</li>
</ul>
</blockquote>
<p><strong>动态规划解析：</strong></p>
<ul>
<li><p>状态定义： 设动态规划列表 dp ，dp[i] 代表以元素 nums[i] 为结尾的连续子数组最大和。</p>
<p>为何定义最大和 dp[i] 中必须包含元素 nums[i] ：保证 dp[i] 递推到 dp[i+1] 的正确性；如果不包含 nums[i] ，递推时则不满足题目的连续子数组要求。</p>
</li>
<li><p>转移方程： 若 dp[i-1]≤0 ，说明 dp[i - 1] 对 dp[i] 产生负贡献，即 dp[i-1] + nums[i]  还不如 nums[i] 本身大。</p>
<ul>
<li>当 dp[i - 1]&gt;0 时：执行 dp[i] &#x3D; dp[i-1] + nums[i] ；</li>
<li>当 dp[i - 1]≤0 时：执行 dp[i] &#x3D; nums[i] ；</li>
</ul>
</li>
<li><p>初始状态： dp[0]&#x3D;nums[0]，即以 nums[0] 结尾的连续子数组最大和为 nums[0] 。</p>
</li>
<li><p>返回值： 返回 dp 列表中的最大值，代表全局最大值。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110816.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>空间复杂度降低：</p>
<ul>
<li>由于 dp[i]  只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums上修改即可。</li>
<li>由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;array.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            array[i]+=<span class="hljs-built_in">max</span>(array[i<span class="hljs-number">-1</span>],<span class="hljs-number">0</span>);<br>            res=<span class="hljs-built_in">max</span>(res,array[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 线性遍历数组 nums 即可获得结果，使用 O(N) 时间。</li>
<li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li>
</ul>
<h1 id="31-从-1-到-n-整数中-1-出现的次数"><a href="#31-从-1-到-n-整数中-1-出现的次数" class="headerlink" title="31.从 1 到 n 整数中 1 出现的次数"></a>31.从 1 到 n 整数中 1 出现的次数</h1><h2 id="题目链接-30"><a href="#题目链接-30" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出 1<del>13 的整数中 1 出现的次数,并算出 100</del>1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、12、13 因此共出现 6 次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中 1 出现的次数（从 1 到 n 中 1 出现的次数）。</p>
<h2 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>从 1 到 n 遍历，每次通过对 10 求余数判断整数的个位数字是不是 1，大于 10 的除以 10 之后再判断。对每个数字都要做除法和求余运算以求出该数字中 1 出现的次数。如果输入数字 n ，n 有 O(logn) 位，需要判断每一位是不是 1，那么时间复杂度为 O(n*logn) 。计算量大，效率不高。</p>
<h3 id="解法二：递归-1"><a href="#解法二：递归-1" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><ul>
<li>最高位为 1<ul>
<li>不包含高位下 1 的个数</li>
<li>除最高位剩余数字中 1 的情况</li>
<li>固定高位下 1 的个数</li>
</ul>
</li>
<li>最高位不为 1<ul>
<li>固定最高位为 1 的情况</li>
<li>不包含高位下 1 的情况</li>
<li>除最高位剩余数字中 1 的情况</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(n);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        string num=<span class="hljs-built_in">to_string</span>(n);<br>        <span class="hljs-type">int</span> p=<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,num.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> high=num[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> last=n-high*p;<br>        <span class="hljs-keyword">if</span>(high==<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 最高位为1，例如: 12345 就需要计算 0~9999 、2345、10000~12345中的1</span><br>        <span class="hljs-comment">// dfs(p-1)表示[0,9999]中的1</span><br>        <span class="hljs-comment">// dfs(last)表示2345中1出现的个数</span><br>        <span class="hljs-comment">// last+1表示固定高位1有多少种情况</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(last)+last+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 最高位不为1，如 22347，就需要计算</span><br>            <span class="hljs-comment">// p 固定高位为1有多少种可能，[10000,19999]</span><br>            <span class="hljs-comment">// high*dfs(p-1) 不固定高位下，[0,9999]及[10000,19999]中非高位1的出现的个数</span><br>            <span class="hljs-comment">// dfs(last) 表示2347中的1</span><br>            <span class="hljs-keyword">return</span> p+high*<span class="hljs-built_in">dfs</span>(p<span class="hljs-number">-1</span>)+<span class="hljs-built_in">dfs</span>(last);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>将 1~n 的个位、十位、百位、…的 1 出现次数相加，即为 1 出现的总次数。</p>
<p>设数字 n 是个 x 位数，记 n 的第 i 位为 $n_i$，则可将 n 写为 $n_{x} n_{x-1} \cdots n_{2} n_{1}$：</p>
<ul>
<li>称 “ $n_i$ “ 为 当前位 ，记为 cur ，</li>
<li>将 “ $n_{i-1} n_{i-2} \cdots n_{2} n_{1}$ “ 称为 低位 ，记为 low ；</li>
<li>将 “ $n_{x} n_{x-1} \cdots n_{i+2} n_{i+1}$ “ 称为 高位 ，记为 high 。</li>
<li>将 $10^i$ 称为 位因子 ，记为 digit 。</li>
</ul>
<p><strong>某位中 1 出现次数的计算方法：</strong></p>
<p>根据当前位 cur 值的不同，分为以下三种情况：</p>
<ol>
<li><p>当 cur&#x3D;0 时： 此位 1 的出现次数只由高位 high 决定，计算公式为：<br>$$<br>high \times digit<br>$$<br>如下图所示，以 n&#x3D;2304 为例，求 digit&#x3D;10 （即十位）的 1 出现次数。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723110721.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>当 cur &#x3D; 1 时：此位 1 的出现次数由高位 high 和低位 low 决定，计算公式为：<br>$$<br>high×digit+low+1<br>$$<br>如下图所示，以 n &#x3D; 2314 为例，求 digit &#x3D; 10 （即十位）的 1 出现次数。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105552.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>当 cur &#x3D; 2,3,…9 时：此位 1 的出现次数只由高位 high 决定，计算公式为：<br>$$<br>(high+1)×digit<br>$$<br>如下图所示，以 n &#x3D; 2324 为例，求 digit &#x3D; 10（即十位）的 1 出现次数。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105514.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></li>
</ol>
<p><strong>变量递推公式：</strong></p>
<p>设计按照 “个位、十位、…” 的顺序计算，则 high &#x2F; cur &#x2F; low &#x2F; digit 应初始化为：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">high</span> = n / <span class="hljs-number">10</span><br><span class="hljs-attr">cur</span> = n % <span class="hljs-number">10</span><br><span class="hljs-attr">low</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">digit</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># 个位</span><br></code></pre></td></tr></table></figure>

<p>因此，从个位到最高位的变量递推公式为：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">while high !=<span class="hljs-number"> 0 </span>or cur != 0: <span class="hljs-comment"># 当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span><br>   low += cur * digit <span class="hljs-comment"># 将 cur 加入 low ，组成下轮 low</span><br>   cur = high %<span class="hljs-number"> 10 </span><span class="hljs-comment"># 下轮 cur 是本轮 high 的最低位</span><br>   high /=<span class="hljs-number"> 10 </span><span class="hljs-comment"># 将本轮 high 最低位删除，得到下轮 high</span><br>   digit *=<span class="hljs-number"> 10 </span><span class="hljs-comment"># 位因子每轮 × 10</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> digit=<span class="hljs-number">1</span>,res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> high=n/<span class="hljs-number">10</span>,cur=n%<span class="hljs-number">10</span>,low=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(high!=<span class="hljs-number">0</span>||cur!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">0</span>)<br>                res+=high*digit;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur==<span class="hljs-number">1</span>)<br>                res+=high*digit+low+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                res+=(high+<span class="hljs-number">1</span>)*digit;<br>            low+=cur*digit;<br>            cur=high%<span class="hljs-number">10</span>;<br>            high/=<span class="hljs-number">10</span>;<br>            digit*=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(logn) ： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 $\log_{10}{n}$，因此循环使用 O(logn) 时间。空</li>
<li>间复杂度 O(1) ： 几个变量使用常数大小的额外空间。</li>
</ul>
<h3 id="解法四：数学之美"><a href="#解法四：数学之美" class="headerlink" title="解法四：数学之美"></a>解法四：数学之美</h3><p>采用数学之美上面提出的方法，设定整数点（如 1、10、100 等等）作为位置点 i（对应 n 的各位、十位、百位等等），分别对每个数位上有多少包含 1 的点进行分析。</p>
<ul>
<li>根据设定的整数位置，对 n 进行分割，分为两部分，高位 n&#x2F;i ，低位 n%i ；</li>
<li>当 i 表示百位，且百位对应的数 &gt;&#x3D;2 ,如 n&#x3D;31456,i&#x3D;100 ，则 a&#x3D;314,b&#x3D;56 ，此时百位为 1 的次数有 a&#x2F;10+1&#x3D;32（最高两位 0~31），每一次都包含 100 个连续的点，即共有 (a&#x2F;10+1)*100 个点的百位为 1；</li>
<li>当 i 表示百位，且百位对应的数为 1，如 n&#x3D;31156,i&#x3D;100，则 a&#x3D;311,b&#x3D;56，此时百位对应的就是 1，则共有 a&#x2F;10 (最高两位 0-30 )次是包含 100 个连续点，当最高两位为 31（即a&#x3D;311），本次只对应局部点 00~56，共 b+1 次，所有点加起来共有（a&#x2F;10*100）+(b+1)，这些点百位对应为 1；</li>
<li>当 i 表示百位，且百位对应的数为 0,如 n&#x3D;31056,i&#x3D;100，则 a&#x3D;310,b&#x3D;56，此时百位为 1 的次数有 a&#x2F;10&#x3D;31（最高两位0~30）；</li>
<li>综合以上三种情况，当百位对应 0 或 &gt;&#x3D;2 时，有 (a+8)&#x2F;10 次包含所有 100 个点，还有当百位为 1(a%10&#x3D;&#x3D;1)，需要增加局部点 b+1；</li>
<li>之所以补 8，是因为当百位为 0，则 a&#x2F;10&#x3D;&#x3D;(a+8)&#x2F;10，当百位 &gt;&#x3D;2，补 8 会产生进位，效果等同于 (a&#x2F;10+1)。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> ones=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i*=<span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> a=n/i,b=n%i;<br>            ones+=(a+<span class="hljs-number">8</span>)/<span class="hljs-number">10</span>*i+(a%<span class="hljs-number">10</span>==<span class="hljs-number">1</span>)*(b+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><h2 id="题目链接-31"><a href="#题目链接-31" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321} ，则打印出这三个数字能排成的最小数字为 321323 。</p>
<h2 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：全排列"><a href="#解法一：全排列" class="headerlink" title="解法一：全排列"></a>解法一：全排列</h3><p>将数组进行全排列，再选取最小的为答案，时间复杂度为 O(N*N!)，全排列的时间复杂度为N！，每次排列结果需要遍历一次 nums 数组。</p>
<h3 id="解法二：贪心-自定义排序"><a href="#解法二：贪心-自定义排序" class="headerlink" title="解法二：贪心+自定义排序"></a>解法二：贪心+自定义排序</h3><ul>
<li><p>此题求拼接起来的“最小数字”，本质上是一个排序问题。</p>
</li>
<li><p>排序判断规则： 设 nums 任意两数字的字符串格式 x 和 y ，则</p>
<p>若拼接字符串 x+y&gt;y+x ，则应该把 y 排在前面；<br>反之，若 x+y&lt;y+x ，则应该把 x 排在前面；</p>
</li>
<li><p>根据以上规则，套用任何排序方法对 nums 执行排序即可。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105416.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; numbers)</span> </span>&#123;<br>        vector&lt;string&gt; strs;<br>        string res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numbers.<span class="hljs-built_in">size</span>();++i)<br>            strs.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(numbers[i]));<br>        <span class="hljs-built_in">sort</span>(strs.<span class="hljs-built_in">begin</span>(),strs.<span class="hljs-built_in">end</span>(),[](string&amp; s1,string&amp; s2)&#123;<span class="hljs-keyword">return</span> s1+s2&lt;s2+s1;&#125;);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();++i)<br>            res+=strs[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(NlogN) ： N 为最终返回值的字符数量（ strs 列表的长度 ≤N ) 。</li>
<li>空间复杂度 O(N)： 字符串列表 strs 占用线性大小的额外空间。</li>
</ul>
<h1 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h1><h2 id="题目链接-32"><a href="#题目链接-32" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<h2 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h2><p>丑数的递推性质： 丑数只包含因子 2, 3, 5，因此有 “丑数 &#x3D; 某较小丑数 × 某因子” （例如：10 &#x3D; 5×2）。</p>
<p>设已知长度为 n 的丑数序列 $x_1, x_2, \cdots , x_n$，求第 n+1 个丑数 $x_{n+1}$ 。根据递推性质，丑数 $x_{n+1}$只可能是以下三种情况其中之一（索引 a, b, c 为未知数）<br>$$<br>x_{n+1}&#x3D;\left{\begin{array}{ll}x_{a} \times 2 &amp; , a \in[1, n] \ x_{b} \times 3 &amp; , b \in[1, n] \ x_{c} \times 5 &amp; , c \in[1, n]\end{array}\right.<br>$$<br>由于 $x_{n+1}$ 是 <strong>最接近</strong> $x_n$ 的丑数，因此索引 a, b, c 需满足以下条件：<br>$$<br>\left{\begin{array}{l}x_{a} \times 2&gt;x_{n} \geq x_{a-1} \times 2 \ x_{b} \times 3&gt;x_{n} \geq x_{b-1} \times 3 \ x_{c} \times 5&gt;x_{n} \geq x_{c-1} \times 5\end{array}\right.<br>$$<br>即 $x_a$ 为首个乘以 2 后大于 $x_n$ 的丑数，即 $x_b$ 为首个乘以 2 后大于 $x_n$ 的丑数，即 $x_c$ 为首个乘以 2 后大于 $x_n$ 的丑数。</p>
<p>若索引 a,b,c 满足以上条件，则可使用递推公式计算下个丑数 $x_{n+1}$ ，其为三种情况中的<strong>最小值</strong>，即：<br>$$<br>x_{n+1}&#x3D;\min \left(x_{a} \times 2, x_{b} \times 3, x_{c} \times 5\right)<br>$$<br>因此，可设置指针 a,b,c 指向首个丑数（即 1 ），循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105313.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p><strong>动态规划解析：</strong></p>
<ul>
<li><p>状态定义： 设动态规划列表 dp ，dp[i] 代表第 i+1个丑数。</p>
</li>
<li><p>转移方程：<br>当索引 a, b, c 满足以下条件时， dp[i] 为三种情况的最小值；<br>每轮计算 dp[i] 后，需要更新索引 a, b, c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2 , dp[b]×3 , dp[c]×5 的大小关系，若相等则将对应索引 a,b,c 加 1 。<br>$$<br>\left{\begin{array}{l}d p[a] \times 2&gt;d p[i-1] \geq d p[a-1] \times 2 \ d p[b] \times 3&gt;d p[i-1] \geq d p[b-1] \times 3 \ d p[c] \times 5&gt;d p[i-1] \geq d p[c-1] \times 5\end{array}\right.<br>$$</p>
<p>$$<br>d p[i]&#x3D;\min (d p[a] \times 2, d p[b] \times 3, d p[c] \times 5)<br>$$</p>
</li>
<li><p>初始状态： dp[0]&#x3D;1 ，即第一个丑数为 1 ；</p>
</li>
<li><p>返回值： dp[n-1] ，即返回第 n 个丑数。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index&lt;=<span class="hljs-number">6</span>)<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(index)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>,c=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;index;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> next2=dp[a]*<span class="hljs-number">2</span>,next3=dp[b]*<span class="hljs-number">3</span>,next5=dp[c]*<span class="hljs-number">5</span>;<br>            dp[i]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(next2,next3),next5);<br>            <span class="hljs-keyword">if</span>(dp[i]==next2) <br>                a++;<br>            <span class="hljs-keyword">if</span>(dp[i]==next3)<br>                b++;<br>            <span class="hljs-keyword">if</span>(dp[i]==next5)<br>                c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N&#x3D;n ，动态规划需遍历计算 dp 列表。</li>
<li>空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N) 的额外空间</li>
</ul>
<h1 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h1><h2 id="题目链接-33"><a href="#题目链接-33" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&&tqId=11187&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串( 0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从 0 开始计数）</p>
<h2 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：使用-map"><a href="#解法一：使用-map" class="headerlink" title="解法一：使用 map"></a>解法一：使用 map</h3><p>建立一个 map ，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为 1，则返回这个字符的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>            mp[i]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp[str[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；Map 查找的操作复杂度为 O(1)；</li>
<li>空间复杂度 O(N)：Map 需存储 N 个字符的键值对，使用 O(N) 大小的额外空间。</li>
</ul>
<h3 id="解法二：用数组代替-map"><a href="#解法二：用数组代替-map" class="headerlink" title="解法二：用数组代替 map"></a>解法二：用数组代替 map</h3><p>需要统计的字符范围有限，所以考虑用有限数组代替 map ，将空间复杂度由 O(N) 降为 O(1)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> mp[<span class="hljs-number">128</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>            mp[i]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mp[str[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：使用-bitset"><a href="#解法三：使用-bitset" class="headerlink" title="解法三：使用 bitset"></a>解法三：使用 bitset</h3><p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p>
<p>具体过程：</p>
<ol>
<li>初始化：bitset&lt;128&gt; b1表示只出现 1 次， b2 表示出现 2 次以上 </li>
<li>遍历字符串，第一次出现，b1[ch] &#x3D; 1 ；</li>
<li>如果第二次出现，b2[ch] &#x3D; 1 ；</li>
<li>最后，找出第一个b1[ch] &#x3D;&#x3D; 1 &amp;&amp; b2[ch] &#x3D;&#x3D; 0 的字符。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        bitset&lt;128&gt; b1,b2;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:str)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!b1[i]&amp;&amp;!b2[i])<br>                b1[i]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(b1[i]&amp;&amp;!b2[i])<br>                b2[i]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(b1[str[i]]&amp;&amp;!b2[str[i]])<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><h2 id="题目链接-34"><a href="#题目链接-34" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P。并将 P 对 1000000007 取模的结果输出。 即输出 P%1000000007。</p>
<p>输入描述:</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">题目保证输入的数组中没有的相同的数字数据范围：	<br>对于%50的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">4</span>	<br>对于%75的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">10</span>^<span class="hljs-number">5</span>	<br>对于%100的数据,<span class="hljs-keyword">size</span>&lt;=<span class="hljs-number">2</span>*<span class="hljs-number">10</span>^<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>示例1</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：<br><span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5,6,7,0</span><br>输出：<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：归并排序思想"><a href="#解法一：归并排序思想" class="headerlink" title="解法一：归并排序思想"></a>解法一：归并排序思想</h3><p>利用归并排序来解决，在并入操作时记录<code>nums[L]&gt;nums[R]</code>的情况即可。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105128.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723105054.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>在 merge 函数内部开辟额外空间的做法很不好。因为这样会涉及到频繁的构建 vector 和析构vector，所以比较好的做法是：直接在最外层开辟一个足够大的数组，然后传引用到函数。此外注意 res 的类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">help</span><span class="hljs-params">(data.size())</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(data,help,<span class="hljs-number">0</span>,data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)%<span class="hljs-number">1000000007</span>;<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp; help,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeSort</span>(nums,help,l,mid)+<span class="hljs-built_in">mergeSort</span>(nums,help,mid+<span class="hljs-number">1</span>,r)+<span class="hljs-built_in">merge</span>(nums,help,l,mid,r);<br>    &#125;<br>     <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;<span class="hljs-type">int</span>&gt;&amp; help,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> p1=l;<br>        <span class="hljs-type">int</span> p2=m+<span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(p1&lt;=m&amp;&amp;p2&lt;=r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[p1]&gt;nums[p2])<br>            &#123;<br>                res+=m-p1+<span class="hljs-number">1</span>;<br>                help[i++]=nums[p2++];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                help[i++]=nums[p1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(p1&lt;=m)<br>            help[i++]=nums[p1++];<br>        <span class="hljs-keyword">while</span>(p2&lt;=r)<br>            help[i++]=nums[p2++];<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,p1=l;p1&lt;=r;)<br>            nums[p1++]=help[i++];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：同归并排序 O(nlogn)。</li>
<li>空间复杂度：同归并排序 O(n），因为归并排序需要用到一个临时数组。</li>
</ul>
<h3 id="解法二：离散化树状数组"><a href="#解法二：离散化树状数组" class="headerlink" title="解法二：离散化树状数组"></a>解法二：离散化树状数组</h3><p>见 Leetcode 题解，链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/</a></p>
<h1 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h1><h2 id="题目链接-35"><a href="#题目链接-35" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104929.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<h2 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：链表拼接"><a href="#解法一：链表拼接" class="headerlink" title="解法一：链表拼接"></a>解法一：链表拼接</h3><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b &#x3D; b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct ListNode *next;</span><br><span class="hljs-comment">	ListNode(int x) :</span><br><span class="hljs-comment">			val(x), next(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1||!pHead2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* l1=pHead1,*l2=pHead2;<br>        <span class="hljs-keyword">while</span>(l1!=l2)<br>        &#123;<br>            l1=(l1==<span class="hljs-literal">NULL</span>)?pHead2:l1-&gt;next;<br>            l2=(l2==<span class="hljs-literal">NULL</span>)?pHead1:l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(M+N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="解法二：双指针-1"><a href="#解法二：双指针-1" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>如果链表相交，则链表公共节点都在尾部。</p>
<ol>
<li>先计算两个链表长度。</li>
<li>让长链表指针先走多出的长度，然后两个链表同时走，如果相遇则为相交节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!pHead1||!pHead2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> len1=<span class="hljs-built_in">len</span>(pHead1),len2=<span class="hljs-built_in">len</span>(pHead2);<br>        <span class="hljs-keyword">if</span>(len1&gt;=len2)<br>        &#123;<br>            <span class="hljs-type">int</span> move=len1-len2;<br>            <span class="hljs-keyword">while</span>(move--)<br>                pHead1=pHead1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> move=len2-len1;<br>            <span class="hljs-keyword">while</span>(move--)<br>                pHead2=pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(pHead1!=pHead2)<br>        &#123;<br>            pHead1=pHead1-&gt;next;<br>            pHead2=pHead2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pHead1;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(pHead!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ++len;<br>            pHead=pHead-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n + m)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h1><h2 id="题目链接-36"><a href="#题目链接-36" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>排序数组中的搜索问题，首先想到 <strong>二分法</strong> 解决。</p>
</blockquote>
<p>排序数组 nums 中的所有数字 target 形成一个窗口，记窗口的左&#x2F;右边界索引分别为 left 和 right，分别对应窗口左边&#x2F;右边的首个元素。</p>
<p>本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到左边界 left 和 右边界 right，易得数字 target 的数量为 right−left−1 。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104621.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p><strong>算法解析：</strong></p>
<ol>
<li>初始化： 左边界 i&#x3D;0 ，右边界 j&#x3D;len(nums)-1 。</li>
<li>循环二分： 当闭区间 [i,j ] 无元素时跳出；<ol>
<li>计算中点 m&#x3D;(i+j)&#x2F;2 （向下取整）；</li>
<li>若 nums[m]&lt;target ，则 target 在闭区间 [m+1,j] 中，因此执行 i&#x3D;m+1；</li>
<li>若 nums[m]&gt;target ，则 target 在闭区间 [i,m-1] 中，因此执行 j&#x3D;m−1；</li>
<li>若 nums[m]&#x3D;target ，则右边界 right 在闭区间 [m+1,j] 中；左边界 left 在闭区间 [i,m-1] 中。因此分为以下两种情况：<br>若查找右边界 right ，则执行 i&#x3D;m+1 ；（跳出时 i 指向右边界）<br>若查找 左边界 left ，则执行 j&#x3D;m−1 ；（跳出时 j 指向左边界）</li>
</ol>
</li>
<li>返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right−left−1 即可。</li>
</ol>
<p><strong>效率优化：</strong></p>
<p>以下优化基于：查找完右边界 right&#x3D;i 后，则 nums[j] 指向最右边的 target（若存在）。</p>
<ol>
<li>查找完右边界后，可用 nums[j]&#x3D;j 判断数组中是否包含 target ，若不包含则直接提前返回 0 ，无需后续查找左边界。</li>
<li>查找完右边界后，左边界 left 一定在闭区间 [0,j] 中，因此直接从此区间开始二分查找即可。</li>
</ol>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104527.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104449.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data ,<span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-comment">// 搜索右边界 right</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m]&lt;=k)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> right=i;<br>        <span class="hljs-comment">// 若数组中无 target ，则提前返回</span><br>        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;data[j]!=k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 搜索左边界 left</span><br>        i=<span class="hljs-number">0</span>;j=data.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(data[m]&lt;k)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> left=j;<br>        <span class="hljs-keyword">return</span> right-left<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于数组 nums 中元素都为整数，因此可以分别二分查找 target 和 target−1 的右边界，将两结果相减并返回即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data ,<span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">binarySearch</span>(data,k)-<span class="hljs-built_in">binarySearch</span>(data,k<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+(j-i)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m]&lt;=target)<br>                i=m+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> j=m<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>本质上看， <code>binarySearch()</code> 函数旨在查找数字 target 在数组 nums 中的 <strong>插入点</strong> ，且若数组中存在值相同的元素，则插入到这些元素的右边。</p>
<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(log N)：二分法为对数级别复杂度。</li>
<li>空间复杂度 O(1)：几个变量使用常数大小的额外空间。</li>
</ul>
<h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><h2 id="题目链接-37"><a href="#题目链接-37" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104349.jpg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h2 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>树的遍历方式总体分为两类：深度优先搜索（DFS）、广度优先搜索（BFS）；</p>
<ul>
<li>常见的 DFS ： 先序遍历、中序遍历、后序遍历；</li>
<li>常见的 BFS ： 层序遍历（即按层遍历）。</li>
</ul>
</blockquote>
<h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><blockquote>
<p>树的深度优先搜索往往利用 <strong>递归</strong> 或 <strong>栈</strong> 实现。</p>
</blockquote>
<p>树的深度等于左子树的深度与右子树的深度中的<strong>最大值+1</strong>。</p>
<p><strong>算法解析：</strong></p>
<ol>
<li>终止条件： 当 root 为空，说明已越过叶节点，因此返回深度 0 。</li>
<li>递推工作： 本质上是对树做后序遍历。<br>计算节点 root 的 左子树的深度 ；<br>计算节点 root 的 右子树的深度 ；</li>
<li>返回值： 返回此树的深度 。</li>
</ol>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104257.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">	int val;</span><br><span class="hljs-comment">	struct TreeNode *left;</span><br><span class="hljs-comment">	struct TreeNode *right;</span><br><span class="hljs-comment">	TreeNode(int x) :</span><br><span class="hljs-comment">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">	&#125;</span><br><span class="hljs-comment">&#125;;*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">TreeDepth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> left&gt;right?left+<span class="hljs-number">1</span>:right+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。</li>
</ul>
<h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><blockquote>
<p>树的层序遍历 &#x2F; 广度优先搜索往往利用 <strong>队列</strong> 实现。</p>
</blockquote>
<p>关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。</p>
<p><strong>算法解析：</strong></p>
<ol>
<li>特例处理： 当 root 为空，直接返回深度 0 。</li>
<li>初始化： 队列 queue （加入根节点 root ），深度 depth&#x3D; 0。</li>
<li>循环遍历： 当 queue 为空时跳出。<br>遍历队列： 弹出 queue 的第一个结点 ，如果该结点有左子节点或右子节点则加入 queue；<br>统计层数： 执行 depth+&#x3D; 1 ，代表层数加 1；</li>
<li>返回值： 返回 depth 即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* node=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span>(node-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            depth++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 queue 同时存储 N&#x2F;2 个节点。</li>
</ul>
<h1 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h1><h2 id="题目链接-38"><a href="#题目链接-38" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树（平衡二叉树左右子树高度差不超过 1）。</p>
<p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104152.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：先序遍历-判断深度-（从顶至底）"><a href="#解法一：先序遍历-判断深度-（从顶至底）" class="headerlink" title="解法一：先序遍历 + 判断深度 （从顶至底）"></a>解法一：先序遍历 + 判断深度 （从顶至底）</h3><p>思路是构造一个获取当前子树的深度的函数 depth(root) （即 38. 二叉树的深度 ），通过比较某子树的左右子树的深度差 abs(depth(root.left) - depth(root.right)) &lt;&#x3D; 1 是否成立，来判断某子树是否是二叉平衡树。若所有子树都平衡，则此树平衡。</p>
<p><strong>算法流程：</strong><br><strong>isBalanced(root) 函数</strong>： 判断树 root 是否平衡</p>
<ul>
<li>特例处理： 若树根节点 root 为空，则直接返回 true ；</li>
<li>返回值： 所有子树都需要满足平衡树性质，因此以下三者使用与逻辑 &amp;&amp; 连接：<br>abs(self.depth(root.left) - self.depth(root.right)) &lt;&#x3D; 1 ：判断 当前子树 是否是平衡树；<br>self.isBalanced(root.left) ：先序遍历递归，判断当前子树的左子树是否是平衡树；<br>self.isBalanced(root.right) ：先序遍历递归，判断当前子树的右子树是否是平衡；</li>
</ul>
<p><strong>depth(root) 函数</strong>：计算树 root 的深度</p>
<ul>
<li>终止条件： 当 root 为空，即越过叶子节点，则返回深度 0 ；</li>
<li>返回值： 返回左 &#x2F; 右子树的深度的最大值 +1 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;left)&amp;&amp;<span class="hljs-built_in">IsBalanced_Solution</span>(pRoot-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(pRoot-&gt;left),<span class="hljs-built_in">depth</span>(pRoot-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(NlogN)： 最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历各子树的所有节点 。</li>
<li>空间复杂度 O(N)：最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
<p>解法一首先判断根结点是不是平衡的，需要使用 depth 获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用 depth 获得子树的左右子树的深度，这样就导致了大量的重复遍历，时间复杂度较高。</p>
<h3 id="解法二：后序遍历-剪枝-（从底至顶）"><a href="#解法二：后序遍历-剪枝-（从底至顶）" class="headerlink" title="解法二：后序遍历 + 剪枝 （从底至顶）"></a>解法二：后序遍历 + 剪枝 （从底至顶）</h3><p>思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p>
<h4 id="用负值表示不平衡，避免重复计算"><a href="#用负值表示不平衡，避免重复计算" class="headerlink" title="用负值表示不平衡，避免重复计算"></a>用负值表示不平衡，避免重复计算</h4><p><strong>算法流程：</strong><br><strong>depth(root) 函数：</strong></p>
<ul>
<li><p>返回值：</p>
<p>当节点 root 左 &#x2F; 右子树的深度差 ≤1 ：则返回当前子树的深度，即节点 root 的左&#x2F;右子树的深度最大值 +1（ max(left, right) + 1 ）；<br>当节点root 左 &#x2F; 右子树的深度差 &gt;2 ：则返回 -1 ，代表此子树不是平衡树 。</p>
</li>
<li><p>终止条件：<br>当 root 为空：说明越过叶节点，因此返回高度 0 ；<br>当左（右）子树深度为 −1 ：代表此树的 左（右）子树不是平衡树，因此剪枝，直接返回 −1；</p>
</li>
</ul>
<p><strong>isBalanced(root) 函数：</strong></p>
<ul>
<li>返回值： 若 depth(root) !&#x3D; -1 ，则说明此树平衡，返回 true； 否则返回 false 。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">depth</span>(pRoot)!=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">-1</span>||right==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>?<span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="使用flag标记"><a href="#使用flag标记" class="headerlink" title="使用flag标记"></a>使用flag标记</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode* pRoot)</span> </span>&#123;<br>        <span class="hljs-built_in">depth</span>(pRoot);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(pRoot-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>)<br>            flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li>空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
<h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><h2 id="题目链接-39"><a href="#题目链接-39" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="解题思路：分组异或"><a href="#解题思路：分组异或" class="headerlink" title="解题思路：分组异或"></a>解题思路：分组异或</h2><p>先考虑一个比较简单的问题：</p>
<blockquote>
<p>如果除了<strong>一个</strong>数字以外，其他数字都出现了两次，那么如何找到出现一次的数字？</p>
</blockquote>
<p>答案：全员进行异或操作。考虑异或操作的性质：对于两个操作数的每一位，相同结果为 0，不同结果为 1。那么在计算过程中，成对出现的数字的所有位会两两抵消为 0，最终得到的结果就是那个出现了一次的数字。</p>
<p>扩展到找出<strong>两个</strong>出现一次的数字：</p>
<p>思路：把所有数字分成两组，使得：</p>
<ol>
<li>两个只出现一次的数字在不同的组中；</li>
<li>相同的数字会被分到相同的组中。</li>
</ol>
<p><strong>算法流程：</strong></p>
<ol>
<li>设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的两种数的异或结果，即 a^b，eor !&#x3D; 0。</li>
<li>eor 不为 0，其数值必然有一个位置上是1，提取 eor 最右的1，假设为第 n 位，则两个只出现一次的数字 a 和 b 在第 n 位不同。</li>
<li>将数组中的数与提取的结果相与，将数分为两类，即第 n 位为 1 的数和第 n 位不为 1 的数，a 和 b 不在同一类。</li>
<li>设置 eor’ （only）为 0 ，将两类中的一类与 eor’ 进行异或，最后的值即为其中一个出现了奇数次的数。</li>
<li>将 eor’ 和 eor 进行异或，则得到另一个出现了奇数次的数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindNumsAppearOnce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; data,<span class="hljs-type">int</span>* num1,<span class="hljs-type">int</span> *num2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> eor=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            eor^=data[i];<br>        &#125;<br>        <span class="hljs-comment">// eor = num1 ^ num2</span><br>		<span class="hljs-comment">// eor != 0</span><br>		<span class="hljs-comment">// eor必然有一个位置上是1</span><br>        <span class="hljs-type">int</span> rightone = eor &amp; (~eor+<span class="hljs-number">1</span>);<span class="hljs-comment">// 提取出最右的1</span><br>        <span class="hljs-type">int</span> only=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;data.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((rightone&amp;data[i])== <span class="hljs-number">0</span>)<br>            &#123;<br>                only^=data[i];<br>            &#125;<br>        &#125;<br>        *num1=only;<br>        *num2=only^eor;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，只需要遍历数组两次。</li>
<li>空间复杂度：O(1)，只需要常数的空间存放若干变量。</li>
</ul>
<h1 id="41-和为-S-的连续正数序列"><a href="#41-和为-S-的连续正数序列" class="headerlink" title="41.和为 S 的连续正数序列"></a>41.和为 S 的连续正数序列</h1><h2 id="题目链接-40"><a href="#题目链接-40" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100 (至少包括两个数)。没多久,他就得到另一组连续正数和为 100 的序列: 18,19,20,21,22 。现在把问题交给你,你能不能也很快的找出所有和为 S 的连续正数序列? Good Luck!</p>
<p><strong>输出描述:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序<br></code></pre></td></tr></table></figure>

<h2 id="解题思路：双指针滑动窗口"><a href="#解题思路：双指针滑动窗口" class="headerlink" title="解题思路：双指针滑动窗口"></a>解题思路：双指针滑动窗口</h2><p>用两个指针 l 和 r 表示当前枚举到的以 l 为起点到 r 的区间，sum 表示 [l,r] 的区间和，由于 [l,r] 是连续的，所以直接使用求和公式：<code>(l+r)*(r-l+1)/2</code> ，起始 l&#x3D;1,r&#x3D;2 。</p>
<p>一共有三种情况：</p>
<ul>
<li>如果 sum&lt;target 则说明指针 r 还可以向右拓展使得 sum 增大，此时指针 r 向右移动，即 r+&#x3D;1；</li>
<li>如果 sum&gt;target 则说明以 l 为起点不存在一个 r 使得 sum&#x3D;target ，此时要枚举下一个起点，指针 l 向右移动，即 l+&#x3D;1；</li>
<li>如果 sum&#x3D;&#x3D;target 则说明找到了以 l 为起点的合法解 [l,r] ，需要将 [l,r] 的序列放进答案数组，且以 l 为起点的合法解最多只有一个，所以需要枚举下一个起点，指针 l 向右移动，即 l+&#x3D;1。</li>
</ul>
<p>终止条件即为 l&gt;&#x3D;r 的时候，这种情况的发生指针 r 移动到了$\lfloor\frac{\textit{target}}{2}\rfloor+1$ 的位置，导致 l&lt;r 的时候区间和始终大于 target。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">FindContinuousSequence</span>(<span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">1</span>,right=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-type">int</span> curSum=(left+right)*(right-left+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(curSum==sum)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;=right;++i)<br>                    tmp.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curSum&lt;sum)<br>                right++;<br>            <span class="hljs-keyword">else</span> <br>                left++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：由于两个指针移动均单调不减，且最多移动 $\lfloor\frac{\textit{target}}{2}\rfloor$次，即枚举的上界，所以时间复杂度为 O(target) 。</li>
<li>空间复杂度：O(1) ，除了答案数组只需要常数的空间存放若干变量。</li>
</ul>
<h1 id="42-和为-S-的两个数字"><a href="#42-和为-S-的两个数字" class="headerlink" title="42.和为 S 的两个数字"></a>42.和为 S 的两个数字</h1><h2 id="题目链接-41"><a href="#题目链接-41" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<p><strong>输出描述:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对应每个测试案例，输出两个数，小的先输出。<br></code></pre></td></tr></table></figure>

<h2 id="解题思路：双指针"><a href="#解题思路：双指针" class="headerlink" title="解题思路：双指针"></a>解题思路：双指针</h2><p>利用 HashMap 可以通过遍历数组找到数字组合，时间和空间复杂度均为 O(N)；本题的 nums 是 <strong>排序数组</strong> ，因此可使用 <strong>双指针法</strong> 将空间复杂度降低至 O(1) 。</p>
<p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum &#x3D;&#x3D; target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p>这么做的好处是，也保证了乘积最小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; array,<span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=array.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;=j)<br>        &#123;<br>            <span class="hljs-type">int</span> cur=array[i]+array[j];<br>            <span class="hljs-keyword">if</span>(cur==sum)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(array[i]);<br>                res.<span class="hljs-built_in">push_back</span>(array[j]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur&lt;sum)<br>                i++;<br>            <span class="hljs-keyword">else</span><br>                j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为数组 nums 的长度；双指针共同线性遍历整个数组。</li>
<li>空间复杂度 O(1) ： 变量 i , j 使用常数大小的额外空间。</li>
</ul>
<h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><h2 id="题目链接-42"><a href="#题目链接-42" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 S，请你把其循环左移 K 位后的序列输出。例如，字符序列 S&#x3D;”abcXYZdef”,要求输出循环左移 3 位后的结果，即 “XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：字符串切片"><a href="#解法一：字符串切片" class="headerlink" title="解法一：字符串切片"></a>解法一：字符串切片</h3><p>分割两个部分字符串，后面拼接前面。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723104034.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=str.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> str;<br>        <span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(str.begin()+n,str.end())</span></span>;<br>        <span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(str.begin(),str.begin()+n)</span></span>;<br>        <span class="hljs-keyword">return</span> s1+s2;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li>
<li>空间复杂度 O(N)： 两个字符串切片的总长度为 N 。</li>
</ul>
<h3 id="解法二：三次翻转"><a href="#解法二：三次翻转" class="headerlink" title="解法二：三次翻转"></a>解法二：三次翻转</h3><p>先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(string str, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&gt;=str.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> str;<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(str,n,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(begin&lt;end)<br>            <span class="hljs-built_in">swap</span>(str[begin++],str[end--]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li>
<li>空间复杂度 O(1)： 原地翻转，无需额外的空间 。</li>
</ul>
<h1 id="44-翻转单词顺序列"><a href="#44-翻转单词顺序列" class="headerlink" title="44.翻转单词顺序列"></a>44.翻转单词顺序列</h1><h2 id="题目链接-43"><a href="#题目链接-43" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h2><p>先旋转每个单词，再旋转整个字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(j&lt;=len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j==len||str[j]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;<br>                <span class="hljs-built_in">reverse</span>(str,i,j<span class="hljs-number">-1</span>);<br>                i=j+<span class="hljs-number">1</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(str,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;str,<span class="hljs-type">int</span> begin,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(begin&lt;end)<br>            <span class="hljs-built_in">swap</span>(str[begin++],str[end--]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度。</li>
<li>空间复杂度 O(1)： 原地翻转，无需额外的空间 。</li>
</ul>
<h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><h2 id="题目链接-44"><a href="#题目链接-44" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL 今天心情特别好,因为他去买了一副扑克牌,发现里面居然有 2 个大王, 2 个小王(一副牌原本是 54 张^_^)…他随机从中抽出了 5 张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心 A,黑桃 3,小王,大王,方片 5”,“Oh My God!”不是顺子…..LL 不高兴了,他想了想,决定大\小王可以看成任何数字,并且 A 看作 1,J 为 11,Q 为 12,K 为 13。上面的 5 张牌就可以变成“1,2,3,4,5”(大小王分别看作 2 和 4 ),“So Lucky!”。LL 决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们 LL 的运气如何， 如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见,你可以认为大小王是 0。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103918.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<h2 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，此 5 张牌是顺子的充分条件如下：</p>
<ol>
<li>除大小王外，所有牌无重复 ；</li>
<li>设此 5 张牌中最大的牌为 max，最小的牌为 min （大小王除外），则需满足：max−min&lt;5。</li>
</ol>
<p>因而，可将问题转化为：此 5 张牌是否满足以上两个条件？</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103829.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<h3 id="解法一：集合-set-遍历"><a href="#解法一：集合-set-遍历" class="headerlink" title="解法一：集合 set +遍历"></a>解法一：集合 set +遍历</h3><ol>
<li>遍历五张牌，遇到大小王（即 0 ）直接跳过。</li>
<li>判别重复： 利用 unordered_set 实现遍历判重， unordered_set 的查找方法的时间复杂度为 O(1) ；</li>
<li>获取最大 &#x2F; 最小的牌： 借助辅助变量 ma 和 mi ，遍历统计即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; repeat;<br>        <span class="hljs-type">int</span> ma=INT_MIN,mi=INT_MAX;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:numbers)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            ma=<span class="hljs-built_in">max</span>(num,ma);<br>            mi=<span class="hljs-built_in">min</span>(num,mi);<br>            <span class="hljs-keyword">if</span>(repeat.<span class="hljs-built_in">count</span>(num))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            repeat.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ma-mi&lt;<span class="hljs-number">5</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)&#x3D;O(5)&#x3D;O(1) ： 其中 N 为 nums 长度，本题中 N≡5 ；遍历数组使用 O(N) 时间。</li>
<li>空间复杂度 O(N)&#x3D;O(5)&#x3D;O(1) ： 用于判重的辅助 set 使用 O(N) 额外空间。</li>
</ul>
<h3 id="解法二：排序-遍历"><a href="#解法二：排序-遍历" class="headerlink" title="解法二：排序 + 遍历"></a>解法二：排序 + 遍历</h3><ol>
<li>先对数组执行排序。</li>
<li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i]&#x3D;nums[i+1] 是否成立来判重。</li>
<li>获取最大 &#x2F; 最小的牌： 排序后，数组末位元素 nums[4] 为最大牌；元素 nums[joker] 为最小牌，其中 joker 为大小王的数量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt; numbers )</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> joker=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(),numbers.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]==<span class="hljs-number">0</span>)<br>                joker++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[i]==numbers[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> numbers[<span class="hljs-number">4</span>]-numbers[joker]&lt;<span class="hljs-number">5</span>?<span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(NlogN)&#x3D;O(5log5)&#x3D;O(1) ： 其中 N 为 nums 长度，本题中 N≡5 ；数组排序使用 O(NlogN) 时间。</li>
<li>空间复杂度 O(1)： 变量 joker 使用 O(1) 大小的额外空间。</li>
</ul>
<h1 id="46-孩子们的游戏（圆圈中最后剩下的数）"><a href="#46-孩子们的游戏（圆圈中最后剩下的数）" class="headerlink" title="46.孩子们的游戏（圆圈中最后剩下的数）"></a>46.孩子们的游戏（圆圈中最后剩下的数）</h1><h2 id="题目链接-45"><a href="#题目链接-45" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF 作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数 m,让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续 0…m-1 报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 n-1)。</p>
<p>如果没有小朋友，请返回 -1。</p>
<h2 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h2><p>一篇比较好的约瑟夫环讲解文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011500062/article/details/72855826">https://blog.csdn.net/u011500062/article/details/72855826</a></p>
<h3 id="解法一：递归-3"><a href="#解法一：递归-3" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 特殊输入的处理</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// base case</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">LastRemaining_Solution</span>(n<span class="hljs-number">-1</span>,m)+m)%n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，需要求解的函数值有 n 个。</li>
<li>空间复杂度：O(n)，函数的递归深度为 n，需要使用 O(n) 的栈空间。</li>
</ul>
<h3 id="解法二：迭代-2"><a href="#解法二：迭代-2" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>可以改写为迭代，避免递归使用栈空间。</p>
<p>最终剩下一个人时的安全位置肯定为 0，反推安全位置在人数为 n 时的编号：<br>人数为1： 0<br>人数为2： (0+m) % 2<br>人数为3： ((0+m) % 2 + m) % 3<br>人数为4： (((0+m) % 2 + m) % 3 + m) % 4<br>……..<br>迭代推理到 n 就可以得出答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)<br>            res=(res+m)%i;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)，需要求解的函数值有 n 个。</li>
<li>空间复杂度：O(1)，只使用常数个变量。</li>
</ul>
<h1 id="47-求-1-2-3-…-n"><a href="#47-求-1-2-3-…-n" class="headerlink" title="47.求 1+2+3+…+n"></a>47.求 1+2+3+…+n</h1><h2 id="题目链接-46"><a href="#题目链接-46" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h2><p>求 1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<h2 id="解题思路：递归"><a href="#解题思路：递归" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>本题在简单问题上做了许多限制，可使用排除法一步步导向答案。1+2+…+(n−1)+n 的计算方法主要有三种：平均计算、迭代、递归。</p>
<p><strong>方法一：</strong> 平均计算<br><strong>问题：</strong> 此计算必须使用 <strong>乘除法</strong> ，因此本方法不可取，直接排除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> + n) * n / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法二：</strong> 迭代<br><strong>问题：</strong> 循环必须使用 while 或 for ，因此本方法不可取，直接排除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        res += i;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法三：</strong> 递归<br>问题： 终止条件需要使用 if ，因此本方法不可取。<br>思考： 除了 if 和 switch 等判断语句外，是否有其他方法可用来终止递归？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    n += <span class="hljs-built_in">sumNums</span>(n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>逻辑运算符的短路效应：</strong></p>
<p>常见的逻辑运算符有三种，即 “与 &amp;&amp; ”，“或 ∣∣”，“非 !”；而其有重要的短路效应，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(A &amp;&amp; B)</span></span>  <span class="hljs-comment">// 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A &amp;&amp; B 为 false</span><br><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(A || B)</span></span> <span class="hljs-comment">// 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true</span><br></code></pre></td></tr></table></figure>

<p>本题需要实现 “当 n &#x3D; 1 时终止递归”的需求，可通过短路效应实现。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">n</span>+=sumNums(<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) // 当 <span class="hljs-built_in">n</span> = <span class="hljs-number">1</span> 时 <span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span> 不成立 ，此时 “短路” ，终止后续递归<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        n&gt;<span class="hljs-number">1</span>&amp;&amp;(n+=<span class="hljs-built_in">Sum_Solution</span>(n<span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(n) ： 计算 n+(n−1)+…+2+1 需要开启 n 个递归函数。</li>
<li>空间复杂度 O(n) ： 递归深度达到 n ，系统使用 O(n) 大小的额外空间。</li>
</ul>
<h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><h2 id="题目链接-47"><a href="#题目链接-47" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、&#x2F;四则运算符号。</p>
<h2 id="解题思路：位运算"><a href="#解题思路：位运算" class="headerlink" title="解题思路：位运算"></a>解题思路：位运算</h2><p>三步走的方式计算二进制值相加： 5-101，7-111</p>
<p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p>
<p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p>
<p>第三步：重复上述两步， 各位相加 010^1010&#x3D;1000，进位值为100&#x3D;(010&amp;1010)&lt;&lt;1。</p>
<p>继续重复上述两步：1000^100 &#x3D; 1100，进位值为0，跳出循环，1100为最终结果。</p>
<p><strong>算法流程：</strong></p>
<ul>
<li>（和 s ）&#x3D;（非进位和 n ）+（进位 c ）。即可将 s&#x3D;a+b 转化为：s&#x3D;a+b⇒s&#x3D;n+c。</li>
<li>循环求 n 和 c ，直至进位 c &#x3D; 0；此时 s&#x3D;n ，返回 n 即可。</li>
</ul>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(num2==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(num1^num2,(num1&amp;num2)&lt;&lt;<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 当进位为 0 时跳出</span><br>        <span class="hljs-keyword">while</span>(num2!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> c=(num1&amp;num2)&lt;&lt;<span class="hljs-number">1</span>;<span class="hljs-comment">//c = 进位</span><br>            num1^=num2; <span class="hljs-comment">//num1 = 非进位和</span><br>            num2=c; <span class="hljs-comment">//num2 = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> num1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(1)： 最差情况下（例如 a&#x3D;0x7fffffff , b&#x3D;1 时），需循环 31 次，使用 O(1) 时间；每轮中的常数次位操作使用 O(1) 时间。</li>
<li>空间复杂度 O(1) ： 使用常数大小的额外空间。</li>
</ul>
<h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><h2 id="题目链接-48"><a href="#题目链接-48" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输入一个字符串,包括数字字母符号,可以为空。<br></code></pre></td></tr></table></figure>

<p><strong>输出描述:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果是合法的数值表达则返回该数字，否则返回0。<br></code></pre></td></tr></table></figure>

<p><strong>示例1</strong></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">Input：<br>+<span class="hljs-number">2147483647</span><br><span class="hljs-number">1</span>a33<br><br>Output：<br><span class="hljs-number">2147483647</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，有以下四种字符需要考虑：</p>
<ol>
<li>首部空格： 删除之即可；</li>
<li>符号位： 三种情况，即 ‘’+’’ , ‘’−’’ , ‘’无符号” ；新建一个变量保存符号位，返回前判断正负即可。</li>
<li>非数字字符： 遇到首个非数字的字符时，应立即返回 0。</li>
<li>数字字符：<ul>
<li>字符转数字：“此数字的 ASCII 码” 与 “ 0 的 ASCII 码” 相减即可；</li>
<li>数字拼接： 若从左向右遍历数字，设当前位字符为 c ，当前位数字为 x ，数字结果为 res ，则数字拼接公式为：</li>
</ul>
</li>
</ol>
<p>$$<br>res &#x3D; 10 \times res + x \ x &#x3D; ascii(c) - ascii(‘0’)<br>$$</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103637.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p><strong>数字越界处理：</strong></p>
<p>题目要求返回的数值范围应在 [−2^31 ,2^31 −1] ，因此需要考虑数字越界问题。而由于题目指出 环境只能存储 32 位大小的有符号整数 ，因此判断数字越界时，要始终保持 res 在 int 类型的取值范围内。</p>
<p>在每轮数字拼接前，判断 res 在此轮拼接后是否超过 2147483647 ，若超过则加上符号位直接返回。<br>设数字拼接边界 bndry&#x3D;2147483647 &#x2F; 10&#x3D;214748364 ，则以下两种情况越界：<br>$$<br>\left{\begin{array}{l}r e s&gt;b n d r y \ r e s&#x3D;b n d r y, x&gt;7\end{array}\right.<br>$$</p>
<ul>
<li>情况一：执行拼接 10×res≥2147483650 越界</li>
<li>情况二：拼接后是 2147483648 或 2147483649 越界</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103627.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,bndry=INT_MAX/<span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,sign=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(str[i]==<span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;i&lt;str.<span class="hljs-built_in">size</span>())<br>            i++;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            sign=<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(str[i]==<span class="hljs-string">&#x27;+&#x27;</span>||str[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            i++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;str.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(str[j]&lt;<span class="hljs-string">&#x27;0&#x27;</span>||str[j]&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(res&gt;bndry||res==bndry&amp;&amp;str[j]&gt;<span class="hljs-string">&#x27;7&#x27;</span>)<br>                <span class="hljs-keyword">return</span> sign==<span class="hljs-number">1</span>?INT_MAX:INT_MIN;<br>            res=res*<span class="hljs-number">10</span>+(str[j]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign*res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为字符串长度，线性遍历字符串占用 O(N) 时间。</li>
<li>空间复杂度 O(N) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(N) 额外空间</li>
</ul>
<h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><h2 id="题目链接-49"><a href="#题目链接-49" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2 。</p>
<h2 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：哈希-遍历"><a href="#解法一：哈希-遍历" class="headerlink" title="解法一：哈希+遍历"></a>解法一：哈希+遍历</h3><p>直接想到的方法是遍历数组，并使用 HashMap 统计每个数字的数量，遇到数量大于 1 的数字则返回。此方法时间复杂度和空间复杂度均为 O(N) 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Parameters:</span><br>    <span class="hljs-comment">//        numbers:     an array of integers</span><br>    <span class="hljs-comment">//        length:      the length of array numbers</span><br>    <span class="hljs-comment">//        duplication: (Output) the duplicated number in the array number</span><br>    <span class="hljs-comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span><br>    <span class="hljs-comment">//                     otherwise false</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> numbers[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span>* duplication)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">NULL</span> || length &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; repeat;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(repeat.<span class="hljs-built_in">count</span>(numbers[i]))<br>            &#123;<br>                *duplication=numbers[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                repeat.<span class="hljs-built_in">insert</span>(numbers[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂性分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。遍历数组一遍。使用哈希集合，添加元素的时间复杂度为 O(1)，故总的时间复杂度是 O(n)。</li>
<li>空间复杂度：O(n)。不重复的每个元素都可能存入集合，因此占用 O(n) 额外空间。</li>
</ul>
<h3 id="解法二：原地交换"><a href="#解法二：原地交换" class="headerlink" title="解法二：原地交换"></a>解法二：原地交换</h3><p>题目指出在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内 。 因此，可遍历数组并通过交换操作使元素的索引与值 一一对应（即 nums[i] &#x3D; i ）。因而，就能通过索引找到对应的值。</p>
<p>遍历中，当第二次遇到数字 x 时，一定有 nums[x] &#x3D; x （因为第一次遇到 x 时已经将其交换至 nums[x] 处了）。利用以上方法，即可得到一组重复数字。</p>
<p><strong>算法流程：</strong></p>
<ul>
<li>遍历数组 nums ，设索引初始值为 i&#x3D;0:<ol>
<li>若 nums[i] &#x3D;&#x3D; i ： 说明此数字已在对应索引位置，无需交换，因此执行 i +&#x3D; 1 与 continue ；</li>
<li>若 nums[nums[i]] &#x3D;&#x3D; nums[i] ： 说明索引 nums[i] 处的元素值也为 nums[i]，即找到一组相同值，返回此值 nums[i]；</li>
<li>否则： 当前数字是第一次遇到，因此交换索引为 i 和 nums[i] 的元素值，将此数字交换至对应索引位置。</li>
</ol>
</li>
<li>若遍历完毕尚未返回，则返回 false ，代表数组中无相同值。</li>
</ul>
<p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103608.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">duplicate</span><span class="hljs-params">(<span class="hljs-type">int</span> numbers[], <span class="hljs-type">int</span> length, <span class="hljs-type">int</span>* duplication)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers == <span class="hljs-literal">NULL</span> || length &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;length)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(numbers[i]==i)<br>            &#123;<br>                i++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(numbers[i]==numbers[numbers[i]])<br>            &#123;<br>                *duplication=numbers[i];<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(numbers[i],numbers[numbers[i]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</li>
<li>空间复杂度 O(1) ： 使用常数复杂度的额外空间。</li>
</ul>
<h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><h2 id="题目链接-50"><a href="#题目链接-50" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 A[0, 1,…, n-1] ,请构建一个数组 B[0,1,…,n-1] ,其中 B 中的元素 B[i]&#x3D;A[0] * A[1]*…<em>A[i-1] * A[i+1]</em>…*A[n-1]。不能使用除法（注意：规定B[0] &#x3D; A[1] * A[2] * … * A[n-1]，B[n-1] &#x3D; A[0] * A[1] * … * A[n-2]）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103555.png" srcset="/img/loading.gif" lazyload  style="zoom: 80%;" />

<h2 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h2><p>观察公式发现，B[i] 公式中没有 A[i] 项，也就是说如果可以使用除法，就可以用公式B[i]&#x3D;A[0] * A[1]*…..*A[n-1]&#x2F;A[i] 来计算 B[i]，但是题目要求不能使用。</p>
<p>根据题目对 B[i] 的定义可列表格，如下图所示。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103545.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p>根据表格的主对角线（全为 1 ），可将表格分为上三角和下三角 两部分。分别迭代计算下三角和上三角两部分的乘积，即可不使用除法就获得结果。即把 B[i]&#x3D;A[0]* A[1]<em>….. * A[i-1]</em> A[i+1]<em>…..<em>A[n-1]。看成A[0]</em> A[1]</em>….. * A[i-1]和 A[i+1]* …..A[n-2]*A[n-1]两部分的乘积。</p>
<p><strong>算法流程：</strong></p>
<ol>
<li>初始化：数组 B ，其中 B[0] &#x3D; 1 ；辅助变量 tmp&#x3D;1 ；</li>
<li>计算 B[i] 的下三角各元素的乘积，直接乘入B[i]，即B[i]&#x3D;B[i-1]*A[i-1] ；</li>
<li>计算 B[i] 的上三角各元素的乘积，记为 tmp ，并乘入 B[i] ，即 B[i]&#x3D;B[i+1]*A[i+1]；</li>
<li>返回 B 。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length=A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">B</span><span class="hljs-params">(length)</span></span>;<br>        <span class="hljs-keyword">if</span>(length==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> B;<br>        B[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;length;++i)<br>            B[i]=B[i<span class="hljs-number">-1</span>]*A[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-type">int</span> tmp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            tmp*=A[i+<span class="hljs-number">1</span>];<br>            B[i]*=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> B;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为数组长度，两轮遍历数组 a ，使用 O(N) 时间。</li>
<li>空间复杂度 O(1)： 变量 tmp 使用常数大小额外空间（数组 b 作为返回值，不计入复杂度考虑）。</li>
</ul>
<h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><h2 id="题目链接-51"><a href="#题目链接-51" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括 ‘ . ‘ 和 ‘ * ‘ 的正则表达式。模式中的字符 ‘ . ‘ 表示任意一个字符，而 ‘ * ‘ 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p>
<h2 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>假设主串为 A，模式串为 B 。从最后一步出发，需要关注最后进来的字符。假设 A 的长度为 n ，B 的长度为 m ，关注正则表达式 B 的最后一个字符是谁，它有三种可能，正常字符、* 和 .（点），那针对这三种情况讨论即可，如下：</p>
<ol>
<li>如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m−1]，相等则看 A{0..m-2} 与 B {0..m−2}，不等则是不能匹配，这就是子问题。</li>
<li>如果 B 的最后一个字符是‘ . ’，它能匹配任意字符，直接看 A{0..n-2}与 B{0..m-2}</li>
<li>如果 B 的最后一个字符是 ‘ * ’，它代表 B[m−2]&#x3D;c 可以重复 0 次或多次，它们是一个整体 c∗<ul>
<li>情况一：A[n−1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A{0..n-1} 和 B{0..m-3} 是否匹配；</li>
<li>情况二：A[n-1] 是多个 c 中的最后一个（这种情况必须 A[n-1]&#x3D;c 或者 c&#x3D;’ . ‘ ），所以 A 匹配完往前挪一个，B 继续匹配，因为可以匹配多个，继续看 A{0..n-2} 和 B{0..m-1} 是否匹配。</li>
</ul>
</li>
</ol>
<p><strong>转移方程：</strong></p>
<p>f [i] [j] 代表 A 的前 i 个和 B 的前 j 个能否匹配：</p>
<ul>
<li>对于前面两个情况，可以合并成一种情况 f [i] [j] &#x3D; f [i-1] [j-1]；</li>
<li>对于第三种情况，对于 c∗ 分为看和不看两种情况：<ul>
<li>不看：直接砍掉正则串的后面两个， f [i] [j] &#x3D; f [i] [j-2]；</li>
<li>看：正则串不动，主串前移一个，f [i] [j] &#x3D; f [i-1] [j]。</li>
</ul>
</li>
</ul>
<p><strong>初始条件：</strong></p>
<p>特判：需要考虑空串空正则</p>
<ul>
<li>空串和空正则是匹配的，f [0] [0] &#x3D; true；</li>
<li>空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如 A&#x3D; ‘’ ‘’, B&#x3D;a∗b∗c∗）；</li>
<li>非空串和空正则必不匹配，f [1] [0]&#x3D;…&#x3D;f [n] [0]&#x3D; false；</li>
<li>非空串和非空正则，那肯定是需要计算的了。</li>
</ul>
<p>大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 ∗ 两种情况了。</p>
<p><strong>结果：</strong></p>
<p>开数组要开 n+1，这样对于空串的处理十分方便。结果就是 f [n] [m]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>* pattern)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n=<span class="hljs-built_in">strlen</span>(str);<br>        <span class="hljs-type">int</span> m=<span class="hljs-built_in">strlen</span>(pattern);<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">f</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m+<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;++j)<br>            &#123;<br>                <span class="hljs-comment">//分成空正则和非空正则两种</span><br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>)<br>                    f[i][j]=(i==<span class="hljs-number">0</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//非空正则分为两种情况 * 和 非*</span><br>                    <span class="hljs-keyword">if</span>(pattern[j<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;(str[i<span class="hljs-number">-1</span>]==pattern[j<span class="hljs-number">-1</span>]||pattern[j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                            f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">//碰到 * 了，分为看和不看两种情况</span><br>                        <span class="hljs-comment">//不看，重复 0 次</span><br>                        <span class="hljs-keyword">if</span>(j&gt;=<span class="hljs-number">2</span>)<br>                            f[i][j]=f[i][j<span class="hljs-number">-2</span>];<br>                        <span class="hljs-comment">//看，重复 1 次或者多次</span><br>                        <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-number">1</span>&amp;&amp;j&gt;=<span class="hljs-number">2</span>&amp;&amp;(str[i<span class="hljs-number">-1</span>]==pattern[j<span class="hljs-number">-2</span>]||pattern[j<span class="hljs-number">-2</span>]==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                            <span class="hljs-comment">//这里要用 || 连接， 不然重复 0 次的会直接覆盖</span><br>                            f[i][j]=f[i][j<span class="hljs-number">-2</span>]||f[i<span class="hljs-number">-1</span>][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：递归-2"><a href="#解法二：递归-2" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p>递归三部曲为：</p>
<ol>
<li>递归函数功能：match(s, p) -&gt; bool , 表示 p 是否可以匹配 s；</li>
<li>递归终止条件：<ul>
<li>如果 s 和 p 同时为空，表明正确匹配 ；</li>
<li>如果 s 不为空，p 为空，表明，不能正确匹配； </li>
<li>如果 s 为空，p 不为空，需要计算，不能直接给出结果 。</li>
</ul>
</li>
<li>下一步递归：<ul>
<li>对于前面讨论的情况 1，2 进行合并，如果 *s &#x3D;&#x3D; *p || *p &#x3D;&#x3D; ‘ . ‘,则 match(s+1, p+1)；</li>
<li>对于情况 3，如果重复一次或者多次，则 match(s+1,p),如果重复 0 次，则 match(s, p+2)。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">match</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">char</span>* pattern)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果 s 和 p 同时为空</span><br>        <span class="hljs-keyword">if</span>(*str==<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;*pattern==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果 s不为空， 但是 p 为空</span><br>        <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;*pattern==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果pattern下一个字符没有 &#x27;*&#x27;</span><br>        <span class="hljs-keyword">if</span>(*(pattern+<span class="hljs-number">1</span>)!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;(*str==*pattern||*pattern==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">match</span>(str+<span class="hljs-number">1</span>,pattern+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果有 &#x27;*&#x27;</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">bool</span> ret=<span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 重复 1 次或多次</span><br>            <span class="hljs-keyword">if</span>(*str!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;(*str==*pattern||*pattern==<span class="hljs-string">&#x27;.&#x27;</span>))<br>                ret=<span class="hljs-built_in">match</span>(str+<span class="hljs-number">1</span>,pattern);<br>            <span class="hljs-comment">// 重复 0 次</span><br>            <span class="hljs-keyword">return</span> ret||<span class="hljs-built_in">match</span>(str,pattern+<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><h2 id="题目链接-52"><a href="#题目链接-52" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&&tqId=11206&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 “+100”,”5e2”,”-123”,”3.1416”和”-1E-16” 都表示数值。 但是 “12e”,”1a3.14”,”1.2.3”,”+-5” 和 “12e+4.3” 都不是。</p>
<h2 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h2><p>启用 3 个标记，分别是 +&#x2F;- 标记，. 标记，e&#x2F;E 标记，标记它们是否多次访问。</p>
<ul>
<li>+&#x2F;-<ul>
<li>第一次出现 不在开头，也不再 e&#x2F;E 后面 就返回 false；</li>
<li>后续出现次数，不在 e&#x2F;E 后面 也返回 false。</li>
</ul>
</li>
<li>e&#x2F;E<ul>
<li>到末尾了，直接返回 false；</li>
<li>存在多个，直接返回 false；</li>
</ul>
</li>
<li>.<ul>
<li>. 多次出现或者出现在 e&#x2F;E 后面，直接返回 false。</li>
</ul>
</li>
<li>不是数字<ul>
<li>直接返回 false。</li>
</ul>
</li>
<li>其他<ul>
<li>返回 true。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNumeric</span><span class="hljs-params">(<span class="hljs-type">char</span>* string)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">bool</span> sign=<span class="hljs-literal">false</span>,decimal=<span class="hljs-literal">false</span>,hasE=<span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(string);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27;</span><br>            <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;+&#x27;</span>||string[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27; 第一次出现 不在开头，也不在e/E后面</span><br>                <span class="hljs-keyword">if</span>(!sign&amp;&amp;i!=<span class="hljs-number">0</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// &#x27;+&#x27;/&#x27;-&#x27; 其他出现次数 不在e/E后面</span><br>                <span class="hljs-keyword">if</span>(sign&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;e&#x27;</span>&amp;&amp;string[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;E&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                sign=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;e&#x27;</span>||string[i]==<span class="hljs-string">&#x27;E&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// 后面没有数字</span><br>                <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>==len)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(hasE)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                hasE=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]==<span class="hljs-string">&#x27;.&#x27;</span>)<span class="hljs-comment">// &#x27;.&#x27;</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(decimal||hasE)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                decimal=<span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(string[i]&lt;<span class="hljs-string">&#x27;0&#x27;</span>||string[i]&gt;<span class="hljs-string">&#x27;9&#x27;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><h2 id="题目链接-53"><a href="#题目链接-53" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<p><strong>输出描述:</strong></p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">如果当前字符流没有存在出现一次的字符，返回<span class="hljs-meta">#字符。</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h2><p>将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在 string 中，然后再遍历 string ，从哈希表中找到第一个出现一次的字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">//Insert one char from stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span></span><br><span class="hljs-function">    </span>&#123;<br>        s+=ch;<br>        count[ch]++;<br>    &#125;<br>  <span class="hljs-comment">//return the first appearence once char in current stringstream</span><br>    <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(count[s[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> s[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    string s;<br>    <span class="hljs-type">int</span> count[<span class="hljs-number">256</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h1><h2 id="题目链接-54"><a href="#题目链接-54" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。</p>
<h2 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h3><ol>
<li>遍历单链表的每个结点；</li>
<li>如果当前结点地址没有出现在 set 中，则存入 set 中；</li>
<li>否则，出现在 set 中，则当前结点就是环的入口结点；</li>
<li>整个单链表遍历完，若没出现在 set 中，则不存在环。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(pHead)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(pHead)==<span class="hljs-number">0</span>)<br>            &#123;<br>                st.<span class="hljs-built_in">insert</span>(pHead);<br>                pHead=pHead-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)，最坏情况下，单链表的所有结点都在存入 set。</li>
</ul>
<h3 id="解法二：双指针-2"><a href="#解法二：双指针-2" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h3><p>使用双指针，一个快指针 fast 每次移动两个节点，一个慢指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。</p>
<p>假设环入口节点为 y1，相遇所在节点为 z1。</p>
<p>假设快指针 fast 在圈内绕了 N 圈，则总路径长度为 x+Ny+(N-1)z。z 为 (N-1) 倍是因为快慢指针最后已经在 z1 节点相遇了，后面就不需要再走了。而慢指针 slow 总路径长度为 x+y。因为快指针是慢指针的两倍，因此 x+Ny+(N-1)z &#x3D; 2(x+y)。我们要找的是环入口节点 y1，也可以看成寻找长度 x 的值，因此我们先将上面的等值分解为和 x 有关：x&#x3D;(N-2)y+(N-1)z。</p>
<p>上面的等值没有很强的规律，但是我们可以发现 y+z 就是圆环的总长度，因此我们将上面的等式再分解：x&#x3D;(N-2)(y+z)+z。这个等式左边是从起点x1 到环入口节点 y1 的长度，而右边是在圆环中走过 (N-2) 圈，再从相遇点 z1 再走过长度为 z 的长度。此时我们可以发现如果让两个指针同时从起点 x1 和相遇点 z1 开始，每次只走过一个距离，那么最后他们会在环入口节点相遇。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103453.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead==<span class="hljs-literal">nullptr</span>||pHead-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* slow=pHead;<br>        ListNode* fast=pHead;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(slow!=fast);<br>        fast=pHead;<br>        <span class="hljs-keyword">while</span>(slow!=fast)<br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h1><h2 id="题目链接-55"><a href="#题目链接-55" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p>
<h2 id="解题思路-49"><a href="#解题思路-49" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>为了防止删除头结点的极端情况发生，先创建空结点 dummy，使 dummy 指向传入的 head 结点；</li>
<li>创建cur的指针，指向链表的头部（即dummy）；</li>
<li>对cur指针迭代，因为要对比 cur ( cur 最初始的定义指向空结点)指针的下一个结点与下下一个结点的值是否相等，为了防止产生空指针异常，故退出迭代的条件为：cur.next !&#x3D; null &amp;&amp; cur.next.next !&#x3D; null；</li>
<li>在迭代过程中，如果 cur.next.val &#x3D;&#x3D; cur.next.next.val 说明此时有重复元素，此时创建一个临时指针 tmp，指向 cur 的下一个节点，即 tmp 指向第一个重复元素所在的位置。通过 while 循环去重，去重后，tmp 指向重复元素中的最后一个位置。最后 cur.next &#x3D; temp.next 就实现了消除重复元素。</li>
<li>如果未发现重复元素，则直接向后迭代即可。</li>
<li>迭代完成后，返回 dummy 的 next。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct ListNode *next;</span><br><span class="hljs-comment">    ListNode(int x) :</span><br><span class="hljs-comment">        val(x), next(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode* pHead)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=pHead;<br>        ListNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)<br>            &#123;<br>                ListNode* tmp=cur-&gt;next;<br>                <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;val==tmp-&gt;next-&gt;val)<br>                    tmp=tmp-&gt;next;<br>                cur-&gt;next=tmp-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h1><h2 id="题目链接-56"><a href="#题目链接-56" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h2 id="解题思路-50"><a href="#解题思路-50" class="headerlink" title="解题思路"></a>解题思路</h2><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103413.png" srcset="/img/loading.gif" lazyload></p>
<p>以上图为例，二叉树的中序遍历是 d,b,h,e,i,a,f,c,g。以这棵树为例来分析如何找出二叉树的下一个结点。</p>
<p>如果一个结点有右子树，那么它的下一个结点就是它的右子树的最左子结点。也就是说从右子结点出发一直沿着指向左子树结点的指针，就能找到它的下一个结点。例如，图中结点 b 的下一个结点是 h，结点 a 的下一个结点是 f。</p>
<p>接着分析一下结点没有右子树的情形。如果结点是它父结点的左子结点，那么它的下一个结点就是它的父结点。例如，途中结点 d 的下一个结点是 b，f 的下一个结点是 c。</p>
<p>如果一个结点既没有右子树，并且它还是父结点的右子结点，这种情形就比较复杂。可以沿着指向父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点。如果这样的结点存在，那么这个结点的父结点就是要找的下一个结点。例如，为了找到结点 g 的下一个结点，沿着指向父结点的指针向上遍历，先到达结点 c。由于结点 c 是父结点 a 的右结点，继续向上遍历到达结点a。由于结点 a 是树的根结点，它没有父结点。因此结点 g 没有下一个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pNode==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeLinkNode* pNext=<span class="hljs-literal">nullptr</span>;<br>         <span class="hljs-comment">// 当前结点有右子树，那么它的下一个结点就是它的右子树中最左子结点</span><br>        <span class="hljs-keyword">if</span>(pNode-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            TreeLinkNode* pRight=pNode-&gt;right;<br>            <span class="hljs-keyword">while</span>(pRight-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                pRight=pRight-&gt;left;<br>            pNext=pRight;<br>        &#125;<br>         <span class="hljs-comment">// 当前结点无右子树，则需要找到一个是它父结点的左子树结点的结点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pNode-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 当前结点</span><br>            TreeLinkNode* pCur=pNode;<br>            <span class="hljs-comment">// 父节点</span><br>            TreeLinkNode* pPar=pNode-&gt;next;<br>            <span class="hljs-keyword">while</span>(pPar!=<span class="hljs-literal">nullptr</span>&amp;&amp;pCur==pPar-&gt;right)<br>            &#123;<br>                pCur=pPar;<br>                pPar=pPar-&gt;next;<br>            &#125;<br>            pNext=pPar;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pNext;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h1><h2 id="题目链接-57"><a href="#题目链接-57" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解题思路-51"><a href="#解题思路-51" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-4"><a href="#解法一：递归-4" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>对称二叉树定义： 对于树中任意两个对称节点 L 和 R ，一定有：</p>
<ul>
<li>L.val&#x3D;R.val ：即此两对称节点值相等。</li>
<li>L.left.val&#x3D;R.right.val ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val&#x3D;R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
<p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103304.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p><strong>算法流程：</strong><br>isSymmetric(root) ：</p>
<ul>
<li>特例处理： 若根节点 root 为空，则直接返回 true ；</li>
<li>返回值： 即 recur(root.left, root.right) 。</li>
</ul>
<p>recur(L, R) ：</p>
<ul>
<li>终止条件：<ul>
<li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；</li>
<li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；</li>
<li>当节点 L 值 !&#x3D; 节点 R 值： 此树不对称，因此返回 false ；</li>
</ul>
</li>
<li>递推工作：<ul>
<li>判断两节点 L.left 和 R.right 是否对称，即 recur(L.left, R.right) ；</li>
<li>判断两节点 L.right 和 R.left 是否对称，即 recur(L.right, R.left) ；</li>
</ul>
</li>
<li>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(pRoot-&gt;left,pRoot-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recur</span><span class="hljs-params">(TreeNode* L,TreeNode* R)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">nullptr</span>&amp;&amp;R==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(L==<span class="hljs-literal">nullptr</span>||R==<span class="hljs-literal">nullptr</span>||L-&gt;val!=R-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recur</span>(L-&gt;left,R-&gt;right)&amp;&amp;<span class="hljs-built_in">recur</span>(L-&gt;right,R-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，每次执行 recur() 可以判断一对节点是否对称，因此最多调用 N&#x2F;2 次 recur() 方法。</li>
<li>空间复杂度 O(N) ： 最差情况下（见下图），二叉树退化为链表，系统使用 O(N) 大小的栈空间。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103253.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<h3 id="解法二：非递归-1"><a href="#解法二：非递归-1" class="headerlink" title="解法二：非递归"></a>解法二：非递归</h3><p>用 stack 或者 queue 模拟 bfs 。</p>
<p>首先从队列中拿出两个节点( left 和 right )比较。将 left 的 left 节点和 right 的 right 节点放入队列，将 left 的 right 节点和 right 的 left 节点放入队列。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200727104447.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode* pRoot)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(pRoot-&gt;left);<br>        s.<span class="hljs-built_in">push</span>(pRoot-&gt;right);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* curR=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* curL=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>&amp;&amp;curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>||curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(curL&amp;&amp;curR)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(curL-&gt;val!=curR-&gt;val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 左子树的左孩子、右子树的右孩子</span><br>                s.<span class="hljs-built_in">push</span>(curL-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;right);<br>                <span class="hljs-comment">// 左子树的右孩子、右子树的左孩子</span><br>                s.<span class="hljs-built_in">push</span>(curL-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)。</li>
<li>空间复杂度 O(N)。</li>
</ul>
<h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><h2 id="题目链接-58"><a href="#题目链接-58" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解题思路-52"><a href="#解题思路-52" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>建议先做 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">22.从上往下打印二叉树</a>、<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">60.把二叉树打印成多行</a>，本题在前两题的基础上增加额外要求，即打印顺序交替变化。</p>
</blockquote>
<h3 id="解法一：层序遍历-倒序"><a href="#解法一：层序遍历-倒序" class="headerlink" title="解法一：层序遍历+倒序"></a>解法一：层序遍历+倒序</h3><p>增加 flag 标记，初始化为 false，即从左到右打印，当一层打印结束后，修改 flag 为 !flag，当 flag&#x3D;true 时，利用 reverse 函数将 tmp 进行倒序，即从右到左打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(pRoot);<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>            flag=!flag;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) 。共完成少于 N 个节点的倒序操作，占用 O(N) 。</li>
<li>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
<h3 id="解法二：层序遍历-双端队列（奇偶层逻辑分离）"><a href="#解法二：层序遍历-双端队列（奇偶层逻辑分离）" class="headerlink" title="解法二：层序遍历 + 双端队列（奇偶层逻辑分离）"></a>解法二：层序遍历 + 双端队列（奇偶层逻辑分离）</h3><p>利用双端队列 deque 可从两边添加元素的特性，从第 1 层开始，规定：</p>
<ul>
<li>打印奇数层时，从左到右打印，即正序打印，从 deque 前面取，后面放元素；</li>
<li>打印偶数层时，从右到左打印，即逆序打印，从 deque 后面取，前面放元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        deque&lt;TreeNode*&gt; dq;<br>        dq.<span class="hljs-built_in">push_back</span>(pRoot);<br>        <span class="hljs-type">int</span> level=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=dq.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur;<br>                <span class="hljs-comment">// 前取后放 从左边往右， 正序 前面取 后面放</span><br>                <span class="hljs-keyword">if</span>((level&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)<br>                &#123;<br>                    cur=dq.<span class="hljs-built_in">front</span>();<br>                    dq.<span class="hljs-built_in">pop_front</span>();<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_back</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_back</span>(cur-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">// 后取前放 从右边向左，逆序 前面放 后面取</span><br>                &#123;<br>                    cur=dq.<span class="hljs-built_in">back</span>();<br>                    dq.<span class="hljs-built_in">pop_back</span>();<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_front</span>(cur-&gt;right);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        dq.<span class="hljs-built_in">push_front</span>(cur-&gt;left);<br>                &#125;<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125;<br>            level++;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。</li>
<li>空间复杂度 O(N) ： 最差情况下，即当树为满二叉树时，最多有 N&#x2F;2 个树节点同时在 deque 中，使用 O(N) 大小的额外空间。</li>
</ul>
<h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><h2 id="题目链接-59"><a href="#题目链接-59" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解题思路-53"><a href="#解题思路-53" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>建议先做 <a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">22.从上往下打印二叉树</a>，两题仅有微小区别，即本题需将每一层打印到一行。</p>
</blockquote>
<h3 id="解法一：迭代-1"><a href="#解法一：迭代-1" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h3><ul>
<li><p>按层打印： 题目要求二叉树的从上至下打印（即按层打印），又称为二叉树的广度优先搜索（BFS）。BFS 通常借助队列的先入先出特性来实现。</p>
</li>
<li><p>每层打印到一行： 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103229.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p><strong>算法流程：</strong></p>
<ol>
<li>特例处理： 当根节点为空，则返回空列表 [ ] ；</li>
<li>初始化： 打印结果列表 res &#x3D; [ ] ，包含根节点的队列 queue &#x3D; [root] ；</li>
<li>BFS 循环： 当队列 queue 为空时跳出；<ol>
<li>新建一个临时列表 tmp ，用于存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即队列 queue 长度）；<ul>
<li>出队： 队首元素出队，记为 cur；</li>
<li>打印： 将 cur.val 添加至 tmp 尾部；</li>
<li>添加子节点： 若 cur 的左（右）子节点不为空，则将左（右）子节点加入队列 queue ；</li>
</ul>
</li>
<li>将当前层结果 tmp 添加入 res 。</li>
</ol>
</li>
<li>返回值： 返回打印结果列表 res 即可。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>            <span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> res;<br>            queue&lt;TreeNode*&gt; que;<br>            que.<span class="hljs-built_in">push</span>(pRoot);<br>            <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>                <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                    que.<span class="hljs-built_in">pop</span>();<br>                    tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                        que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                        que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)： N 为二叉树的节点数量，即 BFS 需循环 N 次。</li>
<li>空间复杂度 O(N)： 最差情况下，即当树为平衡二叉树时，最多有 N&#x2F;2 个树节点同时在 queue 中，使用 O(N) 大小的额外空间。</li>
</ul>
<h3 id="解法二：递归-3"><a href="#解法二：递归-3" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">Print</span>(TreeNode* pRoot) &#123;<br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>            <span class="hljs-built_in">levelOrder</span>(pRoot,<span class="hljs-number">0</span>,res);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> level,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>()==level)<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>            res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-built_in">levelOrder</span>(root-&gt;left,level+<span class="hljs-number">1</span>,res);<br>            <span class="hljs-built_in">levelOrder</span>(root-&gt;right,level+<span class="hljs-number">1</span>,res);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><h2 id="题目链接-60"><a href="#题目链接-60" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&&tqId=11214&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过某种符号表示空节点（#），以 ！表示一个结点值的结束（value!）。</p>
<p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果 str，重构二叉树。</p>
<p>例如，我们可以把一个只有根节点为 1 的二叉树序列化为”1!##”，然后通过自己的函数来解析回这个二叉树。</p>
<h2 id="解题思路-54"><a href="#解题思路-54" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。一般有两种策略：</p>
<ul>
<li>BFS：按照层次的顺序从上到下遍历所有的节点；</li>
<li>DFS（可分为先序、中序、后序遍历）：从一个根开始，一直延伸到某个叶，然后回到根，到达另一个分支。</li>
</ul>
</blockquote>
<h3 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>这里采用先序遍历的方式，中序、后序遍历思路与其相同。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103208.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p>序列化：</p>
<p>先序遍历二叉树，遇到空子树的时候序列化成 ‘#’，否则继续递归序列化。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103157.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p>反序列化：</p>
<p>从左向右遍历这个序列：</p>
<ul>
<li>如果当前的元素为 ‘#’，则当前为空树；</li>
<li>否则先解析这棵树的左子树，再解析它的右子树</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103145.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        string str;<br>        <span class="hljs-built_in">SerializeCore</span>(root,str);<br>        <span class="hljs-comment">// 把str流转换为字符串返回</span><br>        <span class="hljs-type">int</span> len=str.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">char</span>* res=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[len+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            res[i]=str[i];<br>        res[len]=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* res=<span class="hljs-built_in">DeserializeCore</span>(&amp;str);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SerializeCore</span><span class="hljs-params">(TreeNode* root, string&amp; str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 如果指针为空，表示左子节点或右子节点为空，则在序列中用#表示</span><br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            str+=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        str+=<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&#x27;!&#x27;</span>;<br>        <span class="hljs-built_in">SerializeCore</span>(root-&gt;left,str);<br>        <span class="hljs-built_in">SerializeCore</span>(root-&gt;right,str);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 递归时改变了str值使其指向后面的序列，因此要声明为char**</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">DeserializeCore</span><span class="hljs-params">(<span class="hljs-type">char</span>** str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 到达叶节点时，调用两次，都返回null，所以构建完毕，返回父节点的构建</span><br>        <span class="hljs-keyword">if</span>(**str==<span class="hljs-string">&#x27;#&#x27;</span>)<br>        &#123;<br>            (*str)++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">// 因为整数是用字符串表示，一个字符表示一位，先进行转换</span><br>        <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(**str!=<span class="hljs-string">&#x27;!&#x27;</span>&amp;&amp;**str!=<span class="hljs-string">&#x27;\0&#x27;</span>)<br>        &#123;<br>            num=(**str)-<span class="hljs-string">&#x27;0&#x27;</span>+num*<span class="hljs-number">10</span>;<br>            (*str)++;<br>        &#125;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(num);<br>        <span class="hljs-keyword">if</span>(**str==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span><br>            (*str)++;<br>        root-&gt;left=<span class="hljs-built_in">DeserializeCore</span>(str);<br>        root-&gt;right=<span class="hljs-built_in">DeserializeCore</span>(str);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：在序列化和反序列化函数中，只访问每个节点一次，因此时间复杂度为 O(n)，其中 n 是节点数，即树的大小。</li>
<li>空间复杂度：在序列化和反序列化函数中，递归会使用栈空间，故渐进空间复杂度为 O(n)。</li>
</ul>
<h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>序列化：</p>
<ul>
<li>让 null 也入列，说它是真实节点也行，它有对应的”X”，只是没有子节点入列；</li>
<li>考察出列节点：<ul>
<li>如果不为 null，则将它的值推入 string，并将它的左右子节点入列；</li>
<li>如果是 null ，则将 ‘X’ 推入 string。</li>
</ul>
</li>
<li>出列…入列…直到队列为空，所有节点遍历完，string 也构建完，转成 char*。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103112.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p>反序列化：</p>
<ul>
<li>除了第一个是根节点的值，其他节点值都是成对的，分别对应左右子节点；</li>
<li>从第二项开始遍历，每次考察两个节点值；</li>
<li>队列初始推入root 节点。父节点出列，找出子节点入列；</li>
<li>出列的父节点，它对应到指针指向的左子节点值，和指针右边的右子节点值<ul>
<li>如果子节点值不为 ‘X’，则为它创建节点，并认父亲，并作为未来父亲入列；</li>
<li>如果子节点值为 ‘X’，什么都不做即可。</li>
</ul>
</li>
<li>所有父节点（真实节点）都会在队列里走一遍。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103058.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123; <br>        string str;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *cur = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                str+=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                str+=<span class="hljs-string">&#x27;!&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            str+=<span class="hljs-built_in">to_string</span>(cur-&gt;val)+<span class="hljs-string">&#x27;!&#x27;</span>;<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        <span class="hljs-type">char</span> *res=<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[str.<span class="hljs-built_in">length</span>()+<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(res,str.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">Deserialize</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(str==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str)</span></span>;<br>        <span class="hljs-keyword">if</span>(str[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        TreeNode *root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>        s = s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>)+<span class="hljs-number">1</span>);<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 根据序列化字符串再层次遍历一遍，来构造树</span><br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()&amp;&amp;!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode *cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>            &#123;<br>                cur-&gt;left=<span class="hljs-literal">nullptr</span>;<br>                s=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                s = s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>            &#123;<br>                cur-&gt;right=<span class="hljs-literal">nullptr</span>;<br>                s=s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                s=s.<span class="hljs-built_in">substr</span>(s.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&#x27;!&#x27;</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="62-二叉搜索树的第-K-个结点"><a href="#62-二叉搜索树的第-K-个结点" class="headerlink" title="62.二叉搜索树的第 K 个结点"></a>62.二叉搜索树的第 K 个结点</h1><h2 id="题目链接-61"><a href="#题目链接-61" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&&tqId=11215&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉搜索树，请找出其中的第 k 小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为 4。</p>
<h2 id="解题思路-55"><a href="#解题思路-55" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：中序遍历-递归"><a href="#解法一：中序遍历-递归" class="headerlink" title="解法一：中序遍历+递归"></a>解法一：中序遍历+递归</h3><blockquote>
<p>二叉搜索树的中序遍历为 <strong>递增序列</strong> 。</p>
</blockquote>
<p>为求第 k 个节点，需要实现以下三项工作 ：</p>
<ol>
<li>递归遍历时计数，统计当前节点的序号；</li>
<li>递归到第 k 个节点时，应记录结果 res ；</li>
<li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeNode *left;</span><br><span class="hljs-comment">    struct TreeNode *right;</span><br><span class="hljs-comment">    TreeNode(int x) :</span><br><span class="hljs-comment">            val(x), left(NULL), right(NULL) &#123;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    TreeNode* target=<span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* pRoot, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(pRoot,k);<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||count&gt;=k)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left,k);<br>        count++;<br>        <span class="hljs-keyword">if</span>(count==k)<br>            target=root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right,k);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。</li>
<li>空间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N) 大小的栈空间。</li>
</ul>
<h3 id="解法二：迭代-3"><a href="#解法二：迭代-3" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>用栈来模拟递归中序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode* pRoot, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">while</span>(pRoot!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(pRoot!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(pRoot);<br>                pRoot=pRoot-&gt;left;<br>            &#125;<br>            pRoot=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(++count==k)<br>                <span class="hljs-keyword">return</span> pRoot;<br>            pRoot=pRoot-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><h2 id="题目链接-62"><a href="#题目链接-62" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。</p>
<h2 id="解题思路-56"><a href="#解题思路-56" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：排序法"><a href="#解法一：排序法" class="headerlink" title="解法一：排序法"></a>解法一：排序法</h3><p>将添加的数保存在数组中，返回中位数时，只需将数组排序，返回中间位置数即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; store;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        store.<span class="hljs-built_in">push_back</span>(num);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-built_in">sort</span>(store.<span class="hljs-built_in">begin</span>(),store.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> n=store.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> store[n/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (store[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+store[n/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(nlogn)。Insert() 函数消耗 O(1) 的时间复杂度，GetMedian() 函数使用了排序，时间复杂度为 O(nlogn)。因此总的时间复杂度为 O(nlogn)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法二：二分查找插入"><a href="#解法二：二分查找插入" class="headerlink" title="解法二：二分查找插入"></a>解法二：二分查找插入</h3><p>方法一的缺点在于对数组进行了排序操作，导致时间复杂度较高，假如每次插入一个值前数组已经排好序了呢？这样只需考虑每次将值插在合适的位置即可，所以使用二分查找来找到这个合适的位置，会将时间复杂度降低到 O(n)（查找: O(logn)，插入: O(n)）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; store;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(store.<span class="hljs-built_in">empty</span>())<br>            store.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">else</span><br>            store.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">lower_bound</span>(store.<span class="hljs-built_in">begin</span>(),store.<span class="hljs-built_in">end</span>(),num),num);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        <span class="hljs-type">int</span> n=store.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> store[n/<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (store[n/<span class="hljs-number">2</span><span class="hljs-number">-1</span>]+store[n/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。O(logn)+O(n)≈O(n)。</li>
<li>空间复杂度：O(n)。使用了数组保存输入。</li>
</ul>
<h3 id="解法三：优先队列-x2F-堆"><a href="#解法三：优先队列-x2F-堆" class="headerlink" title="解法三：优先队列&#x2F;堆"></a>解法三：优先队列&#x2F;堆</h3><blockquote>
<p>借助 <strong>堆</strong> 可进一步优化时间复杂度。</p>
</blockquote>
<p>建立一个 小顶堆 A 和 大顶堆 B ，各保存列表的一半元素，且规定：</p>
<ul>
<li>A 保存较大的一半，长度为 N&#x2F;2（ N 为偶数）或  (N+1)&#x2F;2（ N 为奇数）；</li>
<li>B 保存较小的一半，长度为 N&#x2F;2（ N 为偶数）或（N-1)&#x2F;2（ N 为奇数）。</li>
</ul>
<p>随后，中位数可仅根据 A,B 的堆顶元素计算得到。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723103031.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p><strong>算法流程：</strong></p>
<p>设元素总数为 N&#x3D;m + n，其中 m 和 n 分别为 A 和 B 中的元素个数。</p>
<p>Insert(num) 函数：</p>
<ol>
<li>当 m&#x3D;n（即 N 为 偶数）：需向 A 添加一个元素。实现方法：将新元素 num 插入至 B ，再将 B 堆顶元素插入至 A （由于 num 可能属于“较小的一半”，即属于 B ，因此不能将 num 直接插入至 A 。而应先将 num 插入至 B ，再将 B 堆顶元素插入至 A 。这样就可以始终保持 A 保存较大一半、 B 保存较小一半）。</li>
<li>当 m!&#x3D;n（即 N 为 奇数）：需向 B 添加一个元素。实现方法：将新元素 num 插入至 A ，再将 A 堆顶元素插入至 B 。</li>
</ol>
<p>GetMedian() 函数：</p>
<p>当 m&#x3D;n（ N 为 偶数）：则中位数为 （A 的堆顶元素 + B 的堆顶元素 )&#x2F;2。<br>当 m!&#x3D;n（ N 为 奇数）：则中位数为 A 的堆顶元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt; A; <span class="hljs-comment">//小顶堆，保存较大的一半</span><br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; B; <span class="hljs-comment">//大顶堆，保存较小的一半</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()==B.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            B.<span class="hljs-built_in">push</span>(num);<br>            A.<span class="hljs-built_in">push</span>(B.<span class="hljs-built_in">top</span>());<br>            B.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            A.<span class="hljs-built_in">push</span>(num);<br>            B.<span class="hljs-built_in">push</span>(A.<span class="hljs-built_in">top</span>());<br>            A.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (A.<span class="hljs-built_in">top</span>()+B.<span class="hljs-built_in">top</span>())/<span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(logN) ：<ul>
<li>查找中位数 O(1) ： 获取堆顶元素使用 O(1) 时间；</li>
<li>添加数字 O(logN) ： 堆的插入和弹出操作使用 O(logN) 时间。</li>
</ul>
</li>
<li>空间复杂度 O(N) ： 其中 N 为数据流中的元素数量，小顶堆 A 和大顶堆 B 最多同时保存 N 个元素。</li>
</ul>
<h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><h2 id="题目链接-63"><a href="#题目链接-63" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组 {2,3,4,2,6,2,5,1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4,4,6,6,6,5}； 针对数组 {2,3,4,2,6,2,5,1} 的滑动窗口有以下 6 个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解题思路-57"><a href="#解题思路-57" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力方法"><a href="#解法一：暴力方法" class="headerlink" title="解法一：暴力方法"></a>解法一：暴力方法</h3><p>每次窗口滑动到一个位置就去计算一下这个窗口里的最大值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (num.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||size&lt;<span class="hljs-number">1</span>||num.<span class="hljs-built_in">size</span>()&lt;size)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=num.<span class="hljs-built_in">size</span>()-size;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> max_val=num[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i;j&lt;i+size;++j)<br>                max_val=<span class="hljs-built_in">max</span>(max_val,num[j]);<br>            res.<span class="hljs-built_in">push_back</span>(max_val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n*k), 其中 n 为数组大小，k 为窗口大小；</li>
<li>空间复杂度：O(n-k+1)，用于输出数组。</li>
</ul>
<h3 id="解法二：单调双向队列"><a href="#解法二：单调双向队列" class="headerlink" title="解法二：单调双向队列"></a>解法二：单调双向队列</h3><p>如何优化时间复杂度呢？首先想到的是使用堆，因为在最大堆中 heap[0] 永远是最大的元素。在大小为 k 的堆中插入一个元素消耗 log(k) 时间，因此算法的时间复杂度为 O(Nlog(k))。</p>
<p>能否得到只要 O(N) 的算法？</p>
<p>可以使用<strong>双向队列</strong>，该数据结构可以从两端以常数时间压入&#x2F;弹出元素。</p>
<p>存储双向队列的索引比存储元素更方便，因为两者都能在数组解析中使用。</p>
<p><strong>算法流程</strong>：</p>
<ol>
<li>处理前 size 个元素，初始化双向队列。</li>
<li>遍历整个数组。在每一步清理双向队列:<ul>
<li>只保留当前滑动窗口中有的元素的索引，即当上一轮窗口首元素不在当前窗口中时，需要将它从队列中弹出。   </li>
<li>移除比当前元素小的所有元素，它们不可能是最大的。</li>
</ul>
</li>
<li>将当前元素添加到双向队列中。</li>
<li>形成窗口后，将 deque[0] 添加到输出中。</li>
<li>返回输出数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; num, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>||size&lt;<span class="hljs-number">1</span>||num.<span class="hljs-built_in">size</span>()&lt;size)<br>            <span class="hljs-keyword">return</span> res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标</span><br>            <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>()&amp;&amp;num[dq.<span class="hljs-built_in">back</span>()]&lt;num[i])<br>                dq.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-comment">//把每次滑动的num下标加入队列</span><br>            dq.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">//当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出</span><br>            <span class="hljs-keyword">if</span>(i-dq.<span class="hljs-built_in">front</span>()+<span class="hljs-number">1</span>&gt;size)<br>                dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-comment">//当i大于等于size时才开始写入窗口最大值</span><br>            <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&gt;=size)<br>                res.<span class="hljs-built_in">push_back</span>(num[dq.<span class="hljs-built_in">front</span>()]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：O(N)，每个元素被处理两次（其索引被添加到双向队列中和被双向队列删除）。</li>
<li>空间复杂度：O(N)，输出数组使用了 O(N−k+1) 空间，双向队列使用了 O(k)。</li>
</ul>
<h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><h2 id="题目链接-64"><a href="#题目链接-64" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如下图中矩阵中包含一条字符串 “bcced” 的路径，但是矩阵中不包含 “abcb” 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102945.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="解题思路：深度优先搜索-DFS-回溯"><a href="#解题思路：深度优先搜索-DFS-回溯" class="headerlink" title="解题思路：深度优先搜索 DFS +回溯"></a>解题思路：深度优先搜索 DFS +回溯</h2><blockquote>
<p>典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
</blockquote>
<p><strong>算法原理：</strong></p>
<ul>
<li>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li>剪枝： 在搜索中，遇到这条路不可能和目标字符串匹配成功的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为可行性剪枝 。</li>
</ul>
<p><strong>算法剖析：</strong></p>
<ul>
<li>递归参数： 当前元素在矩阵 matrix 中的行列索引 i 和 j ，当前目标字符在 str 中的索引 k 。</li>
<li>终止条件：<ul>
<li>返回 false ： ① 行或列索引越界或 ② 当前矩阵元素与目标字符不同或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。</li>
<li>返回 true ： 字符串 str 已全部匹配，即 k &#x3D; len(str) - 1 (str[k+1]&#x3D;&#x3D;’\0’)。</li>
</ul>
</li>
<li>递推工作：<ol>
<li>标记当前矩阵元素： 将 matrix[i,j] 值暂存于变量 tmp ，并修改为字符  ‘&#x2F;‘ ，代表此元素已访问过，防止之后搜索时重复访问。</li>
<li>搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 “||” 连接 （代表只需一条可行路径） ，并记录结果至 res 。</li>
<li>还原当前矩阵元素： 将 tmp 暂存值还原至 matrix[i,j] 元素。</li>
</ol>
</li>
<li>回溯返回值： 返回 res ，代表是否搜索到目标字符串。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix==<span class="hljs-literal">nullptr</span>||rows&lt;<span class="hljs-number">1</span>||cols&lt;<span class="hljs-number">1</span>||str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j,str,<span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span>* str,<span class="hljs-type">int</span> pathlength)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||i&lt;<span class="hljs-number">0</span>||j&gt;=cols||j&lt;<span class="hljs-number">0</span>||matrix[i*cols+j]!=str[pathlength])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(str[pathlength+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp=matrix[i*cols+j];<span class="hljs-comment">// 用于暂时保存字符</span><br>        matrix[i*cols+j]=<span class="hljs-string">&#x27;/&#x27;</span>;<span class="hljs-comment">// 代表这个字符已经访问过</span><br>        <span class="hljs-type">bool</span> res=<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i+<span class="hljs-number">1</span>,j,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i<span class="hljs-number">-1</span>,j,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j+<span class="hljs-number">1</span>,str,pathlength+<span class="hljs-number">1</span>)||<br>                 <span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j<span class="hljs-number">-1</span>,str,pathlength+<span class="hljs-number">1</span>);<br>        matrix[i*cols+j]=tmp;<span class="hljs-comment">// 遍历结束后改回来</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>matrix[i,j] 临时赋值成 ‘&#x2F;‘，用来标记已访问的元素，省下了bool[][] visited的空间，很巧妙，并且省略了当前矩阵元素是否访问过的判断，因为访问后矩阵元素修改为 ‘&#x2F;‘ 后，与字符串必不相等。</p>
<p>另一种写法：</p>
<p>用数组循环写代替四个 dfs。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPath</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(matrix==<span class="hljs-literal">nullptr</span>||rows&lt;<span class="hljs-number">1</span>||cols&lt;<span class="hljs-number">1</span>||str==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,i,j,str,<span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>* matrix,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span>* str,<span class="hljs-type">int</span> pathlength)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||i&lt;<span class="hljs-number">0</span>||j&gt;=cols||j&lt;<span class="hljs-number">0</span>||matrix[i*cols+j]!=str[pathlength])<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(str[pathlength+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">char</span> tmp=matrix[i*cols+j];<br>        matrix[i*cols+j]=<span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> q=<span class="hljs-number">0</span>;q&lt;<span class="hljs-number">4</span>;++q)<br>        &#123;<br>            <span class="hljs-type">int</span> m=i+dx[q],n=j+dy[q];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(matrix,rows,cols,m,n,str,pathlength+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        matrix[i*cols+j]=tmp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小， K 为字符串 str 长度。</p>
<ul>
<li>时间复杂度 O(MN3^K)： 最差情况下，需要遍历矩阵中长度为 K 字符串的所有方案，时间复杂度为 O(3^K)；矩阵中共有 MN 个起点，时间复杂度为 O(MN) 。<ul>
<li>方案数计算： 设字符串长度为 K ，搜索中每个字符有上、下、左、右四个方向可以选择，舍弃回头（上个字符）的方向，剩下 3 种选择，因此方案数的复杂度为 O(3^K)。</li>
</ul>
</li>
<li>空间复杂度 O(K)： 搜索过程中的递归深度不超过 K ，因此系统因函数调用累计使用的栈空间占用 O(K) （因为函数返回后，系统调用的栈空间会释放）。最坏情况下 K&#x3D;MN ，递归深度为 MN ，此时系统栈使用 O(MN) 的额外空间。</li>
</ul>
<h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><h2 id="题目链接-65"><a href="#题目链接-65" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 0,0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 &#x3D; 18。但是，它不能进入方格（35,38），因为 3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路-58"><a href="#解题思路-58" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>典型的矩阵搜索问题。此类问题通常可使用 <strong>深度优先搜索（DFS）</strong> 或 <strong>广度优先搜索（BFS）</strong> 解决。</p>
</blockquote>
<p><strong>数位之和计算：</strong></p>
<p>设一数字 x ，向下取整除法符号 &#x2F; ，求余符号 % ，则有：</p>
<ul>
<li>x %10 ：得到 x 的个位数字；</li>
<li>x &#x2F;10 ： 令 x 的十进制数向右移动一位，即删除个位数字。</li>
</ul>
<p>因此，可通过循环求得数位和 ，数位和计算的封装函数如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>    &#123;<br>        sum+=num%<span class="hljs-number">10</span>;<br>        num=num/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>搜索方向简化：</strong></p>
<ul>
<li>数位和特点： <ul>
<li>设 x 的数位和为 $s_x$，x+1 的数位和为 $s_{x+1}$：<ul>
<li>当 (x+1)%10&#x3D;0 时： $s_{x+1}$ &#x3D; $s_x$ - 8。例如 19, 20 的数位和分别为 10, 2；</li>
<li>当 (x+1)%10 !&#x3D;0 时： $s_{x+1}$ &#x3D; $s_x$ + 1 。例如 1,2 的数位和分别为 1, 2。</li>
</ul>
</li>
<li>根据数位和增量得知，数位和每逢进位突变一次。</li>
</ul>
</li>
<li>解的三角形结构：<ul>
<li>根据数位和特点，矩阵中满足数位和的解构成的几何形状形如多个等腰直角三角形 ，每个三角形的直角顶点位于 0,10,20,… 等数位和突变的矩阵索引处 。</li>
<li>三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 不可达解 ；同理，可到达的解称为 可达解 （本题求此解） 。</li>
</ul>
</li>
<li>结论： 根据可达解的结构，易推出机器人可仅通过向右和向下移动，访问所有可达解 。<ul>
<li>三角形内部： 全部连通，易证；</li>
<li>两三角形连通处： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。</li>
</ul>
</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102529.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102515.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<h3 id="解法一：深度优先遍历-DFS"><a href="#解法一：深度优先遍历-DFS" class="headerlink" title="解法一：深度优先遍历 DFS"></a>解法一：深度优先遍历 DFS</h3><ul>
<li>深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为可行性剪枝 。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ul>
<li>递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</li>
<li>终止条件： 当 ① 行列索引越界或 ② 数位和超出目标值 k或 ③ 当前元素已访问过时，返回 0 ，代表不计入可达解。</li>
<li>递推工作：<ul>
<li>标记当前单元格 ：将 visited [i] [j] 标记为 true ，代表此单元格已被访问过。</li>
<li>搜索下一单元格： 计算当前元素的下、右两个方向元素的数位和，并开启下层递归 。</li>
</ul>
</li>
<li>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,threshold,rows,cols,visited);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> threshold,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&gt;=rows||j&gt;=cols||<span class="hljs-built_in">bitsum</span>(i)+<span class="hljs-built_in">bitsum</span>(j)&gt;threshold||visited[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">dfs</span>(i+<span class="hljs-number">1</span>,j,threshold,rows,cols,visited)+<span class="hljs-built_in">dfs</span>(i,j+<span class="hljs-number">1</span>,threshold,rows,cols,visited);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            sum+=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong><br>M,N 分别为矩阵行列大小。</p>
<ul>
<li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li>
<li>空间复杂度 O(MN) ： visited 使用 O(MN) 的额外空间。</li>
</ul>
<h3 id="解法二：广度优先遍历-BFS"><a href="#解法二：广度优先遍历-BFS" class="headerlink" title="解法二：广度优先遍历 BFS"></a>解法二：广度优先遍历 BFS</h3><ul>
<li>BFS&#x2F;DFS ： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。</li>
<li>BFS 实现： 通常利用队列实现广度优先遍历。</li>
</ul>
<p><strong>算法解析：</strong></p>
<ul>
<li>初始化： 将机器人初始点 (0,0) 加入队列 queue ；</li>
<li>迭代终止条件： queue 为空。代表已遍历完所有可达解。</li>
<li>迭代工作：<ul>
<li>单元格出队： 将队首单元格的索引弹出，作为当前搜索单元格。</li>
<li>判断是否跳过： 若 ① 行列索引越界或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</li>
<li>标记当前单元格 ：将 visited [i] [j] 标记为 true，代表此单元格已被访问过 。</li>
<li>可达解数目加 1，即 res++。</li>
<li>单元格入队： 将当前元素的下方、右方单元格的索引加入 queue 。</li>
</ul>
</li>
<li>返回值： 返回 res，即可达解的数量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-type">int</span> threshold, <span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> i_j=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> i=i_j.first;<br>            <span class="hljs-type">int</span> j=i_j.second;<br>            <span class="hljs-keyword">if</span>(i&gt;=rows||j&gt;=cols||<span class="hljs-built_in">bitsum</span>(i)+<span class="hljs-built_in">bitsum</span>(j)&gt;threshold||visited[i][j])<br>                <span class="hljs-keyword">continue</span>;<br>            visited[i][j]=<span class="hljs-literal">true</span>;<br>            res++;<br>            que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i+<span class="hljs-number">1</span>,j));<br>            que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bitsum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num!=<span class="hljs-number">0</span>)<br>        &#123;<br>            sum+=num%<span class="hljs-number">10</span>;<br>            num=num/<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong><br>M, N 分别为矩阵行列大小。</p>
<ul>
<li>时间复杂度 O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li>
<li>空间复杂度 O(MN) ： visited 使用 O(MN) 的额外空间。</li>
</ul>
<h1 id="67-剪绳子"><a href="#67-剪绳子" class="headerlink" title="67.剪绳子"></a>67.剪绳子</h1><h2 id="题目链接-66"><a href="#题目链接-66" class="headerlink" title="题目链接"></a>题目链接</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">牛客网</a></p>
<h2 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（m、n都是整数，n&gt;1 并且 m&gt;1，m&lt;&#x3D;n），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]x…xk[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入描述<span class="hljs-symbol">:</span><br>输入一个数<span class="hljs-built_in">n</span>，意义见题面。（<span class="hljs-number">2</span> &lt;= <span class="hljs-built_in">n</span> &lt;= <span class="hljs-number">60</span>）<br>输出描述<span class="hljs-symbol">:</span><br>输出答案。<br><br>示例：<br>输入<br><span class="hljs-number">8</span><br>输出<br><span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-59"><a href="#解题思路-59" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：暴力递归（超时）"><a href="#解法一：暴力递归（超时）" class="headerlink" title="解法一：暴力递归（超时）"></a>解法一：暴力递归（超时）</h3><p>假设现在绳子长度为 n，由题知绳子n&gt;1，最少长度为2，设 F(n) 为长度为 n 的绳子可以得到的最大乘积，对于每一个 F(n)，可以得到如下分解，从而形成类似于斐波那契数列的递归树。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102458.png" srcset="/img/loading.gif" lazyload  style="zoom: 50%;" />

<p>从上图看出可以把求解 F(n) 的问题分解成求解 F(n−1) 的问题，以此类推，直到求解到 F(2) 时，F(2)&#x3D;1，递推回去，问题就得到了解决。这用到的就是分治的思想。</p>
<p>分治思想的解决方法往往是递归，注意到每次将一段绳子剪成两段时，剩下的部分可以继续剪，也可以不剪，选择不剪此时 F(n)&#x3D;1*(n-1)， 选择剪就是根据 F(n) 一样求 F(n-1)。因此得到了递归函数 F(n)&#x3D;max(i×(n−i),i×F(n−i)) , i&#x3D;1,2,…,n−2。</p>
<p>注意以下代码<strong>超时</strong>，无法通过！！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 隐含F(1) = -1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;++i)<br>            res=<span class="hljs-built_in">max</span>(res,<span class="hljs-built_in">max</span>(i*(number-i),i*<span class="hljs-built_in">cutRope</span>(number-i)));<span class="hljs-comment">// 当调用F(1)的时候就是-1</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n!)。</li>
<li>空间复杂度：O(n), 最多分 n 段，每段长度为 1， 所以递归深度为 n。</li>
</ul>
<h3 id="解法二：记忆化搜索"><a href="#解法二：记忆化搜索" class="headerlink" title="解法二：记忆化搜索"></a>解法二：记忆化搜索</h3><p>上述暴力解法会超时，但是很多进阶解法往往是暴力解法的优化。注意到上述代码中超时的原因主要是因为重复计算了 F(n)，为了避免重复计算可以使用记忆化（memoization）技术。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102447.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<p>因此可以将每次 F(x) 计算的结果进行存储。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; memo=<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">59</span>,<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>)<br>            memo[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;number;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> eachFn;<br>            <span class="hljs-keyword">if</span>(memo[number-i]!=<span class="hljs-number">-1</span>)<br>                eachFn=<span class="hljs-built_in">max</span>(i*(number-i),i*memo[number-i]);<br>            <span class="hljs-keyword">else</span><br>                eachFn=<span class="hljs-built_in">max</span>(i*(number-i),i*<span class="hljs-built_in">cutRope</span>(number-i));<br>            memo[number]=<span class="hljs-built_in">max</span>(memo[number],eachFn);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[number];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n^2)，对于每一个 i 调用一次递归，递归的时间复杂度为 O(N)，故时间复杂度为 O(n^2)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法三：动态规划（自底向上）"><a href="#解法三：动态规划（自底向上）" class="headerlink" title="解法三：动态规划（自底向上）"></a>解法三：动态规划（自底向上）</h3><p>同样地，也可以使用动态规划，从已知值 F(2) 逐步迭代到目标值 F(n)，它是一种自底向上的方法。</p>
<p><strong>算法流程：</strong></p>
<p>建立一维动态数组 dp：</p>
<ul>
<li>边界条件：dp[1] &#x3D; dp[2] &#x3D; 1，表示长度为 2 的绳子最大乘积为 1；</li>
<li>状态转移方程：dp[i] &#x3D; max(dp[i], max((i - j) * j, j * dp[i - j]))，可以这样理解：</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102432.jpg" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">59</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;++i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)<br>                dp[i]=<span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*(i-j),j*dp[i-j]));<br>        <span class="hljs-keyword">return</span> dp[number];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N^2)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h3 id="解法四：动态规划优化解法"><a href="#解法四：动态规划优化解法" class="headerlink" title="解法四：动态规划优化解法"></a>解法四：动态规划优化解法</h3><p>可以发现任何大于 3 的数都可以拆分为数字 1，2，3 的和，且它们对 3 的余数总是 0，1，2，因此可以仅用 dp[0]，dp[1]，dp[2] 表示所有大于 3 的值，这样空间复杂度可降到 O(1)。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102413.gif" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>这样重复使用 dp 数组，只须一趟遍历即可完成，可使时间复杂度降到 O(N)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;dp[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;dp[<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=number;++i)<br>            dp[i%<span class="hljs-number">3</span>]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>((<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-1</span>)),<span class="hljs-number">2</span>*<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-2</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-2</span>)),<span class="hljs-number">3</span>*<span class="hljs-built_in">max</span>(dp[(i<span class="hljs-number">-3</span>)%<span class="hljs-number">3</span>],i<span class="hljs-number">-3</span>));<br>        <span class="hljs-keyword">return</span> dp[number%<span class="hljs-number">3</span>];<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(1)。使用了有限长的数组。</li>
</ul>
<h3 id="解法五：找规律-x2F-贪心思想"><a href="#解法五：找规律-x2F-贪心思想" class="headerlink" title="解法五：找规律&#x2F;贪心思想"></a>解法五：找规律&#x2F;贪心思想</h3><p>题目分析：</p>
<p>先举几个例子，可以看出规律来。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span>： <span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">7 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">8 </span>： <span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-symbol">9 </span>： <span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">10</span>：<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">11</span>：<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">12</span>：<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><span class="hljs-number">13</span>：<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span> 或者<span class="hljs-number">4</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>下面是分析：<br>首先判断 F[0] 到 F[n] 可能有哪些数字，实际上只可能是 2 或者 3。<br>当然也可能有 4，但是<code>4=2*2</code>，就简单些不考虑了。<br><code>5&lt;2*3</code>，<code>6&lt;3*3</code>,比 6 更大的数字就更不用考虑了，肯定要继续分。<br>其次看 2 和 3 的数量，2 的数量肯定小于 3 个，为什么呢？因为<code>2*2*2&lt;3*3</code>，那么题目就简单了。<br>直接用 n 除以3，根据得到的余数判断是一个 2 还是两个 2 还是没有 2 就行了。<br>由于题目规定<code>n&gt;1</code>，所以2只能是<code>1*1</code>，3只能是<code>2*1</code>，这两个特殊情况直接返回就行了。</p>
<p>详细思想和数学推导过程参考@ <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/">Krahets </a>大佬题解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> a=number/<span class="hljs-number">3</span>,b=number%<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a);<br>        <span class="hljs-keyword">if</span>(b==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>*<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>,a)*<span class="hljs-number">2</span>;<br>    &#125;        <br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(1)： 仅有求整、求余、次方运算。<ul>
<li>求整和求余运算：资料提到不超过机器数的整数可以看作是 O(1) ；</li>
<li>幂运算：查阅资料，提到浮点取幂为 O(1)。</li>
</ul>
</li>
<li>空间复杂度 O(1)： 变量 a 和 b 使用常数大小额外空间。</li>
</ul>
<hr>
<p>完结撒花~</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Tree</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">2020牛客左神算法课笔记——算法入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
