

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为树篇。部分内容搬运自 Leetcode-cn 大佬题解、wind-liang 题解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Tree">
<meta property="og:url" content="https://simpleforever.github.io/2020/07/25/Leetcode%20Notes%E2%80%94%E2%80%94Tree/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为树篇。部分内容搬运自 Leetcode-cn 大佬题解、wind-liang 题解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141547.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140908.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140943.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141010.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141035.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141051.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141111.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141131.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141148.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141209.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141226.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150827.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150840.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150847.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150753.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150945.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726151006.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120337.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120312.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101434.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104913.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801105031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095809.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095759.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095731.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805100145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105628.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105648.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200807100242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141626.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141648.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141713.jpeg">
<meta property="article:published_time" content="2020-07-24T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-24T05:43:15.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Tree">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141547.gif">
  
  
  <title>Leetcode Notes——Tree - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Tree">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-25 00:00" pubdate>
        2020年7月25日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      72k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      601 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Tree</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>树</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a target="_blank" rel="noopener" href="https://leetcode.wang/">wind-liang</a> 题解。</p>
<span id="more"></span>

<h1 id="94-二叉树的中序遍历-medium"><a href="#94-二叉树的中序遍历-medium" class="headerlink" title="94. 二叉树的中序遍历[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>[medium]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的中序遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span><br>   1<br>    \<br>     2<br>    /<br>   3<br><br>输出: <span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>中序遍历:左-打印-右。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;left,res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorderTraversal</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li>
<li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li>
</ul>
<h3 id="解法二：基于栈的迭代"><a href="#解法二：基于栈的迭代" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><p>利用栈来模拟中序的递归过程。递归的过程是不断往左边走，当左边走不下去了，就打印结点，并转向右边，然后右边继续这个过程。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141547.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//节点不为空一直压栈</span><br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<span class="hljs-comment">//考虑左子树</span><br>            &#125;<br>             <span class="hljs-comment">//节点为空，就出栈</span><br>            cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//当前值加入</span><br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-comment">//考虑右子树</span><br>            cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法三：Morris遍历"><a href="#解法三：Morris遍历" class="headerlink" title="解法三：Morris遍历"></a>解法三：Morris遍历</h3><p>解法一和解法二本质上是一致的，都需要 O(h) ( h 为二叉树高度）的空间来保存上一层的信息。而中序遍历，就是遍历完左子树，然后遍历根节点。如果把当前根节点存起来，然后遍历左子树，左子树遍历完以后回到当前根节点就可以了，怎么做到呢？</p>
<p>左子树最后遍历的节点一定是一个叶子节点，它的左右孩子都是 null，把它右孩子指向当前根节点存起来，这样就不需要额外空间了。这样做，遍历完当前左子树，就可以回到根节点了。</p>
<p>当然如果当前根节点左子树为空，那么只需要保存根节点的值，然后考虑右子树即可。</p>
<p>所以总体思想就是：记当前遍历的节点为 cur。</p>
<ol>
<li>cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right；</li>
<li>cur.left 不为 null，找到 cur.left 这颗子树最右边的节点记做 last；<ul>
<li>last.right 为 null，那么将 last.right &#x3D; cur，更新 cur &#x3D; cur.left；</li>
<li>last.right 不为 null，说明之前已经访问过，第二次来到这里，表明当前子树遍历完成，保存 cur 的值，更新 cur &#x3D; cur.right。</li>
</ul>
</li>
</ol>
<p>结合图示：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140908.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，cur 指向根节点。 当前属于 2.1 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子为 null，那么把最右边的节点的右孩子指向 cur。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725140943.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>接着，更新 cur &#x3D; cur.left。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141010.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当前属于 2.1 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子为 null，那么把最右边的节点的右孩子指向 cur。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141035.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>更新 cur &#x3D; cur.left。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141051.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141111.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当前属于 2.2 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子已经指向 cur，保存 cur 的值，更新 cur &#x3D; cur.right。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141131.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141148.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当前属于 2.2 的情况，cur.left 不为 null，cur 的左子树最右边的节点的右孩子已经指向 cur，保存 cur 的值，更新 cur &#x3D; cur.right。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141209.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当前属于情况 1，cur.left 为 null，保存 cur 的值，更新 cur &#x3D; cur.right。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141226.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>cur 指向 null，结束遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (root!=<span class="hljs-literal">nullptr</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;left!=<span class="hljs-literal">nullptr</span>) <br>            &#123;<br>                TreeNode* pre=root-&gt;left;<br>                <span class="hljs-comment">// 找左子树最右边的节点</span><br>                <span class="hljs-keyword">while</span> (pre-&gt;right!=<span class="hljs-literal">nullptr</span> &amp;&amp; pre-&gt;right!=root) <br>                    pre=pre-&gt;right;<br>                <span class="hljs-comment">// 情况 2.1</span><br>                <span class="hljs-keyword">if</span> (pre-&gt;right==<span class="hljs-literal">nullptr</span>) <br>                &#123;<br>                    pre-&gt;right=root;<br>                    root=root-&gt;left;<br>                &#125; <br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">//情况 2.2</span><br>                &#123;<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//这里可以恢复为 null</span><br>                    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    root=root-&gt;right;<br>                &#125;<br>            &#125; <br>            <span class="hljs-keyword">else</span>  <span class="hljs-comment">//情况1</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root=root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。每个节点遍历常数次。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="144-二叉树的前序遍历-medium"><a href="#144-二叉树的前序遍历-medium" class="headerlink" title="144. 二叉树的前序遍历[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>[medium]</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的前序遍历。</p>
<p> <strong>示例:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span>  <br>   1<br>    \<br>     2<br>    /<br>   3 <br><br>输出: <span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>前序遍历:打印-左-右。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">preorderTraversal</span>(root-&gt;right,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li>
<li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li>
</ul>
<h3 id="解法二：基于栈的迭代-1"><a href="#解法二：基于栈的迭代-1" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>利用栈模拟递归。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<span class="hljs-comment">//考虑左子树</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//节点为空，就出栈</span><br>                cur=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                cur=cur-&gt;right;<span class="hljs-comment">//考虑右子树</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>首先将根节点压入栈中，打印根节点的数据，然后将左右子树分别压栈，每次从栈里取元素。需要注意的是，因为我们应该先访问左子树，而栈的话是先进后出，所以压栈先压右子树。此时得到的流程如下:</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150827.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            s.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法三：Morris遍历-1"><a href="#解法三：Morris遍历-1" class="headerlink" title="解法三：Morris遍历"></a>解法三：Morris遍历</h3><p>详细过程参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>。</p>
<ol>
<li>在某个根结点创建连线的时候打印。因为是顺着左边的根节点来创建连线，且创建的过程只有一次。</li>
<li>打印某些自身无法创建连线的节点，也就是叶子节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode* pre=root-&gt;left;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;right!=root)<br>                    pre=pre-&gt;right;<br>                <span class="hljs-keyword">if</span>(pre-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre-&gt;right=root;<br>                    res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                    root=root-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>;<br>                    root=root-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                root=root-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="145-二叉树的后序遍历-hard"><a href="#145-二叉树的后序遍历-hard" class="headerlink" title="145. 二叉树的后序遍历[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>[hard]</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回它的后序遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span>  <br>   1<br>    \<br>     2<br>    /<br>   3 <br><br>输出: <span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-2"><a href="#解法一：递归-2" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>后序遍历:左-右-打印。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">postorderTraversal</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;left,res);<br>        <span class="hljs-built_in">postorderTraversal</span>(root-&gt;right,res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。递归函数 T(n)&#x3D;2*T(n&#x2F;2)+1。</li>
<li>空间复杂度：最坏情况下需要空间 O(n)，平均情况为 O(logn)。</li>
</ul>
<h3 id="解法二：基于栈的迭代-2"><a href="#解法二：基于栈的迭代-2" class="headerlink" title="解法二：基于栈的迭代"></a>解法二：基于栈的迭代</h3><p>后序遍历的非递归形式相比中序、先序会比较难一些。主要是因为，当遍历完某个根节点的左子树，回到根节点的时候，对于中序和先序遍历可以把当前根节点从栈里弹出，然后转到右子树。而对于后序遍历，当到达根节点的时候，不能立刻弹出，因为遍历完右子树，还需要将这个根节点打印。所以就需要进行<strong>判断</strong>，是左子树到的根节点，还是右子树到的根节点。</p>
<ul>
<li>如果是左子树到的根节点，应该转到右子树；</li>
<li>如果是右子树到的根节点，那么就可以把当前节点弹出并打印。</li>
<li>如果是左子树到的根节点，此时如果根节点的右子树为 NULL，此时也可以把当前节点弹出并打印。</li>
</ul>
<h4 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h4><p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 解法二。开始的话，也是不停的往左子树走，直到 NULL。不同之处是，中序直接把节点 pop 并打印，然后转到右子树。而后序应该把节点 top 出来，然后判断一下当前根节点的右子树是否为空或者是否从右子树回到根节点。</p>
<p>第一个想法是用一个 set，当从左子树到根节点的时候，把根节点加入到 set 中，之后就可以判断当前节点在不在 set 中，如果在的话就意味着当前是第二次回来，也就意味着是从右子树到的根节点。</p>
<p>利用 set 会浪费额外的空间，还有一个更直接的方法，通过记录上一次遍历的节点。如果当前节点的右节点和上一次遍历的节点相同，那就表明是从右节点过来的了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">//是否变到右子树</span><br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(tmp-&gt;val);<br>                    last=tmp;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h4><p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 解法二中思路二。将左右子树分别压栈，然后从栈里取元素。需要注意的是，因为我们应该先访问左子树，而栈的话是先进后出，所以压栈先压右子树。而后序遍历遇到的问题是到根节点的时候不能直接 pop，因为后边还需要回来。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/45582/A-real-Postorder-Traversal-.without-reverse-or-insert-4ms">有人</a>提出只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。</p>
<ul>
<li>如果相同，就意味着是从左子树到的根节点。</li>
<li>如果不同，就意味着是从右子树到的根节点，此时就可以把节点打印。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(root);<br>            s.<span class="hljs-built_in">push</span>(root);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()&amp;&amp;cur==s.<span class="hljs-built_in">top</span>())<br>            &#123;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法三：前序的转换"><a href="#解法三：前序的转换" class="headerlink" title="解法三：前序的转换"></a>解法三：前序的转换</h3><p>参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a> 解法二中思路一。前序遍历的顺序是<strong>根 -&gt; 左 -&gt; 右</strong>，左右其实是等价的，因此也可以写出<strong>根 -&gt; 右 -&gt; 左</strong>的代码。然后把<strong>根 -&gt; 右 -&gt; 左</strong>逆序，就是<strong>左-&gt; 右 -&gt; 根</strong>了，也就是后序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur=cur-&gt;right;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                cur=s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                cur=cur-&gt;left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h3 id="解法四：Morris遍历"><a href="#解法四：Morris遍历" class="headerlink" title="解法四：Morris遍历"></a>解法四：Morris遍历</h3><h4 id="思路一-2"><a href="#思路一-2" class="headerlink" title="思路一"></a>思路一</h4><p>参考前序遍历的 Morris 遍历，把 left 改成 right，right 改成 left，最后再倒置。</p>
<h4 id="思路二-2"><a href="#思路二-2" class="headerlink" title="思路二"></a>思路二</h4><p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 的 Morris 遍历详细过程。发现除了叶子节点只访问一次，其他节点都会访问两次，结合下图。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150840.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当第二次访问某个节点的时候，只需要将它的左节点，以及左节点的右节点，左节点的右节点的右节点… 逆序打印即可。比如上边的例子。上边的遍历顺序其实就是按照深度优先的方式。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs tap">先访问 15, 7, 3,<span class="hljs-number"> 1 </span>然后往回走<br>3 第二次访问，将它的左节点逆序打印<br>list = [1]<br><br>继续访问 2, 然后往回走<br>7 第二次访问，将它的左节点，左节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3]<br><br>继续访问<span class="hljs-number"> 6 </span>4, 然后往回走<br>6 第二次访问, 将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3 4]<br><br>继续访问 5, 然后往回走<br>15 第二次访问, 将它的左节点, 左节点的右节点, 左节点的右节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7]<br><br>然后访问<span class="hljs-number"> 14 </span>10 8, 然后往回走<br>10 第二次访问，将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7 8]<br><br>继续访问 9, 然后往回走<br>14 第二次访问，将它的左节点，左节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 10]<br><br>继续访问<span class="hljs-number"> 13 </span>11, 然后往回走<br>13 第二次访问, 将它的左节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11]<br><br>继续遍历 12，结束遍历<br><br>然后单独把根节点，以及根节点的右节点，右节点的右节点，右节点的右节点的右节点逆序打印<br>list = [1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9<span class="hljs-number"> 10 </span>11<span class="hljs-number"> 12 </span>13<span class="hljs-number"> 14 </span>15]<br><br>得到的结果就刚好是后序遍历<br></code></pre></td></tr></table></figure>

<p>如下图，问题就转换成了 <code>9</code> 组单链表的逆序问题。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150847.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>当遇到第二次访问的节点，将单链表逆序，然后打印并且还原即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        TreeNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;left=root;<br>        TreeNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode* pre=cur-&gt;left;<br>                <span class="hljs-keyword">while</span>(pre-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;pre-&gt;right!=cur)<br>                    pre=pre-&gt;right;<br>                <span class="hljs-keyword">if</span>(pre-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    pre-&gt;right=cur;<br>                    cur=cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">reverseAddNodes</span>(cur-&gt;left,pre,res);<br>                    pre-&gt;right=<span class="hljs-literal">NULL</span>;<br>                    cur=cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseNodes</span><span class="hljs-params">(TreeNode* start,TreeNode* end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==end)<br>            <span class="hljs-keyword">return</span>;<br>        TreeNode* x=start;<br>        TreeNode* y=start-&gt;right;<br>        TreeNode* z;<br>        <span class="hljs-keyword">while</span>(x!=end)<br>        &#123;<br>            z=y-&gt;right;<br>            y-&gt;right=x;<br>            x=y;<br>            y=z;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseAddNodes</span><span class="hljs-params">(TreeNode* start,TreeNode* end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">reverseNodes</span>(start,end);<br>        TreeNode* node=end;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span>(node==start)<br>                <span class="hljs-keyword">break</span>;<br>            node=node-&gt;right;<br>        &#125;<br>        <span class="hljs-built_in">reverseNodes</span>(end,start);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="102-二叉树的层序遍历-medium"><a href="#102-二叉树的层序遍历-medium" class="headerlink" title="102. 二叉树的层序遍历[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>[medium]</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按<strong>层序遍历</strong>得到的节点值。（即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例：</strong></p>
<p>二叉树：[3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>利用广度优先搜索 BFS。层序遍历的顺序与 BFS 是相同的。但是层序遍历要求区分每一层，即返回一个二维数组，而 BFS 是一个一维数组，无法区别每一层。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150753.jpeg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>那么，怎么给 BFS 遍历的结果分层呢？首先观察一下 BFS 遍历的过程中，结点进队列和出队列的过程：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726150945.gif" srcset="/img/loading.gif" lazyload></p>
<p>截取 BFS 遍历过程中的某个时刻：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200726151006.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，无法区分队列中的结点来自哪一层。</p>
<p>因此，需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 cnt（也就是这一层的结点数量），然后一口气处理完这一层的 cnt 个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<p>记树上所有节点的个数为 n。</p>
<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)。</li>
</ul>
<h3 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h3><p>DFS 不是按照层次遍历的。为了让递归的过程中同一层的节点放到同一个列表中，在递归时要记录每个节点的深度 level。递归到新节点要把该节点放入 level 对应列表的末尾。</p>
<p>当遍历到一个新的深度 level，而最终结果 res 中还没有创建 level 对应的列表时，应该在 res 中新建一个列表用来保存该 level 的所有节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(h)，<code>h</code> 是树的高度。</li>
</ul>
<h1 id="103-二叉树的锯齿形层序遍历-medium"><a href="#103-二叉树的锯齿形层序遍历-medium" class="headerlink" title="103. 二叉树的锯齿形层序遍历[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a>[medium]</h1><h2 id="解法一：BFS层序遍历"><a href="#解法一：BFS层序遍历" class="headerlink" title="解法一：BFS层序遍历"></a>解法一：BFS层序遍历</h2><blockquote>
<p>参考 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#59-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91">剑指offer题解——59.按之字形顺序打印二叉树</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                TreeNode* cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)<br>                <span class="hljs-built_in">reverse</span>(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>            flag=!flag;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：DFS-1"><a href="#解法二：DFS-1" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h2><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> DFS解法相同，只不过根据 level 是否是偶数进行不同的插入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; ());<br>        <span class="hljs-comment">// 这里默认根节点是第0层</span><br>        <span class="hljs-keyword">if</span>(level%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 偶数层相当于从左往右遍历，所以要添加到集合的末尾，</span><br>            res[level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 奇数层相当于从右往左遍历，要把数据添加到集合的开头</span><br>            res[level].<span class="hljs-built_in">insert</span>(res[level].<span class="hljs-built_in">begin</span>(),root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101. 对称二叉树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a>[easy]</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  <span class="hljs-number">4</span> <span class="hljs-number">4</span>  <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">1</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2</span><br> <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br> <span class="hljs-number">3</span>    <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>详细思路参考<strong>剑指offer题解</strong> <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">58.对称的二叉树</a>。</p>
<h3 id="解法一：递归-3"><a href="#解法一：递归-3" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(root-&gt;left,root-&gt;right);        <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* l,TreeNode* r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>&amp;&amp;r==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(l==<span class="hljs-literal">nullptr</span>||r==<span class="hljs-literal">nullptr</span>||l-&gt;val!=r-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSymmetric</span>(l-&gt;left,r-&gt;right)&amp;&amp;<span class="hljs-built_in">isSymmetric</span>(l-&gt;right,r-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)。</li>
<li>空间复杂度 O(N)。</li>
</ul>
<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        s.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* curR=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* curL=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>&amp;&amp;curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(curL==<span class="hljs-literal">nullptr</span>||curR==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(curL!=<span class="hljs-literal">nullptr</span>&amp;&amp;curR!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(curL-&gt;val!=curR-&gt;val)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                s.<span class="hljs-built_in">push</span>(curL-&gt;left);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curL-&gt;right);<br>                s.<span class="hljs-built_in">push</span>(curR-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)。</li>
<li>空间复杂度 O(N)。</li>
</ul>
<h1 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104. 二叉树的最大深度[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>[easy]</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-4"><a href="#解法一：递归-4" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>分别计算左子树和右子树的最大深度，返回左子树和右子树最大深度的较大值 +1，递归退出条件为到叶子节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left),<span class="hljs-built_in">maxDepth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个结点只访问一次，因此时间复杂度为 O(N)，其中 N 是结点的数量。</li>
<li>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</li>
</ul>
<h3 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>利用队列进行 BFS。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(N)。</li>
</ul>
<h1 id="110-平衡二叉树-easy"><a href="#110-平衡二叉树-easy" class="headerlink" title="110. 平衡二叉树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a>[easy]</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例 1:</p>
<p>给定二叉树 [3,9,20,null,null,15,7]</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>返回 true 。</p>
<p>示例 2:</p>
<p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">1</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>   <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>   <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>返回 false 。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>详细思路参考<strong>剑指offer题解</strong> <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">39.平衡二叉树</a>。</p>
<h3 id="解法一：从顶至底（暴力法）"><a href="#解法一：从顶至底（暴力法）" class="headerlink" title="解法一：从顶至底（暴力法）"></a>解法一：从顶至底（暴力法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left)&amp;&amp;<span class="hljs-built_in">isBalanced</span>(root-&gt;right)&amp;&amp;<span class="hljs-built_in">abs</span>(left-right)&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">depth</span>(root-&gt;left),<span class="hljs-built_in">depth</span>(root-&gt;right))+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(NlogN)： 最差情况下（为 “满二叉树” 时）， isBalanced(root) 遍历树所有节点，判断每个节点的深度 depth(root) 需要遍历各子树的所有节点 。</li>
<li>空间复杂度 O(N)：最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
<h3 id="解法二：从底至顶（提前阻断）"><a href="#解法二：从底至顶（提前阻断）" class="headerlink" title="解法二：从底至顶（提前阻断）"></a>解法二：从底至顶（提前阻断）</h3><p>使用 flag 做标记，进行剪枝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left-right)&gt;<span class="hljs-number">1</span>)<br>            flag=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li>空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N) 的栈空间。</li>
</ul>
<h1 id="111-二叉树的最小深度-easy"><a href="#111-二叉树的最小深度-easy" class="headerlink" title="111. 二叉树的最小深度[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a>[easy]</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>返回它的最小深度  2.</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-5"><a href="#解法一：递归-5" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>叶子节点的定义是左孩子和右孩子都为空。因此递归结束条件为：</p>
<ol>
<li>左孩子和右孩子都为空，说明到达了叶子节点，直接返回 1；</li>
<li>左孩子和右孩子有一个为空，那么需要返回较大的那个孩子的深度+1；</li>
<li>左右孩子都不为空，那么返回左右孩子较小孩子的深度+1。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>        <span class="hljs-comment">// left和right有一个必然为0</span><br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>||root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left+right+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left,right)+<span class="hljs-number">1</span>;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：访问每个节点一次，时间复杂度为 O(N) ，其中 N 是节点个数。</li>
<li>空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 N （树的高度）次，因此栈的空间开销是 O(N) 。但在最好情况下，树是完全平衡的，高度只有 log(N)，因此在这种情况下空间复杂度只有 O(log(N)) 。</li>
</ul>
<h3 id="解法二：迭代-2"><a href="#解法二：迭代-2" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><h4 id="思路一：BFS"><a href="#思路一：BFS" class="headerlink" title="思路一：BFS"></a>思路一：BFS</h4><p>在 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a> 的解法二上稍作修改，在第二个 while 中增加一个判断，即判断当前节点是否是叶子节点，如果是，返回当前的 depth。实际的效果为层次遍历遇到第一个叶子节点，就返回当前的节点深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> depth=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            depth++;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    <span class="hljs-keyword">return</span> depth;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：最坏情况下，这是一棵平衡树，需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N&#x2F;2 个节点，因此复杂度是 O(N)。</li>
<li>空间复杂度：和时间复杂度相同，也是 O(N)。</li>
</ul>
<h4 id="思路二：DFS"><a href="#思路二：DFS" class="headerlink" title="思路二：DFS"></a>思路二：DFS</h4><p>用 pair 记录节点和节点的深度，模拟二叉树的遍历，当遇到叶子节点时，更新最小深度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        stack&lt;pair&lt;TreeNode*,<span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(root,<span class="hljs-number">1</span>));<br>        <span class="hljs-type">int</span> mindepth=INT_MAX;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>().first;<br>            <span class="hljs-type">int</span> depth=s.<span class="hljs-built_in">top</span>().second;<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                mindepth=<span class="hljs-built_in">min</span>(mindepth,depth);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(cur-&gt;left,depth+<span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(cur-&gt;right,depth+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> mindepth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)。</li>
<li>空间复杂度：最坏情况下会在栈中保存整棵树，此时空间复杂度为 O(N)。</li>
</ul>
<h1 id="100-相同的树-easy"><a href="#100-相同的树-easy" class="headerlink" title="100. 相同的树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a>[easy]</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>示例 1:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 3 </span>   <span class="hljs-number"> 2 </span>  3<br><br>        [1,2,3],   [1,2,3]<br><br>输出: true<br></code></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入:      <span class="hljs-number">1</span>          <span class="hljs-number">1</span><br>          /           \<br>         <span class="hljs-number">2</span>             <span class="hljs-number">2</span><br><span class="hljs-string"></span><br><span class="hljs-string">        [1,2]</span>,     [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入:      <span class="hljs-number"> 1 </span>        1<br>          / \       / \<br>        <span class="hljs-number"> 2 </span> <span class="hljs-number"> 1 </span>   <span class="hljs-number"> 1 </span>  2<br><br>        [1,2,1],   [1,1,2]<br><br>输出: false<br></code></pre></td></tr></table></figure>

<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-6"><a href="#解法一：递归-6" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>判断两棵树是否相等有三个条件：</p>
<ul>
<li>根节点值相等；</li>
<li>并且，p 的左子树和 q 的左子树相等；</li>
<li>并且，p 的右子树和 q 的右子树相等。</li>
</ul>
<p>终止条件：</p>
<ul>
<li>两棵树的当前结点同时为 null 时返回 true；</li>
<li>其中一个为 null 另一个不为 null 时返回 false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>&amp;&amp;q==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>||q==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp;<span class="hljs-built_in">isSameTree</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="hljs-built_in">isSameTree</span>(p-&gt;right,q-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</li>
<li>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护递归栈。</li>
</ul>
<h3 id="解法二：迭代-3"><a href="#解法二：迭代-3" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>把两个树同时遍历一下，遍历过程中判断数值是否相等或者同时为 null 即可。遍历的方法，可以选择 DFS 里的先序遍历，中序遍历，后序遍历，或者 BFS。</p>
<p>这里选择先序遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; s;<br>        s.<span class="hljs-built_in">push</span>(q);<br>        s.<span class="hljs-built_in">push</span>(p);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* p_cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            TreeNode* q_cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(p_cur==<span class="hljs-literal">nullptr</span>&amp;&amp;q_cur==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(p_cur==<span class="hljs-literal">nullptr</span>||q_cur==<span class="hljs-literal">nullptr</span>||p_cur-&gt;val!=q_cur-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            s.<span class="hljs-built_in">push</span>(q_cur-&gt;right);<br>            s.<span class="hljs-built_in">push</span>(p_cur-&gt;right);<br>            s.<span class="hljs-built_in">push</span>(q_cur-&gt;left);<br>            s.<span class="hljs-built_in">push</span>(p_cur-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</li>
<li>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护栈。</li>
</ul>
<h1 id="572-另一个树的子树-easy"><a href="#572-另一个树的子树-easy" class="headerlink" title="572. 另一个树的子树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subtree-of-another-tree/">572. 另一个树的子树</a>[easy]</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<p>示例 1:<br>给定的树 s:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">4</span> <br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>


<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>
<p>示例 2:<br>给定的树 s：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br>   /<br>  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>给定的树 t：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">4</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>


<p>返回 false。</p>
<h2 id="解题思路：递归"><a href="#解题思路：递归" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>判断 t 是否为 s 的子树的三个条件时或的关系：</p>
<ul>
<li>t 是 s 的左子树的子树；</li>
<li>t 是 s 的右子树的子树；</li>
<li>t 和 s 两棵树相等。</li>
</ul>
<p>而判断两棵树是否相等的三个条件是与的关系：</p>
<ul>
<li>根节点值相等；</li>
<li>并且，s 的左子树和 t 的左子树相等；</li>
<li>并且，s 的右子树和 t 的右子树相等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* s, TreeNode* t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubtree</span>(s-&gt;left,t)||<span class="hljs-built_in">isSubtree</span>(s-&gt;right,t)||<span class="hljs-built_in">isSameTree</span>(s,t);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* s,TreeNode* t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>&amp;&amp;t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-literal">nullptr</span>||t==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> s-&gt;val==t-&gt;val&amp;&amp;<span class="hljs-built_in">isSameTree</span>(s-&gt;left,t-&gt;left)&amp;&amp;<span class="hljs-built_in">isSameTree</span>(s-&gt;right,t-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="965-单值二叉树-easy"><a href="#965-单值二叉树-easy" class="headerlink" title="965. 单值二叉树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/univalued-binary-tree/">965. 单值二叉树</a>[easy]</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p>
<p>示例 1：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120337.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>


<p>示例 2：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120331.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />

<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,2,5,2]</span><br>输出：false<br></code></pre></td></tr></table></figure>


<p>提示：</p>
<ol>
<li>给定树的节点数范围是 [1, 100]。</li>
<li>每个节点的值都是整数，范围为 [0, 99] 。</li>
</ol>
<h2 id="解题思路：递归-1"><a href="#解题思路：递归-1" class="headerlink" title="解题思路：递归"></a>解题思路：递归</h2><p>把当前节点的值记为 val，和左&#x2F;右子树一起传入递归函数。</p>
<p>递归终止条件：</p>
<ul>
<li>节点为 null 则返回 true；</li>
<li>如果传入进来的父节点的值 val 和 当前节点的值不相等，则返回 false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isUnivalTree</span>(root,root-&gt;val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnivalTree</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val!=val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isUnivalTree</span>(root-&gt;left,root-&gt;val)&amp;&amp;<span class="hljs-built_in">isUnivalTree</span>(root-&gt;right,root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是给定树中节点的数量。</li>
<li>空间复杂度：O(H)，其中 H 是给定树的高度。</li>
</ul>
<h1 id="107-二叉树的层次遍历-II-easy"><a href="#107-二叉树的层次遍历-II-easy" class="headerlink" title="107. 二叉树的层次遍历 II[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a>[easy]</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回其节点值自底向上的层次遍历。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[15,7]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[9,20]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>一种思路是，顺序的层次遍历，然后将结果翻转，但是这里采用不用翻转结果的方法。</p>
<h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 解法二，需要做两处修改：</p>
<ol>
<li><p>之前根据 level 得到数组的位置，然后添加。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">res[level].push_back(root-&gt;val);<br><br>res   [] [] [] [] []<br>index<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>level<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>      -------------&gt;<br>index=0+level<br>    <br>现在 level 是逆过来存的<br>res   [] [] [] [] []<br>index<span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span> 4<br>level<span class="hljs-number"> 4 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 1 </span> 0<br>      &lt;----------<span class="language-yaml"><span class="hljs-meta">---</span></span><br><span class="language-yaml"><span class="hljs-string">index=4-level</span></span><br><span class="language-yaml"><span class="hljs-string">即</span> <span class="hljs-string">res.size()-1-level</span></span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在添加当前 level 的第一个元素的时候，首先添加一个空列表到 res 中</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">level</span>&gt;=res.size())<br>    res.push_back(vector&lt;<span class="hljs-type">int</span>&gt;());<br><br>假设当前 <span class="hljs-keyword">level</span>=<span class="hljs-number">2</span>,res 中只添加了 <span class="hljs-keyword">level</span> 是 <span class="hljs-number">0</span> 和 <span class="hljs-number">1</span> 的元素<br>res   [<span class="hljs-number">3</span>] [<span class="hljs-number">9</span>] <br><span class="hljs-keyword">index</span>  <span class="hljs-number">0</span>   <span class="hljs-number">1</span> <br><span class="hljs-keyword">level</span>  <span class="hljs-number">1</span>   <span class="hljs-number">0</span><br>因为 <span class="hljs-keyword">level</span> 是从右往左增加的，所以空列表要加到 res 的头部<br>res   [] [<span class="hljs-number">3</span>] [<span class="hljs-number">9</span>] <br><span class="hljs-keyword">index</span> <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span><br><span class="hljs-keyword">level</span> <span class="hljs-number">2</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span><br><br>所以改成：<br>res.<span class="hljs-keyword">insert</span>(res.<span class="hljs-keyword">begin</span>(),vector&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">dfs</span>(root,res,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res,<span class="hljs-type">int</span> level)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 当前层数还没有元素，先创建一个空的列表</span><br>        <span class="hljs-keyword">if</span>(level&gt;=res.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-comment">// 当前值加入</span><br>        res[res.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-level].<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,res,level+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,res,level+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)。</li>
<li>空间复杂度：O(h)，<code>h</code> 是树的高度。</li>
</ul>
<h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a> 解法一，BFS 的修改相比 DFS 比较简单，只需要做一处修改，即把当前层遍历的结果加到 res 头部即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrderBottom</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>(),tmp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个点进队出队各一次，故渐进时间复杂度为 O(n)。</li>
<li>空间复杂度：队列中元素的个数不超过 n 个，故渐进空间复杂度为 O(n)</li>
</ul>
<h1 id="872-叶子相似的树-easy"><a href="#872-叶子相似的树-easy" class="headerlink" title="872. 叶子相似的树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a>[easy]</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个叶值序列。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200730120312.png" srcset="/img/loading.gif" lazyload style="zoom: 33%;" />

<p>举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。</p>
<p>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。</p>
<p>如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>给定的两颗树可能会有 <code>1</code> 到 <code>200</code> 个结点。</li>
<li>给定的两颗树上的值介于 <code>0</code> 到 <code>200</code> 之间。</li>
</ul>
<h2 id="解题思路：深度优先搜索"><a href="#解题思路：深度优先搜索" class="headerlink" title="解题思路：深度优先搜索"></a>解题思路：深度优先搜索</h2><p>找出给定的两个树的叶值序列。之后，比较它们，看它们是否相等。</p>
<p>要找出树的叶值序列，可以使用深度优先搜索。如果结点是叶子，那么 dfs 函数会写入结点的值，然后递归地探索每个子结点。这可以保证按从左到右的顺序访问每片叶子，因为在右孩子结点之前完全探索了左孩子结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; leaves1;<br>        vector&lt;<span class="hljs-type">int</span>&gt; leaves2;<br>        <span class="hljs-built_in">dfs</span>(root1,leaves1);<br>        <span class="hljs-built_in">dfs</span>(root2,leaves2);<br>        <span class="hljs-keyword">return</span> leaves1==leaves2;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; leaves)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            leaves.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,leaves);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,leaves);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(T1 + T2)，其中 T1, T2 是给定的树的长度。</li>
<li>空间复杂度：O(T1 + T2)，存储叶值所使用的空间。</li>
</ul>
<h1 id="814-二叉树剪枝-medium"><a href="#814-二叉树剪枝-medium" class="headerlink" title="814. 二叉树剪枝[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a>[medium]</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>
<p>返回移除了所有不包含 1 的子树的原二叉树。</p>
<p>( 节点 X 的子树为 X 本身，以及所有 X 的后代。)</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例1:</span><br><span class="hljs-section">输入: [1,null,0,0,1]</span><br><span class="hljs-section">输出: [1,null,0,null,1]</span><br><br><span class="hljs-section">解释: </span><br>只有红色节点满足条件“所有不包含 1 的子树”。<br>右图为返回的答案。<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101346.png" srcset="/img/loading.gif" lazyload  style="zoom: 33%;" />

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">示例2:</span><br><span class="hljs-section">输入: [1,0,1,0,0,0,1]</span><br><span class="hljs-section">输出: [1,null,1,null,1]</span><br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101434.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />

<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例<span class="hljs-number">3</span>:<br>输入: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1,0,1,0</span>]<br>输出: [<span class="hljs-number">1,1,0,1</span>,<span class="hljs-number">1</span>,null,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801101459.png" srcset="/img/loading.gif" lazyload style="zoom:33%;" />

<p><strong>说明:</strong></p>
<ul>
<li>给定的二叉树最多有 <code>100</code> 个节点。</li>
<li>每个节点的值只会为 <code>0</code> 或 <code>1</code> 。</li>
</ul>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：自顶向下递归"><a href="#解法一：自顶向下递归" class="headerlink" title="解法一：自顶向下递归"></a>解法一：自顶向下递归</h3><p>用 containsOne(node) 函数来判断以 node 为根的子树中是否包含 1，其不包含 1 当且仅当以 node 的左右孩子为根的子树均不包含 1，并且 node 节点本身的值也不为 1。</p>
<p>如果 node 的左右孩子为根的子树不包含 1，那就需要把对应的指针置为空。例如当 node 的左孩子为根的子树不包含 1 时，我们将 node.left 置为 null。</p>
<p>在递归结束之后，如果整颗二叉树都不包含 1，那么返回 null，否则返回原来的根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">containsOne</span>(root)?root:<span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsOne</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> left=<span class="hljs-built_in">containsOne</span>(node-&gt;left);<br>        <span class="hljs-type">bool</span> right=<span class="hljs-built_in">containsOne</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span>(!left) node-&gt;left=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(!right) node-&gt;right=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> node-&gt;val==<span class="hljs-number">1</span>||left||right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是树中节点的个数。</li>
<li>空间复杂度：O(H)，其中 H 是树的高度，为在递归时使用的栈空间大小。</li>
</ul>
<h3 id="解法二：从底向上后序遍历"><a href="#解法二：从底向上后序遍历" class="headerlink" title="解法二：从底向上后序遍历"></a>解法二：从底向上后序遍历</h3><p>本质是找到叶子节点，对于操作叶子节点，首先考虑后序遍历，因为叶子节点的处理可能影响到根节点的操作，而只有后序遍历是先处理左右孩子，再处理根节点的顺序。从底向上后序遍历，如果当前节点值为 0，且左右子树均为 null，则删除节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left=<span class="hljs-built_in">pruneTree</span>(root-&gt;left);<br>        root-&gt;right=<span class="hljs-built_in">pruneTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(root-&gt;val==<span class="hljs-number">0</span>&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是树中节点的个数。</li>
<li>空间复杂度：O(H)，其中 H 是树的高度，为在递归时使用的栈空间大小。</li>
</ul>
<h1 id="669-修剪二叉搜索树-easy"><a href="#669-修剪二叉搜索树-easy" class="headerlink" title="669. 修剪二叉搜索树[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>[easy]</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;&#x3D;L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<p>示例 1:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: <br>    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">0</span>   <span class="hljs-number">2</span><br><br>  L = <span class="hljs-number">1</span><br>  R = <span class="hljs-number">2</span><br><br>输出: <br>    <span class="hljs-number">1</span><br>      <span class="hljs-string">\</span><br>       <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs crystal">输入: <br>    <span class="hljs-number">3</span><br>   <span class="hljs-regexp">/ \</span><br><span class="hljs-regexp">  0   4</span><br><span class="hljs-regexp">   \</span><br><span class="hljs-regexp">    2</span><br><span class="hljs-regexp">   /</span><br>  <span class="hljs-number">1</span><br><br>  L = <span class="hljs-number">1</span><br>  R = <span class="hljs-number">3</span><br><br>输出: <br>      <span class="hljs-number">3</span><br>     <span class="hljs-regexp">/ </span><br><span class="hljs-regexp">   2   </span><br><span class="hljs-regexp">  /</span><br> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求返回 BST 被修剪后的根结点，那么从根结点开始修剪。</p>
<ul>
<li>如果根结点太小，根结点的左子树的所有结点只会更小，说明根结点及其左子树都应该剪掉，因此直接返回右子树的修剪结果。</li>
<li>如果根结点太大，根结点的右子树的所有结点只会更大，说明根结点及其右子树都应该剪掉，因此直接返回左子树的修剪结果。</li>
<li>如果根结点没问题，则递归地修剪左子结点和右子结点。</li>
<li>如果结点为空，说明无需修剪，直接返回空即可。</li>
<li>左右子结点都修剪完后，返回自身。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val&gt;R)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>        <span class="hljs-keyword">if</span>(root-&gt;val&lt;L)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>        root-&gt;left=<span class="hljs-built_in">trimBST</span>(root-&gt;left,L,R);<br>        root-&gt;right=<span class="hljs-built_in">trimBST</span>(root-&gt;right,L,R);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是给定的树的全部节点。最多访问每个节点一次。</li>
<li>空间复杂度：O(N)，即使没有明确使用任何额外的内存，在最糟糕的情况下，递归调用的栈可能与节点数一样大。</li>
</ul>
<h1 id="1325-删除给定值的叶子节点-medium"><a href="#1325-删除给定值的叶子节点-medium" class="headerlink" title="1325. 删除给定值的叶子节点[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-leaves-with-a-given-value/">1325. 删除给定值的叶子节点</a>[medium]</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。</p>
<p>注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。</p>
<p>也就是说，你需要重复此过程直到不能继续删除。</p>
<p><strong>示例 1：</strong></p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104913.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">3</span>,<span class="hljs-keyword">null</span>,<span class="hljs-number">4</span>]<br>解释：<br>上面左边的图中，绿色节点为叶子节点，且它们的值与 <span class="hljs-keyword">target</span> 相同（同为 <span class="hljs-number">2</span> ），它们会被删除，得到中间的图。<br>有一个新的节点变成了叶子节点且它的值与 <span class="hljs-keyword">target</span> 相同，所以将再次进行删除，从而得到最右边的图。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801104956.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200801105031.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">target</span> = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1</span>]<br>解释：每一步都删除一个绿色的叶子节点（值为 <span class="hljs-number">2</span>）。<br></code></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,1,1]</span>, target = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2,3]</span>, target = 1<br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 1000</code></li>
<li>每一棵树最多有 <code>3000</code> 个节点。</li>
<li>每一个节点值的范围是 <code>[1, 1000]</code> 。</li>
</ul>
<h2 id="解题思路：二叉树的后序遍历"><a href="#解题思路：二叉树的后序遍历" class="headerlink" title="解题思路：二叉树的后序遍历"></a>解题思路：二叉树的后序遍历</h2><p>基本思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-pruning/">814. 二叉树剪枝</a> 解法二相同。二叉树的遍历无非就先序，中序和后序三种。根据题目要求，由于子节点的处理结果会影响到父节点的处理过程，所以应当先访问左右两个子节点，再访问节点本身。这也就对应着二叉树遍历方式中的后序遍历。即节点遍历顺序为左子节点 -&gt; 右子节点 -&gt; 节点本身。</p>
<p>有了遍历过程，接下来的就是返回值的处理。因为如果当前节点需要被删除，那么方式其实是通过修改父节点对应的指针。而父节点无法直接在当前节点访问到。如果重新从根节点开始查找当前节点的父节点，还需要额外的遍历开销。所以这里考虑通过递归调用的返回值来做处理。</p>
<p><strong>递归流程：</strong></p>
<ol>
<li>如果左子节点存在，递归的处理当前节点的左子节点，并更新左子节点的值。</li>
<li>如果右子节点存在，递归的处理当前节点的右子节点，并更新右子节点的值。</li>
<li>判断当前节点是否是符合要求的叶节点，并返回当前节点的最新值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">removeLeafNodes</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        root-&gt;left=<span class="hljs-built_in">removeLeafNodes</span>(root-&gt;left,target);<br>        root-&gt;right=<span class="hljs-built_in">removeLeafNodes</span>(root-&gt;right,target);<br>        <span class="hljs-keyword">if</span>(root-&gt;val==target&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;       <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)，其中 N 是二叉树的节点个数。</li>
<li>空间复杂度：O(H)，其中 H 是二叉树的高度。</li>
</ul>
<h1 id="112-路径总和-easy"><a href="#112-路径总和-easy" class="headerlink" title="112. 路径总和[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>[easy]</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<div class="code-wrapper"><pre><code class="hljs">          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre></div>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS递归"><a href="#解法一：DFS递归" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>题目询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。假定从根节点到当前节点的值之和为 val，可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。</p>
<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，只需要递归地询问它的子节点是否能满足条件即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> root-&gt;val==sum;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,sum-root-&gt;val)||<span class="hljs-built_in">hasPathSum</span>(root-&gt;right,sum-root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</li>
<li>空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li>
</ul>
<h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>对二叉树进行层次遍历，除了遍历需要的队列外，再准备一个队列，保存从根节点到当前节点的路径和，以防止重复计算。两个队列同步进行压入和弹出操作，当遇到叶子节点，且路径和为 sum 时返回 true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        queue&lt;<span class="hljs-type">int</span>&gt; queSum;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        queSum.<span class="hljs-built_in">push</span>(root-&gt;val);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> curSum=queSum.<span class="hljs-built_in">front</span>();<br>                queSum.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">//判断叶子节点是否满足了条件</span><br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>&amp;&amp;curSum==sum)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    queSum.<span class="hljs-built_in">push</span>(curSum+cur-&gt;left-&gt;val);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queSum.<span class="hljs-built_in">push</span>(curSum+cur-&gt;right-&gt;val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</li>
<li>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>
</ul>
<h3 id="解法三：DFS迭代"><a href="#解法三：DFS迭代" class="headerlink" title="解法三：DFS迭代"></a>解法三：DFS迭代</h3><p>DFS 本身也可以用栈去模拟，参考二叉树前序、中序、后序的非递归版本。对于这道题，可以像解法二 BFS 一样，再增加一个栈，去保存从根节点到当前节点的路径和。</p>
<p>但是对于这种利用栈模拟递归的思路，对时间复杂度和空间复杂度没有什么提高。只是把递归的压栈过程变成了手动压栈。那么能不能提高一下，省去额外的保存路径和的栈，参考<a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum/discuss/36382/Accepted-By-using-postorder-traversal">这里</a>。</p>
<p>如果只用一个变量 curSum 来记录根节点到当前节点的路径和，有节点入栈就加上节点的值，有节点出栈就减去节点的值。</p>
<p>比如对于下边的树，进行中序遍历。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs abnf">     <span class="hljs-number">3</span><br>    / \<br>   <span class="hljs-number">9</span>   <span class="hljs-number">20</span><br>  / \   <br> <span class="hljs-number">8</span>   <span class="hljs-number">15</span>   <br><br><span class="hljs-attribute">curSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br><span class="hljs-number">3</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">3</span>，<span class="hljs-number">3</span><br><span class="hljs-number">9</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">12</span>，<span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">8</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">20</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">8</span><br><span class="hljs-number">8</span> 出栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">12</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">9</span> 出栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">3</span>， <br><span class="hljs-number">15</span> 入栈， curSum <span class="hljs-operator">=</span> <span class="hljs-number">18</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>

<p>此时路径是 <code>3 -&gt; 9 -&gt; 15</code>，和应该是 <code>27</code>。但得到的是 <code>18</code>，少加了 <code>9</code>。原因是进行的是中序遍历，当我们还没访问右边的节点的时候，根节点已经出栈了，再访问右边节点的时候，<code>curSum</code>就会少一个根节点的值。所以，需要使用后序遍历，先访问左子树，再访问右子树，最后访问根节点。再看一下上边的二叉树。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">3</span><br>    / <span class="hljs-string">\</span><br>   <span class="hljs-number">9</span>   <span class="hljs-number">20</span><br>  / <span class="hljs-string">\</span>   <br> <span class="hljs-number">8</span>   <span class="hljs-number">15</span>   <br><br>curSum = <span class="hljs-number">0</span><br><span class="hljs-number">3</span> 入栈， curSum = <span class="hljs-number">3</span>，<span class="hljs-number">3</span><br><span class="hljs-number">9</span> 入栈， curSum = <span class="hljs-number">12</span>，<span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">8</span> 入栈， curSum = <span class="hljs-number">20</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">8</span><br><span class="hljs-number">8</span> 出栈， curSum = <span class="hljs-number">12</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span><br><span class="hljs-number">15</span> 入栈， curSum = <span class="hljs-number">27</span>， <span class="hljs-number">3</span> -&gt; <span class="hljs-number">9</span> -&gt; <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>

<p>此时路径 <code>3 -&gt; 9 -&gt; 15</code> 对应的 <code>curSum</code> 就是正确的了。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a> 解法二思路一，修改相关代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                curSum+=cur-&gt;val;<br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-keyword">if</span>(curSum==sum&amp;&amp;tmp-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    curSum-=tmp-&gt;val;<br>                    last=tmp;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="113-路径总和-II-medium"><a href="#113-路径总和-II-medium" class="headerlink" title="113. 路径总和 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a>[medium]</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<div class="code-wrapper"><pre><code class="hljs">          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre></div>
<p>返回:</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[</span><br><span class="hljs-comment">   <span class="hljs-comment">[5,4,11,2]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[5,8,4,5]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a> 的升级版，给定一个<code>sum</code>，输出从根节点开始到叶子节点，和为<code>sum</code> 的所有路径可能。</p>
<h3 id="解法一：DFS递归-1"><a href="#解法一：DFS递归-1" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>深度优先搜索。使用前序遍历，使用两个全局变量 res 和 path，res 来存放最终结果，path 用来存放临时结果。</p>
<p>若当前节点是叶子节点，那么直接判断 sum 是否等于 val 即可，如果满足条件，就将 path 压入 res 中。若当前节点不是叶子节点，只需要递归地询问它的子节点是否能满足条件即可。向上回溯前，需要将当前节点从路径 path 中删除，不要影响到其他分支的临时结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(root,sum,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> sum,vector&lt;<span class="hljs-type">int</span>&gt;&amp; path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span>(sum==root-&gt;val&amp;&amp;root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left,sum-root-&gt;val,path,res);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right,sum-root-&gt;val,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：DFS迭代"><a href="#解法二：DFS迭代" class="headerlink" title="解法二：DFS迭代"></a>解法二：DFS迭代</h3><p>112 题中解法二为BFS，但是这题需要保存一条一条的路径，而 BFS 是一层一层进行的。在遍历过程中，需要保存不同的路径，对于这题不划算。</p>
<p>和 112 解法三一样，进行后序遍历。使用两个变量 res 和 path，res 来存放最终结果，path 用来存放临时结果，向上回溯前，需要将当前节点从路径 path 中删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathSum</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur=root;<br>        TreeNode* last=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> curSum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>||!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                curSum+=cur-&gt;val;<br>                path.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<span class="hljs-comment">//将当前节点加入路径</span><br>                cur=cur-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                TreeNode* tmp=s.<span class="hljs-built_in">top</span>();<br>                <span class="hljs-comment">//判断是否满足条件</span><br>                <span class="hljs-keyword">if</span>(curSum==sum&amp;&amp;tmp-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">if</span>(tmp-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;tmp-&gt;right!=last)<br>                    cur=tmp-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    curSum-=tmp-&gt;val;<br>                    last=tmp;<br>                    path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//将当前节点从入路径中删除</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="437-路径总和-III-medium"><a href="#437-路径总和-III-medium" class="headerlink" title="437. 路径总和 III[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a>[medium]</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<p>示例：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript">root = [<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-number">3</span>,-<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>], sum = <span class="hljs-number">8</span><br><br>      <span class="hljs-number">10</span><br>     /  <span class="hljs-string">\</span><br>    <span class="hljs-number">5</span>   -<span class="hljs-number">3</span><br>   / <span class="hljs-string">\</span>    <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span>   <span class="hljs-number">2</span>   <span class="hljs-number">11</span><br> / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br><span class="hljs-number">3</span>  -<span class="hljs-number">2</span>   <span class="hljs-number">1</span><br><br>返回 <span class="hljs-number">3</span>。和等于 <span class="hljs-number">8</span> 的路径有:<br><br><span class="hljs-number">1.</span>  <span class="hljs-number">5</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">2.</span>  <span class="hljs-number">5</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span><br><span class="hljs-number">3.</span>  -<span class="hljs-number">3</span> -&gt; <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-7"><a href="#解法一：递归-7" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>题目要求路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。这就要求我们只需要去求三部分即可：</p>
<ul>
<li>以当前节点作为头节点的满足条件的路径数量</li>
<li>当前节点的左子树中满足条件的路径数量</li>
<li>当前节点的右子树中满足条件的路径数量</li>
</ul>
<p>将这三部分之和作为最后的结果。接下来的问题是，如何求以当前节点作为头节点的路径数量，继续遍历树，按照 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a> 的思路 DFS 递归进行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">paths</span>(root,sum)+<span class="hljs-built_in">pathSum</span>(root-&gt;left,sum)+<span class="hljs-built_in">pathSum</span>(root-&gt;right,sum);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">paths</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;val==sum)<br>            cnt+=<span class="hljs-number">1</span>;<br>        cnt+=<span class="hljs-built_in">paths</span>(node-&gt;left,sum-node-&gt;val);<br>        cnt+=<span class="hljs-built_in">paths</span>(node-&gt;right,sum-node-&gt;val);<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n^2)。如果是高度平衡的二叉树，时间复杂度为 O(nlogn)，如果是斜的二叉树，时间复杂度为 O(n)。</li>
<li>空间复杂度：O(h)，h为树的高度。</li>
</ul>
<h3 id="解法二：前缀和-回溯"><a href="#解法二：前缀和-回溯" class="headerlink" title="解法二：前缀和+回溯"></a>解法二：前缀和+回溯</h3><p>解法一存在大量重复计算，因此采取前缀和的思路。前缀和就是到达当前元素的路径上，之前所有元素的和。</p>
<p>如果两个数的前缀总和是相同的，那么这些节点之间的元素总和为零。进一步扩展相同的想法，如果前缀总和 currSum，在节点 A 和节点 B 处相差 target，则位于节点 A 和节点 B 之间的元素之和是 target。</p>
<p>因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，有且仅有一条路径，因为不存在环。(如果存在环，前缀和就不能用了，需要改造算法)</p>
<p>抵达当前节点(即 B 节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和 currSum-target 的节点(即 A 节点)，存在即表示从 A 到 B 有一条路径之和满足条件的情况。结果加上满足前缀和 currSum-target 的节点的数量。然后递归进入左右子树。</p>
<p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// key是前缀和, value是大小为key的前缀和出现的次数</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; prefixSumCount;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-comment">// 前缀和为0的一条路径</span><br>        prefixSumCount[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursionPathSum</span>(root,sum,<span class="hljs-number">0</span>);<br>    &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前缀和的递归回溯思路</span><br><span class="hljs-comment">     * 从当前节点反推到根节点(反推比较好理解，正向其实也只有一条)，有且仅有一条路径，因为这是一棵树</span><br><span class="hljs-comment">     * 如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span><br><span class="hljs-comment">     * 所以前缀和对于当前路径来说是唯一的，当前记录的前缀和，在回溯结束，回到本层时去除，保证其不影响其他分支的结果</span><br><span class="hljs-comment">     * @param node 树节点</span><br><span class="hljs-comment">     * @param target 目标值</span><br><span class="hljs-comment">     * @param currSum 当前路径和</span><br><span class="hljs-comment">     * @return 满足题意的解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">recursionPathSum</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> currSum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 1.递归终止条件</span><br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 2.本层要做的事情</span><br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 当前路径上的和</span><br>        currSum+=node-&gt;val;<br>        <span class="hljs-comment">// 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径</span><br>        <span class="hljs-comment">// 当前节点-&gt;root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了</span><br>        <span class="hljs-comment">// currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target</span><br>        res+=prefixSumCount[currSum-target];<br>        <span class="hljs-comment">// 更新路径上当前节点前缀和的个数</span><br>        prefixSumCount[currSum]++;<br>         <span class="hljs-comment">// 3.进入下一层</span><br>         res+=<span class="hljs-built_in">recursionPathSum</span>(node-&gt;left,target,currSum);<br>         res+=<span class="hljs-built_in">recursionPathSum</span>(node-&gt;right,target,currSum);<br>         <span class="hljs-comment">// 4.回到本层，恢复状态，去除当前节点的前缀和数量</span><br>         prefixSumCount[currSum]--;<br>         <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<p>时间复杂度：O(n)，每个节点只遍历一次。</p>
<p>空间复杂度：O(n)，开辟了一个 hashMap。</p>
<h1 id="129-求根到叶子节点数字之和-medium"><a href="#129-求根到叶子节点数字之和-medium" class="headerlink" title="129. 求根到叶子节点数字之和[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a>[medium]</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>    <span class="hljs-number">1</span><br>   / \<br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-number">25</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span> 代表数字 <span class="hljs-number">12</span>.<br>从根到叶子节点路径 <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span> 代表数字 <span class="hljs-number">13</span>.<br>因此，数字总和 = <span class="hljs-number">12</span> + <span class="hljs-number">13</span> = <span class="hljs-number">25</span>.<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br>    <span class="hljs-number">4</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>   <span class="hljs-number">0</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">5</span>   <span class="hljs-number">1</span><br>输出: <span class="hljs-number">1026</span><br>解释:<br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">5</span> 代表数字 <span class="hljs-number">495.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">9</span>-&gt;<span class="hljs-number">1</span> 代表数字 <span class="hljs-number">491.</span><br>从根到叶子节点路径 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span> 代表数字 <span class="hljs-number">40.</span><br>因此，数字总和 = <span class="hljs-number">495</span> + <span class="hljs-number">491</span> + <span class="hljs-number">40</span> = <span class="hljs-number">1026.</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归先序遍历"><a href="#解法一：递归先序遍历" class="headerlink" title="解法一：递归先序遍历"></a>解法一：递归先序遍历</h3><ol>
<li>先遍历根节点；</li>
<li>遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；</li>
<li>遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；</li>
<li>更新总的和。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root,<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node,<span class="hljs-type">int</span> father)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current=father*<span class="hljs-number">10</span>+node-&gt;val;<br>        <span class="hljs-keyword">if</span>(node-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> current;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(node-&gt;left,current)+<span class="hljs-built_in">dfs</span>(node-&gt;right,current);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：非递归先序遍历"><a href="#解法二：非递归先序遍历" class="headerlink" title="解法二：非递归先序遍历"></a>解法二：非递归先序遍历</h3><p>准备一个额外的 stack，用来记录数字。每次出 stack 之后，如果是叶子节点，那么加和。如果不是，那么就看左右子树入 stack。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> sum;<br>        stack&lt;TreeNode*&gt; s;<br>        stack&lt;<span class="hljs-type">int</span>&gt; sNum;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        sNum.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> curNum=sNum.<span class="hljs-built_in">top</span>()*<span class="hljs-number">10</span>+cur-&gt;val;<br>            sNum.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                sum+=curNum;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                sNum.<span class="hljs-built_in">push</span>(curNum);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                sNum.<span class="hljs-built_in">push</span>(curNum);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：BFS"><a href="#解法三：BFS" class="headerlink" title="解法三：BFS"></a>解法三：BFS</h3><p>本质上是层序遍历，准备一个额外的 queue，用来记录数字。每次出 queue 之后，如果是叶子节点，那么加和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        queue&lt;<span class="hljs-type">int</span>&gt; queNum;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        queNum.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> cnt=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(cnt--&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> curNum=queNum.<span class="hljs-built_in">front</span>()*<span class="hljs-number">10</span>+cur-&gt;val;<br>                queNum.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                    sum+=curNum;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    queNum.<span class="hljs-built_in">push</span>(curNum);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                    queNum.<span class="hljs-built_in">push</span>(curNum);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="257-二叉树的所有路径-easy"><a href="#257-二叉树的所有路径-easy" class="headerlink" title="257. 二叉树的所有路径[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a>[easy]</h1><h2 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br><br>   <span class="hljs-number">1</span><br> /   <span class="hljs-string">\</span><br><span class="hljs-number">2</span>     <span class="hljs-number">3</span><br> <span class="hljs-string">\</span><br>  <span class="hljs-number">5</span><br><br>输出: [<span class="hljs-string">&quot;1-&gt;2-&gt;5&quot;</span>, <span class="hljs-string">&quot;1-&gt;3&quot;</span>]<br><br>解释: 所有根节点到叶子节点的路径为: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-8"><a href="#解法一：递归-8" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>在遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，就在当前的路径末尾添加该节点，并递归遍历该结点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，把该路径添加到答案中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">constructPaths</span>(root,<span class="hljs-string">&quot;&quot;</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constructPaths</span><span class="hljs-params">(TreeNode* root,string path,vector&lt;string&gt;&amp; paths)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            path+=<span class="hljs-built_in">to_string</span>(root-&gt;val);<br>            paths.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">constructPaths</span>(root-&gt;left,path+<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;-&gt;&quot;</span>,paths);<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-built_in">constructPaths</span>(root-&gt;right,path+<span class="hljs-built_in">to_string</span>(root-&gt;val)+<span class="hljs-string">&quot;-&gt;&quot;</span>,paths);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)，其中 N 表示节点数目。</li>
<li>空间复杂度：O(N)。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 N，此时空间复杂度为 O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log(N)，此时空间复杂度为 O(log(N))。</li>
</ul>
<h3 id="解法二：迭代-4"><a href="#解法二：迭代-4" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>DFS 和 BFS 都可以实现。除了本身遍历使用的栈&#x2F;队列以外，额外维护一个栈&#x2F;队列存储节点以及根到该节点的路径，或者采用 pair 的形式。整体思路仍然与递归相同。这里只写 DFS。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode*&gt; node_stack;<br>        stack&lt;string&gt; path_stack;<br>        node_stack.<span class="hljs-built_in">push</span>(root);<br>        path_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">to_string</span>(root-&gt;val));<br>        <span class="hljs-keyword">while</span>(!node_stack.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur_node=node_stack.<span class="hljs-built_in">top</span>();<br>            node_stack.<span class="hljs-built_in">pop</span>();<br>            string cur_path=path_stack.<span class="hljs-built_in">top</span>();<br>            path_stack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left==<span class="hljs-literal">nullptr</span>&amp;&amp;cur_node-&gt;right==<span class="hljs-literal">nullptr</span>)<br>                res.<span class="hljs-built_in">push_back</span>(cur_path);<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;right);<br>                path_stack.<span class="hljs-built_in">push</span>(cur_path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(cur_node-&gt;right-&gt;val));<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur_node-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                node_stack.<span class="hljs-built_in">push</span>(cur_node-&gt;left);<br>                path_stack.<span class="hljs-built_in">push</span>(cur_path+<span class="hljs-string">&quot;-&gt;&quot;</span>+<span class="hljs-built_in">to_string</span>(cur_node-&gt;left-&gt;val));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：O(N)，每个节点只会被访问一次。</li>
<li>空间复杂度：O(N)，在最坏情况下，栈中有 N 个节点。</li>
</ul>
<h1 id="235-二叉搜索树的最近公共祖先-easy"><a href="#235-二叉搜索树的最近公共祖先-easy" class="headerlink" title="235. 二叉搜索树的最近公共祖先[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>[easy]</h1><h2 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树:  root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095809.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">8</span><br>输出: <span class="hljs-number">6</span> <br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">8</span> 的最近公共祖先是 <span class="hljs-number">6</span>。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">2</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">2</span><br>解释: 节点 <span class="hljs-number">2</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是 <span class="hljs-number">2</span>, 因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h2><p>二叉搜索树（BST）的性质如下：</p>
<blockquote>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
<li>没有键值相等的节点。</li>
</ol>
</blockquote>
<p>节点 p，q 的最近公共祖先（LCA）是距离这两个节点最近的公共祖先节点。在这里 <code>最近</code> 考虑的是节点的深度。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095759.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h3 id="解法一：递归-9"><a href="#解法一：递归-9" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>由于是二叉搜索树，所以找最近的共同祖先比较容易，总共就三种情况。</p>
<ul>
<li><p>如果给定的两个节点的值都小于根节点的值，那么最近的共同祖先一定在左子树</p>
</li>
<li><p>如果给定的两个节点的值都大于根节点的值，那么最近的共同祖先一定在右子树</p>
</li>
<li><p>如果一个大于等于、一个小于等于根节点的值，那么当前根节点就是最近的共同祖先了</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095745.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" /></li>
</ul>
<p>前两种情况用递归继续去解决即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(N)，其中 N 为 BST 中节点的个数，在最坏的情况下需要访问 BST 中所有的节点。</li>
<li>空间复杂度：O(N)，所需开辟的额外空间主要是递归栈产生的。</li>
</ul>
<h3 id="解法二：迭代-5"><a href="#解法二：迭代-5" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>用迭代的方式替代递归来遍历整棵树。由于不需要回溯来找到 LCA 节点，所以是完全可以不利用栈或者是队列的。实际上这个问题本身就是可以迭代的，只需要找到分割点就可以了。这个分割点就是能让节点 p 和节点 q 不能在同一颗子树上的那个节点，或者是节点 p 和节点 q 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(root!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;val&gt;root-&gt;val &amp;&amp; q-&gt;val&gt;root-&gt;val)<br>                root=root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val &amp;&amp; q-&gt;val&lt;root-&gt;val)<br>                root=root-&gt;left;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 为 BST 中节点的个数，在最坏的情况下需要遍历 BST 中所有的节点。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="236-二叉树的最近公共祖先-medium"><a href="#236-二叉树的最近公共祖先-medium" class="headerlink" title="236. 二叉树的最近公共祖先[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>[medium]</h1><h2 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉树:  root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805095731.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">1</span><br>输出: <span class="hljs-number">3</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">1</span> 的最近公共祖先是节点 <span class="hljs-number">3</span>。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>], <span class="hljs-attr">p</span> = <span class="hljs-number">5</span>, <span class="hljs-attr">q</span> = <span class="hljs-number">4</span><br>输出: <span class="hljs-number">5</span><br>解释: 节点 <span class="hljs-number">5</span> 和节点 <span class="hljs-number">4</span> 的最近公共祖先是节点 <span class="hljs-number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。<br></code></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归-10"><a href="#解法一：递归-10" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>若 root 是 p,q 的 最近公共祖先 ，则只可能为以下情况之一：</p>
<ul>
<li>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；</li>
<li>p &#x3D; root ，且 q 在 root 的左或右子树中；</li>
<li>q &#x3D; root ，且 p 在 root 的左或右子树中；</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200805100145.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</p>
<p><strong>具体思路：</strong></p>
<ul>
<li>如果当前结点 root 等于 NULL，则直接返回 NULL；</li>
<li>如果 root 等于 p 或者 q ，那这棵树一定返回 p 或者 q；</li>
<li>然后递归左右子树，因为是递归，使用函数后可认为左右子树已经算出结果，用 left 和 right 表示；</li>
<li>此时若 left 为空，那最终结果只要看 right；若 right 为空，那最终结果只要看 left；</li>
<li>如果 left 和 right 都非空，因为只给了 p 和 q 两个结点，都非空，说明一边一个，因此 root 是他们的最近公共祖先；</li>
<li>如果 left 和 right 都为空，则返回空（其实已经包含在前面的情况中了）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(root==p||root==q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode* left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>&amp;&amp;right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> root;<span class="hljs-comment">//if(left != null and right != null)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>可将上述代码合并一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>||root==p||root==q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode* left=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode* right=<span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span>(right==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度 O(N) ： 其中 N 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li>
<li>空间复杂度 O(N) ： 最差情况下，递归深度达到 N ，系统使用 O(N) 大小的额外空间。</li>
</ul>
<h3 id="解法二：存储父节点"><a href="#解法二：存储父节点" class="headerlink" title="解法二：存储父节点"></a>解法二：存储父节点</h3><p>用哈希表存储所有节点的父节点，然后利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是最近公共祖先。</p>
<p><strong>具体算法：</strong></p>
<ol>
<li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li>
<li>从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li>
<li>同样，再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        unordered_map&lt;TreeNode*,TreeNode*&gt; childToFather;<span class="hljs-comment">// &lt;子结点 , 父结点&gt;</span><br>        childToFather[root]=<span class="hljs-literal">nullptr</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 层序遍历</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                childToFather[cur-&gt;left]=cur;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                childToFather[cur-&gt;right]=cur;<br>            &#125;   <br>        &#125;<br>        unordered_set&lt;TreeNode*&gt; parentSet;<br>        <span class="hljs-comment">// 找出 p 的所有父结点</span><br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            parentSet.<span class="hljs-built_in">insert</span>(p);<br>            p=childToFather[p];<br>        &#125;<br>         <span class="hljs-comment">// 第一个存在于parentSet的q的父结点，即为最近公共祖先</span><br>        <span class="hljs-keyword">while</span>(parentSet.<span class="hljs-built_in">count</span>(q)==<span class="hljs-number">0</span>)<br>            q=childToFather[q];<br>        <span class="hljs-keyword">return</span> q;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 p 和 q 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。</li>
<li>空间复杂度：O(N) ，其中 N 是二叉树的节点数。哈希表存储每个节点的父节点需要 O(N) 的空间复杂度。</li>
</ul>
<h1 id="508-出现次数最多的子树元素和-medium"><a href="#508-出现次数最多的子树元素和-medium" class="headerlink" title="508. 出现次数最多的子树元素和[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/most-frequent-subtree-sum/">508. 出现次数最多的子树元素和</a>[medium]</h1><h2 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>
<p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入:<br>  5<br> /  \<br>2   <span class="hljs-string">-3</span><br>返回 [2, <span class="hljs-string">-3</span>, 4]，所有的值均只出现一次，以任意顺序返回所有值。<br></code></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：<br>  5<br> /  \<br>2   <span class="hljs-string">-5</span><br>返回 [2]，只有 2 出现两次，<span class="hljs-string">-5</span> 只出现 1 次。<br></code></pre></td></tr></table></figure>

<p>提示： 假设任意子树元素和均可以用 32 位有符号整数表示。</p>
<h2 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h2><p>计算子树元素和，应该自底向上，故考虑后序遍历，遍历过程中存取每个节点为根节点的子树元素和，用 hashmap 记录和出现的次数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findFrequentTreeSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-built_in">dfs</span>(m,root);<br>        <span class="hljs-type">int</span> maxTime=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:m)<br>            maxTime=<span class="hljs-built_in">max</span>(maxTime,item.second);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> item:m)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(item.second==maxTime)<br>                res.<span class="hljs-built_in">push_back</span>(item.first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&amp; m,TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">dfs</span>(m,root-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">dfs</span>(m,root-&gt;right);<br>        <span class="hljs-type">int</span> sum=left+right+root-&gt;val;<br>        m[sum]++;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="297-二叉树的序列化与反序列化-hard"><a href="#297-二叉树的序列化与反序列化-hard" class="headerlink" title="297. 二叉树的序列化与反序列化[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a>[hard]</h1><h2 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例: </p>
<p>你可以将以下二叉树：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>序列化为 <span class="hljs-string">&quot;[1,2,3,null,null,4,5]&quot;</span><br></code></pre></td></tr></table></figure>

<p>提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>说明: 不要使用类的成员 &#x2F; 全局 &#x2F; 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<h2 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：DFS递归-2"><a href="#解法一：DFS递归-2" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><p>递归遍历一棵树，只关注当前单个节点就好，子树的遍历交给递归完成。这里选择前序遍历，因为前序遍历为<strong>根-左-右</strong>的顺序，反序列化更容易定位出根节点的值。遇到 null 节点也要翻译成一个特殊符号，反序列化时才知道这里对应 null 节点。按什么方法序列化，就按什么方法反序列化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>        <span class="hljs-built_in">serialize</span>(root,out);<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root,ostringstream&amp; out)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            out&lt;&lt;<span class="hljs-string">&quot;# &quot;</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            out&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-built_in">serialize</span>(root-&gt;left,out);<br>            <span class="hljs-built_in">serialize</span>(root-&gt;right,out);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream&amp; in)</span></span><br><span class="hljs-function">    </span>&#123;<br>        string val;<br>        in&gt;&gt;val;<br>        <span class="hljs-keyword">if</span>(val==<span class="hljs-string">&quot;#&quot;</span>)<span class="hljs-comment">//这里无&quot; &quot;字符</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>        node-&gt;left=<span class="hljs-built_in">deserialize</span>(in);<br>        node-&gt;right=<span class="hljs-built_in">deserialize</span>(in);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec codec;</span><br><span class="hljs-comment">// codec.deserialize(codec.serialize(root));</span><br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-2"><a href="#解法二：BFS-2" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>序列化：</p>
<ul>
<li>让 null 也入列，说它是真实节点也行，它有对应的”#”，只是没有子节点入列。</li>
<li>考察出列节点<ul>
<li>如果不为 null，则将它的值推入 out，并将它的左右子节点入列；</li>
<li>如果是 null ，则将 ‘#’ 推入 out。</li>
</ul>
</li>
<li>出列…入列…直到队列为空，所有节点遍历完，out 也构建完，转成字符串。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105628.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>反序列化：</p>
<ul>
<li>除了第一个是根节点的值，其他节点值都是成对的，分别对应左右子节点。</li>
<li>从第二项开始遍历，每次考察两个节点值。</li>
<li>起初构建 root 节点并入列。</li>
<li>安排节点出列，找出子节点入列，连续考察两个 string，第一个为左子节点，第二个为右子节点<ul>
<li>如果子节点值不为 ‘#’，则为它创建节点，并认父亲，并作为未来的父亲入列；</li>
<li>如果子节点值为 ‘#’，什么都不做即可。</li>
</ul>
</li>
<li>所有的父节点（真实节点）都会在队列里走一遍。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200806105648.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        ostringstream out;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span>(root!=<span class="hljs-literal">nullptr</span>)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)<br>                out&lt;&lt;<span class="hljs-string">&quot;# &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                out&lt;&lt;cur-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        string val;<br>        in&gt;&gt;val;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* cur=que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//左子树</span><br>            in&gt;&gt;val;<br>            <span class="hljs-keyword">if</span>(val!=<span class="hljs-string">&quot;#&quot;</span>)<br>            &#123;<br>                cur-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            &#125;<br>            <span class="hljs-comment">//右子树</span><br>            in&gt;&gt;val;<br>            <span class="hljs-keyword">if</span>(val!=<span class="hljs-string">&quot;#&quot;</span>)<br>            &#123;<br>                cur-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">stoi</span>(val));<br>                que.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="124-二叉树中的最大路径和-hard"><a href="#124-二叉树中的最大路径和-hard" class="headerlink" title="124. 二叉树中的最大路径和[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>[hard]</h1><h2 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3]</span><br><br>       1<br>      / \<br>     2   3<br><br><span class="hljs-section">输出: 6</span><br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入: [-<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br><br>   -<span class="hljs-number">10</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>    /  <span class="hljs-string">\</span><br>   <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br><br>输出: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到二叉树的题，首先想到递归。递归常规的思路，是递归考虑左子树的最大值，递归考虑右子树的最大值。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> max<span class="hljs-constructor">PathSum(TreeNode <span class="hljs-params">root</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) &#123;<br>        return Integer.MIN_VALUE;<br>    &#125;<br>    <span class="hljs-comment">//左子树的最大值</span><br>    <span class="hljs-built_in">int</span> left = max<span class="hljs-constructor">PathSum(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>    <span class="hljs-comment">//右子树的最大值</span><br>    <span class="hljs-built_in">int</span> right = max<span class="hljs-constructor">PathSum(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;  <br>    <span class="hljs-comment">//再考虑包含根节点的最大值</span><br>    <span class="hljs-built_in">int</span>  all = ....;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(left, right), all);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>怎么考虑包含根节点的最大路径等于多少？因为我们递归求出来的最大 <code>left</code> 可能不包含根节点的左孩子，例如下边的情况。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">     <span class="hljs-number">8</span><br>    / <span class="hljs-string">\</span><br>  -<span class="hljs-number">3</span>   <span class="hljs-number">7</span><br> /  <span class="hljs-string">\</span><br><span class="hljs-number">1</span>    <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>左子树的最大值 <code>left</code> 肯定就是 <code>4</code> 了，然而此时的根节点 <code>8</code> 并不能直接和 <code>4</code> 去相连。所以考虑包含根节点的路径的最大值时，并不能单纯的用 <code>root.val + left + right</code>。</p>
<p>所以如果考虑包含当前根节点的 <code>8</code> 的最大路径，首先必须包含左右孩子，其次每次遇到一个分叉，就要选择能产生更大的值的路径。例如下边的例子：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs livescript">      <span class="hljs-number">8</span><br>    /  <span class="hljs-string">\</span><br>   -<span class="hljs-number">3</span>   <span class="hljs-number">7</span><br> /    <span class="hljs-string">\</span><br><span class="hljs-number">1</span>      <span class="hljs-number">4</span><br> <span class="hljs-string">\</span>    / <span class="hljs-string">\</span>    <br>  <span class="hljs-number">3</span>  <span class="hljs-number">2</span>   <span class="hljs-number">6</span><br><br>考虑左子树 -<span class="hljs-number">3</span> 的路径的时候，我们有左子树 <span class="hljs-number">1</span> 和右子树 <span class="hljs-number">4</span> 的选择，但我们不能同时选择<br>如果同时选了，路径就是 ... -&gt; <span class="hljs-number">1</span> -&gt; -<span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; ... 就无法通过根节点 <span class="hljs-number">8</span> 了<br>所以我们只能去求左子树能返回的最大值，右子树能返回的最大值，选一个较大的<br></code></pre></td></tr></table></figure>

<p>假设我们只考虑通过根节点 <code>8</code> 的最大路径是多少，那么代码就可以写出来了。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs qml">public <span class="hljs-built_in">int</span> maxPathSum(TreeNode root) &#123;<br>    <span class="hljs-comment">//如果最大值是负数，我们选择不选</span><br>    <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">Math</span>.max(helper(root.left), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">Math</span>.max(helper(root.right), <span class="hljs-number">0</span>); <br>    <span class="hljs-keyword">return</span> root.val + left + right;<br>&#125;<br><br><span class="hljs-built_in">int</span> helper(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <span class="hljs-built_in">int</span> left = <span class="hljs-built_in">Math</span>.max(helper(root.left), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">int</span> right = <span class="hljs-built_in">Math</span>.max(helper(root.right), <span class="hljs-number">0</span>);  <br>    <span class="hljs-comment">//选择左子树和右子树产生的值较大的一个</span><br>    <span class="hljs-keyword">return</span> root.val + <span class="hljs-built_in">Math</span>.max(left, right);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>现在我们只考虑了包含最初根节点 <code>8</code> 的路径。那如果不包含当前根节点，而是其他的路径呢？</p>
<p>可以发现在 <code>helper</code> 函数中，我们每次都求了当前给定的节点的左子树和右子树的最大值，和我们 <code>maxPathSum</code> 函数的逻辑是一样的。所以我们利用一个全局变量，在考虑 <code>helper</code> 函数中当前 <code>root</code> 的时候，同时去判断一下包含当前 <code>root</code> 的路径的最大值。</p>
<p>这样在递归过程中就考虑了所有包含当前节点的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxpath=INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> maxpath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//计算左边分支最大值，左边分支如果为负数还不如不选择</span><br>        <span class="hljs-type">int</span> leftmax=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;left));<br>        <span class="hljs-comment">//计算右边分支最大值，右边分支如果为负数还不如不选择</span><br>        <span class="hljs-type">int</span> rightmax=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,<span class="hljs-built_in">dfs</span>(root-&gt;right));<br>        <span class="hljs-comment">//求的过程中考虑包含当前根节点的最大路径，left-&gt;root-&gt;right 作为路径与历史最大值做比较</span><br>        maxpath=<span class="hljs-built_in">max</span>(maxpath,root-&gt;val+leftmax+rightmax);<br>        <span class="hljs-comment">// 返回经过root的单边最大分支给上游，即只返回包含当前根节点和左子树或者右子树的路径</span><br>        <span class="hljs-keyword">return</span> root-&gt;val+<span class="hljs-built_in">max</span>(leftmax,rightmax);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是二叉树中的节点个数。对每个节点访问不超过 2 次。</li>
<li>空间复杂度：O(N)，其中 N 是二叉树中的节点个数。空间复杂度主要取决于递归调用层数，最大层数等于二叉树的高度，最坏情况下，二叉树的高度等于二叉树中的节点个数。</li>
</ul>
<h1 id="543-二叉树的直径-easy"><a href="#543-二叉树的直径-easy" class="headerlink" title="543. 二叉树的直径[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a>[easy]</h1><h2 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<p><strong>示例 :</strong><br>给定二叉树</p>
<div class="code-wrapper"><pre><code class="hljs">      1
     / \
    2   3
   / \     
  4   5    
</code></pre></div>
<p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>
<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>
<h2 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h2><p>思想与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 相似。</p>
<blockquote>
<p>一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p>
</blockquote>
<p>任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200807100242.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>如图可以知道路径 [9, 4, 2, 5, 7, 8] 可以被看作以 2 为起点，从其左儿子向下遍历的路径 [2, 4, 9] 和从其右儿子向下遍历的路径 [2, 5, 7, 8] 拼接得到。</p>
<p>假设我们知道对于该节点的左儿子向下遍历经过最多的节点数 L （即以左儿子为根的子树的深度） 和其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度），那么以该节点为起点的路径经过节点数的最大值即为 L+R+1 。</p>
<p>记节点 node 为起点的路径经过节点数的最大值为 max ，那么二叉树的直径就是所有节点 max 的最大值减一。</p>
<p>最后的算法流程为：定义一个递归函数 depth(node) 计算 max，函数返回该节点为根的子树的深度。先递归调用左儿子和右儿子求得它们为根的子树的深度 L 和 R ，则该节点为根的子树的深度即为 max(L,R)+1，该节点的 max 值为 L+R+1，递归搜索每个节点并设一个全局变量 res 记录 max的最大值，最后返回 <code>res-1</code> 即为树的直径。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        res=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">depth</span>(root);<br>        <span class="hljs-comment">// 边数 = 结点数 - 1</span><br>        <span class="hljs-keyword">return</span> res<span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> res;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">depth</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 左子树高度</span><br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">depth</span>(root-&gt;left);<br>        <span class="hljs-comment">// 右子树高度</span><br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">depth</span>(root-&gt;right);<br>        res=<span class="hljs-built_in">max</span>(res,left+right+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li>
<li>空间复杂度：O(Height)，其中 Height 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 O(Height) 。</li>
</ul>
<h1 id="687-最长同值路径-easy"><a href="#687-最长同值路径-easy" class="headerlink" title="687. 最长同值路径[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-univalue-path/">687. 最长同值路径</a>[easy]</h1><h2 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>              <span class="hljs-number">5</span><br>             / <span class="hljs-string">\</span><br>            <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>           / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>          <span class="hljs-number">1</span>   <span class="hljs-number">1</span>   <span class="hljs-number">5</span><br><br>输出:<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>              <span class="hljs-number">1</span><br>             / <span class="hljs-string">\</span><br>            <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br>           / <span class="hljs-string">\</span>   <span class="hljs-string">\</span><br>          <span class="hljs-number">4</span>   <span class="hljs-number">4</span>   <span class="hljs-number">5</span><br><br>输出:<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><strong>注意:</strong> 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p>
<h2 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h2><p>思想与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a>、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a> 相似。</p>
<p>可以将任何路径（具有相同值的节点）看作是最多两个从其根延伸出的箭头。</p>
<p>最长的路径可能有三种情况：</p>
<ul>
<li>在左子树内部。</li>
<li>在右子树内部。</li>
<li>在穿过左子树，根节点，右子树的一条路径中。</li>
</ul>
<p>设计一个递归函数，返回以该节点为根节点，向下走的最长同值路径，知道这个值以后，以某个节点为根节点的最长同值路径就是</p>
<ul>
<li>如果该节点的值等于其左子树的值，则最长同值路径为左子树的最长同值路径+1，如果不等，左子树的路径为 0。</li>
<li>如果该节点的值等于其右子树的值，则最长同值路径为右子树的最长同值路径+1，如果不等，右子树的路径为 0。</li>
<li>返回上述两种情况的最大值。</li>
</ul>
<p>当我们计算箭头长度时，候选答案将是该节点在两个方向上的箭头之和。用一个全局变量记录这个最大值，不断更新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">arrowLength</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">arrowLength</span><span class="hljs-params">(TreeNode* node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left=<span class="hljs-built_in">arrowLength</span>(node-&gt;left);<br>        <span class="hljs-type">int</span> right=<span class="hljs-built_in">arrowLength</span>(node-&gt;right);<br>        <span class="hljs-type">int</span> arrowleft=<span class="hljs-number">0</span>,arrowright=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;left!=<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;left-&gt;val==node-&gt;val)<br>            arrowleft=left+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(node-&gt;right!=<span class="hljs-literal">nullptr</span>&amp;&amp;node-&gt;right-&gt;val==node-&gt;val)<br>            arrowright=right+<span class="hljs-number">1</span>;<br>        res=<span class="hljs-built_in">max</span>(res,arrowleft+arrowright);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(arrowleft,arrowright);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N 是树中节点数。处理每个节点一次。</li>
<li>空间复杂度：O(H)，其中 H 是树的高度。递归调用栈可以达到 H 层的深度。</li>
</ul>
<h1 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>[medium]</h1><h2 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">前序遍历 preorder = <span class="hljs-string">[3,9,20,15,7]</span><br>中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br></code></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>给定二叉树前序遍历序列和中序遍历序列，可以唯一确定一颗二叉树。其中的规律为，<strong>前序遍历序列的第一个元素为二叉树的根结点，在中序遍历序列中，根结点左边的元素为左子树的结点，右边的元素为右子树上的结点</strong>。</p>
</blockquote>
<h3 id="解法一：递归-11"><a href="#解法一：递归-11" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。所以只需要根据先序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs inform7">preorder = <span class="hljs-comment">[3,9,20,15,7]</span><br>inorder = <span class="hljs-comment">[9,3,15,20,7]</span><br>首先根据 preorder 找到根节点是 3<br><br>然后根据根节点将 inorder 分成左子树和右子树<br>左子树<br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>把相应的前序遍历的数组也加进来<br>左子树<br>preorder<span class="hljs-comment">[9]</span> <br>inorder <span class="hljs-comment">[9]</span><br><br>右子树<br>preorder<span class="hljs-comment">[20 15 7]</span> <br>inorder <span class="hljs-comment">[15,20,7]</span><br><br>现在我们只需要构造左子树和右子树即可，成功把大问题化成了小问题<br>然后重复上边的步骤继续划分，直到 preorder 和 inorder 都为空，返回 null 即可<br></code></pre></td></tr></table></figure>

<p>事实上，不需要真的把 <code>preorder</code> 和 <code>inorder</code> 切分了，只需要分别用两个指针指向开头和结束位置即可。下边的两个指针指向的数组范围是包括左边界，不包括右边界，即左闭右开。</p>
<p>对于下边的树的合成。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141626.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>左子树</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141648.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>右子树</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200809141713.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>(),inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// preorder 为空，直接返回 null</span><br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=preorder[p_start];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-comment">//在中序遍历中找到根节点的位置</span><br>        <span class="hljs-type">int</span> i_root_index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=i_start;i&lt;i_end;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(inorder[i]==root_val)<br>            &#123;<br>                i_root_index=i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>         <span class="hljs-comment">//递归的构造左子树</span><br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>,p_start+<span class="hljs-number">1</span>+leftNum,inorder,i_start,i_root_index);<br>        <span class="hljs-comment">//递归的构造右子树</span><br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>+leftNum,p_end,inorder,i_root_index+<span class="hljs-number">1</span>,i_end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>上边的代码存在一个问题，在中序遍历中找到根节点的位置每次都得遍历中序遍历的数组去寻找。我们可以用一个<code>HashMap</code>把中序遍历数组的每个元素的值和下标存起来，这样在此后构造二叉树的过程中，就只需要 O(1) 的时间对根节点进行定位了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();++i)<br>            valueIndex[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>(),inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; valueIndex;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=preorder[p_start];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-type">int</span> i_root_index=valueIndex[root_val];<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>,p_start+<span class="hljs-number">1</span>+leftNum,inorder,i_start,i_root_index);<br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(preorder,p_start+<span class="hljs-number">1</span>+leftNum,p_end,inorder,i_root_index+<span class="hljs-number">1</span>,i_end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li>
<li>空间复杂度：O(n)，需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</li>
</ul>
<h3 id="解法二：迭代-6"><a href="#解法二：迭代-6" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p><strong>思路：</strong></p>
<p>迭代法是一种非常巧妙的实现方法。</p>
<p>对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p>
<ul>
<li>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；</li>
<li>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 u_a，那么 v 就是 u_a 的右儿子。</li>
</ul>
<p>第二种关系看上去有些复杂。举一个例子来说明其正确性，并在例子中给出迭代算法。</p>
<p><strong>例子：</strong></p>
<p>以树</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">        3<br>       / \<br>     <span class="hljs-number"> 9 </span> 20<br>     /  /  \<br>   <span class="hljs-number"> 8 </span><span class="hljs-number"> 15 </span>  7<br>   / \<br> <span class="hljs-number"> 5 </span> 10<br> /<br>4<br></code></pre></td></tr></table></figure>

<p>为例，它的前序遍历和中序遍历分别为</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">preorder</span> = [<span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">7</span>]<br><span class="hljs-attr">inorder</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure>

<p>我们用一个栈  <code>stack</code>  来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针  <code>index</code> 指向中序遍历的某个位置，初始值为 <code>0</code>。<code>index</code>  对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点 <code>3</code> 入栈，再初始化 <code>index</code> 所指向的节点为 <code>4</code>，随后对于前序遍历中的每个节点，我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<ul>
<li><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code> 的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code> 的右儿子，那么 <code>3</code> 没有左儿子，index 应该恰好指向 <code>3</code>，但实际上为 <code>4</code> ，因此产生了矛盾。所以我们将 <code>9</code> 作为 <code>3</code>  的左儿子，并将 <code>9</code> 入栈。</p>
<ul>
<li><code>stack = [3, 9]</code> </li>
<li><code>index -&gt; inorder[0] = 4</code></li>
</ul>
</li>
<li><p>我们遍历 <code>8</code>，<code>5</code> 和 <code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p>
<ul>
<li><code>stack = [3, 9, 8, 5, 4]</code> </li>
<li><code>index -&gt; inorder[0] = 4</code></li>
</ul>
</li>
<li><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现 <code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说 <code>4</code> 没有左儿子，那么 <code>10</code> 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，<strong>那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的</strong>。</p>
<blockquote>
<p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p>
</blockquote>
<p>因此我们可以把 <code>index</code> 不断向右移动，并与栈顶节点进行比较。如果 <code>index</code> 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 <code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到 <code>index</code> 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 <code>x</code> 就是 <code>10</code> 的双亲节点，<strong>这是因为 <code>10</code> 出现在了 <code>x</code> 与 <code>x</code> 在栈中的下一个节点的中序遍历之间</strong>，因此 <code>10</code> 就是 <code>x</code> 的右儿子。</p>
<p>回到我们的例子，我们会依次从栈顶弹出 <code>4</code>，<code>5</code> 和 <code>8</code>，并且将 <code>index</code> 向右移动了三次。我们将 <code>10</code> 作为最后弹出的节点 <code>8</code> 的右儿子，并将 <code>10</code>入栈。</p>
<ul>
<li><code>stack = [3, 9, 10]</code> </li>
<li><code>index -&gt; inorder[3] = 10</code></li>
</ul>
</li>
<li><p>我们遍历 <code>20</code>。同理，<code>index</code> 恰好指向当前栈顶节点 <code>10</code>，那么我们会依次从栈顶弹出 <code>10</code>，<code>9</code> 和 <code>3</code>，并且将 <code>index</code> 向右移动了三次。我们将 <code>20</code> 作为最后弹出的节点 <code>3</code> 的右儿子，并将 <code>20</code> 入栈。</p>
<ul>
<li><code>stack = [20]</code> </li>
<li><code>index -&gt; inorder[6] = 15</code></li>
</ul>
</li>
<li><p>我们遍历 <code>15</code>，将 <code>15</code> 作为栈顶节点 <code>20</code> 的左儿子，并将 <code>15</code> 入栈。</p>
<ul>
<li><code>stack = [20, 15]</code> </li>
<li><code>index -&gt; inorder[6] = 15</code></li>
</ul>
</li>
<li><p>我们遍历 <code>7</code>。 <code>index</code> 恰好指向当前栈顶节点 <code>15</code>，那么我们会依次从栈顶弹出 <code>15</code> 和 <code>20</code>，并且将 <code>index</code> 向右移动了两次。我们将 <code>7</code> 作为最后弹出的节点 <code>20</code> 的右儿子，并将 <code>7</code> 入栈。</p>
<ul>
<li><code>stack = [7]</code> </li>
<li><code>index -&gt; inorder[8] = 7</code></li>
</ul>
</li>
</ul>
<p>此时遍历结束，我们就构造出了正确的二叉树。</p>
<p><strong>算法：</strong></p>
<p>我们归纳出上述例子中的算法流程：</p>
<ul>
<li>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</li>
<li>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</li>
<li>无论是哪一种情况，我们最后都将当前的节点入栈。</li>
</ul>
<p>最后得到的二叉树即为答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stack&lt;TreeNode*&gt; preStack;<br>        preStack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;preorder.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> preorderVal=preorder[i];<br>            TreeNode* node=preStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val!=inorder[inorderIndex])<br>            &#123;<br>                node-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                preStack.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">while</span>(!preStack.<span class="hljs-built_in">empty</span>()&amp;&amp;preStack.<span class="hljs-built_in">top</span>()-&gt;val==inorder[inorderIndex])<br>                &#123;<br>                    node=preStack.<span class="hljs-built_in">top</span>();<br>                    preStack.<span class="hljs-built_in">pop</span>();<br>                    ++inorderIndex;<br>                &#125;<br>                node-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorderVal);<br>                preStack.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li>
<li>空间复杂度：O(n)，需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</li>
</ul>
<h1 id="106-从中序与后序遍历序列构造二叉树-medium"><a href="#106-从中序与后序遍历序列构造二叉树-medium" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>[medium]</h1><h2 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br>后序遍历 postorder = <span class="hljs-string">[9,15,7,20,3]</span><br></code></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<h2 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h2><p>与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a> 思路基本一致。105 题给的是先序遍历和中序遍历，这里把先序遍历换成后序遍历。</p>
<h3 id="解法一：递归-12"><a href="#解法一：递归-12" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>先序遍历的顺序为<strong>根-左-右</strong>，后序遍历的顺序为<strong>左-右-根</strong>，因此与 105 题利用先序遍历第一个节点为根节点不同的是，后序遍历的最后一个节点为根节点。还是先确定根节点，然后在中序遍历中找根节点的位置，然后分出左子树和右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();++i)<br>            valueIndex[inorder[i]]=i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>(),postorder,<span class="hljs-number">0</span>,postorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; valueIndex;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> i_start,<span class="hljs-type">int</span> i_end,vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder,<span class="hljs-type">int</span> p_start,<span class="hljs-type">int</span> p_end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(p_start==p_end)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> root_val=postorder[p_end<span class="hljs-number">-1</span>];<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root_val);<br>        <span class="hljs-type">int</span> i_root_index=valueIndex[root-&gt;val];<br>        <span class="hljs-type">int</span> leftNum=i_root_index-i_start;<br>        root-&gt;left=<span class="hljs-built_in">buildTree</span>(inorder,i_start,i_root_index,postorder,p_start,p_start+leftNum);<br>        root-&gt;right=<span class="hljs-built_in">buildTree</span>(inorder,i_root_index+<span class="hljs-number">1</span>,i_end,postorder,p_start+leftNum,p_end<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li>
<li>空间复杂度：O(n)，需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h&lt;n，所以总空间复杂度为 O(n)。</li>
</ul>
<h3 id="解法二：迭代-7"><a href="#解法二：迭代-7" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>105 题是通过前序遍历的数组实现的，所以构造过程是根节点，左子树，右子树。但这里是后序遍历，先找根节点，所以相当于从右往左遍历，这样顺序变成了<strong>根-右-左</strong>，会先生成右子树，再生成左子树，相应的中序遍历的指针 <code>index</code> 也要从右往左移动。之前解法是构造左子树、左子树、左子树，出现相等，构造一颗右子树。这里相应的要改成构造右子树、右子树、右子树，出现相等，构造一颗左子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(postorder.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> postSize=postorder.<span class="hljs-built_in">size</span>();<br>        TreeNode* root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[postSize<span class="hljs-number">-1</span>]);<br>        stack&lt;TreeNode*&gt; postStack;<br>        postStack.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> inorderIndex=inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=postSize<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-type">int</span> postorderVal=postorder[i];<br>            TreeNode* node=postStack.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val!=inorder[inorderIndex])<br>            &#123;<br>                node-&gt;right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorderVal);<br>                postStack.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">while</span>(!postStack.<span class="hljs-built_in">empty</span>()&amp;&amp;postStack.<span class="hljs-built_in">top</span>()-&gt;val==inorder[inorderIndex])<br>                &#123;<br>                    node=postStack.<span class="hljs-built_in">top</span>();<br>                    postStack.<span class="hljs-built_in">pop</span>();<br>                    --inorderIndex;<br>                &#125;<br>                node-&gt;left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorderVal);<br>                postStack.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li>
<li>空间复杂度：O(n)，需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h&lt;n，所以（在最坏情况下）总空间复杂度为 O(n)。</li>
</ul>
<h1 id="337-打家劫舍-III-medium"><a href="#337-打家劫舍-III-medium" class="headerlink" title="337. 打家劫舍 III[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/">337. 打家劫舍 III</a>[medium]</h1><h2 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h2><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [3,2,3,null,3,null,1]<br><br>     3<br>    / \<br>  <span class="hljs-number"> 2 </span>  3<br>    \   \ <br>    <span class="hljs-number"> 3 </span>  1<br><br>输出:<span class="hljs-number"> 7 </span><br>解释: 小偷一晚能够盗取的最高金额 =<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>= 7.<br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [3,4,5,1,3,null,1]<br><br>     3<br>    / \<br>  <span class="hljs-number"> 4 </span>  5<br>  / \   \ <br><span class="hljs-number"> 1 </span> <span class="hljs-number"> 3 </span>  1<br><br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 =<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>= 9.<br></code></pre></td></tr></table></figure>

<h2 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>树形 DP 问题。从暴力递归到动态规划。</p>
</blockquote>
<h3 id="解法一：暴力递归-最优子结构"><a href="#解法一：暴力递归-最优子结构" class="headerlink" title="解法一：暴力递归-最优子结构"></a>解法一：暴力递归-最优子结构</h3><p>在解法一和解法二中，使用爷爷、两个孩子、4 个孙子来说明问题。首先来定义这个问题的状态，爷爷节点则么获取到最大的偷取的钱数呢？</p>
<ul>
<li>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷。</li>
<li>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子。</li>
</ul>
<p>根据以上条件，可以得出单个节点的钱该怎么算，即 <strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构。</strong>由于是二叉树，这里可以选择计算所有子节点。</p>
<p>4 个孙子投的钱加上爷爷的钱如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">int</span> method1 = root.val + rob(root.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">left</span>) + rob(root.<span class="hljs-keyword">left</span>.<span class="hljs-keyword">right</span>) + rob(root.<span class="hljs-keyword">right</span>.<span class="hljs-keyword">left</span>) + rob(root.<span class="hljs-keyword">right</span>.<span class="hljs-keyword">right</span>)<br></code></pre></td></tr></table></figure>

<p>两个儿子偷的钱如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">int method2 = rob(root.<span class="hljs-built_in">left</span>) + rob(root.<span class="hljs-built_in">right</span>);<br></code></pre></td></tr></table></figure>

<p>挑选一个钱数多的方案则：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> <span class="hljs-keyword">result</span> <span class="hljs-operator">=</span> Math.<span class="hljs-built_in">max</span>(method1, method2);<br></code></pre></td></tr></table></figure>

<p>使用 C++超时，Java 不超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> money=root.val;<br>        <span class="hljs-keyword">if</span>(root.left!=<span class="hljs-literal">null</span>)<br>            money+=rob(root.left.left)+rob(root.left.right);<br>        <span class="hljs-keyword">if</span>(root.right!=<span class="hljs-literal">null</span>)<br>            money+=rob(root.right.left)+rob(root.right.right);<br>        <span class="hljs-keyword">return</span> Math.max(money,rob(root.left)+rob(root.right));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：记忆化-解决重复子问题"><a href="#解法二：记忆化-解决重复子问题" class="headerlink" title="解法二：记忆化 - 解决重复子问题"></a>解法二：记忆化 - 解决重复子问题</h3><p>针对解法一速度太慢的问题，经过分析其实现，发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>
<p><strong>重复子问题：</strong></p>
<p>这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。由于二叉树不适合拿数组当缓存，这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; memo;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rob</span>(root,memo);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root,unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt;&amp; memo)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(memo.<span class="hljs-built_in">count</span>(root)!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> memo[root];<br>        <span class="hljs-type">int</span> money=root-&gt;val;<br>        <span class="hljs-keyword">if</span>(root-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            money+=<span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right,memo);<br>        <span class="hljs-keyword">if</span>(root-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>            money+=<span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right,memo);<br>        <span class="hljs-type">int</span> result=<span class="hljs-built_in">max</span>(money,<span class="hljs-built_in">rob</span>(root-&gt;left,memo)+<span class="hljs-built_in">rob</span>(root-&gt;right,memo));<br>        memo[root]=result;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：树形DP"><a href="#解法三：树形DP" class="headerlink" title="解法三：树形DP"></a>解法三：树形DP</h3><p>换一种办法来定义此问题，每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷：</p>
<ul>
<li>当前节点选择偷时，那么两个孩子节点就不能选择偷了。</li>
<li>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)。</li>
</ul>
<p>使用一个大小为 2 的数组来表示 int[] res &#x3D; new int[2] ，0 代表不偷，1 代表偷。<br>任何一个节点能偷到的最大钱的状态可以定义为：</p>
<ul>
<li>当前节点选择不偷：当前节点能偷到的最大钱数 &#x3D; 左孩子能偷到的钱 + 右孩子能偷到的钱</li>
<li>当前节点选择偷：当前节点能偷到的最大钱数 &#x3D; 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>
</ul>
<p>表示为公式如下：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">res[<span class="hljs-number">0</span>] = Math<span class="hljs-built_in">.max</span>(rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">0</span>], rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">1</span>]) + Math<span class="hljs-built_in">.max</span>(rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">0</span>], rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">1</span>])<br>res[<span class="hljs-number">1</span>] = rob<span class="hljs-built_in">(root</span>.left)[<span class="hljs-number">0</span>] + rob<span class="hljs-built_in">(root</span>.right)[<span class="hljs-number">0</span>] +<span class="hljs-built_in"> root</span>.val;<br></code></pre></td></tr></table></figure>

<p>用两个 hashmap 来保存结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(unselected[root],selected[root]);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; unselected;<br>    unordered_map&lt;TreeNode*,<span class="hljs-type">int</span>&gt; selected;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        unselected[root]=<span class="hljs-built_in">max</span>(unselected[root-&gt;left],selected[root-&gt;left])+<span class="hljs-built_in">max</span>(unselected[root-&gt;right],selected[root-&gt;right]);<br>        selected[root]=unselected[root-&gt;left]+unselected[root-&gt;right]+root-&gt;val;     <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法四：降维优化空间复杂度"><a href="#解法四：降维优化空间复杂度" class="headerlink" title="解法四：降维优化空间复杂度"></a>解法四：降维优化空间复杂度</h3><p>观察上面发现，左右子树的两个状态影响当前子树的两个状态，但别的子树的状态影响不了。因此没必要用 hashmap 记录每一个子树的状态，递归总是子调用的解返回给父调用，所以只需在每次递归中用两个变量，存当前子问题的两个状态，返回出来给父调用即可。用一个 pair 来返回，分别存放不偷和偷两种状态，即 res[0]，res[1]。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; money=<span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(money.first,money.second);<br>    &#125;<br><br>    <span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; money;<br>        <span class="hljs-keyword">auto</span> left=<span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right=<span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        money.first=<span class="hljs-built_in">max</span>(left.first,left.second)+<span class="hljs-built_in">max</span>(right.first,right.second);<br>        money.second=left.first+right.first+root-&gt;val;<br>        <span class="hljs-keyword">return</span> money;      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Tree/">Tree</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/08/11/Leetcode%20Notes%E2%80%94%E2%80%94BST/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——BST</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/">
                        <span class="hidden-mobile">剑指offer题解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
