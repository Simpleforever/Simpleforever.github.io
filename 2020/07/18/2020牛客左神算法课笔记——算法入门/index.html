

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己在学习左神算法课时的笔记，部分内容转载自 loveforever 博客。">
<meta property="og:type" content="article">
<meta property="og:title" content="2020牛客左神算法课笔记——算法入门">
<meta property="og:url" content="https://simpleforever.github.io/2020/07/18/2020%E7%89%9B%E5%AE%A2%E5%B7%A6%E7%A5%9E%E7%AE%97%E6%B3%95%E8%AF%BE%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己在学习左神算法课时的笔记，部分内容转载自 loveforever 博客。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145522.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725150132.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145556.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145625.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725144917.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145656.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae11912cf6">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae138de589">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145122.png">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/19/169045ae2427ea5e?w=784&h=340&f=jpeg&s=131998">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210118133820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095806.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724102716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724104322.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141346.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141353.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141402.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141409.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815140644.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815142439.png">
<meta property="og:image" content="https://github.com/chenBright/leetcode/raw/master/155-%E6%9C%80%E5%B0%8F%E6%A0%88/MinStack2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200728123002.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094958.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808122511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141900.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103725.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103730.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103736.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141429.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141435.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141443.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141454.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141502.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102118.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102221702.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145756.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141518">
<meta property="article:published_time" content="2020-07-17T16:00:00.000Z">
<meta property="article:modified_time" content="2021-01-18T05:38:31.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="数据结构与算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145522.jpeg">
  
  
  <title>2020牛客左神算法课笔记——算法入门 - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="2020牛客左神算法课笔记——算法入门">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-07-18 00:00" pubdate>
        2020年7月18日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      80k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      668 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">2020牛客左神算法课笔记——算法入门</h1>
            
            <div class="markdown-body">
              <p>记录一下自己在学习左神算法课时的笔记，部分内容转载自 <a target="_blank" rel="noopener" href="https://zhenganwen.top/posts/d162ff6c/">loveforever</a> 博客。 </p>
<span id="more"></span>

<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p><strong>常数时间的操作</strong>：一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</p>
<p>时间复杂度为一个算法流程中，常数操作数量的一个指标，是衡量算法好坏的重要指标之一。常用O(读作big O)来表示。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为<code>O(n)</code>），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于<strong>常数</strong>时间内的操作（对应时间复杂度<code>O(1)</code>）。</p>
<p>时间复杂度表达式化简原则：</p>
<ul>
<li>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如<code>O(n^2)+O(n)</code>可化简为<code>O(n^2)</code>，<code>O(n)+O(1)</code>可化简为<code>O(n)</code>。</li>
<li>可省去样本量前的常量系数，如<code>O(2n)</code>可化简为<code>O(n)</code>，<code>O(8)</code>可化简为<code>O(1)</code>。</li>
<li>对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如<code>O(logm)+O(n^2)</code>不能化简为<code>O(n^2)</code>或<code>O(logm)</code>。而要视m、n两者之间的差距来化简，比如m&gt;&gt;n时可以化简为<code>O(logm)</code>，因为表达式增量是由样本量决定的。</li>
</ul>
<p>评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”。</p>
<h1 id="额外空间复杂度"><a href="#额外空间复杂度" class="headerlink" title="额外空间复杂度"></a>额外空间复杂度</h1><p>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量<code>temp</code>，那么该算法的额外空间复杂度为<code>O(1)</code>。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为<code>O(n)</code>。</p>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="交换操作swap"><a href="#交换操作swap" class="headerlink" title="交换操作swap"></a>交换操作swap</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交换arr的i和j位置上的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>	arr[i] = arr[j];<br>	arr[j] = tmp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>以升序排序为例：找到 n 个数中最小数的下标<code>minIndex</code>，将其与第一个数（数组下标为 0 ）交换。接着对剩下的 n-1 个数，即子序列（1-n）重复该操作，直到子序列只含一个元素为止。(即选出最小的数放到第一个位置，该数安排好了，再对剩下的数选出最小的放到第二个位置，以此类推）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145522.jpeg" srcset="/img/loading.gif" lazyload  />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span><br>			minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<br>		&#125;<br>		swap(arr, i, minIndex);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>算法的时间复杂度（big o）为<code>O(n^2)</code>（n-1+n-2+n-3+…+1）</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725150132.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; e &gt; <span class="hljs-number">0</span>; e--) &#123; <span class="hljs-comment">// 0 ~ e</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; e; i++) &#123;<br>			<span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>]) &#123;<br>				swap(arr, i, i + <span class="hljs-number">1</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该算法的时间复杂度为<code>n+(n-1)+...+1</code>，很明显是一个等差数列，由（首项+末项）*项数&#x2F;2求其和为<code>(n+1)n/2</code>，可知时间复杂度为<code>O(n^2)</code>。</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序的过程可以联想到打扑克时揭一张牌然后将其到手中有序纸牌的合适位置上。比如我现在手上的牌是7、8、9、J、Q、K，这时揭了一张10，我需要将其依次与K、Q、J、9、8、7比较，当比到9时发现大于9，于是将其插入到9之后。对于一个无序序列，可以将其当做一摞待揭的牌，首先将首元素揭起来，因为揭之前手上无牌，因此此次揭牌无需比较，此后每揭一次牌都需要进行上述的插牌过程，当揭完之后，手上的握牌顺序就对应着该序列的有序形式。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145556.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-comment">// 0~0 有序的</span><br>	<span class="hljs-comment">// 0~i 想有序</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// 0 ~ i 做到有序</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="hljs-number">1</span>]; j--) &#123;<br>			swap(arr, j, j + <span class="hljs-number">1</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入排序的big o该如何计算？可以发现如果序列有序，那么该算法的big o为<code>O(n)</code>，因为只是遍历了一次序列（这是最好情况）；如果序列降序排列，那么该算法的big o为<code>O(n^2)</code>（每次插入前的比较交换加起来要：1+2+…+n-1）（最坏情况）。<strong>一般应用场景中都是按算法的最坏情况来考量算法的效率的，因为你做出来的应用要能够承受最坏情况。</strong>即该算法的big o为<code>O(n^2)</code>。</p>
<h3 id="归并排序及其扩展"><a href="#归并排序及其扩展" class="headerlink" title="归并排序及其扩展"></a>归并排序及其扩展</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序整体是一个简单递归，核心思想是先让序列的左半部分有序，再让序列的右半部分有序，最后让其整体有序。先对左右两部分分别递归执行归并排序，直到某次递归时左右两半部分均为一个元素时递归终止。让其整体有序的过程里使用了<strong>外排</strong>的方式，即用两个指针分别指向两个子序列（左右两半）的头，再依次进行比较，往辅助数组中填入较小的数。</p>
<p>以序列<code>&#123;2,1,4,3&#125;</code>为例，归并排序的过程大致如下：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145625.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	process(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>	<span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">if</span> (L == R) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>    <span class="hljs-comment">//(L+R)/2可能会溢出</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>	process(arr, L, mid);<span class="hljs-comment">//让其左半部分有序</span><br>	process(arr, mid + <span class="hljs-number">1</span>, R);<span class="hljs-comment">//让其右半部分有序</span><br>	merge(arr, L, mid, R);<span class="hljs-comment">//外排方式使其整体有序</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> R)</span> &#123;<br>	<span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//辅助数组指针</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> L;<span class="hljs-comment">//左指针</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> M + <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span><br>	<span class="hljs-keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;<br>    <span class="hljs-comment">//当左指针所指的数=右指针所指的数时，先填左边的</span><br>		help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];<br>	&#125;<br>    <span class="hljs-comment">//以下两个while只会发生一个</span><br>	<span class="hljs-keyword">while</span> (p1 &lt;= M) &#123;<br>		help[i++] = arr[p1++];<br>	&#125;<br>	<span class="hljs-keyword">while</span> (p2 &lt;= R) &#123;<br>		help[i++] = arr[p2++];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>		arr[L + i] = help[i];<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当一个递归过程比较复杂时（不像递归求阶乘那样一幕了然），我们可以列举简短样本进行分析。</p>
<p>对于这样复杂的递归行为，千万不要想着追溯整个递归过程，只需分析第一步要做的事（比如此例中第一步要做的是就是<code>process</code>函数所呈现出来的那样：对左半部分排序、对右半部分排序、最后并入，你先不管是怎么排序的）和递归终止的条件（比如此例中是要排序的序列只有一个元素时）。</p>
<p>归并排序的时间复杂度是<code>O(nlogn)</code>，额外空间复杂度是<code>O(n)</code>。</p>
<p>根据<strong>Master公式</strong>（本文 <strong>小技巧</strong>一节中有讲到）可得<code>T(n)=2T(n/2)+O(n)</code>，第一个2的含义是子过程（对子序列进行归并排序）要执行两次，第二个2的含义是子过程样本量占一半（因为分成了左右两半部分），最后<code>O(n)</code>表示左右有序之后进行的并入操作为<code>O(n+n)=O(n)</code>(L、R指针移动次数总和为n，将辅助数组覆盖源数组为n)，符合<code>T(n)=aT(n/b)+O(n^d)</code>，经计算该算法的时间复杂度为<code>O(nlogn)</code>。</p>
<p>归并排序的实质：</p>
<blockquote>
<p><code>O(n^2)</code>的排序算法（即选择排序、冒泡排序等）之所以时间复杂度差的原因是其大量浪费了比较次数，每次只搞定了一个数。而归并排序快的原因是其比较行为变成了整体有序的部分，再与下一部分进行 merge 。比较行为没被浪费，比较行为变成了共同有序的东西，传递了下去。</p>
</blockquote>
<h4 id="归并排序的扩展"><a href="#归并排序的扩展" class="headerlink" title="归并排序的扩展"></a>归并排序的扩展</h4><h5 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h5><p>在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">对于数组[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>]<br><span class="hljs-number">1</span>左边比<span class="hljs-number">1</span>小的数，没有；<br><span class="hljs-number">3</span>左边比<span class="hljs-number">3</span>小的数，<span class="hljs-number">1</span>；<br><span class="hljs-number">4</span>左边比<span class="hljs-number">4</span>小的数，<span class="hljs-number">1</span>、<span class="hljs-number">3</span>；<br><span class="hljs-number">2</span>左边比<span class="hljs-number">2</span>小的数，<span class="hljs-number">1</span>；<br><span class="hljs-number">5</span>左边比<span class="hljs-number">5</span>小的数，<span class="hljs-number">1</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">2</span>；<br>所以小和为<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">1</span>+<span class="hljs-number">1</span>+<span class="hljs-number">3</span>+<span class="hljs-number">4</span>+<span class="hljs-number">2</span>=<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure>

<p>简单的做法就是遍历一遍数组，将当前遍历的数与该数之前数比较并记录小于该数的数。易知其时间复杂度为<code>O(n^2)</code>（0+1+2+……+n-1）。</p>
<p>更优化的做法是利用归并排序的<strong>并入逻辑</strong>，小和问题可理解为在外排过程中右边有多少个数比左指针指向的数大，在这个过程中产生小和。例如：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725144917.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>对应代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">smallSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> mergeSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// arr[L..R]既要排好序，也要求小和</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>	<span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">return</span> mergeSort(arr, l, mid) <span class="hljs-comment">//左半部分产生的小和</span><br>			+ mergeSort(arr, mid + <span class="hljs-number">1</span>, r) <span class="hljs-comment">//右半部分产生的小和</span><br>			+ merge(arr, l, mid, r);<span class="hljs-comment">//外排产生的小和</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span> &#123;<br>	<span class="hljs-type">int</span>[] help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[r - l + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//辅助数组指针</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> l;<span class="hljs-comment">//左指针</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> m + <span class="hljs-number">1</span>;<span class="hljs-comment">//右指针</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;<br>	<span class="hljs-comment">//当左指针所指的数=右指针所指的数时，先填右边的（与归并排序不同），不然没法知道右边有多少个数比左边大，所以此处为&lt;而不是&lt;=。</span><br>    <span class="hljs-comment">//小和的产生即右边有多少个数比左指针所指的数大，左指针所指的数*右边比它大的个数</span><br>        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="hljs-number">1</span>) * arr[p1] : <span class="hljs-number">0</span>;<br>		help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];<br>	&#125;<br>	<span class="hljs-keyword">while</span> (p1 &lt;= m) &#123;<br>		help[i++] = arr[p1++];<br>	&#125;<br>	<span class="hljs-keyword">while</span> (p2 &lt;= r) &#123;<br>		help[i++] = arr[p2++];<br>	&#125;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; help.length; i++) &#123;<br>		arr[l + i] = help[i];<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该算法在归并排序的基础上做了略微改动，即<code>merge</code>中添加了变量<code>res</code>记录每次<strong>并入</strong>操作应该累加的小和、<code>mergeSort</code>则将每次并入应该累加的小和汇总。此种做法的复杂度与归并排序的相同，优于遍历的做法。可以理解，依次求每个数的小和过程中有很多比较是重复的，而利用归并排序求小和时利用了并入的两个序列分别有序的特性省去了不必要的比较，如<code>134并入25</code>时，<code>2&gt;1</code>直接推出<code>2</code>后面的数都<code>&gt;1</code>。这在样本量不大的情况下看不出来优化的效果，试想一下如果样本量为<code>2^32</code>，那么依照前者求小和<code>O(n^2)</code>可知时间复杂度为<code>O(21亿的平方)</code>，而归并排序求小和则只需<code>O(21亿*32)</code>，足以见得<code>O(n^2)</code>和<code>O(nlogn)</code>的优劣。</p>
<h5 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h5><p>在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。</p>
<blockquote>
<p>这题的思路也可以利用归并排序来解决，在并入操作时记录<code>arr[L]&gt;arr[R]</code>的情况即可。</p>
</blockquote>
<h3 id="堆结构和堆排序"><a href="#堆结构和堆排序" class="headerlink" title="堆结构和堆排序"></a>堆结构和堆排序</h3><p>堆结构就是用<strong>数组</strong>实现的完全二叉树结构，是将一颗<strong>完全二叉树</strong>映射到数组中的一种存储方式：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725145656.jpeg" srcset="/img/loading.gif" lazyload></p>
<h4 id="大根堆和小根堆"><a href="#大根堆和小根堆" class="headerlink" title="大根堆和小根堆"></a>大根堆和小根堆</h4><p>完全二叉树中如果每棵子树的最大值都在顶部就是大根堆，如果每棵子树的最小值都在顶部就是小根堆。其中大根堆的应用较为广泛，是一种很重要的数据结构。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae11912cf6" srcset="/img/loading.gif" lazyload></p>
<h4 id="heapInsert-和-heapify"><a href="#heapInsert-和-heapify" class="headerlink" title="heapInsert 和 heapify"></a>heapInsert 和 heapify</h4><p>堆的主要操作可以理解为一个黑盒，即用户给你一些数据建立堆的过程和返回当前最大值的过程。</p>
<p>heapInsert：当一个元素加入到大根堆时应该自底向上与其父结点比较，若大于父结点则交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//index之前的序列符合大根堆，将index位置的元素加入堆结构，但不能破坏大根堆的特性，往上继续移动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br>	<span class="hljs-comment">//当该结点大于父结点时</span><br>    <span class="hljs-keyword">while</span> (arr[index] &gt; arr[(index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) &#123;<br>		swap(arr, index, (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>		index = (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">//继续向上比较</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>heapify：当堆中某个结点的数值发生变化时，应不断向下与其孩子结点中的最大值比较，若小于则交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 数组中下标从0到heapSize符合大根堆排序</span><br><span class="hljs-comment">// index位置的值发生了变化，重新调整堆结构为大根堆</span><br><span class="hljs-comment">// heapSize指的是数组中符合大根堆排序的范围而不是数组长度,最大为数组长度，最小为0 </span><br><span class="hljs-comment">// 某个数在index位置，能否往下移动</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapify</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> heapSize)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <span class="hljs-comment">// 左孩子的下标</span><br>	<span class="hljs-keyword">while</span> (left &lt; heapSize) &#123; <span class="hljs-comment">// 下方还有孩子的时候</span><br>		<span class="hljs-comment">// 两个孩子中，谁的值大，把下标给largest</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="hljs-number">1</span>] &gt; arr[left] ? left + <span class="hljs-number">1</span> : left;<br>		<span class="hljs-comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span><br>		largest = arr[largest] &gt; arr[index] ? largest : index;<br>		<span class="hljs-keyword">if</span> (largest == index) &#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		swap(arr, largest, index);<br>		index = largest;<br>		left = index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="数组的扩容代价"><a href="#数组的扩容代价" class="headerlink" title="数组的扩容代价"></a>数组的扩容代价</h4><p>在某一个时刻，当数组大小不够使用的时候，会存在一个扩容代价，即将源数组拷贝到新数组的过程。但是平摊下来，时间复杂度很低。扩容通常是成倍扩容的，即1，2，4…这种形式。当加入N个数时，扩容的次数为$log_2N$次，而每次扩容需要<code>O(n)</code>代价，总代价为$log_2N<em>O(N)$。平摊下来，每加入一个数为$log_2N</em>O(N)&#x2F;N$。即加入一个数时间复杂度仍为<code>O(logn)</code>。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序主要利用 heapInsert 和 heapify 两种操作，主要思想是先建立大根堆，让整个数组变成大根堆结构，然后将堆的最大值和堆末尾的值交换，减小堆的大小 heapSize 之后，再重新将剩下的调整为大根堆，一直周而复始。堆的大小减小成 0 之后，排序完成。在这个过程中，大根堆的根节点就是数组的最大值，可以直接放入堆尾，并将堆范围缩小（表示该元素排好序了）。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/169045ae138de589" srcset="/img/loading.gif" lazyload></p>
<p>建立大根堆的过程根据用户给数据的方式（一个一个给还是全部一起给）有两种方式，前者利用 heapInsert ，后者利用 heapify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>    <span class="hljs-comment">//建立堆的两种方式</span><br>    <span class="hljs-comment">// O(NlogN)复杂度</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123; <span class="hljs-comment">// O(N)</span><br>		heapInsert(arr, i); <span class="hljs-comment">// O(logN)</span><br>	&#125;<br>    <span class="hljs-comment">// O(N)复杂度</span><br>	<span class="hljs-comment">// for(int i = arr.length -1; i &gt;=0; i--) &#123;</span><br>	<span class="hljs-comment">// heapify(arr, i, arr.length);</span><br>	<span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//循环弹出堆顶元素并heapify</span><br>    <span class="hljs-comment">// O(NlogN)复杂度</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">heapSize</span> <span class="hljs-operator">=</span> arr.length;<br>	swap(arr, <span class="hljs-number">0</span>, --heapSize);<span class="hljs-comment">//相当于弹出堆顶元素</span><br>	<span class="hljs-keyword">while</span> (heapSize &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// O(N)</span><br>		heapify(arr, <span class="hljs-number">0</span>, heapSize); <span class="hljs-comment">// O(logN)</span><br>		swap(arr, <span class="hljs-number">0</span>, --heapSize); <span class="hljs-comment">// O(1)</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>堆排序的优势在于无论是入堆一个元素<code>heapInsert</code>还是出堆一个元素之后的<code>heapify</code>都不是将整个样本遍历一遍（<code>O(n)</code>级别的操作），而是树层次上的遍历（<code>O(logn)</code>级别的操作）。</p>
<p>这样的话堆排序过程中，建立堆的时间复杂度为<code>O(nlogn)</code>，循环弹出堆顶元素并<code>heapify</code>的时间复杂度为<code>O(nlogn)</code>，整个堆排序的时间复杂度为<code>O(nlogn)</code>，额外空间复杂度为<code>O(1)</code>。</p>
<blockquote>
<p>优先级队列结构（比如Java中的<code>PriorityQueue</code>）就是堆结构。</p>
</blockquote>
<h4 id="堆结构和堆排序扩展题目"><a href="#堆结构和堆排序扩展题目" class="headerlink" title="堆结构和堆排序扩展题目"></a>堆结构和堆排序扩展题目</h4><p>1）已知一个几乎有序的数组，几乎有序是指，如果把数组排好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortedArrDistanceLessK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>	<span class="hljs-comment">// 默认小根堆</span><br>	PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>	<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; index &lt;= Math.min(arr.length, k); index++)&#123;<br>		heap.add(arr[index]);<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (; index &lt; arr.length; i++, index++) &#123;<br>		heap.add(arr[index]);<br>		arr[i] = heap.poll();<br>	&#125;<br>	<span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>		arr[i++] = heap.poll();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）一个数据流中，随时可以取得中位数。</p>
<p>准备一个大根堆和一个小根堆，第一个数先进大根堆，之后进来的数 num 和大根堆堆顶的数 a 进行比较，如果 num&lt;&#x3D;a，则 num 进入大根堆，否则进入小根堆。然后检查大根堆和小根堆中数的数量的差值，如果差值为 2，则从较多数量的那个堆中拿出堆顶进入另一个堆。</p>
<p>按照上述规则进行后，较小的 2&#x2F;N 个数按照大根堆组织，较大的 2&#x2F;N 个数按照小根堆组织，即可利用两个堆的堆顶求出中位数。</p>
<ul>
<li>如果两个堆的 size 不一样，则 size 较大的堆顶即为中位数。</li>
<li>如果两个堆的 size 一样，则两个堆顶相加除以 2 即为中位数。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145122.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianHolder</span> &#123;<br>	<span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxHeapComparator</span>());<br>	<span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MinHeapComparator</span>());<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyTwoHeapsSize</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.maxHeap.size() == <span class="hljs-built_in">this</span>.minHeap.size() + <span class="hljs-number">2</span>) &#123;<br>			<span class="hljs-built_in">this</span>.minHeap.add(<span class="hljs-built_in">this</span>.maxHeap.poll());<br>		&#125;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.minHeap.size() == <span class="hljs-built_in">this</span>.maxHeap.size() + <span class="hljs-number">2</span>) &#123;<br>			<span class="hljs-built_in">this</span>.maxHeap.add(<span class="hljs-built_in">this</span>.minHeap.poll());<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 大根堆为空是进入第一个数的情况</span><br>		<span class="hljs-keyword">if</span> (maxHeap.isEmpty() || num &lt;= maxHeap.peek()) &#123;<br>			maxHeap.add(num);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			minHeap.add(num);<br>		&#125;<br>        <span class="hljs-comment">// 检查差值是否为2</span><br>		modifyTwoHeapsSize();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getMedian</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">maxHeapSize</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.maxHeap.size();<br>		<span class="hljs-type">int</span> <span class="hljs-variable">minHeapSize</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.minHeap.size();<br>		<span class="hljs-keyword">if</span> (maxHeapSize + minHeapSize == <span class="hljs-number">0</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">maxHeapHead</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.maxHeap.peek();<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">minHeapHead</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.minHeap.peek();<br>		<span class="hljs-keyword">if</span> (maxHeapSize == minHeapSize) &#123;<br>			<span class="hljs-keyword">return</span> (maxHeapHead + minHeapHead) / <span class="hljs-number">2</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> maxHeapSize &gt; minHeapSize ? maxHeapHead : minHeapHead;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxHeapComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt; &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>		<span class="hljs-keyword">if</span> (o2 &gt; o1) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinHeapComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt; &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>		<span class="hljs-keyword">if</span> (o2 &lt; o1) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="荷兰国旗问题和快速排序"><a href="#荷兰国旗问题和快速排序" class="headerlink" title="荷兰国旗问题和快速排序"></a>荷兰国旗问题和快速排序</h3><h4 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h4><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><p>给定一个数组arr，和一个数num，请把小于等于 num 的数放在数组的左边，大于 num 的数放在数组的右边。要求额外空间复杂O(1)，时间复杂度O(N)。</p>
<p>思路：划分一个<code>&lt;=</code>区，遍历数组，将当前数与区分值进行比较。若当前值<code>&lt;=</code>区分值，将当前数与<code>&lt;=</code>区下一个数交换，<code>&lt;=</code>区往右扩一个位置，当前数跳下一个位置。若当前数<code>&gt;</code>区分值，<code>&lt;=</code>区不扩，当前数跳下一个。相当于<code>&lt;=</code>区推着<code>&gt;</code>区往右走。</p>
<h5 id="问题二-荷兰国旗问题"><a href="#问题二-荷兰国旗问题" class="headerlink" title="问题二(荷兰国旗问题)"></a>问题二(荷兰国旗问题)</h5><p>给定一个数组arr，和一个数 num，请把小于 num 的数放在数组的左边，等于 num 的数放在数组的中间，大于 num 的数放在数组的右边。要求额外空间复杂度O(1)，时间复杂度O(N)。</p>
<p>思路：划分一个<code>&lt;</code>区和一个<code>&gt;</code>区，遍历数组，将当前数与划分值进行比较。若当前值<code>&lt;</code>划分值，将当前数与<code>&lt;</code>区下一个数交换，<code>&lt;</code>区往右扩一个位置，当前数跳下一个位置。若当前数<code>=</code>划分值，当前数直接跳下一个。若当前数<code>&gt;</code>划分值，将当前数与<code>&gt;</code>区前一个数交换，<code>&gt;</code>区向左扩一个位置，当前数停在原地不动。相当于<code>&lt;</code>区推着<code>=</code>区往右走。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 荷兰国旗问题，分3块儿</span><br><span class="hljs-comment">// 在arr[L...R]范围上，根据p分块，&lt;p在左边，==p在中间，&gt;p在右边</span><br><span class="hljs-comment">//返回值含义：一定会返回一个长度为2的数组，记录等于区域的左边界和右边界</span><br><span class="hljs-comment">// arr=[...3 5 5 4 6 7...]</span><br><span class="hljs-comment">// index:  4 5 6 7 8 9</span><br><span class="hljs-comment">// p=5</span><br><span class="hljs-comment">// arr=[...(34)5 5(67)...]</span><br><span class="hljs-comment">//             6 7</span><br><span class="hljs-comment">//返回一个长度为2的数组[6,7]</span><br><span class="hljs-comment">//如果无等于区域，返回值左边界&gt;右边界</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> p) &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区的右边界</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R + <span class="hljs-number">1</span>; <span class="hljs-comment">// &gt;区的左边界</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> L;<br>	<span class="hljs-keyword">while</span> (index &lt; more) &#123; <br>		<span class="hljs-keyword">if</span> (arr[index] &lt; p) &#123;<br>			swap(arr, ++less, index++);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[index] &gt; p) &#123;<br>			swap(arr, --more, index);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			index++;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; less + <span class="hljs-number">1</span>, more - <span class="hljs-number">1</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>less</code>代表小于<code>num</code>的数的右界，<code>more</code>代表大于<code>num</code>的左界，<code>partition</code>的过程就是遍历元素、不断壮大<code>less、more</code>范围的过程。这里比较难理解的地方可能是为什么<code>arr[index]&lt;num</code>时要右移<code>index</code>而<code>arr[index]&gt;num</code>时却不需要。这是因为对于当前元素<code>arr[index]</code>，如果<code>arr[index]&lt;num</code>时进行<code>swap</code>之后对于当前下标的数据状况是知晓的（一定有<code>arr[index]=arr[less+1]</code>），因为是从头遍历到<code>i</code>的，而<code>less+1&lt;=i</code>。但是如果<code>arr[index]&gt;num</code>进行<code>swap</code>之后对于当前元素的数据状况是不清楚的，因为<code>more-1&gt;=i</code>，<code>arr[more-1]</code>还没遍历到。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h5><p>将数组的最后一个值作为划分值<code>p</code> ，然后将前面的数进行<code>partition</code> 过程，<code>&lt;=p</code>的放左边，<code>&gt;p</code>的放右边。接着将最后一个数<code>p</code> 与<code>&gt;p</code>的第一个数交换，形成 <code>&lt;=p、p、&gt;p</code>的形式，然后对<code>&lt;=p</code>和<code>&gt;p</code>的区域递归重复执行上述过程。每次递归搞定一个数，最终形成有序。</p>
<p>快排1.0的时间复杂度与数据状况有关，如果<strong>每一次</strong><code>partition</code>时，尾元素都是序列中最大或最小的，那么去除该元素序列并未给我们划分为样本量相同的左右两个子序列，而是只安排好了一个元素（划分值<code>p</code>），这样的话时间复杂度就是<code>O(n-1+n-2+……+1)=O(n^2)</code>；但如果每一次<code>partition</code>时，都将序列分成了两个样本量相差无几的左右两个子序列，那么时间复杂度就是<code>O(nlogn)</code>（使用Master公式求解）。</p>
<h5 id="快排2-0（荷兰国旗问题引发的改进）"><a href="#快排2-0（荷兰国旗问题引发的改进）" class="headerlink" title="快排2.0（荷兰国旗问题引发的改进）"></a>快排2.0（荷兰国旗问题引发的改进）</h5><p>将数组的最后一个值作为划分值<code>p</code> ，然后将前面的数进行<code>partition</code> 过程，<code>&lt;p</code>的放左边，<code>=p</code>的放中间，<code>&gt;p</code>的放右边。接着将最后一个数<code>p</code> 与<code>&gt;p</code>的第一个数交换，形成 <code>&lt;=p、=p、&gt;p</code>的形式，然后对<code>&lt;p</code>和<code>&gt;p</code>的区域递归重复执行上述过程。每次递归搞定一组<code>=p</code>的数 ，最终形成有序。</p>
<p>快排2.0与快排1.0相比，每一次递归<code>partition</code> 都搞定了一组数（<code>=p</code>的区域），而不是一个数，有了一定的优化。但是只是常数时间的优化，实质还要看数据状况（最好的情况为<code>O(nlogn)</code>，最坏的情况为<code>O(n^2)</code>）。</p>
<h5 id="快排3-0-随机快排-——O-nlogn"><a href="#快排3-0-随机快排-——O-nlogn" class="headerlink" title="快排3.0(随机快排)——O(nlogn)"></a>快排3.0(随机快排)——<code>O(nlogn)</code></h5><p>快排1.0和快排2.0都是以最后一个数作为划分值，随机快排则等概率的挑选一个数，人为的放到最后一个位置上去，再进行<code>partition</code>过程，从而避免了每一轮选择尾元素会受数据状况的影响的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// arr[l..r]排好序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> &#123;<br>	<span class="hljs-keyword">if</span> (L &lt; R) &#123;<br>         swap(arr, L + (<span class="hljs-type">int</span>) (Math.random() * (R - L + <span class="hljs-number">1</span>)), R);<br>		<span class="hljs-type">int</span>[] p = partition(arr, L, R);<span class="hljs-comment">// 返回等于区域的左边界和右边界</span><br>		quickSort(arr, L, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>); <span class="hljs-comment">// &lt; 区</span><br>		quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, R); <span class="hljs-comment">// &gt; 区</span><br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 这是一个处理arr[l..r]的函数</span><br><span class="hljs-comment">// 默认以arr[r]做划分，arr[r] -&gt; p     &lt;p   ==p   &gt;p</span><br><span class="hljs-comment">// 返回等于区域(左边界，右边界), 所以返回一个长度为2的数组res, res[0] res[1]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] partition(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R) &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">less</span> <span class="hljs-operator">=</span> L - <span class="hljs-number">1</span>; <span class="hljs-comment">// &lt;区右边界</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">more</span> <span class="hljs-operator">=</span> R; <span class="hljs-comment">// &gt;区左边界</span><br>	<span class="hljs-keyword">while</span> (L &lt; more) &#123; <span class="hljs-comment">// L表示当前数的位置   arr[R]  -&gt;  划分值</span><br>		<span class="hljs-keyword">if</span> (arr[L] &lt; arr[R]) &#123; <span class="hljs-comment">// 当前数   &lt;  划分值</span><br>			swap(arr, ++less, L++);<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[L] &gt; arr[R]) &#123; <span class="hljs-comment">// 当前数   &gt;  划分值</span><br>			swap(arr, --more, L);<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			L++;<br>		&#125;<br>	&#125;<br>	swap(arr, more, R);<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123; less + <span class="hljs-number">1</span>, more &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快排1.0和快排2.0都能很轻易的举出最坏情况的例子，因此实质是<code>O(n^2)</code>的算法。而随机快排每一轮<code>partition</code>选出的作为比较对象的数是随机的，因此好情况和坏情况都是概率事件，每种情况占<code>1/N</code>的概率，其数学期望最终收敛于<code>O(nlogn)</code>，因此随机快排的时间复杂度为<code>O(nlogn)</code>。</p>
<p>随机快排需要记录<code>p</code>的位置，从而执行递归过程，因此需要<code>O(logn)</code>的额外空间复杂度。快排1.0和快排2.0最好情况为<code>O(logn)</code>，最差情况为<code>O(N)</code>。</p>
<blockquote>
<p>事实上，为了让算法中的操作不依托于数据状况（如快排中每一次<code>partition</code>取尾元素作为比较，这就没有规避样本的数据状况，如果尾元素是最大或最小值就成了最坏情况）常常有两种做法：</p>
<p>1、使用随机取数</p>
<p>2、将样本数据哈希打乱</p>
</blockquote>
<h3 id="比较器的使用"><a href="#比较器的使用" class="headerlink" title="比较器的使用"></a>比较器的使用</h3><p>之前所讲的一些算法大都是对基本类型的排序，但实际工程中要排序的对象可能是无法预测的，那么如何实现一个通用的排序算法以应对呢？事实上，之前的排序都可以归类为<strong>基于比较的排序</strong>。也就是说我们只需要对要比较的对象实现一个比较器，然后排序算法基于比较器来排序，这样算法和具体要排序的对象之间就解耦了。以后在排序之前，基于要排序的对象实现一个比较器（定义了如何比较对象大小的逻辑），然后将比较器丢给排序算法即可，这样就实现了复用。</p>
<p>在<code>Java</code>中，这个比较器就是<code>Comparator</code>接口，我们需要实现其中的<code>compare</code>方法，对于要排序的对象集合定义一个比较大小的逻辑，然后在构造用来添加这类对象的有序容器时传入这个构造器即可。封装好的容器会在容器元素发生改变时使用我们的比较器来重新组织这些元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>		<span class="hljs-keyword">public</span> String name;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;	<br>		<br>         <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age)</span> &#123;<br>			<span class="hljs-built_in">this</span>.name = name;<br>			<span class="hljs-built_in">this</span>.id = id;<br>			<span class="hljs-built_in">this</span>.age = age;<br>		&#125;<br>        <br>    &#125;<br>    <br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdAscendingComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Student&gt; &#123;<br><br>		<span class="hljs-comment">// 对于任意比较器，首先需要指定两个对象:o1,o2;</span><br>         <span class="hljs-comment">// 返回值有统一的规范：</span><br>         <span class="hljs-comment">// 返回负数时：认为o1应该排在o2的前面</span><br>         <span class="hljs-comment">// 返回正数时：认为o2应该排在o1的前面</span><br>         <span class="hljs-comment">// 返回0时：谁排前面都可以</span><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Student o1, Student o2)</span> &#123;<br>			<span class="hljs-keyword">return</span> o2.id - o1.id;<br>		&#125;<br><br>	&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//大根堆，默认小根堆</span><br>        PriorityQueue&lt;Student&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IdAscendingComparator</span>());<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>);<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">22</span>);<br>        heap.add(a);<br>        heap.add(b);<br>        heap.add(c);<br>        <span class="hljs-keyword">while</span> (!heap.isEmpty()) &#123;<br>            System.out.println(heap.poll());<span class="hljs-comment">//弹出并返回堆顶元素</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有<code>TreeSet</code>等，都是在构造是传入比较器，否则将直接根据元素的值（<code>Java</code>中引用类型变量的值为地址，比较将毫无意义）来比较，这里就不一一列举了。</p>
<blockquote>
<p>总结：</p>
<p>1）比较器的实质就是重载比较运算符。<br>2）比较器可以很好的应用在特殊标准的排序上。<br>3）比较器可以很好的应用在根据特殊标准排序的结构上。</p>
</blockquote>
<h3 id="桶排序思想下的排序"><a href="#桶排序思想下的排序" class="headerlink" title="桶排序思想下的排序"></a>桶排序思想下的排序</h3><p>之前的都是基于比较的排序，也即通过比较确定每个元素所处的位置。那么能不能不比较而实现排序呢？这就涉及到了 <strong>桶排序</strong> 这个方法论：准备一些桶，将序列中的元素按某些规则放入对应的桶中，最后根据既定的规则依次倒出桶中的元素。</p>
<blockquote>
<p>桶排序思想下的排序都是不基于比较的排序，其应用范围有限，需要样本的数据状况满足桶的划分。所以实际中并不经常使用。</p>
</blockquote>
<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>计数排序是 <strong>桶排序</strong> 方法论的一种实现，即准备一个与序列中元素的数据范围大小相同的数组，然后遍历序列，将遇到的元素作为数组的下标并将该位置上的数加1。其适用于数据范围小（最大值和最小值相差不大）的数组排序，比如0~200.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// only for 0~200 value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		max = Math.max(max, arr[i]);<br>	&#125;<br>	<span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max + <span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		bucket[arr[i]]++;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; bucket.length; j++) &#123;<br>		<span class="hljs-keyword">while</span> (bucket[j]-- &gt; <span class="hljs-number">0</span>) &#123;<br>			arr[i++] = j;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序只适用于十进制的无符号整数进行排序。其主要思想是，先找到位数最多的数，不足该位数的数字前面补0.然后准备10个桶（队列结构，保证先进桶的先出），先根据数字的个位决定进入哪个桶，全部进桶之后再从左到右依次倒出回原数组，即按照个位数字排序。再根据数字的十位进桶，进行同样的操作，再按数字的百位进桶，进行同样的操作。依此类推，最后达到全局有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// only for no-negative value</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	radixSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, maxbits(arr));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxbits</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		max = Math.max(max, arr[i]);<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (max != <span class="hljs-number">0</span>) &#123;<br>		res++;<br>		max /= <span class="hljs-number">10</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// arr[L..R]排序，digit:最大的数字有多少个十进制位</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> digit)</span> &#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">radix</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 有多少个数准备多少个辅助空间</span><br>	<span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[R - L + <span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; d &lt;= digit; d++) &#123; <span class="hljs-comment">// 有多少位就进出几次</span><br><br>		<span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[radix]; <span class="hljs-comment">// count[0..9]，固定的，统计数组</span><br>		<span class="hljs-keyword">for</span> (i = L; i &lt;= R; i++) &#123;<br>            <span class="hljs-comment">//example:</span><br>            <span class="hljs-comment">//arr[022,021,032,031,001,100]</span><br>            <span class="hljs-comment">//按个位时：</span><br>            <span class="hljs-comment">//count[1 3 2 0 0 0 0 0 0 0]</span><br>            <span class="hljs-comment">//......0 1 2 3 4 5 6 7 8 9]</span><br>            <span class="hljs-comment">//含义：个位数字为0的有几个，个位数字为1的有几个...</span><br>            <span class="hljs-comment">//d:从右往左第几位的数</span><br>			j = getDigit(arr[i], d);<br>            <span class="hljs-comment">//做词频统计</span><br>			count[j]++;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; radix; i++) &#123;<br>            <span class="hljs-comment">//example:</span><br>            <span class="hljs-comment">//按个位时：</span><br>            <span class="hljs-comment">//count[1 4 6 6 6 6 6 6 6 6]</span><br>            <span class="hljs-comment">//......0 1 2 3 4 5 6 7 8 9]</span><br>            <span class="hljs-comment">//含义：个位数字&lt;=0的有几个，个位数字&lt;=1的有几个</span><br>		   <span class="hljs-comment">// 10个空间</span><br>		   <span class="hljs-comment">// count[0] 当前位(d位)是0的数字有多少个</span><br>		   <span class="hljs-comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span><br>		   <span class="hljs-comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span><br>		   <span class="hljs-comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span><br>			count[i] = count[i] + count[i - <span class="hljs-number">1</span>];<br>		&#125;<br>		<span class="hljs-keyword">for</span> (i = R; i &gt;= L; i--) &#123;<br>            <span class="hljs-comment">//从右往左遍历数组</span><br>			j = getDigit(arr[i], d);<br>            <span class="hljs-comment">//放入0~count[j]-1范围的的最后位置</span><br>			bucket[count[j] - <span class="hljs-number">1</span>] = arr[i];<br>            <span class="hljs-comment">//词频变小</span><br>			count[j]--;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (i = L, j = <span class="hljs-number">0</span>; i &lt;= R; i++, j++) &#123;<br>            <span class="hljs-comment">//拷贝回原数组</span><br>			arr[i] = bucket[j];<br>		&#125;<br>	&#125;<br>&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> &#123;<br>		<span class="hljs-keyword">return</span> ((x / ((<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, d - <span class="hljs-number">1</span>))) % <span class="hljs-number">10</span>);<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>基数排序的代码用了非常精细的设计代替了生成10个队列的实现方式。通过给数字划片的方式依次从每一片的右侧开始填起，往左填。</p>
<p>桶排序思想下的排序时间复杂度为<code>O(N)</code>，额外空间复杂度为<code>O(M)</code>。</p>
<blockquote>
<p>如果下次面试官问你有没有时间复杂度比<code>O(NlogN)</code>更优的排序算法时，不要忘了桶排序（计数排序和基数排序）哦！！！</p>
</blockquote>
<h4 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h4><p>给定一个数组，求如果排序后，相邻两数的最大值，要求时间复杂度为<code>O(N)</code>，且要求不能用非基于比较的排序。</p>
<p>这道题的思路比较巧妙：首先为这N个数准备N+1个桶，然后以其中的最小值和最大值为边界将数值范围均分成N等分，然后遍历数组将对应范围类的数放入对应的桶中，下图以数组长度为9举例。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/19/169045ae2427ea5e?w=784&h=340&f=jpeg&s=131998" srcset="/img/loading.gif" lazyload></p>
<p>这里比较难理解的是：</p>
<p>题目问的是求<strong>如果排序后，相邻两数的最大差值</strong>。该算法巧妙的借助一个空桶（N个数进N+1个桶，必然有一个是空桶），将问题转向了求<strong>两个相邻非空桶</strong>（其中可能隔着若干个空桶）之间前桶的最大值和后桶最小值的差值，而无需在意每个桶中进了哪些数（<strong>只需记录每个桶入数的最大值和最小值以及是否有数</strong>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxGap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>	<span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-comment">//找出最大最小值</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>		min = Math.min(min, nums[i]);<br>		max = Math.max(max, nums[i]);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (min == max) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>    <span class="hljs-comment">//记录每个桶的最大最小值以及是否有数，初始时每个桶都没数</span><br>	<span class="hljs-type">boolean</span>[] hasNum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[len + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span>[] maxs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span>[] mins = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">bid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//bucket id</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>		bid = bucket(nums[i], len, min, max);<br>        <span class="hljs-comment">//如果桶里没数，则该数入桶后，最大最小值都是它，否则更新最大最小值</span><br>		mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];<br>		maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];<br>		hasNum[bid] = <span class="hljs-literal">true</span>;<br>	&#125;<br>    <span class="hljs-comment">//find the max gap between two nonEmpty buckets</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">lastMax</span> <span class="hljs-operator">=</span> maxs[<span class="hljs-number">0</span>];<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span> (; i &lt;= len; i++) &#123;<br>		<span class="hljs-keyword">if</span> (hasNum[i]) &#123;<br>            <span class="hljs-comment">//the last bucket must has number</span><br>			res = Math.max(res, mins[i] - lastMax);<br>			lastMax = maxs[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bucket</span><span class="hljs-params">(<span class="hljs-type">long</span> num, <span class="hljs-type">long</span> len, <span class="hljs-type">long</span> min, <span class="hljs-type">long</span> max)</span> &#123;<br>    <span class="hljs-comment">//根据要入桶的数和最大最小值得到对应桶编号</span><br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((num - min) * len / (max - min));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="排序算法的稳定性及其汇总"><a href="#排序算法的稳定性及其汇总" class="headerlink" title="排序算法的稳定性及其汇总"></a>排序算法的稳定性及其汇总</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>排序算法的稳定性指的是排序前后是否维持值相同的元素在序列中的相对次序。同样值的个体之间，如果不因为排序而改变相对次序，这个排序就是有稳定性的；否则就没有。如序列<code>271532</code>，在排序过程中如果能维持第一次出现的<code>2</code>在第二次出现的<code>2</code>的前面，那么该排序算法能够保证稳定性。首先我们来分析一下前面所讲排序算法的稳定性，再来谈谈稳定性的意义。</p>
<ul>
<li><strong>选择排序</strong>：无法保证稳定性，比如序列<code>926532</code>，在第一轮<code>maxIndex</code>的选择出来之后（<code>maxIndex=0</code>），第二次出现的<code>2</code>（尾元素）将与<code>9</code>交换位置，那么两个<code>2</code>的相对次序就发生了变化，破坏了排序的稳定性。</li>
<li><strong>冒泡排序</strong>：可以保证稳定性，只需在比较相邻两个数时只在后一个数比前一个数大的情况下才交换位置即可，即相等不交换。</li>
<li><strong>插入排序</strong>：可以保证稳定性，每次插入一个数到有序序列中时，遇到比它大的就替换，否则不替换。这样的话，值相同的元素，后面插入的就总在前面插入的后面了。</li>
<li><strong>归并排序</strong>：可以保证稳定性，在左右两半子序列排好序后的<code>merge</code>过程中，比较大小时如果相等，那么优先插入左子序列中的数。</li>
<li><strong>堆排序</strong>：不能保证稳定性。二叉树如果交换位置的结点是相邻层次的可以保证稳定性，但堆排序中弹出堆顶元素后的<code>heapify</code>交换的是第一层的结点和最后一层的结点。</li>
<li><strong>快速排序</strong>：不能保证稳定性，因为<code>partition</code>的过程会将比<code>num</code>小的数与<code>&lt;</code>区域的右一个数交换位置，将比<code>num</code>大的与<code>&gt;</code>区域的左一个数交换位置，而<code>&lt;</code>区、<code>&gt;</code>区位于序列两侧，很容易打乱值相同元素的相对次序，破坏了稳定性。</li>
<li><strong>一切桶排序思想下的排序</strong>：可以保证稳定性，按对应规则入桶时保证先进桶的先出，就不会打乱相同元素的相对次序。</li>
</ul>
<p>维持稳定性一般是为了满足业务需求。假设下面是一张不同厂商下同一款产品的价格和销售情况表：</p>
<table>
<thead>
<tr>
<th align="left">品牌</th>
<th align="left">价格</th>
<th align="left">销量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">三星</td>
<td align="left">1603</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">小米</td>
<td align="left">1603</td>
<td align="left">74</td>
</tr>
<tr>
<td align="left">vivo</td>
<td align="left">1604</td>
<td align="left">92</td>
</tr>
</tbody></table>
<p>要求先按价格排序，再按销量排序。如果保证稳定性，那么排序后应该是这样的：</p>
<table>
<thead>
<tr>
<th align="left">品牌</th>
<th align="left">价格</th>
<th align="left">销量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">三星</td>
<td align="left">1603</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">vivo</td>
<td align="left">1604</td>
<td align="left">92</td>
</tr>
<tr>
<td align="left">小米</td>
<td align="left">1603</td>
<td align="left">74</td>
</tr>
</tbody></table>
<p>即按销量排序后，销量相同的两条记录会保持之前的按价格排序的状态，这样先前的价格排序这个工作就没白做。</p>
<h4 id="排序算法时间复杂度、额外空间复杂度、稳定性汇总"><a href="#排序算法时间复杂度、额外空间复杂度、稳定性汇总" class="headerlink" title="排序算法时间复杂度、额外空间复杂度、稳定性汇总"></a>排序算法时间复杂度、额外空间复杂度、稳定性汇总</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">时间复杂度</th>
<th align="center">额外空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">选择排序</td>
<td align="center">O(N^2)​</td>
<td align="center">O(1)​</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(N^2)​</td>
<td align="center">O(1)​</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(N^2)​</td>
<td align="center">O(1)​</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(N*logN)​</td>
<td align="center">O(N)​</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(N*logN)​</td>
<td align="center">O(1)​</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(N*logN)​</td>
<td align="center">O(logN)​</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(N)​</td>
<td align="center">O(N)​</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>具体选择哪个排序算法需要看具体需求：</p>
<ul>
<li><strong>快速排序</strong>：不追求稳定性，只追求时间复杂度指标最优，其常数时间最优。</li>
<li><strong>堆排序</strong>：追求额外空间复杂度最少。</li>
<li><strong>归并排序</strong>：追求稳定性。</li>
</ul>
<blockquote>
<p>目前没有找到时间复杂度<code>O(nlogn)</code>，额外空间复杂度低于<code>O(n)</code>，又稳定的排序。</p>
</blockquote>
<h3 id="有关排序问题常见的坑"><a href="#有关排序问题常见的坑" class="headerlink" title="有关排序问题常见的坑"></a>有关排序问题常见的坑</h3><ul>
<li>归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，有兴趣可以搜“归并排序 内部缓存法”。</li>
<li>“原地归并排序”的帖子都是垃圾，会让归并排序的时间复杂度变成<code>O(n^2)</code></li>
<li>快速排序可以做到稳定性问题，但是非常难，不需要掌握， 可以搜<code>01 stable sort</code>（论文）。</li>
<li>所有的改进都不重要，因为目前没有找到时间复杂度<code>O(nlogn)</code>，额外空间复杂度低于<code>O(n)</code>，又稳定的排序。</li>
<li>有一道题目，是奇数放在数组左边，偶数放在数组右边，要求原始的相对次序不变，还要求时间复杂度<code>O(n)</code>，额外空间复杂度<code>O(1)</code>.碰到这个问题，可以怼面试官。因为此题与快速排序如出一辙，均为”01 标准排序问题”，即“一个数非奇即偶”和“一个数<code>&lt;=num</code>或<code>&gt;num</code>”。如果此题能做到，那么快排也能做到。如果不要求时间复杂度和额外空间复杂度，要使这类问题做到稳定性，要看<code>01 stable sort</code>这篇论文。</li>
</ul>
<h3 id="工程上对排序的改进"><a href="#工程上对排序的改进" class="headerlink" title="工程上对排序的改进"></a>工程上对排序的改进</h3><p>实际工程中的排序算法一般会将 <strong>归并排序</strong>、<strong>插入排序</strong>、<strong>快速排序</strong>综合起来，集大家之所长来应对不同的场景要求：</p>
<ul>
<li>稳定性的考虑：当要排序的元素为基本数据类型且样本规模较大时，将采用 <strong>快速排序</strong>；当要排序的元素为对象数据类型（包括若干字段），为保证稳定性将采用<strong>归并排序</strong>。</li>
<li>充分利用<code>O(nlogn)</code>和<code>O(n^2)</code>排序各自的优势：当要排序的元素为基本数据类型且元素个数较少时，直接使用 <strong>插入排序</strong>。因为在样本规模较小时（比如60），<code>O(NlogN)</code>的优势并不明显甚至不及<code>O(N^2)</code>，而在<code>O(N^2)</code>的算法中，插入排序的常数时间操作最少。因此在实际工程中，数据规模较大时整体采用<strong>快速排序</strong>，其中数据规模小于60时，内嵌<strong>插入排序</strong>。即采用以下伪代码方式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>	<span class="hljs-comment">//if (l == r) &#123;</span><br>		<span class="hljs-comment">//return;</span><br>	<span class="hljs-comment">//&#125;</span><br>	<span class="hljs-keyword">if</span> (l &gt; r - <span class="hljs-number">60</span>) &#123;<br>		在arr[l..r]插入排序<br>		O(N^<span class="hljs-number">2</span>) 小样本量的时候，跑的快<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	swap(arr, l + (<span class="hljs-type">int</span>) (Math.random() * (r - l + <span class="hljs-number">1</span>)), r);<br>	<span class="hljs-type">int</span>[] p = partition(arr, l, r);<br>	quickSort(arr, l, p[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>); <span class="hljs-comment">// &lt; 区</span><br>	quickSort(arr, p[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// &gt; 区</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic2/20210118133820.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试时链表解题的方法论"><a href="#面试时链表解题的方法论" class="headerlink" title="面试时链表解题的方法论"></a>面试时链表解题的方法论</h3><ol>
<li>对于笔试，不用太在乎空间复杂度，一切为了时间复杂度；</li>
<li>对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法。</li>
</ol>
<blockquote>
<p>重要技巧：</p>
<ul>
<li>额外数据结构记录（哈希表等）</li>
<li>快慢指针（注意 coding 时的边界问题，奇数、偶数个结点等）</li>
</ul>
</blockquote>
<h3 id="1）反转单向和双向链表"><a href="#1）反转单向和双向链表" class="headerlink" title="1）反转单向和双向链表"></a>1）反转单向和双向链表</h3><p> 分别实现反转单向链表和反转双向链表的函数。要求如果链表长度为 <code>N</code>，时间复杂度要求为 <code>O(N)</code> ，额外空间复杂度要求为 <code>O(1)</code>。</p>
<blockquote>
<p>此题的难点就是反转一个结点的 <code>next</code> 指针后，就无法在该结点通过<code>next</code>指针找到后续的结点了。因此每次反转之前需要将该结点的后继结点记录下来。</p>
</blockquote>
<h4 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> Node next;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>		<span class="hljs-built_in">this</span>.value = data;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reverseList</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>		next = head.next;<br>		head.next = pre;<br>		pre = head;<br>		head = next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="反转双向链表"><a href="#反转双向链表" class="headerlink" title="反转双向链表"></a>反转双向链表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleNode</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> DoubleNode last;<br>	<span class="hljs-keyword">public</span> DoubleNode next;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleNode</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>		<span class="hljs-built_in">this</span>.value = data;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(DoubleNode head)</span> &#123;<br>	<span class="hljs-type">DoubleNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-type">DoubleNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>		next = head.next;<br>		head.next = pre;<br>		head.last = next;<br>		pre = head;<br>		head = next;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2）打印两个有序链表的公共部分"><a href="#2）打印两个有序链表的公共部分" class="headerlink" title="2）打印两个有序链表的公共部分"></a>2）打印两个有序链表的公共部分</h3><p>给定两个有序链表的头指针 head1 和 head2，打印两个链表的公共部分。要求如果两个链表的长度之和为 N，时间复杂度要求为 O(N)，额外空间复杂度要求为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> Node next;<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>		<span class="hljs-built_in">this</span>.value = data;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printCommonPart</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br>	System.out.print(<span class="hljs-string">&quot;Common Part: &quot;</span>);<br>	<span class="hljs-keyword">while</span> (head1 != <span class="hljs-literal">null</span> &amp;&amp; head2 != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (head1.value &lt; head2.value) &#123;<br>			head1 = head1.next;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head1.value &gt; head2.value) &#123;<br>			head2 = head2.next;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			System.out.print(head1.value + <span class="hljs-string">&quot; &quot;</span>);<br>			head1 = head1.next;<br>			head2 = head2.next;<br>		&#125;<br>	&#125;<br>	System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3）判断一个链表是否为回文结构"><a href="#3）判断一个链表是否为回文结构" class="headerlink" title="3）判断一个链表是否为回文结构"></a>3）判断一个链表是否为回文结构</h3><p>给定一个单链表的头节点 head，请判断该链表是否为回文结构。要求如果链表长度为 N，时间复杂度达到 O(N)，额外空间复杂度达到 O(1)。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">示例：<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">15</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">15</span>，返回<span class="hljs-literal">true</span>；<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure>

<p>单链表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>		<span class="hljs-keyword">public</span> Node next;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>			<span class="hljs-built_in">this</span>.value = data;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="空间复杂度-O-n-做法"><a href="#空间复杂度-O-n-做法" class="headerlink" title="空间复杂度 O(n) 做法"></a>空间复杂度 O(n) 做法</h4><p>回文链表具有前后两半部分逆序的特点，与栈先进后出的特性相吻合。因此可以借助栈来解决此问题。遍历链表，将结点依次压入栈中。然后从头遍历链表，依次与栈弹出的结点相比较。如果每一步结点值都相等，则为回文结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need n extra space</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome1</span><span class="hljs-params">(Node head)</span> &#123;<br>		Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			stack.push(cur);<br>			cur = cur.next;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;<br>			head = head.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="空间复杂度-O-n-x2F-2-做法"><a href="#空间复杂度-O-n-x2F-2-做法" class="headerlink" title="空间复杂度 O(n&#x2F;2) 做法"></a>空间复杂度 O(n&#x2F;2) 做法</h4><p>因为回文链表前后两部分逆序，因此可以省下一半的空间。即将链表中间结点之后的结点依次压入栈中，然后从链表头结点开始遍历链表的前半部分，将遍历的结点与栈弹出的结点相比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need n/2 extra space</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome2</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> head.next;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>		<span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.next != <span class="hljs-literal">null</span>) &#123;<br>			right = right.next;<br>			cur = cur.next.next;<br>		&#125;<br>		Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>		<span class="hljs-keyword">while</span> (right != <span class="hljs-literal">null</span>) &#123;<br>			stack.push(right);<br>			right = right.next;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>			<span class="hljs-keyword">if</span> (head.value != stack.pop().value) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;<br>			head = head.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="空间复杂度-O-1-做法——双指针"><a href="#空间复杂度-O-1-做法——双指针" class="headerlink" title="空间复杂度 O(1) 做法——双指针"></a>空间复杂度 O(1) 做法——双指针</h4><p>利用两个指针，快指针每次走两步，慢指针每次走一步。当快指针走完的时候，慢指针来到中点位置。然后将单链表右半部分逆序。然后利用 L 和 R 指针分别从链表头和尾出发，向中间推进，一一比较。为了不破坏原始数据结构，最后再将单链表恢复到原状态，即将右半部分逆序回来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// need O(1) extra space</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome3</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//慢指针</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">//快指针</span><br>        <span class="hljs-comment">//找到中间结点</span><br>		<span class="hljs-keyword">while</span> (n2.next != <span class="hljs-literal">null</span> &amp;&amp; n2.next.next != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// find mid node</span><br>			n1 = n1.next; <span class="hljs-comment">// n1 -&gt; mid</span><br>			n2 = n2.next.next; <span class="hljs-comment">// n2 -&gt; end</span><br>		&#125;<br>		n2 = n1.next; <span class="hljs-comment">// n2 -&gt; right part first node</span><br>		n1.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// mid.next -&gt; null</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">n3</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">while</span> (n2 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// right part convert</span><br>			n3 = n2.next; <span class="hljs-comment">// n3 -&gt; save next node</span><br>			n2.next = n1; <span class="hljs-comment">// next of right node convert</span><br>			n1 = n2; <span class="hljs-comment">// n1 move</span><br>			n2 = n3; <span class="hljs-comment">// n2 move</span><br>		&#125;<br>		n3 = n1; <span class="hljs-comment">// n3 -&gt; save last node</span><br>		n2 = head;<span class="hljs-comment">// n2 -&gt; left first node</span><br>		<span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">while</span> (n1 != <span class="hljs-literal">null</span> &amp;&amp; n2 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// check palindrome</span><br>			<span class="hljs-keyword">if</span> (n1.value != n2.value) &#123;<br>				res = <span class="hljs-literal">false</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			n1 = n1.next; <span class="hljs-comment">// left to mid</span><br>			n2 = n2.next; <span class="hljs-comment">// right to mid</span><br>		&#125;<br>		n1 = n3.next;<br>		n3.next = <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">while</span> (n1 != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// recover list</span><br>			n2 = n1.next;<br>			n1.next = n3;<br>			n3 = n1;<br>			n1 = n2;<br>		&#125;<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题"><a href="#4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题" class="headerlink" title="4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题"></a>4）将单向链表按某值划分成左边小、中间相等、右边大的形式——链表与荷兰国旗问题</h3><p>给定一个单链表的头节点 head，节点的值类型是整型，再给定一个整数 pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。</p>
<p>单链表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>		<span class="hljs-keyword">public</span> Node next;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>			<span class="hljs-built_in">this</span>.value = data;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="借助数组"><a href="#借助数组" class="headerlink" title="借助数组"></a>借助数组</h4><p>将链表中的所有结点放入一个数组中，那么就转换成了荷兰国旗问题，进行<code>partition</code> 过程，最后再将数组中的结点重新连接起来。但这种做法会使用 O(N) 的额外空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> Node <span class="hljs-title">listPartition1</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> pivot)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (head == null) &#123;<br>			<span class="hljs-keyword">return</span> head;<br>		&#125;<br>		Node cur = head;<br>		<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (cur != null) &#123;<br>			i++;<br>			cur = cur.next;<br>		&#125;<br>		Node[] nodeArr = <span class="hljs-keyword">new</span> Node[i];<br>		i = <span class="hljs-number">0</span>;<br>		cur = head;<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != nodeArr.length; i++) &#123;<br>			nodeArr[i] = cur;<br>			cur = cur.next;<br>		&#125;<br>		<span class="hljs-built_in">arrPartition</span>(nodeArr, pivot);<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i != nodeArr.length; i++) &#123;<br>			nodeArr[i - <span class="hljs-number">1</span>].next = nodeArr[i];<br>		&#125;<br>		nodeArr[i - <span class="hljs-number">1</span>].next = null;<br>		<span class="hljs-keyword">return</span> nodeArr[<span class="hljs-number">0</span>];<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">arrPartition</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-type">int</span> pivot)</span> </span>&#123;<br>		<span class="hljs-type">int</span> small = <span class="hljs-number">-1</span>;<br>		<span class="hljs-type">int</span> big = nodeArr.length;<br>		<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (index != big) &#123;<br>			<span class="hljs-keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;<br>				<span class="hljs-built_in">swap</span>(nodeArr, ++small, index++);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeArr[index].value == pivot) &#123;<br>				index++;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-built_in">swap</span>(nodeArr, --big, index);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Node[] nodeArr, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>		Node tmp = nodeArr[a];<br>		nodeArr[a] = nodeArr[b];<br>		nodeArr[b] = tmp;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>在实现原问题功能的基础上增加如下的要求：</p>
<ul>
<li>调整后所有小于 pivot 的节点之间的相对顺序和调整前一样；</li>
<li>调整后所有等于 pivot 的节点之间的相对顺序和调整前一样；</li>
<li>调整后所有大于pivot 的节点之间的相对顺序和调整前一样；</li>
<li>时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)。</li>
</ul>
<p>思路：分出逻辑上的 small,equal,big 三个区域，用六个变量，即 small 区域的头和尾，equal 区域的头和尾，big 区域的头和尾表示。遍历链表结点将其添加到对应的区域中，最后再将这三个区域连起来。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724095806.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">listPartition2</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> pivot)</span> &#123;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">sH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// small head</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">sT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// small tail</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">eH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// equal head</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">eT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// equal tail</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">mH</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// big head</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">mT</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// big tail</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// save next node</span><br>		<span class="hljs-comment">// every node distributed to three lists</span><br>		<span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			next = head.next;<br>			head.next = <span class="hljs-literal">null</span>;<br>			<span class="hljs-keyword">if</span> (head.value &lt; pivot) &#123;<br>				<span class="hljs-keyword">if</span> (sH == <span class="hljs-literal">null</span>) &#123;<br>					sH = head;<br>					sT = head;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					sT.next = head;<br>					sT = head;<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (head.value == pivot) &#123;<br>				<span class="hljs-keyword">if</span> (eH == <span class="hljs-literal">null</span>) &#123;<br>					eH = head;<br>					eT = head;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					eT.next = head;<br>					eT = head;<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">if</span> (mH == <span class="hljs-literal">null</span>) &#123;<br>					mH = head;<br>					mT = head;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					mT.next = head;<br>					mT = head;<br>				&#125;<br>			&#125;<br>			head = next;<br>		&#125;<br>		<span class="hljs-comment">// small and equal reconnect</span><br>		<span class="hljs-keyword">if</span> (sT != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果有小于区域</span><br>			sT.next = eH;<br>			eT = eT == <span class="hljs-literal">null</span> ? sT : eT; <span class="hljs-comment">// 下一步，谁去连大于区域的头，谁就变成eT</span><br>		&#125;<br>		<span class="hljs-comment">// 上面的if，不管跑了没有，et</span><br>		<span class="hljs-comment">// all reconnect</span><br>		<span class="hljs-keyword">if</span> (eT != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果小于区域和等于区域，不是都没有</span><br>			eT.next = mH;<br>		&#125;<br>		<span class="hljs-keyword">return</span> sH != <span class="hljs-literal">null</span> ? sH : (eH != <span class="hljs-literal">null</span> ? eH : mH);<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5）复制含有随机指针节点的链表——深度拷贝"><a href="#5）复制含有随机指针节点的链表——深度拷贝" class="headerlink" title="5）复制含有随机指针节点的链表——深度拷贝"></a>5）复制含有随机指针节点的链表——深度拷贝</h3><p>一种特殊的单链表节点类描述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-type">int</span> value;<br>	Node next;<br>	Node rand;<br>	Node(<span class="hljs-type">int</span> val) &#123;<br>	value = val;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>rand 指针是单链表节点结构中新增的指针，rand 可能指向链表中的任意一个节点，也可能指向null。给定一个由 Node 节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。要求时间复杂度 O(N)，额外空间复杂度 O(1)。</p>
<h4 id="借助哈希表"><a href="#借助哈希表" class="headerlink" title="借助哈希表"></a>借助哈希表</h4><p>遍历链表，建立一张 Hashmap，将链表的所有结点复制一份，存储到哈希表中（key 为原链表的结点，value 为新链表的结点，即复制结点）。再遍历原链表，借助哈希表查表的方式拷贝 next 和 random 指针，如下图所示。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724102716.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">copyListWithRand1</span><span class="hljs-params">(Node head)</span> &#123;<br>		HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Node, Node&gt;();<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			map.put(cur, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.value));<br>			cur = cur.next;<br>		&#125;<br>		cur = head;<br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-comment">// cur 老</span><br>			<span class="hljs-comment">// map.get(cur) 新</span><br>			map.get(cur).next = map.get(cur.next);<br>			map.get(cur).rand = map.get(cur.rand);<br>			cur = cur.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> map.get(head);<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="进阶——额外空间-O-1"><a href="#进阶——额外空间-O-1" class="headerlink" title="进阶——额外空间 O(1)"></a>进阶——额外空间 O(1)</h4><p>将复制结点追加到对应源结点之后，建立复制结点的 random 指针域，最后将复制结点从该链表中分离出来。即利用结点的位置摆放关系代替了哈希表的作用。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724104322.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">copyListWithRand2</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">// copy node and link to every node</span><br>		<span class="hljs-comment">// 1 -&gt; 2</span><br>		<span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2</span><br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			next = cur.next;<br>			cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.value);<br>			cur.next.next = next;<br>			cur = next;<br>		&#125;<br>		cur = head;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">curCopy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-comment">// set copy node rand</span><br>		<span class="hljs-comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27;</span><br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			next = cur.next.next;<br>			curCopy = cur.next;<br>			curCopy.rand = cur.rand != <span class="hljs-literal">null</span> ? cur.rand.next : <span class="hljs-literal">null</span>;<br>			cur = next;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.next;<br>		cur = head;<br>		<span class="hljs-comment">// split</span><br>		<span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>			next = cur.next.next;<br>			curCopy = cur.next;<br>			cur.next = next;<br>			curCopy.next = next != <span class="hljs-literal">null</span> ? next.next : <span class="hljs-literal">null</span>;<br>			cur = next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6）两个单链表相交的一系列问题"><a href="#6）两个单链表相交的一系列问题" class="headerlink" title="6）两个单链表相交的一系列问题"></a>6）两个单链表相交的一系列问题</h3><p>给定两个可能有环也可能无环的单链表，头节点 head1 和 head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回 null。要求如果两个链表长度之和为 N，时间复杂度请达到 O(N)，额外空间复杂度请达到 O(1)。</p>
<p>单链表结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>		<span class="hljs-keyword">public</span> Node next;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>			<span class="hljs-built_in">this</span>.value = data;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>以上问题可以分解为三个子问题：</p>
<h4 id="判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空"><a href="#判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空" class="headerlink" title="判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空"></a>判断单链表是否有环？如果有环，返回第一个入环结点；如果无环，返回空</h4><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141346.jpeg" srcset="/img/loading.gif" lazyload></p>
<h5 id="借助-hashset"><a href="#借助-hashset" class="headerlink" title="借助 hashset"></a>借助 hashset</h5><p>遍历链表，如果链表结点不在 hashset 中，就添加进去。如果链表有环，则第一个重复的结点即为入环结点，如果无环，则会遍历到空。</p>
<h5 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>准备快慢指针，快指针从第三个结点出发，每次走两步，慢指针从第二个结点出发，每次走一步。当快指针遍历到空时，链表无环，否则快慢指针必会在环上相遇。当快慢指针相遇时，快指针回到链表头节点，每次走一步，慢指针停在相遇的位置，每次走一步。当快慢指针再次相遇的时候，则相遇结点为入环结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 找到链表第一个入环节点，如果无环，返回null</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLoopNode</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> head.next; <span class="hljs-comment">// n1 -&gt; slow</span><br>		<span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> head.next.next; <span class="hljs-comment">// n2 -&gt; fast</span><br>		<span class="hljs-keyword">while</span> (n1 != n2) &#123;<br>			<span class="hljs-keyword">if</span> (n2.next == <span class="hljs-literal">null</span> || n2.next.next == <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>			&#125;<br>			n2 = n2.next.next;<br>			n1 = n1.next;<br>		&#125;<br>		n2 = head; <span class="hljs-comment">// n2 -&gt; walk again from head</span><br>		<span class="hljs-keyword">while</span> (n1 != n2) &#123;<br>			n1 = n1.next;<br>			n2 = n2.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> n1;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="返回两个无环链表的第一个相交结点"><a href="#返回两个无环链表的第一个相交结点" class="headerlink" title="返回两个无环链表的第一个相交结点"></a>返回两个无环链表的第一个相交结点</h4><h5 id="借助-hashset-1"><a href="#借助-hashset-1" class="headerlink" title="借助 hashset"></a>借助 hashset</h5><p>遍历第一个链表，全部加到 hashset 中，然后遍历第二个链表，检查其结点是否在 hashset 中，遇到的第一个重复的结点即为相交结点。</p>
<h5 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h5><p>遍历第一个链表和第二个链表，记下链表的长度 len1、len2 和尾节点 end1、end2。如果 end1!&#x3D;end2，则两链表不相交，如果 end1&#x3D;&#x3D;end2，则两链表相交。此时，让长链表先走 |len1-len2| 步，然后两个指针一起走，相遇的结点即为第一个相交结点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141353.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">null</span> || head2 == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> head1;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> head2;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-literal">null</span>) &#123;<br>			n++;<br>			cur1 = cur1.next;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-literal">null</span>) &#123;<br>			n--;<br>			cur2 = cur2.next;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (cur1 != cur2) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-comment">// n  :  链表1长度减去链表2长度的值</span><br>		cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2; <span class="hljs-comment">// 谁长，谁的头变成cur1</span><br>		cur2 = cur1 == head1 ? head2 : head1; <span class="hljs-comment">// 谁短，谁的头变成cur2</span><br>		n = Math.abs(n);<br>		<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>			n--;<br>			cur1 = cur1.next;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (cur1 != cur2) &#123;<br>			cur1 = cur1.next;<br>			cur2 = cur2.next;<br>		&#125;<br>		<span class="hljs-keyword">return</span> cur1;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="返回两个有环链表的第一个相交结点"><a href="#返回两个有环链表的第一个相交结点" class="headerlink" title="返回两个有环链表的第一个相交结点"></a>返回两个有环链表的第一个相交结点</h4><p>总共有三种情况：</p>
<ul>
<li><p>两个有环链表不相交，此时 loop1!&#x3D;loop2；</p>
</li>
<li><p>两个有环链表在入环前相交，此时 loop1&#x3D;loop2，变回了两个无环链表的相交问题，只是把 loop1&#x2F;loop2 当作终止结点；</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141402.jpeg" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>两个有环链表在环上相交，入环接入点不一样，即 loop1!&#x3D;loop2。与第一种情况区分的方法是让 loop1 继续往下走，如果转回自己都没有遇上 loop2 则为第一种情况。如果遇上了 loop2 则为第三种情况，且 loop1、loop2 都为第一个相交结点。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141409.jpeg" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 两个有环链表，返回第一个相交节点，如果不相交返回null</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">cur2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">if</span> (loop1 == loop2) &#123; <span class="hljs-comment">//第二种情况，与无环链表相交相同</span><br>			cur1 = head1;<br>			cur2 = head2;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span> (cur1 != loop1) &#123;<br>				n++;<br>				cur1 = cur1.next;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (cur2 != loop2) &#123;<br>				n--;<br>				cur2 = cur2.next;<br>			&#125;<br>			cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;<br>			cur2 = cur1 == head1 ? head2 : head1;<br>			n = Math.abs(n);<br>			<span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>				n--;<br>				cur1 = cur1.next;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (cur1 != cur2) &#123;<br>				cur1 = cur1.next;<br>				cur2 = cur2.next;<br>			&#125;<br>			<span class="hljs-keyword">return</span> cur1;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			cur1 = loop1.next;<br>			<span class="hljs-keyword">while</span> (cur1 != loop1) &#123;<br>				<span class="hljs-keyword">if</span> (cur1 == loop2) &#123; <span class="hljs-comment">//第三种情况</span><br>					<span class="hljs-keyword">return</span> loop1;<br>				&#125;<br>				cur1 = cur1.next;<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//第一种情况</span><br>		&#125;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="一个链表有环，一个链表无环，不可能相交"><a href="#一个链表有环，一个链表无环，不可能相交" class="headerlink" title="一个链表有环，一个链表无环，不可能相交"></a>一个链表有环，一个链表无环，不可能相交</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>综上，两单链表若相交，要么都无环，要么都有环。主方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head1 == <span class="hljs-literal">null</span> || head2 == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">loop1</span> <span class="hljs-operator">=</span> getLoopNode(head1);<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">loop2</span> <span class="hljs-operator">=</span> getLoopNode(head2);<br>		<span class="hljs-keyword">if</span> (loop1 == <span class="hljs-literal">null</span> &amp;&amp; loop2 == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> noLoop(head1, head2);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (loop1 != <span class="hljs-literal">null</span> &amp;&amp; loop2 != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="1）用数组结构实现大小固定的队列和栈"><a href="#1）用数组结构实现大小固定的队列和栈" class="headerlink" title="1）用数组结构实现大小固定的队列和栈"></a>1）用数组结构实现大小固定的队列和栈</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>准备一个变量 index，表示如果新来一个数，把新来的数放在哪个位置。加完数之后 index++，减数则 index–。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815102420.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayStack</span> &#123;<br>		<span class="hljs-keyword">private</span> Integer[] arr;<br>		<span class="hljs-keyword">private</span> Integer index;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayStack</span><span class="hljs-params">(<span class="hljs-type">int</span> initSize)</span> &#123;<br>			<span class="hljs-keyword">if</span> (initSize &lt; <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The init size is less than 0&quot;</span>);<br>			&#125;<br>			arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[initSize];<br>			index = <span class="hljs-number">0</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>			&#125;<br>			<span class="hljs-keyword">return</span> arr[index - <span class="hljs-number">1</span>];<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> obj)</span> &#123;<br>			<span class="hljs-keyword">if</span> (index == arr.length) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is full&quot;</span>);<br>			&#125;<br>			arr[index++] = obj;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is empty&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">return</span> arr[--index];<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>准备两个变量 start 和 end，end 表示如果新加一个数，该填到哪个位置上，start 表示如果拿去一个数，需要从哪个位置拿给用户。一开始 start 和 end 都指向 0。再准备一个变量 size 来约束 start 和 end 的行为。如果 size 没有超过数组大小，就把新给的数填到 end 上去。同时，如果 size 不为 0，用户需要数的时候，总把 start 指向的数给用户。start 和 end 之间是解耦的，即两者是独立的。加数时 end++，size++；取数时 start++，size–；当 end 到底后，回到开头位置，start 不断地追 end 位置。能不能继续加数或者取数取决于 size 的值，循环利用数组。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815140644.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayQueue</span> &#123;<br>		<span class="hljs-keyword">private</span> Integer[] arr;<br>		<span class="hljs-keyword">private</span> Integer size;<br>		<span class="hljs-keyword">private</span> Integer start;<br>		<span class="hljs-keyword">private</span> Integer end;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> initSize)</span> &#123;<br>			<span class="hljs-keyword">if</span> (initSize &lt; <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;The init size is less than 0&quot;</span>);<br>			&#125;<br>			arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[initSize];<br>			size = <span class="hljs-number">0</span>;<br>			start = <span class="hljs-number">0</span>;<br>			end = <span class="hljs-number">0</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>			&#125;<br>			<span class="hljs-keyword">return</span> arr[start];<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> obj)</span> &#123;<br>			<span class="hljs-keyword">if</span> (size == arr.length) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is full&quot;</span>);<br>			&#125;<br>			size++;<br>			arr[end] = obj;<br>            <span class="hljs-comment">//如果end来到底部位置，则跳回到0，如果没有end++</span><br>			end = end == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : end + <span class="hljs-number">1</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayIndexOutOfBoundsException</span>(<span class="hljs-string">&quot;The queue is empty&quot;</span>);<br>			&#125;<br>			size--;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> start;<br>            <span class="hljs-comment">//如果start来到底部位置，则跳回到0，如果没有start++</span><br>			start = start == arr.length - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : start + <span class="hljs-number">1</span>;<br>			<span class="hljs-keyword">return</span> arr[tmp];<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2）取栈中最小元素"><a href="#2）取栈中最小元素" class="headerlink" title="2）取栈中最小元素"></a>2）取栈中最小元素</h3><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作<code>getMin</code>，要求如下：</p>
<ul>
<li><code>pop</code>、<code>push</code>、<code>getMin</code>操作的时间复杂度都是<code>O(1)</code>。</li>
<li>设计的栈类型可以使用现成的栈结构。</li>
</ul>
<p>思路：由于每次<code>push</code>之后都会可能导致栈中已有元素的最小值发生变化，因此需要一个容器与该栈联动（记录每次<code>push</code>产生的栈中最小值），我们可以借助一个辅助栈，即总共有两个栈，数据栈和最小值栈。</p>
<p>然后有两种设计方法：</p>
<ol>
<li><p>数据栈<code>push</code>第一个元素时，将其也<code>push</code>到最小值栈，此后每次向数据栈<code>push</code>元素的同时将其和最小值栈的栈顶元素比较，如果小，则将其也<code>push</code>到最小值栈，否则取最小值栈的栈顶元素<code>push</code>到最小值栈，即重复压入栈顶。最小值栈的栈顶始终是所有加入的数的最小值。（数据栈正常<code>push</code>、<code>pop</code>数据，而最小值栈<code>push</code>每次数据栈<code>push</code>后产生的栈中最小值；但数据栈<code>pop</code>时，最小值栈也只需简单的<code>pop</code>即可，保持同步）</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815142439.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack1</span> &#123;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack1</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-built_in">this</span>.stackData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>			<span class="hljs-built_in">this</span>.stackMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> newNum)</span> &#123;<br>            <span class="hljs-comment">//min栈的更新</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br>				<span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt; <span class="hljs-built_in">this</span>.getmin()) &#123;<br>				<span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">newMin</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br>				<span class="hljs-built_in">this</span>.stackMin.push(newMin);<br>			&#125;<br>            <span class="hljs-comment">//data栈的更新</span><br>			<span class="hljs-built_in">this</span>.stackData.push(newNum);<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackData.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>			&#125;<br>			<span class="hljs-built_in">this</span>.stackMin.pop();<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackData.pop();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>第二种设计方法也是使用两个栈，与方法一不同的是<code>stackMin</code>保存最小值的策略不同，体现在入栈和出栈操作中。</p>
<ul>
<li>入栈：如果 stackMin 为空，将 x 压入 stackMin 中。如果 stackMin 不为空，只有当 x 小于等于 stackMin.top() 时，才将 x 压入 stackMin。</li>
<li>出栈：如果 stackMin 不为空，且 stackData 出栈的元素与 stackMin 栈顶元素相等，则 stackMin 将栈顶元素弹出。</li>
</ul>
<p>栈的对应关系如下图，一次压入3、4、5、1、2、1。</p>
<p><img src="https://github.com/chenBright/leetcode/raw/master/155-%E6%9C%80%E5%B0%8F%E6%A0%88/MinStack2.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack2</span> &#123;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackData;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackMin;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">MyStack2</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-built_in">this</span>.stackData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>			<span class="hljs-built_in">this</span>.stackMin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> newNum)</span> &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br>				<span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newNum &lt;= <span class="hljs-built_in">this</span>.getmin()) &#123;<br>				<span class="hljs-built_in">this</span>.stackMin.push(newNum);<br>			&#125;<br>			<span class="hljs-built_in">this</span>.stackData.push(newNum);<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackData.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>			&#125;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stackData.pop();<br>			<span class="hljs-keyword">if</span> (value == <span class="hljs-built_in">this</span>.getmin()) &#123;<br>				<span class="hljs-built_in">this</span>.stackMin.pop();<br>			&#125;<br>			<span class="hljs-keyword">return</span> value;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getmin</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.stackMin.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Your stack is empty.&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.stackMin.peek();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="3）仅用队列结构实现栈结构"><a href="#3）仅用队列结构实现栈结构" class="headerlink" title="3）仅用队列结构实现栈结构"></a>3）仅用队列结构实现栈结构</h3><p>思路：只要将关注点放在 <strong>后进先出</strong> 这个特性就不难实现了。使用一个数据队列和辅助队列，当放入数据时使用队列的操作正常向数据队列中放，但出队元素时，需将数据队列的前 n-1 个数入队辅助队列，而将数据队列的队尾元素弹出来，最后数据队列和辅助队列交换角色。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150328.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoQueuesStack</span> &#123;<br>		<span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br>		<span class="hljs-keyword">private</span> Queue&lt;Integer&gt; help;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoQueuesStack</span><span class="hljs-params">()</span> &#123;<br>			queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>			help = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> pushInt)</span> &#123;<br>			queue.add(pushInt);<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">1</span>) &#123;<br>				help.add(queue.poll());<br>			&#125;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> queue.poll();<br>			help.add(res);<br>			swap();<br>			<span class="hljs-keyword">return</span> res;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (queue.isEmpty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Stack is empty!&quot;</span>);<br>			&#125;<br>            <span class="hljs-comment">//前n-1个数入辅助队列</span><br>			<span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>) &#123;<br>				help.add(queue.poll());<br>			&#125;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> queue.poll();<br>            <span class="hljs-comment">//数据队列和辅助队列交换角色</span><br>			swap();<br>			<span class="hljs-keyword">return</span> res;<br>		&#125;<br><br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">()</span> &#123;<br>			Queue&lt;Integer&gt; tmp = help;<br>			help = queue;<br>			queue = tmp;<br>		&#125;<br><br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4）仅用栈结构实现队列结构"><a href="#4）仅用栈结构实现队列结构" class="headerlink" title="4）仅用栈结构实现队列结构"></a>4）仅用栈结构实现队列结构</h3><p>思路：使用两个栈，一个栈<code>stackPush</code>用来放数据，一个栈<code>stackPop</code>用来取数据。取数据时，如果<code>stackPop</code>为空则需要将<code>stackPush</code>中的<strong>所有元素</strong>一次性依次<code>pop</code>并放入<code>stackPop</code>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815150836.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<p>特别要注意的是这个<strong>倒数据</strong>的原则：</p>
<ul>
<li>只有当<code>stackPop</code>为空时才能往里倒；</li>
<li><strong>倒数据</strong>时必须一次性将<code>stackPush</code>中的数据倒完。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoStacksQueue</span> &#123;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPush;<br>		<span class="hljs-keyword">private</span> Stack&lt;Integer&gt; stackPop;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">TwoStacksQueue</span><span class="hljs-params">()</span> &#123;<br>			stackPush = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>			stackPop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> pushInt)</span> &#123;<br>			stackPush.push(pushInt);<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stackPop.empty()) &#123;<br>				<span class="hljs-keyword">while</span> (!stackPush.empty()) &#123;<br>					stackPop.push(stackPush.pop());<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">return</span> stackPop.pop();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (stackPop.empty() &amp;&amp; stackPush.empty()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Queue is empty!&quot;</span>);<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stackPop.empty()) &#123;<br>				<span class="hljs-keyword">while</span> (!stackPush.empty()) &#123;<br>					stackPop.push(stackPush.pop());<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">return</span> stackPop.peek();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5）猫狗队列"><a href="#5）猫狗队列" class="headerlink" title="5）猫狗队列"></a>5）猫狗队列</h3><p>宠物、狗和猫的类如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>;<br>public <span class="hljs-type">Pet</span>(<span class="hljs-type">String</span> <span class="hljs-class"><span class="hljs-keyword">type</span>) </span>&#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span> = <span class="hljs-class"><span class="hljs-keyword">type</span></span>; &#125;<br>public <span class="hljs-type">String</span> getPetType() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-keyword">type</span>; &#125;<br>&#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pet</span> </span>&#123; public <span class="hljs-type">Dog</span>() &#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;dog&quot;</span>); &#125; &#125;<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Pet</span> </span>&#123; public <span class="hljs-type">Cat</span>() &#123; <span class="hljs-keyword">super</span>(<span class="hljs-string">&quot;cat&quot;</span>); &#125; &#125;<br></code></pre></td></tr></table></figure>

<p>实现一种狗猫队列的结构，要求如下： 用户可以调用 add 方法将 cat 类或 dog 类的实例放入队列中； 用户可以调用 pollAll 方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用 pollDog 方法，将队列中 dog 类的实例按照进队列的先后顺序依次弹出； 用户可以调用 pollCat 方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用 isEmpty 方法，检查队列中是否还有dog或cat的实例； 用户可以调用 isDogEmpty 方法，检查队列中是否有dog类的实例； 用户可以调用 isCatEmpty 方法，检查队列中是否有 cat 类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pet</span> &#123;<br>		<span class="hljs-keyword">private</span> String type;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Pet</span><span class="hljs-params">(String type)</span> &#123;<br>			<span class="hljs-built_in">this</span>.type = type;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPetType</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.type;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;dog&quot;</span>);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pet</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-built_in">super</span>(<span class="hljs-string">&quot;cat&quot;</span>);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PetEnterQueue</span> &#123;<br>		<span class="hljs-keyword">private</span> Pet pet;<br>		<span class="hljs-keyword">private</span> <span class="hljs-type">long</span> count;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">PetEnterQueue</span><span class="hljs-params">(Pet pet, <span class="hljs-type">long</span> count)</span> &#123;<br>			<span class="hljs-built_in">this</span>.pet = pet;<br>			<span class="hljs-built_in">this</span>.count = count;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">getPet</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pet;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.count;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getEnterPetType</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.pet.getPetType();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DogCatQueue</span> &#123;<br>		<span class="hljs-keyword">private</span> Queue&lt;PetEnterQueue&gt; dogQ;<br>		<span class="hljs-keyword">private</span> Queue&lt;PetEnterQueue&gt; catQ;<br>		<span class="hljs-keyword">private</span> <span class="hljs-type">long</span> count;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">DogCatQueue</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-built_in">this</span>.dogQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;PetEnterQueue&gt;();<br>			<span class="hljs-built_in">this</span>.catQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;PetEnterQueue&gt;();<br>			<span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Pet pet)</span> &#123;<br>			<span class="hljs-keyword">if</span> (pet.getPetType().equals(<span class="hljs-string">&quot;dog&quot;</span>)) &#123;<br>				<span class="hljs-built_in">this</span>.dogQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetEnterQueue</span>(pet, <span class="hljs-built_in">this</span>.count++));<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pet.getPetType().equals(<span class="hljs-string">&quot;cat&quot;</span>)) &#123;<br>				<span class="hljs-built_in">this</span>.catQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PetEnterQueue</span>(pet, <span class="hljs-built_in">this</span>.count++));<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;err, not dog or cat&quot;</span>);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Pet <span class="hljs-title function_">pollAll</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.dogQ.isEmpty() &amp;&amp; !<span class="hljs-built_in">this</span>.catQ.isEmpty()) &#123;<br>				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.dogQ.peek().getCount() &lt; <span class="hljs-built_in">this</span>.catQ.peek().getCount()) &#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>				&#125;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.dogQ.isEmpty()) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.catQ.isEmpty()) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;err, queue is empty!&quot;</span>);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Dog <span class="hljs-title function_">pollDog</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isDogQueueEmpty()) &#123;<br>				<span class="hljs-keyword">return</span> (Dog) <span class="hljs-built_in">this</span>.dogQ.poll().getPet();<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Dog queue is empty!&quot;</span>);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> Cat <span class="hljs-title function_">pollCat</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isCatQueueEmpty()) &#123;<br>				<span class="hljs-keyword">return</span> (Cat) <span class="hljs-built_in">this</span>.catQ.poll().getPet();<br>			&#125; <span class="hljs-keyword">else</span><br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Cat queue is empty!&quot;</span>);<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.isEmpty() &amp;&amp; <span class="hljs-built_in">this</span>.catQ.isEmpty();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDogQueueEmpty</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dogQ.isEmpty();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCatQueueEmpty</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.catQ.isEmpty();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的先序、中序、后序遍历"><a href="#二叉树的先序、中序、后序遍历" class="headerlink" title="二叉树的先序、中序、后序遍历"></a>二叉树的先序、中序、后序遍历</h3><h4 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>		<span class="hljs-keyword">public</span> Node left;<br>		<span class="hljs-keyword">public</span> Node right;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>			<span class="hljs-built_in">this</span>.value = data;<br>		&#125;<br>	&#125;<br><br><span class="hljs-comment">//先序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>		preOrderRecur(head.left); <br>		preOrderRecur(head.right);<br>	&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//中序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		inOrderRecur(head.left);<br>		System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>		inOrderRecur(head.right);<br>	&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//后序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		posOrderRecur(head.left);<br>		posOrderRecur(head.right);<br>		System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>以先序遍历二叉树为例，可以发现递归方式首先尝试打印当前结点的值，随后尝试打印左子树，打印完左子树后尝试打印右子树，递归过程的<code>base case</code>是当某个结点为空时停止子过程的展开。这种递归尝试是由二叉树本身的结构所决定的，因为二叉树上的任意结点都可看做一棵二叉树的根结点（即使是叶子结点，也可以看做是一棵左右子树为空的二叉树根结点）。</p>
<h5 id="二叉树的递归序"><a href="#二叉树的递归序" class="headerlink" title="二叉树的递归序"></a>二叉树的递归序</h5><p>观察先序、中序、后序三个递归方法你会发现，不同点在于打印当前结点的值这一操作的时机。<strong>你会发现每个结点会被访问三次</strong>：进入方法时算一次、递归处理左子树完成之后返回时算一次、递归处理右子树完成之后返回时算一次。因此在<code>preOrderRecur</code>中将打印语句放到方法开始时就产生了先序遍历；在<code>inOrderRecur</code>中，将打印语句放到递归处理左子树完成之后就产生了中序遍历；在<code>posOrderRecur</code>中，将打印语句放到递归处理左右子树都完成之后就产生了后序遍历。</p>
<p>例如下列二叉树：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span> / <span class="hljs-string">\</span><br><span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">6</span>  <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>其递归序为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">4</span>，<span class="hljs-number">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，<span class="hljs-number">5</span>，<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">6</span>，<span class="hljs-number">6</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>，<span class="hljs-number">7</span>，<span class="hljs-number">7</span>，<span class="hljs-number">7</span>，<span class="hljs-number">3</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>打印第一次出现的顺序即为先序（中左右）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">3</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>打印第二次出现的顺序即为中序（左中右）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>，<span class="hljs-number">2</span>，<span class="hljs-number">5</span>，<span class="hljs-number">1</span>，<span class="hljs-number">6</span>，<span class="hljs-number">3</span>，<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>

<p>打印打三次出现的顺序即为后序（左右中）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">2</span>，<span class="hljs-number">6</span>，<span class="hljs-number">7</span>，<span class="hljs-number">3</span>，<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="非递归方式"><a href="#非递归方式" class="headerlink" title="非递归方式"></a>非递归方式</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>准备一个栈，先将根节点压栈。循环：从栈顶弹出当前结点并打印其值，再将当前节点的非空右孩子、非空左孩子依次压栈。当栈为空时停止循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>		System.out.print(<span class="hljs-string">&quot;pre-order: &quot;</span>);<br>		<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>			stack.add(head);<br>			<span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>				head = stack.pop();<br>				System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>				<span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>					stack.push(head.right);<br>				&#125;<br>				<span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>					stack.push(head.left);<br>				&#125;<br>			&#125;<br>		&#125;<br>		System.out.println();<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>你会发现压栈的顺序和打印的顺序是相反的，压栈是先根结点，然后有右孩子就压右孩子、有左孩子就压左孩子，这是利用栈的后进先出。每次获取到一棵子树的根节点之后就可以获取其左右孩子，因此无需保留其信息，直接弹出并打印，然后保留其左右孩子到栈中即可。</p>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><ol>
<li>阶段一：子树整条左边界，依次进栈，如没有左边界，进入阶段二。</li>
<li>阶段二：栈中弹出结点 cur 并打印，cur 的右孩子重复阶段一。</li>
</ol>
<p>即对于一棵树，将该树的左边界全部压栈，<code>head</code>的走向是只要左孩子不为空就走向左孩子。当左孩子为空时弹出栈顶结点（此时该结点是一棵左子树为空的树的根结点，根据中序遍历可以直接打印该结点，然后中序遍历该结点的右子树）打印，如果该结点的右孩子非空（说明有右子树），那么将其右孩子压栈，这个右孩子又可能是一棵子树的根节点，因此将这棵子树的左边界压栈，这时回到了开头，以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>		System.out.print(<span class="hljs-string">&quot;in-order: &quot;</span>);<br>		<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>			<span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>					stack.push(head);<br>					head = head.left;<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					head = stack.pop();<br>					System.out.print(head.value + <span class="hljs-string">&quot; &quot;</span>);<br>					head = head.right;<br>				&#125;<br>			&#125;<br>		&#125;<br>		System.out.println();<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>一颗二叉树是可以只由左边界或者右边界分解掉的。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200728123002.png" srcset="/img/loading.gif" lazyload></p>
<p>对于整条左边界来说，压栈顺序是先中再左<code>d,c,b,a</code>，因此弹出顺序为先左再中<code>a,b,c,d</code>，在弹出 a 之后，中途加入 a 的右子树重复这个行为，在弹出 b 之后，中途加入 b 的右子树重复这个行为，以此类推。对于 b 来说，整颗左树先执行了打印，对于 c 和 d 来说也是这样。因此每个结点都是先执行其左子树，再打印自己，再执行其右子树。</p>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>思路一：先序得到的序列是<code>中-左-右</code>，如果压栈的时候先压左孩子，再压右孩子，则可以得到<code>中-右-左</code>，再将这个顺序逆序，则可以得到<code>左-右-中</code>，即为后序遍历。因此准备两个栈，一个栈用来保存遍历时的结点信息，另一个栈用来排列后序（根节点先进栈，右孩子再进，左孩子最后进）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderUnRecur1</span><span class="hljs-params">(Node head)</span> &#123;<br>		System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br>		<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			Stack&lt;Node&gt; s1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>			Stack&lt;Node&gt; s2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>			s1.push(head);<br>			<span class="hljs-keyword">while</span> (!s1.isEmpty()) &#123;<br>				head = s1.pop();<br>				s2.push(head);<br>				<span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>					s1.push(head.left);<br>				&#125;<br>				<span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>					s1.push(head.right);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (!s2.isEmpty()) &#123;<br>				System.out.print(s2.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125;<br>		System.out.println();<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>思路二：只用一个栈。借助两个变量<code>h</code>和<code>c</code>，<code>h</code>代表最近一次打印过的结点，<code>c</code>代表栈顶结点。首先将根结点压栈，此后栈非空循环，令<code>c</code>等于栈顶元素（<code>c=stack.peek()</code>）执行以下三个分支：</p>
<ol>
<li><code>c</code>的左右孩子是否与<code>h</code>相等，如果都不相等，说明<code>c</code>的左右孩子都不是最近打印过的结点，由于左右孩子是左右子树的根节点，根据后根遍历的特点，左右子树肯定都没打印过，那么将左孩子压栈（打印左子树）。</li>
<li>分支1没有执行说明<code>c</code>的左孩子要么不存在；要么左子树刚打印过了；要么右子树刚打印过了。这时如果是前两种情况中的一种，那就轮到打印右子树了，因此如果<code>c</code>的右孩子非空就压栈。</li>
<li>如果前两个分支都没执行，说明<code>c</code>的左右子树都打印完了，因此弹出并打印<code>c</code>结点，更新一下<code>h</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">posOrderUnRecur2</span><span class="hljs-params">(Node h)</span> &#123;<br>		System.out.print(<span class="hljs-string">&quot;pos-order: &quot;</span>);<br>		<span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span>) &#123;<br>			Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>			stack.push(h);<br>			<span class="hljs-type">Node</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>			<span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>				c = stack.peek();<br>				<span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;<br>					stack.push(c.left);<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) &#123;<br>					stack.push(c.right);<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					System.out.print(stack.pop().value + <span class="hljs-string">&quot; &quot;</span>);<br>					h = c;<br>				&#125;<br>			&#125;<br>		&#125;<br>		System.out.println();<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的层序遍历及其扩展"><a href="#二叉树的层序遍历及其扩展" class="headerlink" title="二叉树的层序遍历及其扩展"></a>二叉树的层序遍历及其扩展</h3><h4 id="层序（宽度优先）遍历"><a href="#层序（宽度优先）遍历" class="headerlink" title="层序（宽度优先）遍历"></a>层序（宽度优先）遍历</h4><p>准备一个队列，先把头节点加入，弹出结点并打印，然后先进入其左节点，再进入其右节点，周而复始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node head)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    Queue&lt;Node&gt; queue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(head);<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        Node cur=queue.poll();<br>        System.out.println(cur.value+<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">if</span>(cur.left!=<span class="hljs-literal">null</span>)&#123;<br>            queue.add(cur.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur.right!=<span class="hljs-literal">null</span>)&#123;<br>            queue.add(cur.right);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="层序遍历扩展"><a href="#层序遍历扩展" class="headerlink" title="层序遍历扩展"></a>层序遍历扩展</h4><h5 id="1）求一棵二叉树的最大宽度"><a href="#1）求一棵二叉树的最大宽度" class="headerlink" title="1）求一棵二叉树的最大宽度"></a>1）求一棵二叉树的最大宽度</h5><p>准备一个 HashMap 记录结点的层数，每个结点进队列时设置其层数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">w</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>		&#125;<br>		Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>		queue.add(head);<br>		HashMap&lt;Node, Integer&gt; levelMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>		levelMap.put(head, <span class="hljs-number">1</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">curLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">curLevelNodes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>		<span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;<br>			<span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> queue.poll();<br>			<span class="hljs-type">int</span> <span class="hljs-variable">curNodeLevel</span> <span class="hljs-operator">=</span> levelMap.get(cur);<br>			<span class="hljs-keyword">if</span>(curNodeLevel == curLevel) &#123;<br>				curLevelNodes++;<br>			&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//level!=curLevel</span><br>				max = Math.max(max, curLevelNodes);<br>				curLevel++;<br>				curLevelNodes = <span class="hljs-number">1</span>; <span class="hljs-comment">//已经进入了下一层，为下一层的第一个结点</span><br>			&#125;<br>			<span class="hljs-keyword">if</span>(cur.left !=<span class="hljs-literal">null</span>) &#123;<br>				levelMap.put(cur.left, curNodeLevel+<span class="hljs-number">1</span>);<br>				queue.add(cur.left);<br>			&#125;<br>			<span class="hljs-keyword">if</span>(cur.right !=<span class="hljs-literal">null</span>) &#123;<br>				levelMap.put(cur.right, curNodeLevel+<span class="hljs-number">1</span>);<br>				queue.add(cur.right);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> max;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2）判断一颗二叉树是否是完全二叉树"><a href="#2）判断一颗二叉树是否是完全二叉树" class="headerlink" title="2）判断一颗二叉树是否是完全二叉树"></a>2）判断一颗二叉树是否是完全二叉树</h5><p>整体是宽度优先遍历。在遍历的过程中，需要满足以下条件：</p>
<ul>
<li><p>遍历的任何一个节点，不能有右孩子而没有左孩子；</p>
</li>
<li><p>在上述条件满足的情况下，一旦遇到孩子不双全的节点，后续遇到节点，必须是叶节点。如下图 2 之后的节点都必须是叶子节点。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094945.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCBT</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125;<br>		LinkedList&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>		<span class="hljs-comment">// 是否遇到过左右两个孩子不双全的节点</span><br>		<span class="hljs-type">boolean</span> <span class="hljs-variable">isMeet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		queue.add(head);<br>		<span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>			head = queue.poll();<br>			l = head.left;<br>			r = head.right;<br>			<span class="hljs-keyword">if</span> (<br>					<span class="hljs-comment">// 如果遇到了不双全的节点之后，又发现当前节点不是叶节点</span><br>					(isMeet &amp;&amp; !(l == <span class="hljs-literal">null</span> &amp;&amp; r == <span class="hljs-literal">null</span>)) <br>					|| <br>					(l == <span class="hljs-literal">null</span> &amp;&amp; r != <span class="hljs-literal">null</span>)<br>				) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;			<br>			<span class="hljs-keyword">if</span> (l != <span class="hljs-literal">null</span>) &#123;<br>				queue.add(l);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>				queue.add(r);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span> || r == <span class="hljs-literal">null</span>) &#123;<br>				isMeet = <span class="hljs-literal">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树的递归套路"><a href="#二叉树的递归套路" class="headerlink" title="二叉树的递归套路"></a>二叉树的递归套路</h3><p>出发点：先思考，以任意一个节点 X 为头部的子树的情况下，答案是什么。假设可以问自己的左右子树信息的情况下，则么列出答案的可能性。</p>
<h4 id="1）判断一颗二叉树是否是搜索二叉树"><a href="#1）判断一颗二叉树是否是搜索二叉树" class="headerlink" title="1）判断一颗二叉树是否是搜索二叉树"></a>1）判断一颗二叉树是否是搜索二叉树</h4><blockquote>
<p>搜索二叉树的定义：对于二叉树的任意一棵子树，其左子树上的所有结点的值小于该子树的根节点的值，而其右子树上的所有结点的值大于该子树的根结点的值，并且整棵树上任意两个结点的值不同。</p>
</blockquote>
<p>不使用递归时的解法，写出该二叉树的中序遍历序列，如果该序列是递增的，则为搜索二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">inOrderUnRecur</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>	Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Node&gt;();<br>	<span class="hljs-keyword">while</span> (!stack.isEmpty() || head != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			stack.push(head);<br>			head = head.left;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			head = stack.pop();<br>			<span class="hljs-keyword">if</span> (head.value &lt;= pre) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>			&#125;<br>			pre = head.value;<br>			head = head.right;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>递归套路：思考以 X 为头的子树是否是搜索二叉树，假设可以问左右子树要信息的情况，整理答案的可能性，即以左右子树的信息构建答案。</p>
<p>判断以 x 为头的子树为搜索二叉树需要满足以x下三个条件：</p>
<ul>
<li>左子树整体是搜索二叉树</li>
<li>右子树整体是搜索二叉树</li>
<li>左子树 max&lt; x &lt; 右子树min</li>
</ul>
<p>所以需要问左子树的信息为：1）是否是 BST；2）max。问右子树的信息为：1）是否是 BST；2）min。由于是递归函数，所以对于左右子树的要求和本身节点的要求是一样的，所以需要整合一下。即需要返回三个信息：1）整棵树是否为 BST；2）整棵树的 max；3）整棵树的 min。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBST;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> min;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> max;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">boolean</span> is, <span class="hljs-type">int</span> mi, <span class="hljs-type">int</span> ma)</span> &#123;<br>		isBST = is;<br>		min = mi;<br>		max = ma;<br>	&#125;<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBSTtest</span><span class="hljs-params">(Node head)</span>&#123;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-keyword">return</span> info.isBST;<br>   &#125;<br><br>   <span class="hljs-comment">//以x为头的树，返回info（3个信息）</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-type">Info</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br>	<span class="hljs-type">Info</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br>       <span class="hljs-comment">//整合x的三个信息</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> x.value;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x.value;<br>	<span class="hljs-keyword">if</span>(leftData!=<span class="hljs-literal">null</span>) &#123;<br>		min = Math.min(min, leftData.min);<br>		max = Math.max(max, leftData.max);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(rightData!=<span class="hljs-literal">null</span>) &#123;<br>		min = Math.min(min, rightData.min);<br>		max = Math.max(max, rightData.max);<br>	&#125;<br>	<span class="hljs-type">boolean</span> <span class="hljs-variable">isBST</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>	<span class="hljs-keyword">if</span>(<br>			(leftData != <span class="hljs-literal">null</span> ? (leftData.isBST  &amp;&amp;  leftData.max &lt; x.value) : <span class="hljs-literal">true</span>)<br>			  &amp;&amp;<br>			(rightData !=<span class="hljs-literal">null</span> ? (rightData.isBST  &amp;&amp; rightData.min &gt; x.value) : <span class="hljs-literal">true</span>)	  	<br>			) &#123;			<br>		isBST = <span class="hljs-literal">true</span>;		<br>	&#125;		<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(isBST, min, max);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2）判断一颗二叉树是否是满二叉树"><a href="#2）判断一颗二叉树是否是满二叉树" class="headerlink" title="2）判断一颗二叉树是否是满二叉树"></a>2）判断一颗二叉树是否是满二叉树</h4><blockquote>
<p>满二叉树的条件：如果一棵树的高度为 h，则节点数 N&#x3D;2^h-1。</p>
</blockquote>
<p>递归套路：整理以 x 为头的子树需要返回的信息：1）节点数 N；2）最大高度 h。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> nodes;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> n)</span> &#123;<br>		height = h;<br>		nodes = n;<br>	&#125;		<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-type">Info</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br>	<span class="hljs-type">Info</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">height</span>  <span class="hljs-operator">=</span> Math.max(leftData.height,rightData.height)+<span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">nodes</span> <span class="hljs-operator">=</span> leftData.nodes + rightData.nodes + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(height, nodes);<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> info.nodes;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">H</span> <span class="hljs-operator">=</span> info.height;<br>	<span class="hljs-type">return</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span>= (<span class="hljs-number">1</span> &lt;&lt; H) - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3）判断一颗二叉树是否是平衡二叉树"><a href="#3）判断一颗二叉树是否是平衡二叉树" class="headerlink" title="3）判断一颗二叉树是否是平衡二叉树"></a>3）判断一颗二叉树是否是平衡二叉树</h4><blockquote>
<p>平衡二叉树的定义：当二叉树的任意一棵子树的左子树的高度和右子树的高度相差不超过1时，该二叉树为平衡二叉树。</p>
</blockquote>
<p>满足二叉树是平衡二叉树的条件：</p>
<ul>
<li>左子树是平衡的；</li>
<li>右子树是平衡的；</li>
<li>左子树和右子树的高度差不超过 1。</li>
</ul>
<p>递归套路：整理以 x 为头的子树需要返回的信息：1）是否平衡；2）子树的高度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReturnType</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> isBalanced;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> height;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">ReturnType</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isB, <span class="hljs-type">int</span> hei)</span> &#123;<br>		isBalanced = isB;<br>		height = hei;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReturnType <span class="hljs-title function_">process</span><span class="hljs-params">(Node x)</span> &#123;<br>	<span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(<span class="hljs-literal">true</span>, <span class="hljs-number">0</span>);<br>	&#125;<br>	<span class="hljs-type">ReturnType</span> <span class="hljs-variable">leftData</span> <span class="hljs-operator">=</span> process(x.left);<br>	<span class="hljs-type">ReturnType</span> <span class="hljs-variable">rightData</span> <span class="hljs-operator">=</span> process(x.right);<br>	<span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> Math.max(leftData.height, rightData.height) + <span class="hljs-number">1</span>;<br>	<span class="hljs-type">boolean</span> <span class="hljs-variable">isBalanced</span> <span class="hljs-operator">=</span> leftData.isBalanced &amp;&amp; rightData.isBalanced<br>			&amp;&amp; Math.abs(leftData.height - rightData.height) &lt; <span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReturnType</span>(isBalanced, height);<br>&#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-type">ReturnType</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head);<br>       <span class="hljs-keyword">return</span> info.isBalanced;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4）给定两个二叉树的节点-node1-和-node2，找到他们的最低公共祖先节点"><a href="#4）给定两个二叉树的节点-node1-和-node2，找到他们的最低公共祖先节点" class="headerlink" title="4）给定两个二叉树的节点 node1 和 node2，找到他们的最低公共祖先节点"></a>4）给定两个二叉树的节点 node1 和 node2，找到他们的最低公共祖先节点</h4><p>如下图所示，节点 5 和 8 的最低公共祖先是 1，节点 8 和 9 的最低公共祖先是 3。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802094958.png" srcset="/img/loading.gif" lazyload  />

<p>分析以 x 为头的子树的可能性：</p>
<ul>
<li>既无 o1，也无 o2，则 x 树上不存在最低公共祖先；</li>
<li>o1 和 o2 存在一个，则 x 树上不存在最低公共祖先，但可以记下 o1、o2 的存在状态；</li>
<li>o1 和 o2 都在 x 树上，需要再分情况：<ul>
<li>如果左子树含有一个，右子树含有另一个，则 x 为最低公共祖先；</li>
<li>如果 o1 和 o2 都在左子树上，则左子树上得到的最低公共祖先是 x 树的答案；</li>
<li>如果 o1 和 o2 都在右子树上，则右子树上得到的最低公共祖先是 x 树的答案；</li>
</ul>
</li>
</ul>
<p>递归套路：整理以 x 为头的子树需要返回的信息：1）是否发现了 o1 和 o2 的最低公共祖先，如果发现了，低共不等于空，如果发现了，低共等于空；2）整棵树上是否发现了 o1；3）整棵树上是否发现了 o2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findO1;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> findO2;<br>       <span class="hljs-keyword">public</span> Node findAns;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Info</span><span class="hljs-params">(<span class="hljs-type">boolean</span> f1, <span class="hljs-type">boolean</span> f2,Node f)</span> &#123;<br>           findO1 = f1;<br>           findO2 = f2;<br>           findAns = f;<br>	&#125;		<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Info <span class="hljs-title function_">process</span><span class="hljs-params">(Node x,Node o1,Node o2)</span>&#123;<br>       <span class="hljs-keyword">if</span>(x == <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">false</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>       &#125;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">leftInfo</span> <span class="hljs-operator">=</span> process(x.left,o1,o2);<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">rightInfo</span> <span class="hljs-operator">=</span> process(x.right,o1,o2);<br>       <span class="hljs-comment">// 两个if只会有一个成立，或者都不成立</span><br>       <span class="hljs-keyword">if</span>(leftInfo.findAns != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,leftInfo.findAns)<br>       &#125;<br>       <span class="hljs-keyword">if</span>(rightInfo.findAns != <span class="hljs-literal">null</span>)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,rightInfo.findAns)<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没有发现最低公共祖先</span><br>       <span class="hljs-keyword">if</span>(leftInfo.findO1 &amp;&amp; rightInfo.findO2)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>       &#125;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO2 &amp;&amp; rightInfo.findO1)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没有发现最低公共祖先，而且最低公共祖先不在x处交汇</span><br>       <span class="hljs-comment">// 左右两树只包含o1，或只包含o2，或什么都没发现</span><br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">findO1</span> <span class="hljs-operator">=</span> x == o1;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">findO2</span> <span class="hljs-operator">=</span> x == o2;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO1 || rightInfo.findO1)&#123;<br>           <span class="hljs-keyword">if</span>(findO2)&#123;<span class="hljs-comment">//x为o2</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">false</span>,<span class="hljs-literal">null</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(leftInfo.findO2 || rightInfo.findO2)&#123;<br>           <span class="hljs-keyword">if</span>(findO1)&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">true</span>,<span class="hljs-literal">true</span>,x);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-comment">// 左右两树都没发现o1，或o2</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Info</span>(findO1,findO2,<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">lowestCommon</span><span class="hljs-params">(Node head,Node o1,Node o2)</span>&#123;<br>       <span class="hljs-type">Info</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> process(head,o1,o2);<br>       <span class="hljs-keyword">return</span> info.findAns;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h3 id="二叉树扩展"><a href="#二叉树扩展" class="headerlink" title="二叉树扩展"></a>二叉树扩展</h3><h4 id="1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0-N-，N为这棵树的节点个数"><a href="#1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0-N-，N为这棵树的节点个数" class="headerlink" title="1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0(N)，N为这棵树的节点个数"></a>1）已知一棵完全二叉树，求其节点的个数，要求时间复杂度低于0(N)，N为这棵树的节点个数</h4><p>如果我们遍历二叉树的每个结点来计算结点个数，那么时间复杂度将是<code>O(N)</code>，我们可以log利用满二叉树的结点个数为<code>2^h-1</code>（h为树的层数）来加速这个过程。</p>
<p>首先遍历树的左边界，可以得到树的层数 h，代价是<code>O(logN)</code>。然后遍历右子树的左边界，看是否到达最后一层。</p>
<ul>
<li><p>如果到达了最后一层，则左子树为满二叉树，且左子树的高度为<code>h-1</code>，右子树为完全二叉树，递归求解右子树。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095011.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />
</li>
<li><p>如果没到达最后一层，则右子树为满二叉树，且高度为<code>h-2</code>，左子树为完全二叉树，递归求解左子树。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200802095019.png" srcset="/img/loading.gif" lazyload  style="zoom: 50%;" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nodeNum</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> bs(head, <span class="hljs-number">1</span>, mostLeftLevel(head, <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// level为当前node的层数，h为整棵树的高度，返回以node为头的整棵树的节点个数</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bs</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> h)</span> &#123;<br>	<span class="hljs-keyword">if</span> (level == h) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (mostLeftLevel(node.right, level + <span class="hljs-number">1</span>) == h) &#123;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; (h - level)) + bs(node.right, level + <span class="hljs-number">1</span>, h);<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; (h - level - <span class="hljs-number">1</span>)) + bs(node.left, level + <span class="hljs-number">1</span>, h);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mostLeftLevel</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level)</span> &#123;<br>	<span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>		level++;<br>		node = node.left;<br>	&#125;<br>	<span class="hljs-keyword">return</span> level - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法每层只会遍历一个节点，当遍历该节点时，会计算右子树的左边界，所以时间复杂度为<code>O((logN)^2)</code>。</p>
<h4 id="2）在二叉树中找到一个节点的后继节点"><a href="#2）在二叉树中找到一个节点的后继节点" class="headerlink" title="2）在二叉树中找到一个节点的后继节点"></a>2）在二叉树中找到一个节点的后继节点</h4><p>现在有一种新的二叉树节点类型如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-keyword">public</span> Node right;<br>	<span class="hljs-keyword">public</span> Node parent;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>		<span class="hljs-built_in">this</span>.value = data;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该结构比普通二叉树节点结构多了一个指向父节点的 parent 指针。假设有一棵 Node 类型的节点组成的二叉树，树中每个节点的 parent 指针都正确地指向自己的父节点，头节点的 parent 指向null。只给一个在二叉树中的某个节点 node，请实现返回 node 的后继节点的函数。</p>
<blockquote>
<p>在二叉树的中序遍历的序列中， node的下一个节点叫作node的后继节点，node的前一个节点叫作node的前驱节点。</p>
</blockquote>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808122511.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>如图二叉树的中序遍历顺序为 4,2,5,1,6,3,7。</p>
<p>当然可以将二叉树中序遍历以下，在遍历到该结点的时候标记一下，那么下一个要打印的节点就是该结点的后继节点。其时间复杂度为 O(N)，需要完整遍历整棵二叉树。</p>
<p>使用一种策略利用 parent 指针直接去找节点的后继节点：</p>
<ul>
<li>当前节点 X 有右孩子时，后继节点为右子树上的最左的节点。图中 1 节点的后继为 6 节点。</li>
<li>当前节点 X 无右孩子时，不断往上寻找，直到找到一个节点 Z 是其父节点 S 的左孩子时停止，则父节点 S 是 节点 X 的后继。如果找不到，则没有后继节点。图中 5 节点的后继为 1 节点。</li>
</ul>
<p>这里当前节点的右孩子为空的情况比较难分析，我们可以借助一个指针<code>parent</code>，当前来到的结点<code>node</code>和其父结点<code>parent</code>的<code>parent.left</code>比较，如果相同则直接返回<code>parent</code>，否则<code>node</code>来到<code>parent</code>的位置，<code>parent</code>则继续向上追溯，直到<code>parent</code>到达根节点为止。若<code>node</code>还是不等于<code>parent</code>的左孩子，则返回<code>null</code>表明给出的结点没有后继结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getSuccessorNode</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> node;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> getLeftMost(node.right);<br>		&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 无右子树</span><br>			<span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> node.parent;<br>			<span class="hljs-keyword">while</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; parent.left != node) &#123; <span class="hljs-comment">// 当前节点是其父亲节点右孩子</span><br>				node = parent;<br>				parent = node.parent;<br>			&#125;<br>			<span class="hljs-keyword">return</span> parent;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">getLeftMost</span><span class="hljs-params">(Node node)</span> &#123;<br>		<span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> node;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>			node = node.left;<br>		&#125;<br>		<span class="hljs-keyword">return</span> node;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）"><a href="#3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）" class="headerlink" title="3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）"></a>3）二叉树的序列化和反序列化（深度优先与宽度优先遍历）</h4><p>就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树。</p>
<h5 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h5><p>二叉树的序列化要注意的两个点如下：</p>
<ul>
<li>每序列化一个结点数值之后都应该加上一个结束符表示一个结点序列化的终止，如<code>_</code>。</li>
<li>不能忽视空结点的存在，可以使用一个占位符如<code>#</code>表示空结点的序列化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以head为头的树，请序列化成字符串返回</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialByPre</span><span class="hljs-params">(Node head)</span> &#123;<br>	<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#_&quot;</span>;<br>	&#125;<br>	<span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.value + <span class="hljs-string">&quot;_&quot;</span>;<br>	res += serialByPre(head.left);<br>	res += serialByPre(head.right);<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反序列化：</p>
<p>怎么序列化的，就怎么反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconByPreString</span><span class="hljs-params">(String preStr)</span> &#123;<br>	String[] values = preStr.split(<span class="hljs-string">&quot;_&quot;</span>);<br>	Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;String&gt;();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != values.length; i++) &#123;<br>		queue.add(values[i]);<br>	&#125;<br>	<span class="hljs-keyword">return</span> reconPreOrder(queue);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconPreOrder</span><span class="hljs-params">(Queue&lt;String&gt; queue)</span> &#123;<br>	<span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> queue.poll();<br>	<span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(value));<br>	head.left = reconPreOrder(queue);<br>	head.right = reconPreOrder(queue);<br>	<span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h5><p>序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">serialByLevel</span><span class="hljs-params">(Node head)</span> &#123;<br>		<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#_&quot;</span>;<br>		&#125;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> head.value + <span class="hljs-string">&quot;_&quot;</span>;<br>		Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Node&gt;();<br>		queue.add(head);<br>		<span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>			head = queue.poll();<br>			<span class="hljs-keyword">if</span> (head.left != <span class="hljs-literal">null</span>) &#123;<br>				res += head.left.value + <span class="hljs-string">&quot;_&quot;</span>;<br>				queue.add(head.left);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				res += <span class="hljs-string">&quot;#_&quot;</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (head.right != <span class="hljs-literal">null</span>) &#123;<br>				res += head.right.value + <span class="hljs-string">&quot;_&quot;</span>;<br>				queue.add(head.right);<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				res += <span class="hljs-string">&quot;#_&quot;</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> res;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>反序列化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">reconByLevelString</span><span class="hljs-params">(String levelStr)</span> &#123;<br>		String[] values = levelStr.split(<span class="hljs-string">&quot;_&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> generateNodeByString(values[index++]);<br>		Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Node&gt;();<br>		<span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>			queue.add(head);<br>		&#125;<br>		<span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>			node = queue.poll();<br>			node.left = generateNodeByString(values[index++]);<br>			node.right = generateNodeByString(values[index++]);<br>			<span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>				queue.add(node.left);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>				queue.add(node.right);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> head;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title function_">generateNodeByString</span><span class="hljs-params">(String val)</span> &#123;<br>		<span class="hljs-keyword">if</span> (val.equals(<span class="hljs-string">&quot;#&quot;</span>)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.valueOf(val));<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4）折纸问题"><a href="#4）折纸问题" class="headerlink" title="4）折纸问题"></a>4）折纸问题</h4><p>请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折 1 次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折 2 次，压出折痕后展开，此时有三条折痕，从上到下依次是凹折痕、凹折痕和凸折痕。<br>给定一个输入参数 N，代表纸条都从下边向上方连续对折 N 次。请从上到下打印所有折痕的方向。例如:N&#x3D;1时，打印: 凹；N&#x3D;2时，打印: 凹 凹 凸。</p>
<p>将 3 次对折的结果依次画出，如图所示：</p>
<ul>
<li>头节点为凹折痕</li>
<li>左孩子为凹折痕</li>
<li>右孩子为凸折痕</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141314.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>而最后纸带上的结果为二叉树的中序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllFolds</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> &#123;<br>		printProcess(<span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>	&#125;<br><br>	<span class="hljs-comment">// 递归过程，来到了某一个节点，</span><br>	<span class="hljs-comment">// i是节点的层数，N一共的层数，down == true  凹    down == false 凸</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printProcess</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> N, <span class="hljs-type">boolean</span> down)</span> &#123;<br>		<span class="hljs-keyword">if</span> (i &gt; N) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">true</span>);<br>		System.out.println(down ? <span class="hljs-string">&quot;凹 &quot;</span> : <span class="hljs-string">&quot;凸 &quot;</span>);<br>		printProcess(i + <span class="hljs-number">1</span>, N, <span class="hljs-literal">false</span>);<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>左子树的递归过程如图所示。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200808141900.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<blockquote>
<p>本题的本质是要建立对于问题的敏感度。</p>
</blockquote>
<h2 id="前缀树（字典树）"><a href="#前缀树（字典树）" class="headerlink" title="前缀树（字典树）"></a>前缀树（字典树）</h2><h3 id="前缀树的介绍"><a href="#前缀树的介绍" class="headerlink" title="前缀树的介绍"></a>前缀树的介绍</h3><p>前缀树是一种存储字符串的高效容器，基于此结构的操作有：</p>
<ul>
<li><code>insert</code>插入一个字符串到容器中。</li>
<li><code>search</code>容器中是否存在某字符串，返回该字符串进入到容器的次数，没有则返回0。</li>
<li><code>delete</code>将某个字符串进入到容器的次数减1。</li>
<li><code>prefixNumber</code>返回所有插入操作中，以某个串为前缀的字符串出现的次数。</li>
</ul>
<p>设计思路：该结构的重点实现在于存储。前缀树以字符为存储单位，将其存储在结点之间的树枝上而非结点上，如插入字符串<code>abc</code>之后前缀树如下：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103725.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>每次插入串都要从头结点开始，遍历串中的字符依次向下“铺路”，如上图中的<code>abc</code>3条路。对于每个结点而言，它可以向下铺<code>a~z</code>26条不同的路，假如来到某个结点后，它要向下铺的路（取决于遍历到哪个字符来了）被之前插入串的过程铺过了那么就可以直接走这条路去往下一个结点，否则就要先铺路再去往下一个结点。如再插入串<code>abde</code>和<code>bcd</code>的前缀树将如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103730.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>除了需要在路上存储字符以外，在每次字符串的铺路过程中，还需要在结点中存储两个参数：<code>pass</code> 和 <code>end</code>，前者表示经过该节点的次数，后者表示以该结点结束的次数。有了这两个参数，可以很方便的进行前缀树的<code>search</code>和<code>prefixNumber</code>操作。如插入下列字符串后的完整前缀树将如下所示：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200815103736.png" srcset="/img/loading.gif" lazyload></p>
<p>因此加入一个新字符串的过程为：总是从头节点出发，沿着每一个字符往下走，路存在就复用，不存在就新建，每个结点存储自己的数据项，沿途结点<code>pass++</code> ，最后一个结点 <code>end++</code>。</p>
<h3 id="前缀树的实现"><a href="#前缀树的实现" class="headerlink" title="前缀树的实现"></a>前缀树的实现</h3><h4 id="结点数据结构"><a href="#结点数据结构" class="headerlink" title="结点数据结构"></a>结点数据结构</h4><p>后续的路可以由数组实现，也可以由<code>HashMap</code>或者<code>TreeMap</code> 实现，这里用数组形式表达。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pass;<br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br>		<span class="hljs-comment">// HashMap&lt;Char, Node&gt; nexts;</span><br>		<span class="hljs-comment">// TreeMap&lt;Char, Node&gt; nexts;</span><br>		<span class="hljs-keyword">public</span> TrieNode[] nexts;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">TrieNode</span><span class="hljs-params">()</span> &#123;<br>			pass = <span class="hljs-number">0</span>;<br>			end = <span class="hljs-number">0</span>;<br>			<span class="hljs-comment">// nexts[0] == null 没有走向‘a’的路</span><br>			<span class="hljs-comment">// nexts[0] != null 有走向‘a’的路</span><br>			<span class="hljs-comment">// ...</span><br>			<span class="hljs-comment">// nexts[25] != null 有走向‘z’的路</span><br>			nexts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>[<span class="hljs-number">26</span>];<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h4 id="前缀树结构"><a href="#前缀树结构" class="headerlink" title="前缀树结构"></a>前缀树结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br>		<span class="hljs-keyword">private</span> TrieNode root;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Trie</span><span class="hljs-params">()</span> &#123;<br>			root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>		&#125;<br><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String word)</span> &#123;<br>			<span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			<span class="hljs-type">char</span>[] chs = word.toCharArray();<br>			<span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>			node.pass++;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123; <span class="hljs-comment">// 从左往右遍历字符</span><br>				index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// 由字符，对应成走向哪条路</span><br>				<span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//	没有路就新建</span><br>					node.nexts[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrieNode</span>();<br>				&#125;<br>				node = node.nexts[index];<span class="hljs-comment">// node来到下级结点</span><br>				node.pass++;<br>			&#125;<br>			node.end++;<br>		&#125;<br>		<br>    	<span class="hljs-comment">// delete需要处理pass减成0的特殊情况，此时需要将pass为0之后的结点删除</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String word)</span> &#123;<br>			<span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 确定树中确实加入过word，才删除</span><br>				<span class="hljs-type">char</span>[] chs = word.toCharArray();<br>				<span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>				node.pass--;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>					index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>					<span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;<br>						<span class="hljs-comment">// java实现（JVM自动释放空间） C++ 要遍历到底去析构</span><br>						node.nexts[index] = <span class="hljs-literal">null</span>;<br>						<span class="hljs-comment">// ...</span><br>						<span class="hljs-keyword">return</span>;<br>					&#125;<br>					node = node.nexts[index];<br>				&#125;<br>				node.end--;<br>			&#125;<br>		&#125;<br>		<br>    	<span class="hljs-comment">//delete的cpp实现</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCPP</span><span class="hljs-params">(String word)</span> &#123;<br>			<span class="hljs-keyword">if</span> (search(word) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 确定树中确实加入过word，才删除</span><br>				<span class="hljs-type">char</span>[] chs = word.toCharArray();<br>				<span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>				node.pass--;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>				<span class="hljs-type">TrieNode</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>				<span class="hljs-type">int</span> <span class="hljs-variable">deleteIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>				HashSet&lt;TrieNode&gt; deleteSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>					index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>					<span class="hljs-keyword">if</span> (--node.nexts[index].pass == <span class="hljs-number">0</span>) &#123;<br>						a = a == <span class="hljs-literal">null</span> ? node : a;<br>						deleteIndex = deleteIndex == -<span class="hljs-number">1</span> ? index : deleteIndex;<br><br>						deleteSet.add(node.nexts[index]);<br>					&#125;<br>					node = node.nexts[index];<br>				&#125;<br>				node.end--;<br>				<br>				a.nexts[deleteIndex] = <span class="hljs-literal">null</span>;<br>				<br>				<span class="hljs-comment">// deleteSet ... 析构</span><br><br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// 计算word这个单词之前加入过几次</span><br>    	<span class="hljs-comment">// 则么插入就则么查找</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String word)</span> &#123;<br>			<span class="hljs-keyword">if</span> (word == <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>			<span class="hljs-type">char</span>[] chs = word.toCharArray();<br>			<span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>				index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>				<span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//提前没路说明之前没有加入过word</span><br>					<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>				&#125;<br>				node = node.nexts[index];<br>			&#125;<br>			<span class="hljs-keyword">return</span> node.end;<br>		&#125;<br><br>		<span class="hljs-comment">// 所有加入的字符串中，有几个是以pre这个字符串作为前缀的</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">prefixNumber</span><span class="hljs-params">(String pre)</span> &#123;<br>			<span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>			&#125;<br>			<span class="hljs-type">char</span>[] chs = pre.toCharArray();<br>			<span class="hljs-type">TrieNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chs.length; i++) &#123;<br>				index = chs[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>				<span class="hljs-keyword">if</span> (node.nexts[index] == <span class="hljs-literal">null</span>) &#123;<br>					<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>				&#125;<br>				node = node.nexts[index];<br>			&#125;<br>			<span class="hljs-keyword">return</span> node.pass;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="前缀树的相关问题"><a href="#前缀树的相关问题" class="headerlink" title="前缀树的相关问题"></a>前缀树的相关问题</h3><p>一个字符串类型的数组 arr1，另一个字符串类型的数组 arr2：</p>
<ul>
<li>arr2 中有哪些字符，是 arr1 中出现的？请打印</li>
<li>arr2 中有哪些字符，是作为 arr1 中某个字符串前缀出现的？请打印</li>
<li>arr2 中有哪些字符，是作为 arr1 中某个字符串前缀出现的？请打印 arr2 中出现次数最大的前缀。</li>
</ul>
<h2 id="哈希表简单介绍"><a href="#哈希表简单介绍" class="headerlink" title="哈希表简单介绍"></a>哈希表简单介绍</h2><ol>
<li>哈希表在使用层面上可以理解为一种集合结构；</li>
<li>如果只有 key，没有伴随数据 value，可以使用 HashSet 结构(C++中叫 unordered_set );</li>
<li>如果既有 key，又有伴随数据 value，可以使用 HashMap 结构(C++中叫 unordered_map);</li>
<li>有无伴随数据，是 HashMap 和 HashSet 唯一的区别，底层的实际结构是一回事；</li>
<li>使用哈希表增(put) 、删(remove)、改(put)和查(get)的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大；</li>
<li>放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小；</li>
<li>放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地<br>址的大小。</li>
</ol>
<h2 id="有序表简单介绍"><a href="#有序表简单介绍" class="headerlink" title="有序表简单介绍"></a>有序表简单介绍</h2><ol>
<li>有序表在使用层面上可以理解为一种集合结构；</li>
<li>如果只有 key，没有伴随数据 value，可以使用 TreeSet 结构(C++中叫 Set )；</li>
<li>如果既有 key，又有伴随数据 value，可以使用 TreeMap 结构(C++中叫 Map )；</li>
<li>有无伴随数据，是 TreeSet 和 TreeMap 唯一的区别，底层的实际结构是一回事；</li>
<li>有序表和哈希表的区别是，有序表把 key 按照顺序组织起来，而哈希表完全不组织；</li>
<li>红黑树、AVL树、size-balance-tree和跳表等都属于有序表结构，只是底层具体实现<br>不同；</li>
<li>放入有序表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小；</li>
<li>放入有序表的东西，如果不是基础类型，必须提供比较器，内部按引用传递，内存占<br>用是这个东西内存地址的大小；</li>
<li>不管是什么底层具体实现，只要是有序表，都有以下固定的基本功能和固定的时间复<br>杂度。<ul>
<li>void put(K key, V value)：将一个（key，value）记录加入到表中，或者将 key 的记录<br>更新成 value。</li>
<li>V get(K key)：根据给定的 key，查询 value 并返回。</li>
<li>void remove(K key)：移除 key 的记录。</li>
<li>boolean containsKey(K key)：询问是否有关于 key 的记录。</li>
<li>K firstKey()：返回所有键值的排序结果中，最左（最小）的那个。</li>
<li>K lastKey()：返回所有键值的排序结果中，最右（最大）的那个。</li>
<li>K floorKey(K key)：如果表中存入过 key，返回 key；否则返回所有键值的排序结果中，<br>key的前一个。</li>
<li>K ceilingKey(K key)：如果表中存入过key，返回key；否则返回所有键值的排序结果中，key的后一个</li>
<li>以上所有操作时间复杂度都是 <code>O(logN)</code>，N 为有序表含有的记录数。</li>
</ul>
</li>
</ol>
<h1 id="矩阵打印和查找问题"><a href="#矩阵打印和查找问题" class="headerlink" title="矩阵打印和查找问题"></a>矩阵打印和查找问题</h1><h2 id="1）转圈打印矩阵"><a href="#1）转圈打印矩阵" class="headerlink" title="1）转圈打印矩阵"></a>1）转圈打印矩阵</h2><p>给定一个整型矩阵matrix，请按照转圈的方式打印它。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100228.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">12</span> <span class="hljs-number">16</span> <span class="hljs-number">15</span> <span class="hljs-number">14</span> <span class="hljs-number">13</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<p>思路：这类问题需要将思维打开，从宏观的层面去找出问题存在的共性从而求解。如果你的思维局限在1是如何变到2的、4是怎么变到8的、11之后为什么时10、它们之间有什么关联，那么你就陷入死胡同了。</p>
<p>从宏观的层面找共性，其实转圈打印的过程就是不断顺时针打印外围元素的过程，只要给你一个左上角的点（如<code>(0,0)</code>）和右下角的点（如<code>(3,3)</code>），你就能够打印出<code>1 2 3 4 8 12 16 15 14 13 9 5</code>；同样，给你<code>(1,1)</code>和<code>(2,2)</code>，你就能打印出<code>6 7 11 10</code>。这个根据两点打印正方形上元素的过程可以抽取出来，整个问题也就迎刃而解了。</p>
<p>打印一个矩阵某个正方形上的点的逻辑如下：</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141429.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">spiralOrderPrint</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC) &#123;<br>			printEdge(matrix, tR++, tC++, dR--, dC--);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC)</span> &#123;<br>		<span class="hljs-keyword">if</span> (tR == dR) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tC; i &lt;= dC; i++) &#123;<br>				System.out.print(m[tR][i] + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tC == dC) &#123;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> tR; i &lt;= dR; i++) &#123;<br>				System.out.print(m[i][tC] + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">curC</span> <span class="hljs-operator">=</span> tC;<br>			<span class="hljs-type">int</span> <span class="hljs-variable">curR</span> <span class="hljs-operator">=</span> tR;<br>			<span class="hljs-keyword">while</span> (curC != dC) &#123;<br>				System.out.print(m[tR][curC] + <span class="hljs-string">&quot; &quot;</span>);<br>				curC++;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (curR != dR) &#123;<br>				System.out.print(m[curR][dC] + <span class="hljs-string">&quot; &quot;</span>);<br>				curR++;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (curC != tC) &#123;<br>				System.out.print(m[dR][curC] + <span class="hljs-string">&quot; &quot;</span>);<br>				curC--;<br>			&#125;<br>			<span class="hljs-keyword">while</span> (curR != tR) &#123;<br>				System.out.print(m[curR][tC] + <span class="hljs-string">&quot; &quot;</span>);<br>				curR--;<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2）旋转正方形矩阵"><a href="#2）旋转正方形矩阵" class="headerlink" title="2）旋转正方形矩阵"></a>2）旋转正方形矩阵</h2><p>给定一个整型正方形矩阵 matrix，请把该矩阵调整成顺时针旋转 90 度的样子，要求额外空间复杂度为 O(1)。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141435.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>思路：拿上图举例，首先选取矩阵四个角上的点<code>1,3,9,7</code>，按顺时针的方向<code>1</code>到<code>3</code>的位置（<code>1-&gt;3</code>）、<code>3-&gt;9</code>、<code>9-&gt;7</code>、<code>7-&gt;1</code>，这样对于旋转后的矩阵而言，这四个点已经调整好了。接下来只需调整<code>2,6,8,4</code>的位置，调整方法是一样的。只需对矩阵第一行的前 n-1 个点采用同样的方法进行调整、对矩阵第二行的前前n-3个点……，那么调整 n 阶矩阵就容易了。</p>
<p>这也是在宏观上观察数据变动的一般规律，找到以不变应万变的通解（给定一个点，确定矩阵上以该点为角的正方形，将该正方形旋转90°），整个问题就不攻自破了。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141443.jpeg" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (tR &lt; dR) &#123;<br>			rotateEdge(matrix, tR++, tC++, dR--, dC--);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotateEdge</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> dC - tC; <br>		<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i != times; i++) &#123;<br>			tmp = m[tR][tC + i];<br>			m[tR][tC + i] = m[dR - i][tC];<br>			m[dR - i][tC] = m[dR][dC - i];<br>			m[dR][dC - i] = m[tR + i][dC];<br>			m[tR + i][dC] = tmp;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3）“之”字形打印矩阵"><a href="#3）“之”字形打印矩阵" class="headerlink" title="3）“之”字形打印矩阵"></a>3）“之”字形打印矩阵</h2><p>给定一个矩阵 matrix，按照“之”字形的方式打印这个矩阵。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141454.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>对如上矩阵的打印结果如下（要求额外空间复杂度为<code>O(1)</code>）：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">13</span> <span class="hljs-number">8</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">11</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">12</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<p>思路：此题也是需要从宏观上找出一个共性：给你两个，你能否将该两点连成的45°斜线上的点按给定的打印方向打印出来。拿上图举例，给出<code>(2,0)</code>、<code>(0,2)</code>和<code>turnUp=true</code>，应该打印出<code>13,8,3</code>。那么整个问题就变成了两点的走向问题了，开始时两点均为<code>(0,0)</code>，然后一个点往下走，另一个点往右走（如<code>1-&gt;7</code>，<code>1-&gt;2</code>）；当往下走的点是边界点时就往右走（如<code>13-&gt;14</code>），当往右走的点到边界时就往下走（如<code>6-&gt;12</code>）。每次两点走一步，并打印两点连线上的点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMatrixZigZag</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">tC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">dC</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">endR</span> <span class="hljs-operator">=</span> matrix.length - <span class="hljs-number">1</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">endC</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>		<span class="hljs-type">boolean</span> <span class="hljs-variable">fromUp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">while</span> (tR != endR + <span class="hljs-number">1</span>) &#123;<br>			printLevel(matrix, tR, tC, dR, dC, fromUp);<br>			tR = tC == endC ? tR + <span class="hljs-number">1</span> : tR;<br>			tC = tC == endC ? tC : tC + <span class="hljs-number">1</span>;<br>			dC = dR == endR ? dC + <span class="hljs-number">1</span> : dC;<br>			dR = dR == endR ? dR : dR + <span class="hljs-number">1</span>;<br>			fromUp = !fromUp;<br>		&#125;<br>		System.out.println();<br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLevel</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] m, <span class="hljs-type">int</span> tR, <span class="hljs-type">int</span> tC, <span class="hljs-type">int</span> dR, <span class="hljs-type">int</span> dC,</span><br><span class="hljs-params">			<span class="hljs-type">boolean</span> f)</span> &#123;<br>		<span class="hljs-keyword">if</span> (f) &#123;<br>			<span class="hljs-keyword">while</span> (tR != dR + <span class="hljs-number">1</span>) &#123;<br>				System.out.print(m[tR++][tC--] + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">while</span> (dR != tR - <span class="hljs-number">1</span>) &#123;<br>				System.out.print(m[dR--][dC++] + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4）在行列都排好序的矩阵中找数"><a href="#4）在行列都排好序的矩阵中找数" class="headerlink" title="4）在行列都排好序的矩阵中找数"></a>4）在行列都排好序的矩阵中找数</h2><p>给定一个有 N*M 的整型矩阵 matrix 和一个整数 K，matrix 的每一行和每一 列都是排好序的。实现一个函数，判断 K 是否在 matrix 中。 例如：0 1 2 5 2 3 4 7 44 4 8 5 7 7 9 如果 K 为7，返回true；如果 K 为 6，返回false。要求时间复杂度为O(N+M)，额外空间复杂度为 O(1)。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141502.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>思路：从矩阵右上角的点开始取点与该数比较，如果大于该数，那么说明这个点所在的列都不存在该数，将这个点左移；如果这个点上的数小于该数，那么说明这个点所在的行不存在该数，将这个点下移。直到找到与该数相等的点为止。最坏的情况是，该数只有一个且在矩阵左下角上，那么时间复杂度为<code>O(M-1+N-1)=O(M+N)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContains</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> K)</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">while</span> (row &lt; matrix.length &amp;&amp; col &gt; -<span class="hljs-number">1</span>) &#123;<br>			<span class="hljs-keyword">if</span> (matrix[row][col] == K) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[row][col] &gt; K) &#123;<br>				col--;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				row++;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="二分法的详解与扩展"><a href="#二分法的详解与扩展" class="headerlink" title="二分法的详解与扩展"></a>二分法的详解与扩展</h1><h2 id="1）在一个有序数组中，找某个数是否存在"><a href="#1）在一个有序数组中，找某个数是否存在" class="headerlink" title="1）在一个有序数组中，找某个数是否存在"></a>1）在一个有序数组中，找某个数是否存在</h2><p><strong>在一个有序序列中查找一个元素可以使用二分法（也称折半法）</strong>。原理就是将查找的元素与序列的中位数进行比较，如果小于则去掉中位数及其之后的序列，如果大于则去掉中位数及其之前的序列，如果等于则找到了。如果不等于那么再将其与剩下的序列继续比较直到找到或剩下的序列为空为止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sortedArr, <span class="hljs-type">int</span> num)</span> &#123;<br>	<span class="hljs-keyword">if</span> (sortedArr == <span class="hljs-literal">null</span> || sortedArr.length == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> sortedArr.length - <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// L..R</span><br>	<span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>		mid = L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// mid = (L + R) / 2</span><br>		<span class="hljs-keyword">if</span> (sortedArr[mid] == num) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sortedArr[mid] &gt; num) &#123;<br>			R = mid - <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			L = mid + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> sortedArr[L] == num;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>算法的时间复杂度为<code>O(logn)</code>（如果没有特别说明，log均以2为底），每次砍掉一半。</p>
<h2 id="2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置"><a href="#2）在一个有序数组中，找-gt-x3D-某个数最左侧的位置" class="headerlink" title="2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置"></a>2）在一个有序数组中，找&gt;&#x3D;某个数最左侧的位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在arr上，找满足&gt;=value的最左位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nearestIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> value)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">L</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">R</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 记录最左的对号</span><br>	<span class="hljs-keyword">while</span> (L &lt;= R) &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> L + ((R - L) &gt;&gt; <span class="hljs-number">1</span>);<br>		<span class="hljs-keyword">if</span> (arr[mid] &gt;= value) &#123;<br>			index = mid;<br>			R = mid - <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			L = mid + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3）局部最小值问题"><a href="#3）局部最小值问题" class="headerlink" title="3）局部最小值问题"></a>3）局部最小值问题</h2><p>局部最小的概念：</p>
<ul>
<li>[0] &lt; [i]，0是局部最小</li>
<li>[N-1] &lt; [N-2]，N-1 是局部最小</li>
<li>[i-1] &gt; [i] &lt; [i+1]，i 是局部最小</li>
</ul>
<p>要求：在一个无序数组（相邻位置的数据不相等）上返回任意一个局部最小值的位置。</p>
<p>思路：</p>
<p>1）比较是否 [0] &lt; [1] ，若是，直接返回0；</p>
<p>2）比较是否 [N-1] &lt; [N-2] ，若是，直接返回 N-1；</p>
<ol start="3">
<li>若以上均不是，则 [0]-&gt;[1] 呈下降趋势，[N-2]-&gt;[N-1] 呈上升趋势，[0] 到 [N-1] 上必存在局部最小，必有拐点。然后寻找  [0] 和 [N-1] 的中间位置 M ，比较 [M-1] , [M] , [M+1] 的大小。若 [M] 最小，直接返回；若 [M] 大于 [M-1] ，则 [0] 到 [M] 上必存在局部最小；若 [M] 大于 [M+1] ，则 [M] 到 [N-1] 上必存在局部最小，以此类推。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/img/20200723102118.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLessIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// no exist</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> (arr.length == <span class="hljs-number">1</span> || arr[<span class="hljs-number">0</span>] &lt; arr[<span class="hljs-number">1</span>]) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (arr[arr.length - <span class="hljs-number">1</span>] &lt; arr[arr.length - <span class="hljs-number">2</span>]) &#123;<br>		<span class="hljs-keyword">return</span> arr.length - <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">2</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>		mid = (left + right) / <span class="hljs-number">2</span>;<br>		<span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid - <span class="hljs-number">1</span>]) &#123;<br>			right = mid - <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[mid] &gt; arr[mid + <span class="hljs-number">1</span>]) &#123;<br>			left = mid + <span class="hljs-number">1</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">return</span> mid;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<ul>
<li>不一定是有序数组才能用二分法</li>
<li>优化算法有两个方式：数据状况和问题性质</li>
</ul>
</blockquote>
<h1 id="异或运算的性质与扩展"><a href="#异或运算的性质与扩展" class="headerlink" title="异或运算的性质与扩展"></a>异或运算的性质与扩展</h1><h2 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h2><p>异或运算：相异为1，相同为0，即<strong>无进位加法</strong>。</p>
<p>性质：</p>
<ul>
<li>0^N &#x3D;&#x3D; N  </li>
<li>N^N &#x3D;&#x3D; 0</li>
<li>异或运算满足交换律和结合率</li>
</ul>
<h2 id="1）不用额外变量交换两个数"><a href="#1）不用额外变量交换两个数" class="headerlink" title="1）不用额外变量交换两个数"></a>1）不用额外变量交换两个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 交换arr的i和j位置上的值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-comment">//一种异或操作来交换两数的位置</span><br>    <span class="hljs-comment">//假设arr[i]=a,arr[j]=b</span><br>    arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b,arr[j]=b</span><br>	arr[j] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b,arr[j]=a^b^b=a</span><br>	arr[i] = arr[i] ^ arr[j]; <span class="hljs-comment">//arr[i]=a^b^a=b,arr[j]=a</span><br>    <span class="hljs-comment">//int tmp = arr[i];</span><br>	<span class="hljs-comment">//arr[i] = arr[j];</span><br>	<span class="hljs-comment">//arr[j] = tmp;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数"><a href="#2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数" class="headerlink" title="2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数"></a>2）一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到这一个数</h2><p>思路：设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddTimesNum1</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">eor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : arr) &#123;<br>		eor ^= cur;<br>	&#125;<br>	System.out.println(eor);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数"><a href="#3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数" class="headerlink" title="3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数"></a>3）一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数</h2><p>思路：</p>
<ol>
<li>设置 eor 为0，将 eor 与数组中每一个值异或，最后的值即为出现了奇数次的两种数的异或结果，即 a^b，eor !&#x3D; 0。</li>
<li>eor 不为 0，其数值必然有一个位置上是1，提取 eor 最右的1，假设为第 n 位，a 和 b 在第 n 位不同。</li>
<li>将数组中的数与提取的结果相与，将数分为两类，即第 n 位为 1 的数和第 n 位不为 1 的数，a 和 b 不在同一类。</li>
<li>设置 eor’ （onlyOne）为 0 ，将两类中的一类与 eor’ 进行异或，最后的值即为其中一个出现了奇数次的数。</li>
<li>将  eor’ 和 eor 进行异或，则得到另一个出现了奇数次的数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printOddTimesNum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">eor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; arr.length;i++) &#123;<br>		eor ^= arr[i];<br>	&#125;<br>	<span class="hljs-comment">// eor = a ^ b</span><br>	<span class="hljs-comment">// eor != 0</span><br>	<span class="hljs-comment">// eor必然有一个位置上是1</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">rightOne</span> <span class="hljs-operator">=</span> eor &amp; (~eor + <span class="hljs-number">1</span>); <span class="hljs-comment">// 提取出最右的1</span><br>	<span class="hljs-type">int</span> <span class="hljs-variable">onlyOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// eor&#x27;</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cur : arr) &#123;<br>		<span class="hljs-keyword">if</span> ((cur &amp; rightOne) == <span class="hljs-number">1</span>) &#123;<br>			onlyOne ^= cur;<br>		&#125;<br>	&#125;<br>	System.out.println(onlyOne + <span class="hljs-string">&quot; &quot;</span> + (eor ^ onlyOne));<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h1><h2 id="贪心算法介绍"><a href="#贪心算法介绍" class="headerlink" title="贪心算法介绍"></a>贪心算法介绍</h2><blockquote>
<p>贪心算法：</p>
<p>在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到<br>一个答案的算法。</p>
<p>也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。</p>
<p>贪心策略：局部最优 -?-&gt; 整体最优</p>
<p>需找到是局部最优同时也是整体最优的结果。</p>
</blockquote>
<p>贪心策略在实现时，经常使用到的技巧：</p>
<ul>
<li>根据某标准建立一个比较器来排序。</li>
<li>根据某标准建立一个比较器来组成堆。</li>
</ul>
<h2 id="贪心算法在笔试时的解题套路"><a href="#贪心算法在笔试时的解题套路" class="headerlink" title="贪心算法在笔试时的解题套路"></a>贪心算法在笔试时的解题套路</h2><ol>
<li>实现一个不依靠贪心策略的正确解法 X，可以用最暴力的尝试；</li>
<li>脑补出贪心策略 A、贪心策略 B、贪心策略 C…</li>
<li>用解法 X 和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确；</li>
<li>不要去纠结贪心策略的证明（贪心策略的证明非常难）。</li>
</ol>
<h2 id="1）拼接最小字典序"><a href="#1）拼接最小字典序" class="headerlink" title="1）拼接最小字典序"></a>1）拼接最小字典序</h2><p>给定一个字符串类型的数组 strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最小的字典序。</p>
<p>可以提出的贪心策略：（需注意：提出的贪心策略需具有正确性，在此题中表现为排序方式需要具有传递性，“剪刀石头布”就是一种不具有传递性的排序方式。）</p>
<ul>
<li><p>把数组按照字典序排序，然后从头到尾连接。</p>
<blockquote>
<p>str1，str2，谁字典序低，谁在前。</p>
</blockquote>
<p>但这很容易证明是错的，比如 [“b”,”ba”] 的排序结果是 [“b”,”ba”]，拼接结果是 “bba”，但 “bab” 的字典序更小。 </p>
</li>
<li><p>正确策略：将有序字符串数组从头到尾两两拼接时，应取两两拼接的拼接结果中字典序较小的那个。</p>
<blockquote>
<p>如果令.代表拼接符号，str1.str2&lt;&#x3D;str2.str1，str1 在前，否则，str2 在前。</p>
</blockquote>
<p>证明如下：</p>
<blockquote>
<p>即如果 str1.str2 &lt; str2.str2 且 str2.str3 &lt; str3.str2，那么一定有str1.str3 &lt; str3.str1。这可以使用数学归纳法来证明。如果将 a<del>z 对应到0</del>25，比较两个字符串的字典序的过程，其实就是比较两个 26 进制数大小的过程。str1.str2 拼接的过程可以看做两个 26 进制数拼接的过程。若将两字符串解析成数字 int1 和 int2，那么拼接就对应 int1 * 26^(str2的长度) + int2，那么证明过程就变成了两个整数不等式递推另一个不等式了。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt; &#123;<br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String a, String b)</span> &#123;<br>			<span class="hljs-keyword">return</span> (a + b).compareTo(b + a);<br>		&#125;<br>	&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">lowestString</span><span class="hljs-params">(String[] strs)</span> &#123;<br>	<span class="hljs-keyword">if</span> (strs == <span class="hljs-literal">null</span> || strs.length == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>	&#125;<br>	Arrays.sort(strs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComparator</span>());<br>	<span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strs.length; i++) &#123;<br>		res += strs[i];<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2）金条和铜板"><a href="#2）金条和铜板" class="headerlink" title="2）金条和铜板"></a>2）金条和铜板</h2><p>一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为 20 的金条，不管切成长度多大的两半，都要花费 20 个铜板。一群人想整分整块金条，怎么分最省铜板?</p>
<p>例如，给定数组 {10,20,30}，代表一共三个人，整块金条长度为 10+20+30&#x3D;60。金条要分成 10,20,30 三个部分。 如果先把长度 60 的金条分成 10 和 50，花费 60；再把长度 50 的金条分成 20 和 30，花费 50；一共花费 110 铜板。但是如果先把长度 60 的金条分成 30 和 30，花费 60；再把长度 30 金条分成 10 和 20，花费 30；一共花费 90 铜板。</p>
<p>输入一个数组，返回分割的最小代价。</p>
<p>贪心策略：先把两个小的合在一起，依次逆着过去。</p>
<p>具体操作：将给定的数组中的元素扔进小根堆，每次从小根堆中先后弹出两个元素，这两个元素的和就是某次分割得到的这两个元素的花费，再将这个和扔进小根堆。周而复始，直到小根堆中只有一个元素为止。合的顺序反过来即是切的顺序。这样做即可得到最小代价。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102221702.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lessMoney</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// PriorityQueue是Java语言对堆结构的一个实现，默认将按自然顺序的最小元素放在堆顶</span><br>	PriorityQueue&lt;Integer&gt; pQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		pQ.add(arr[i]);<br>	&#125;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (pQ.size() &gt; <span class="hljs-number">1</span>) &#123;<br>		cur = pQ.poll() + pQ.poll();<br>		sum += cur;<br>		pQ.add(cur);<br>	&#125;<br>	<span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>本质上都是按照某一种标准排序之后依次处理。</p>
</blockquote>
<h2 id="3）会议室项目宣讲"><a href="#3）会议室项目宣讲" class="headerlink" title="3）会议室项目宣讲"></a>3）会议室项目宣讲</h2><p>一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次。</p>
<p>可以提出的贪心策略： </p>
<ul>
<li>开始时间最早的项目先安排。反例：开始时间最早，但持续时间占了一整天，其他项目无法安排。 </li>
<li>持续时间最短的项目先安排。反例：这样安排会导致结束时间在此期间和开始时间在此期间的所有项目不能安排。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220220.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<ul>
<li>最优策略：最先结束的项目先安排。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030220310.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>最优策略实现思路：</p>
<ol>
<li>从项目集合选择一个项目 x，这个 x 是在当前所有项目中结束最早的（end 最小）。</li>
<li>把所有与 x 时间冲突的项目从项目集合中删除。</li>
<li>重复步骤 1 和 2，直到项目集合为空为止。之前选出的那些 x 就是最多的项目宣讲场次。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Program</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>		<span class="hljs-built_in">this</span>.start = start;<br>		<span class="hljs-built_in">this</span>.end = end;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgramComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Program&gt; &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Program o1, Program o2)</span> &#123;<br>		<span class="hljs-keyword">return</span> o1.end - o2.end;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// timePoint 此时来到的时间点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bestArrange</span><span class="hljs-params">(Program[] programs, <span class="hljs-type">int</span> timePoint)</span> &#123;<br>	Arrays.sort(programs, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProgramComparator</span>());<br>	<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// 从左往右依次遍历所有的会议</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; programs.length; i++) &#123;<br>		<span class="hljs-keyword">if</span> (timePoint &lt;= programs[i].start) &#123;<br>			result++;<br>			timePoint = programs[i].end;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4）IPO"><a href="#4）IPO" class="headerlink" title="4）IPO"></a>4）IPO</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：正数数组 costs、正数数组 profits、正数 k、正数 m。<br>含义：costs<span class="hljs-selector-attr">[i]</span> 表示 <span class="hljs-selector-tag">i</span> 号项目的花费、profits<span class="hljs-selector-attr">[i]</span> 表示 <span class="hljs-selector-tag">i</span> 号项目在扣除花费之后还能挣到的钱（利润）、k 表示你只能串行的最多做 k 个项目、m 表示你初始的资金。<br>说明：你每做完一个项目，马上获得的收益（纯利润），可以支持你去做下一个项目。<br>输出：你最后获得的最大钱数。<br></code></pre></td></tr></table></figure>

<p>贪心策略：借助两个堆，一个是存放各个项目花费的小根堆、另一个是存放各个项目利润的大根堆。首先将所有项目放入小根堆而大根堆为空，对于手头上现有的资金（本金），将能做的项目（成本低于现有资金）从小根堆依次弹出并放入到大根堆，再弹出大根堆堆顶项目来完成，完成后根据利润更新本金。本金更新后，再将小根堆中能做的项目弹出加入到大根堆中，再弹出大根堆中的堆顶项目来做，重复此操作，直到某次本金更新和两个堆更新后大根堆无项目可做或者完成的项目个数已达 k 个为止。</p>
<p>下图为图示例子做完三个项目后的结果。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201105145756.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> p;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> c;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> c)</span> &#123;<br>		<span class="hljs-built_in">this</span>.p = p;<br>		<span class="hljs-built_in">this</span>.c = c;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MinCostComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt; &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;<br>		<span class="hljs-keyword">return</span> o1.c - o2.c; <span class="hljs-comment">// 升序，由此构造的堆将把花费最小项目的放到堆顶</span><br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxProfitComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt; &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;<br>		<span class="hljs-keyword">return</span> o2.p - o1.p;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaximizedCapital</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> W, <span class="hljs-type">int</span>[] Profits, <span class="hljs-type">int</span>[] Capital)</span> &#123;<br>	PriorityQueue&lt;Node&gt; minCostQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MinCostComparator</span>());<br>	PriorityQueue&lt;Node&gt; maxProfitQ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxProfitComparator</span>());<br>	<span class="hljs-comment">// 所有项目扔到被锁池中, 花费组织的小根堆</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Profits.length; i++) &#123;<br>		minCostQ.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Profits[i], Capital[i]));<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 进行K轮</span><br>		<span class="hljs-comment">// 能力所及的项目，全解锁</span><br>		<span class="hljs-keyword">while</span> (!minCostQ.isEmpty() &amp;&amp; minCostQ.peek().c &lt;= W) &#123;<br>			maxProfitQ.add(minCostQ.poll());<br>		&#125;<br>        <span class="hljs-comment">// 无法继续解锁项目，做不完K个项目提前返回</span><br>		<span class="hljs-keyword">if</span> (maxProfitQ.isEmpty()) &#123;<br>			<span class="hljs-keyword">return</span> W;<br>		&#125;<br>		W += maxProfitQ.poll().p;<br>	&#125;<br>	<span class="hljs-keyword">return</span> W;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>经验：贪心策略相关的问题，累积经验就好，不必花费大量精力去证明。解题的时候要么找相似点，要么脑补策略然后用对数器、测试用例去证。</p>
</blockquote>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="对数器的概念和使用"><a href="#对数器的概念和使用" class="headerlink" title="对数器的概念和使用"></a>对数器的概念和使用</h2><ol>
<li>对于一个你想要测的方法a</li>
<li>实现功能与该算法相同但绝对正确、复杂度不好但是容易实现的方法b</li>
<li>实现一个随机样本产生器</li>
<li>实现比对：把方法a和方法b跑相同的随机样本，看看得到的结果是否一样。</li>
<li>如果有一个随机样本使得比对结果不一致，打印样本进行人工干预，改对方法a或者方法b</li>
<li>当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</li>
</ol>
<p>对数器使用案例——对于选择排序进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.有一个自写的算法，但不知其健壮性（是否会有特殊情况使程序异常中断甚至崩溃）和正确性</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span> || arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// i ~ N-1</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++) &#123; <span class="hljs-comment">// i ~ N-1 上找最小值的下标 </span><br>			minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;<br>		&#125;<br>		swap(arr, i, minIndex);<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> arr[i];<br>	arr[i] = arr[j];<br>	arr[j] = tmp;<br>&#125;<br><br><span class="hljs-comment">//2、实现一个功能相同、绝对正确但复杂度不好的算法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">comparator</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	Arrays.sort(arr);<br>&#125;<br><br><span class="hljs-comment">//3、实现一个能够产生随机简短样本的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] generateRandomArray(<span class="hljs-type">int</span> maxSize, <span class="hljs-type">int</span> maxValue) &#123;<br>	<span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[(<span class="hljs-type">int</span>) ((maxSize + <span class="hljs-number">1</span>) * Math.random())];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		arr[i] = (<span class="hljs-type">int</span>) ((maxValue + <span class="hljs-number">1</span>) * Math.random()) - (<span class="hljs-type">int</span>) (maxValue * Math.random());<br>	&#125;<br>	<span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyArray(<span class="hljs-type">int</span>[] arr) &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>	&#125;<br>	<span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		res[i] = arr[i];<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">//4、实现一个比对测试算法和正确算法运算结果的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEqual</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2)</span> &#123;<br>	<span class="hljs-keyword">if</span> ((arr1 == <span class="hljs-literal">null</span> &amp;&amp; arr2 != <span class="hljs-literal">null</span>) || (arr1 != <span class="hljs-literal">null</span> &amp;&amp; arr2 == <span class="hljs-literal">null</span>)) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (arr1 == <span class="hljs-literal">null</span> &amp;&amp; arr2 == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (arr1.length != arr2.length) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;<br>		<span class="hljs-keyword">if</span> (arr1[i] != arr2[i]) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	<span class="hljs-keyword">if</span> (arr == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>		System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);<br>	&#125;<br>	System.out.println();<br>&#125;<br><br><span class="hljs-comment">// for test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">testTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">500000</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>	<span class="hljs-type">boolean</span> <span class="hljs-variable">succeed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; testTime; i++) &#123;<br>		<span class="hljs-type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);<br>		<span class="hljs-type">int</span>[] arr2 = copyArray(arr1);<br>		selectionSort(arr1);<br>		comparator(arr2);<br>		<span class="hljs-comment">//5、比对两个算法，只要有一个样本没通过就终止，并打印原始样本</span><br>		<span class="hljs-keyword">if</span> (!isEqual(arr1, arr2)) &#123;<br>			succeed = <span class="hljs-literal">false</span>;<br>			printArray(arr1);<br>			printArray(arr2);<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//6、测试全部通过，该算法大概率上正确	</span><br>	System.out.println(succeed ? <span class="hljs-string">&quot;Nice!&quot;</span> : <span class="hljs-string">&quot;Fucking fucked!&quot;</span>);<br><br>	<span class="hljs-type">int</span>[] arr = generateRandomArray(maxSize, maxValue);<br>	printArray(arr);<br>	selectionSort(arr);<br>	printArray(arr);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="递归的实质和Master公式"><a href="#递归的实质和Master公式" class="headerlink" title="递归的实质和Master公式"></a>递归的实质和Master公式</h2><h3 id="递归的实质"><a href="#递归的实质" class="headerlink" title="递归的实质"></a>递归的实质</h3><p>递归的实质就是系统在帮我们压栈。首先让我们来看一个递归求阶乘的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//base case</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>  <span class="hljs-keyword">return</span> n*<span class="hljs-built_in">fun</span>(n<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>课上老师一般告诉我们递归就是函数自己调用自己。但这听起来很玄学。事实上，在函数执行过程中如果调用了其他函数，那么当前函数的执行状态（执行到了第几行，有几个变量，各个变量的值是什么等等）会被保存起来压进栈（先进后出的存储结构，一般称为函数调用栈）中，转而执行子过程（调用的其他函数，当然也可以是当前函数）。若子过程中又调用了函数，那么调用前子过程的执行状态也会被保存起来压进栈中，转而执行子过程的子过程……以此类推，直到有一个子过程没有调用函数、能顺序执行完毕时会从函数调用栈依次弹出栈顶被保存起来的未执行完的函数（恢复现场）继续执行，直到函数调用栈中的函数都执行完毕，整个递归过程结束。</p>
<p>例如，在<code>main</code>中执行<code>fun(3)</code>，其递归过程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-built_in">fun</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200725141518" srcset="/img/loading.gif" lazyload></p>
<p>很多时候我们分析递归时都喜欢在心中模拟代码执行，去追溯、还原整个递归调用过程。但事实上没有必要这样做，因为每相邻的两个步骤执行的逻辑都是相同的，因此我们只需要分析第一步到第二步是如何执行的以及递归的终点在哪里就可以了。</p>
<p><strong>一切的递归算法都可以转化为非递归</strong>，因为我们完全可以自己压栈。只是说递归的写法更加简洁。在实际工程中，递归的使用是极少的，因为递归创建子函数的开销很大并且存在安全问题（stack overflow）。</p>
<h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><p>包含递归的算法的时间复杂度有时很难通过算法表面分析出来， 比如 <strong>归并排序</strong>。这时Master公式就粉墨登场了，当某递归算法的时间复杂度符合<code>T(n)=aT(n/b)+O(n^d)</code>形式时可以直接求出该算法的直接复杂度：</p>
<ul>
<li>当（以b为底a的对数）<code>log(b,a) &gt; d</code>时，时间复杂度为<code>O(n^log(b,a))</code></li>
<li>当<code>log(b,a) = d</code>时，时间复杂度为<code>O(n^d * logn)</code></li>
<li>当<code>log(b,a) &lt; d</code>时，时间复杂度为<code>O(n^d)</code></li>
</ul>
<p>其中，<code>n</code>为样本规模，<code>n/b</code>为子过程的样本规模（暗含<strong>子过程的样本规模必须相同</strong>，且相加之和等于总样本规模），<code>a</code>为子过程的执行次数，<code>O(n^d)</code>为除子过程之后的操作的时间复杂度。</p>
<p>以归并排序为例，函数本体先对左右两半部分进行归并排序，样本规模被分为了左右各<code>n/2</code>即<code>b=2</code>，左右各归并排序了一次，子过程执行次数为<code>2</code>即<code>a=2</code>，并入操作的时间复杂度为<code>O(n+n)=O(n)</code>即<code>d=1</code>，因此<code>T(n)=2T(n/2)+O(n)</code>，符合<code>log(b,a)=d=1</code>，因此<strong>归并排序的时间复杂度</strong>为<code>O(n^1*logn)=O(nlogn)</code>。</p>
<h2 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h2><p>有时我们不确定二叉树中是否有指针连空了或者连错了，这时需要将二叉树具有层次感地打印出来，下面就提供了这样一个工具。你可以将你的头逆时针旋转90度看打印结果。<code>v</code>表示该结点的头结点是左下方距离该结点最近的一个结点，<code>^</code>表示该结点的头结点是左上方距离该结点最近的一个结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>	<span class="hljs-keyword">public</span> Node left;<br>	<span class="hljs-keyword">public</span> Node right;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>		<span class="hljs-built_in">this</span>.value = data;<br>	&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTree</span><span class="hljs-params">(Node head)</span> &#123;<br>	System.out.println(<span class="hljs-string">&quot;Binary Tree:&quot;</span>);<br>	printInOrder(head, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;H&quot;</span>, <span class="hljs-number">17</span>);<br>	System.out.println();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInOrder</span><span class="hljs-params">(Node head, <span class="hljs-type">int</span> height, String to, <span class="hljs-type">int</span> len)</span> &#123;<br>	<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	printInOrder(head.right, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;v&quot;</span>, len);<br>	<span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> to + head.value + to;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">lenM</span> <span class="hljs-operator">=</span> val.length();<br>	<span class="hljs-type">int</span> <span class="hljs-variable">lenL</span> <span class="hljs-operator">=</span> (len - lenM) / <span class="hljs-number">2</span>;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">lenR</span> <span class="hljs-operator">=</span> len - lenM - lenL;<br>	val = getSpace(lenL) + val + getSpace(lenR);<br>	System.out.println(getSpace(height * len) + val);<br>	printInOrder(head.left, height + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;^&quot;</span>, len);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getSpace</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>	<span class="hljs-type">String</span> <span class="hljs-variable">space</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot; &quot;</span>;<br>	<span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;&quot;</span>);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>		buf.append(space);<br>	&#125;<br>	<span class="hljs-keyword">return</span> buf.toString();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">Node</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(-<span class="hljs-number">222222222</span>);<br>	head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>	head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Integer.MIN_VALUE);<br>	head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">55555555</span>);<br>	head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">66</span>);<br>	head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">777</span>);<br>	printTree(head);<br><br>	head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>);<br>	head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">3</span>);<br>	head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">4</span>);<br>	head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">5</span>);<br>	head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">6</span>);<br>	head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">7</span>);<br>	printTree(head);<br><br>	head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.left.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.right.left = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.right.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	head.left.left.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>);<br>	printTree(head);<br>&#125;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">剑指offer题解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/15/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
