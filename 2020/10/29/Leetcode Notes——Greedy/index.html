

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为贪心算法篇。部分内容搬运自 Leetcode-cn 大佬题解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Greedy">
<meta property="og:url" content="https://simpleforever.github.io/2020/10/29/Leetcode%20Notes%E2%80%94%E2%80%94Greedy/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为贪心算法篇。部分内容搬运自 Leetcode-cn 大佬题解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210735.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210813.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210827.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201031162549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094454.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093606.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093836.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102162656.png">
<meta property="article:published_time" content="2020-10-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-08T13:38:50.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Greedy">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210735.gif">
  
  
  <title>Leetcode Notes——Greedy - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://w.wallhaven.cc/full/3z/wallhaven-3zj7ey.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Greedy">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-10-29 00:00" pubdate>
        2020年10月29日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      163 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Greedy</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>贪心算法</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。</p>
<span id="more"></span>

<h1 id="贪心算法方法论"><a href="#贪心算法方法论" class="headerlink" title="贪心算法方法论"></a>贪心算法方法论</h1><p><strong>贪心算法</strong>（greedy algorithm），是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p>
<p>贪心算法在有<strong>最优子结构</strong>的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。</p>
<p>贪心算法与<strong>动态规划</strong>的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码..…对于其他问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。</p>
<p><strong>贪心算法流程：</strong></p>
<ol>
<li>创建数学模型来描述问题；</li>
<li>把求解的问题分成若干个<strong>子问题</strong>；</li>
<li>对每一子问题求解，得到子问题的局部最优解；</li>
<li>把子问题的解局部最优解合成原来解问题的一个解。</li>
</ol>
<p><strong>贪心算法与回溯算法、动态规划的关系：</strong></p>
<p>回溯算法，动态规划和贪心算法其实是循序渐进的。回溯算法即是暴力的<strong>枚举</strong>，每一步对所有可能都进行计算，计算到达终点即返回，每一步返回后都要把状态回归到之前的状态。回溯算法的痛点是他有很多重复的计算，解决的办法是引入备忘录，备忘录记录了每一步的结果，这其实就是子问题的最优解，动态规划由此产生。所以使用动态规划时必须要满足<strong>无后效性</strong>，子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。如果一个问题没有<strong>重叠子问题</strong>，那就只能使用回溯算法，比如 N 皇后问题。</p>
<h1 id="455-分发饼干-easy"><a href="#455-分发饼干-easy" class="headerlink" title="455. 分发饼干[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a>[easy]</h1><h2 id="解法：贪心算法"><a href="#解法：贪心算法" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：</p>
<ol>
<li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li>
<li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li>
</ol>
<p>在以上的解法中，只在每次分配饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p>
<p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>
<p>代码思路：</p>
<ul>
<li>对 <code>g</code> 和 <code>s</code>升序排序。</li>
<li>初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向 <code>g</code> 和 <code>s</code>初始位置。</li>
<li>对比 <code>g[i]</code> 和 <code>s[j]</code>，<ul>
<li><code>g[i] &lt;= s[j]</code>：饼干满足胃口，把能满足的孩子数量加 1，并移动指针 <code>++i</code>，<code>++j</code>。</li>
<li><code>g[i] &gt; s[j]</code>：无法满足胃口，<code>j</code>右移，继续查看下一块饼干是否可以满足胃口。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;g.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;s.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(g[i]&lt;=s[j])<br>            &#123;<br>                ++i;<br>                ++j;<br>                ++count;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="435-无重叠区间-medium"><a href="#435-无重叠区间-medium" class="headerlink" title="435. 无重叠区间[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a>[medium]</h1><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>&#x3D;&#x3D;TODO&#x3D;&#x3D;</p>
<h2 id="解法二：贪心算法"><a href="#解法二：贪心算法" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><p>先计算有多少个区间不会重叠，即典型的会议室安排问题，那么剩下的就是至少需要去除的区间个数。</p>
<p>贪心策略：</p>
<ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210735.gif" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>代码思路：</p>
<ul>
<li>对区间集合 intvs 按照结束时间升序排序。</li>
<li>筛选开始时间大于等于 x 的区间，计数 count++。</li>
<li>返回结果为总的区间数量减去不相交的区间数量。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;      <br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 按 end 升序排序</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-comment">// 至少有一个区间不相交</span><br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 排序后，第一个区间就是 x</span><br>        <span class="hljs-type">int</span> end=intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;intervals.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>]&gt;=end)<br>            &#123;<br>                <span class="hljs-comment">// 找到下一个选择的区间了</span><br>                count++;<br>                end=intervals[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>()-count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="452-用最少数量的箭引爆气球-medium"><a href="#452-用最少数量的箭引爆气球-medium" class="headerlink" title="452. 用最少数量的箭引爆气球[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a>[medium]</h1><h2 id="解法：贪心算法-1"><a href="#解法：贪心算法-1" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a> 基本相同，也是计算不重叠的区间个数，区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。因从采用和 435 解法二相同的贪心策略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(points.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> end=points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;points.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>]&gt;end)<br>            &#123;<br>                count++;<br>                end=points[i][<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="406-根据身高重建队列-medium"><a href="#406-根据身高重建队列-medium" class="headerlink" title="406. 根据身高重建队列[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a>[medium]</h1><h2 id="解法：贪心算法-2"><a href="#解法：贪心算法-2" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：</p>
<ul>
<li>先排身高更高的，这是要防止后排入人员影响先排入人员位置。</li>
<li>每次排入新人员<code>[h,k]</code>时，已处于队列的人身高都<code>&gt;=h</code>，所以新排入位置就是<code>people[k]</code>。</li>
<li>详细解释可以参考<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode/">官方解答</a>。</li>
</ul>
<p>代码思路：</p>
<p>先将<code>people</code>按照<strong>身高降序排序</strong>，又由于每次插入的位置是<code>k</code>，所以<strong>相同身高需要按<code>k</code>升序排序</strong>，否则插入位置会越界。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[7,1]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[4,4]</span><br>再一个一个插入。<br><span class="hljs-selector-attr">[7,0]</span><br><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[7,1]</span><br><span class="hljs-selector-attr">[5,0]</span>, <span class="hljs-selector-attr">[7,0]</span>, <span class="hljs-selector-attr">[5,2]</span>, <span class="hljs-selector-attr">[6,1]</span>, <span class="hljs-selector-attr">[4,4]</span>, <span class="hljs-selector-attr">[7,1]</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),compare);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:people)<br>            res.<span class="hljs-built_in">insert</span>(res.<span class="hljs-built_in">begin</span>()+e[<span class="hljs-number">1</span>],e);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>由于需要频繁使用<code>insert()</code>操作，可以使用<code>list</code>加速，注意<code>list</code>的迭代器不支持随机访问，需要使用<code>advance()</code>找到相应插入位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),compare);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; tmp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:people)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> pos=tmp.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-built_in">advance</span>(pos,e[<span class="hljs-number">1</span>]);<br>            tmp.<span class="hljs-built_in">insert</span>(pos,e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(tmp.<span class="hljs-built_in">begin</span>(),tmp.<span class="hljs-built_in">end</span>());<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>]&lt;b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>]&gt;b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="605-种花问题-easy"><a href="#605-种花问题-easy" class="headerlink" title="605. 种花问题[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a>[easy]</h1><h2 id="解法：贪心算法-3"><a href="#解法：贪心算法-3" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>从左到右扫描数组，如果数组中有一个 <code>0</code>，并且这个<code>0</code>的左右两侧都是 <code>0</code>，那么就可以在这个位置种花，即将这个位置的<code>0</code>修改成 <code>1</code>，并将计数器 <code>count</code> 增加 <code>1</code>。对于数组的第一个和最后一个位置，只需要考虑一侧是否为 0。在扫描结束之后，将 <code>count</code> 与 <code>n</code> 进行比较。如果 <code>count &gt;= n</code>，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> pre=i==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:flowerbed[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-type">int</span> next=i==flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:flowerbed[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">0</span>&amp;&amp;next==<span class="hljs-number">0</span>)<br>                &#123;<br>                    flowerbed[i]=<span class="hljs-number">1</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>优化：当 <code>count</code> 的值已经达到 <code>n</code>时，可以提前退出循环返回<code>True</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> pre=i==<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:flowerbed[i<span class="hljs-number">-1</span>];<br>                <span class="hljs-type">int</span> next=i==flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>?<span class="hljs-number">0</span>:flowerbed[i+<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(pre==<span class="hljs-number">0</span>&amp;&amp;next==<span class="hljs-number">0</span>)<br>                &#123;<br>                    flowerbed[i]=<span class="hljs-number">1</span>;<br>                    count++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&gt;=n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="思路二：前后补零"><a href="#思路二：前后补零" class="headerlink" title="思路二：前后补零"></a>思路二：前后补零</h3><p>为了避免首位和尾位的特殊情况，可在首位和尾位都填上一个 0，这样就可以一视同仁了，只需寻找到有多少个 0 的左右两边都是 0 即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        flowerbed.<span class="hljs-built_in">insert</span>(flowerbed.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>);<br>        flowerbed.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;flowerbed.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flowerbed[i]==<span class="hljs-number">0</span>&amp;&amp;flowerbed[i<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>&amp;&amp;flowerbed[i+<span class="hljs-number">1</span>]==<span class="hljs-number">0</span>)<br>            &#123;<br>                flowerbed[i]=<span class="hljs-number">1</span>;<br>                count++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count&gt;=n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&gt;=n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="392-判断子序列-easy"><a href="#392-判断子序列-easy" class="headerlink" title="392. 判断子序列[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/is-subsequence/">392. 判断子序列</a>[easy]</h1><h2 id="解法一：贪心算法-双指针"><a href="#解法一：贪心算法-双指针" class="headerlink" title="解法一：贪心算法+双指针"></a>解法一：贪心算法+双指针</h2><p>贪心策略：</p>
<p>每次贪心地匹配靠前的字符。</p>
<p>假定当前需要匹配字符 c，而字符 c 在 t 中的位置 x1 和 x2 出现（x1 &lt; x2），那么贪心取 x1 是最优解，因为 x2 后面能取到的字符，x1 也都能取到，并且通过 x1 与 x2 之间的可选字符，更有希望能匹配成功。</p>
<p>代码思路：</p>
<p>初始化两个指针 i 和 j，分别指向 s 和 t 的初始位置。每次贪心地匹配，匹配成功则 i 和 j 同时右移，匹配 s 的下一个位置，匹配失败则 j 右移，i 不变，尝试用 t 的下一个字符匹配 s。最终如果 i 移动到 s 的末尾，就说明 s 是 t 的子序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;j&lt;t.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==t[j])<br>                ++i;<br>            ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i==s.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p><strong>后续挑战：</strong></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">如果有大量输入的 S，称作<span class="hljs-built_in">S1</span>, <span class="hljs-built_in">S2</span>, ... , Sk 其中 k &gt;= <span class="hljs-number">10</span>亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？<br></code></pre></td></tr></table></figure>

<p>如果有大量输入的 S，需要依次检查它们是否为 T 的子序列，这时候处理每一个子串都需要扫描一遍 T 是很费时的。</p>
<p>在这种情况下，需要在匹配前对 T 做预处理，可以利用一个二维数组记录匹配到某一点时，待匹配的字符在 T 中<strong>下一次</strong>出现的位置。这里的字符是<code>&#39;a&#39; ~ &#39;z&#39;</code>，所以这个数组的大小是 <code>dp[n][26]</code>，n 为 T 的长度。对于要匹配的短字符串，遍历每一个字符，不断地寻找该字符在长字符串中的位置，然后将位置更新，寻找下一个字符，相当于在长字符串上“跳跃”。比如下面匹配 “ada” 的例子，只需要“跳跃”三次。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210813.jpeg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>如果下一个位置为 <code>-1</code>，表示长字符串再没有该字符了，返回 <code>false</code> 即可。如果能正常遍历完毕，则返回<code>true</code> 。</p>
<p>需要注意的一点：对于 “abc” 在 “ahbgdc” 上匹配的时候，由于长字符串第一个 a 的下一个出现 a 的位置为 -1（不出现），会导致访问越界。所以在生成数组时在长字符串前插入一个空字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// 预处理</span><br>        t=<span class="hljs-string">&quot; &quot;</span>+t;<br>        <span class="hljs-type">int</span> len=t.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c=<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++c)<br>        &#123;<br>            <span class="hljs-type">int</span> nextPos=<span class="hljs-number">-1</span>;<span class="hljs-comment">// 表示接下来再不会出现该字符</span><br>            <span class="hljs-comment">// 为了获得下一个字符的位置，要从后往前</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>            &#123;<br>                dp[i][c-<span class="hljs-string">&#x27;a&#x27;</span>]=nextPos;<br>                <span class="hljs-keyword">if</span>(t[i]==c)<br>                    nextPos=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 匹配</span><br>        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:s)<br>        &#123;<br>            <span class="hljs-comment">// 跳跃遍历</span><br>            index=dp[index][c-<span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span>(index==<span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="134-加油站-medium"><a href="#134-加油站-medium" class="headerlink" title="134. 加油站[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a>[medium]</h1><h2 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>题目可以理解为下边的图：每个节点表示添加的油量，每条边表示消耗的油量。只能顺时针方向走。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201030210827.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>分别从每个点出发，看是否能回到出发点。由于是个圆，得到下一个点的时候需要取余数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=gas.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 考虑从每一个点出发</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-type">int</span> j=i;<br>            <span class="hljs-type">int</span> remain=gas[i];<br>            <span class="hljs-comment">// 当前剩余的油能否到达下一个点</span><br>            <span class="hljs-keyword">while</span>(remain-cost[j]&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 减去花费的加上新的点的补给</span><br>                remain=remain-cost[j]+gas[(j+<span class="hljs-number">1</span>)%len];<br>                j=(j+<span class="hljs-number">1</span>)%len;<br>                <span class="hljs-comment">// j 回到了 i</span><br>                <span class="hljs-keyword">if</span>(j==i)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 任何点都不可以</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度 O(1)。</p>
<h2 id="解法二：贪心算法-1"><a href="#解法二：贪心算法-1" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><p>首先要知道能走完整个环的前提是<code>gas</code>的总量要大于<code>cost</code>的总量，这样才会有起点的存在。假设开始设置起点 <code>start=0</code>，从这里出发，遍历所有节点，<code>curTank</code>记录当前节点油箱内剩余油量，如果<code>curTank&gt;=0</code>，则继续前进。当到达某一站点时，如果<code>curTank&lt;0</code>，则说明从起点到这个点中间的任何一个点都不能作为起点，将<code>curTank</code>置 0 ，<code>start</code>置为下一个节点，继续遍历。当遍历完整个环时，当前保存的起点即为所求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> totalTank=<span class="hljs-number">0</span>;<span class="hljs-comment">// 总油量</span><br>        <span class="hljs-type">int</span> curTank=<span class="hljs-number">0</span>;<span class="hljs-comment">// 当前油量</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<span class="hljs-comment">// 起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;gas.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            totalTank+=gas[i]-cost[i];<br>            curTank+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(curTank&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                start=i+<span class="hljs-number">1</span>;<br>                curTank=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalTank&gt;=<span class="hljs-number">0</span>?start:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(1)。</p>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/solution/shi-yong-tu-de-si-xiang-fen-xi-gai-wen-ti-by-cyayc/">神奇的Z</a> 题解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=gas.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> totalTank=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minTotal=INT_MAX;<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            totalTank+=gas[i]-cost[i];<br>            <span class="hljs-keyword">if</span>(totalTank&lt;minTotal)<br>            &#123;<br>                minTotal=totalTank;<br>                minIndex=i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> totalTank&gt;=<span class="hljs-number">0</span>?(minIndex+<span class="hljs-number">1</span>)%len:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="665-非递减数列-easy"><a href="#665-非递减数列-easy" class="headerlink" title="665. 非递减数列[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/">665. 非递减数列</a>[easy]</h1><h2 id="解法：贪心算法-4"><a href="#解法：贪心算法-4" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>在出现 <code>nums[i]&gt;nums[i+1]</code> 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 <code>i+1</code> 之前的数组成为非递减数组，并且<strong>不影响后续的操作</strong> 。</p>
<ul>
<li><p>当数组长度小于 3 时，最多需要调整一次就能满足条件。</p>
</li>
<li><p>当数组长度大于等于 3 时，出现前一个元素 y 大于后一个元素 z 时，如果 y 的前元素 x 不存在，让 y&#x3D;z 即可；若 x 存在，会有以下情况，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>    y   z<br><span class="hljs-attribute">1</span>    <span class="hljs-number">3</span>   <span class="hljs-number">2</span><br><span class="hljs-attribute">2</span>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">3</span>    <span class="hljs-number">3</span>   <span class="hljs-number">1</span><br><span class="hljs-attribute">2</span>    <span class="hljs-number">3</span>   <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>要满足条件，需要如下调整：</p>
<ul>
<li>当 x&lt;z,让 y&#x3D;z</li>
<li>当 x&gt;z,让 z&#x3D;y</li>
<li>当 x&#x3D;z,让 y&#x3D;z</li>
</ul>
<p>综合以上可以得到：当 x 存在且 x&gt;z，就让 z&#x3D;y，否则让 y&#x3D;z。</p>
</li>
<li><p>当变更超过 2 次就不再满足条件。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&gt;nums[i+<span class="hljs-number">1</span>])<br>            &#123;<br>                count++;<br>                <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i<span class="hljs-number">-1</span>]&gt;nums[i+<span class="hljs-number">1</span>])<br>                    nums[i+<span class="hljs-number">1</span>]=nums[i];<br>                <span class="hljs-keyword">else</span><br>                    nums[i]=nums[i+<span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="763-划分字母区间-medium"><a href="#763-划分字母区间-medium" class="headerlink" title="763. 划分字母区间[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a>[medium]</h1><h2 id="解法：贪心算法-双指针"><a href="#解法：贪心算法-双指针" class="headerlink" title="解法：贪心算法+双指针"></a>解法：贪心算法+双指针</h2><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。由于只包含小写字母，因此可以用数组代替哈希表。</p>
<p>在得到每个字母最后一次出现的下标位置之后，使用贪心算法将字符串划分为尽可能多的片段：</p>
<ul>
<li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 <code>start</code> 和结束下标<code>end</code>，初始时 <code>start=end=0</code>。</li>
<li>对于每个访问到的字母，得到当前字母的最后一次出现的下标位置 <code>maxPos</code> ，则当前片段的结束下标一定不会小于 <code>maxPos</code> ，更新 <code>end</code>。</li>
<li>当访问到下标 <code>end</code> 时，当前片段访问结束，进行切割，保存当前片段长度，<code>start</code> 从 <code>end+1</code> 开始继续寻找下一个片段。</li>
<li>重复上述过程，直到遍历完字符串。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201031162549.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxPos</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">// 存放字母与它的最远位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();++i)<br>            maxPos[S[i]-<span class="hljs-string">&#x27;a&#x27;</span>]=i;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-type">int</span> start=<span class="hljs-number">0</span>;<span class="hljs-comment">// 待切割的起始位置</span><br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<span class="hljs-comment">// 已扫描的字符中最远的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            end=<span class="hljs-built_in">max</span>(end,maxPos[S[i]-<span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-comment">// 正好扫描到「已扫描的字符的最远位置」，到达切割点</span><br>            <span class="hljs-keyword">if</span>(i==end)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(end-start+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// 更新下一个待切割的字符串的起始位置</span><br>                start=end+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="621-任务调度器-medium"><a href="#621-任务调度器-medium" class="headerlink" title="621. 任务调度器[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a>[medium]</h1><h2 id="解法：贪心算法-5"><a href="#解法：贪心算法-5" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>贪心策略：每次先安排出现次数多的任务。</p>
<h3 id="思路一：排序"><a href="#思路一：排序" class="headerlink" title="思路一：排序"></a>思路一：排序</h3><p>规定 <code>n + 1</code> 个任务为一轮，这样同一轮中一个任务最多只能被安排一次。在每一轮中，将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 <code>n + 1</code> 个任务依次执行。如果任务的种类 <code>t</code> 少于 <code>n + 1</code> 个，就只选择全部的 <code>t</code> 种任务，其余的时间空闲。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(times[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(times[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">26</span>&amp;&amp;times[i]&gt;<span class="hljs-number">0</span>)<br>                    --times[i];<br>                ++count;<br>            &#125;<br>            <span class="hljs-comment">// 每轮过后重新排序</span><br>            <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="思路二：优先级队列"><a href="#思路二：优先级队列" class="headerlink" title="思路二：优先级队列"></a>思路二：优先级队列</h3><p>在选择每一轮的任务时，用优先队列来代替排序。在一开始，把所有的任务加入到优先队列中。在每一轮，从优先队列中选择最多 <code>n + 1</code> 个任务，把它们的数量减去 <code>1</code>，再放回堆中（如果数量不为 <code>0</code>），直到堆为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">// 大根堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:times)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(num);<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(q.<span class="hljs-built_in">top</span>()&gt;<span class="hljs-number">1</span>)<br>                        tmp.<span class="hljs-built_in">push_back</span>(q.<span class="hljs-built_in">top</span>()<span class="hljs-number">-1</span>);<br>                    q.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                ++count;<br>                <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">empty</span>())<br>                    <span class="hljs-keyword">break</span>; <br>            &#125;<br>            <span class="hljs-comment">// 每轮过后重新维护堆</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;t:tmp)<br>                q.<span class="hljs-built_in">push</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="思路三：桶思想"><a href="#思路三：桶思想" class="headerlink" title="思路三：桶思想"></a>思路三：桶思想</h3><p>参考桶思想，详细说明各种情况。建立大小为 <code>n + 1</code> 的桶子，个数为任务数量最多的那个任务，比如下图，等待时间 n&#x3D;2，A 任务个数 6 个，建立 6 个桶子，每个容量为 3：</p>
<p>可以把一个桶子看作一轮任务</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094432.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<ol>
<li><p>从最简单的情况看起，现在就算没有其他任务，完成任务 A 所需的时间应该是（6-1）*3+1&#x3D;16，因为最后一个桶子，不存在等待时间；</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102094454.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />
</li>
<li><p>接下来添加些其他任务：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093606.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>可以看到 C 其实并没有对总体时间产生影响，因为它被安排在了其他任务的冷却期间；<br>而 B 和 A 数量相同，这会导致最后一个桶子中，需要多执行一次B任务，现在需要的时间是（6-1)*3+2&#x3D;17。</p>
<p><strong>前面两种情况，总结起来：总排队时间 &#x3D; (桶个数 - 1) * (n + 1) + 最后一桶的任务数</strong>。</p>
</li>
<li><p>当冷却时间短，任务种类很多时：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093836.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>比如上图，刚好排满了任务，此时所需时间还是 17，如果现在还要执行两次任务 F，该怎么安排呢？</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102093904.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>此时可以临时扩充某些桶子的大小，插进任务 F，对比一下插入前后的任务执行情况：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">插入前：ABC | <span class="hljs-type">ABC</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> |<span class="hljs-type">AB</span><br>插入后：ABCF | <span class="hljs-type">ABCF</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> | <span class="hljs-type">ABD</span> |<span class="hljs-type">AB</span><br></code></pre></td></tr></table></figure>

<p>在第一个、第二个桶子里插入了任务 F，不难发现无论再继续插入多少任务，都可以类似处理，而且新插入元素肯定满足冷却要求。继续思考一下，这种情况下其实每个任务之间都不存在空余时间，冷却时间已经被完全填满了。<br><strong>也就是说，执行任务所需的时间，就是任务的数量</strong>。</p>
</li>
</ol>
<p>这样剩下就很好处理了，只需要算两个数：</p>
<ul>
<li>记录最大任务数量 N，看一下任务数量并列最多的任务有多少个，即最后一个桶子的任务数 X，计算 NUM1&#x3D;(N-1)*(n+1)+x。</li>
<li>NUM2&#x3D;tasks.size()。</li>
</ul>
<p>输出其中较大值即可。因为存在空闲时间时肯定是 NUM1 大，不存在空闲时间时肯定是NUM2&gt;&#x3D;NUM1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">leastInterval</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; tasks, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">times</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:tasks)<br>            ++times[c-<span class="hljs-string">&#x27;A&#x27;</span>];<br>        <span class="hljs-built_in">sort</span>(times.<span class="hljs-built_in">begin</span>(),times.<span class="hljs-built_in">end</span>(),compare);<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;times.<span class="hljs-built_in">size</span>()&amp;&amp;times[i]==times[<span class="hljs-number">0</span>])<br>            ++i;<br>        <span class="hljs-type">int</span> tasksNum=tasks.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(tasksNum,(times[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>)*(n+<span class="hljs-number">1</span>)+i);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a,<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a&gt;b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="55-跳跃游戏-medium"><a href="#55-跳跃游戏-medium" class="headerlink" title="55. 跳跃游戏[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">55. 跳跃游戏</a>[medium]</h1><h2 id="解法：贪心算法-6"><a href="#解法：贪心算法-6" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><p>对于数组中的任意一个位置 y，如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度 <code>x+nums[x]≥y</code>，那么位置 y 也可以到达。换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p>
<p>这样一来，可以依次遍历数组中的每一个位置，并实时维护最远可以到达的位置。对于当前遍历到的位置 x，如果它在最远可以到达的位置的范围内，那么就可以从起点通过若干次跳跃到达该位置，因此可以用 <code>x+nums[x]</code> 更新最远可以到达的位置。</p>
<p>在遍历的过程中，如果当前位置大于最远可以到达的位置，那么该位置不可达，直接返回 <code>false</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxRight=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;maxRight)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            maxRight=<span class="hljs-built_in">max</span>(maxRight,i+nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="45-跳跃游戏-II-hard"><a href="#45-跳跃游戏-II-hard" class="headerlink" title="45. 跳跃游戏 II[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a>[hard]</h1><h2 id="解法：贪心算法-7"><a href="#解法：贪心算法-7" class="headerlink" title="解法：贪心算法"></a>解法：贪心算法</h2><h3 id="思路一：反向查找出发位置"><a href="#思路一：反向查找出发位置" class="headerlink" title="思路一：反向查找出发位置"></a>思路一：反向查找出发位置</h3><p>目标是到达数组的最后一个位置，因此可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。如果有多个位置通过跳跃都能够到达最后一个位置，那么「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，可以从左到右遍历数组，选择第一个满足要求的位置。找到最后一步跳跃前所在的位置之后，继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。</p>
<p>代码超时！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> position=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<span class="hljs-comment">//要找的位置</span><br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 是否到了第 0 个位置</span><br>        <span class="hljs-keyword">while</span>(position!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;position;++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i+nums[i]&gt;=position)<br>                &#123;<br>                    position=i;<span class="hljs-comment">//更新要找的位置</span><br>                    steps++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，在最坏的情况下，例如数组中的所有元素都是 1，<code>position</code> 需要遍历数组中的每个位置，对于 <code>position</code> 的每个值都有一次循环。空间复杂度 O(1)。</p>
<h3 id="思路二：正向查找可到达的最大位置"><a href="#思路二：正向查找可到达的最大位置" class="headerlink" title="思路二：正向查找可到达的最大位置"></a>思路二：正向查找可到达的最大位置</h3><p>贪心策略：每次找到可到达的最远位置。</p>
<p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p>
<p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201102162656.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>在具体的实现中，维护当前能够到达的最大下标位置，记为边界。从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</p>
<p>在遍历数组时，不访问最后一个元素，这是因为在访问最后一个元素之前，边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，会增加一次「不必要的跳跃次数」，因此不必访问最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> end=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxPos=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 找能跳的最远的</span><br>            maxPos=<span class="hljs-built_in">max</span>(maxPos,i+nums[i]);<br>            <span class="hljs-keyword">if</span>(i==end)<br>            &#123;<br>                <span class="hljs-comment">// 遇到边界，就更新边界，并且步数加一</span><br>                end=maxPos;<br>                steps++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> steps;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(1)。</p>
<h1 id="135-分发糖果-hard"><a href="#135-分发糖果-hard" class="headerlink" title="135. 分发糖果[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a>[hard]</h1><h2 id="解法一：暴力法-1"><a href="#解法一：暴力法-1" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h2><p>使用数组 candies 记录给学生的糖果数。首先给每个学生 1 个糖果。然后开始从左到右扫描数组。对每一个学生，如果当前的评分 ratings[i] 比前一名学生的评分 ratings[i−1] 高，且 candies[i]&lt;&#x3D;candies[i−1] ，那么更新 candies[i]&#x3D;candies[i−1]+1。这样，这两名学生之间的糖果分配目前是正确的。同样的，检查当前学生的评分 ratings[i] 是否比 ratings[i+1] 高，如果成立，同样更新 candies[i]&#x3D;candies[i+1]+1 。继续对 ratings 数组重复此步骤。如果在某次遍历中，candies 数组不再变化，意味着已经得到了最后的糖果分布，此时可以停止遍历。为了记录是否到达最终状态，用 flag 记录每次遍历是否有糖果数目变化，如果有，则为 True ，否则为 False 。最终，把 candies 数组中所有糖果数目加起来，得到要求数目最少的糖果数。</p>
<p>cpp 超时！！！java 不超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">candy</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ratings)</span> &#123;<br>        <span class="hljs-type">int</span>[] candies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ratings.length];<br>        Arrays.fill(candies, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (flag) <br>        &#123;<br>            flag=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ratings.length;i++) &#123;<br>                <span class="hljs-keyword">if</span>(i!=ratings.length-<span class="hljs-number">1</span>&amp;&amp;ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>]&amp;&amp;candies[i]&lt;=candies[i+<span class="hljs-number">1</span>]) <br>                &#123;<br>                    candies[i]=candies[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i&gt;<span class="hljs-number">0</span>&amp;&amp;ratings[i]&gt;ratings[i-<span class="hljs-number">1</span>]&amp;&amp;candies[i]&lt;=candies[i-<span class="hljs-number">1</span>]) <br>                &#123;<br>                    candies[i]=candies[i-<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>                    flag=<span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> candy:candies)<br>            sum+=candy;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n^2)，空间复杂度 O(n)。</p>
<h2 id="解法二：贪心算法-2"><a href="#解法二：贪心算法-2" class="headerlink" title="解法二：贪心算法"></a>解法二：贪心算法</h2><h3 id="思路一：用两个数组"><a href="#思路一：用两个数组" class="headerlink" title="思路一：用两个数组"></a>思路一：用两个数组</h3><p>数组 left2right 用来存储每名学生只与左边邻居有关的所需糖果数。也就是假设规则为：如果一名学生评分比他左边学生高，那么他应该比他左边学生得到更多糖果。类似的，right2left 数组用来保存只与右边邻居有关的所需糖果数。也就是假设规则为：如果一名学生评分比他右边学生高，那么他应该比他右边学生得到更多糖果。</p>
<p>首先，在 left2right 和 right2left 中，给每个学生 1 个糖果。然后，从左向右遍历整个数组，只要当前学生评分比他左邻居高，就在 left2right 数组中更新当前学生的糖果数 left2right[i]&#x3D;left2right[i−1]+1，这是因为在每次更新前，当前学生的糖果数一定小于等于他左邻居的糖果数。然后用同样的方法从右到左更新 right2left 数组。</p>
<p>对于数组中第 i 个学生，为了满足题中条件，需要给他 max(left2right[i],right2left[i]) 个糖果。最后再将这些糖果数相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left2right</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right2left</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 更新与左边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])<br>                left2right[i]=left2right[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 更新与右边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                right2left[i]=right2left[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            <span class="hljs-comment">// 取最大值才满足条件</span><br>            sum+=<span class="hljs-built_in">max</span>(left2right[i],right2left[i]);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(n)。</p>
<h3 id="思路二：用一个数组"><a href="#思路二：用一个数组" class="headerlink" title="思路二：用一个数组"></a>思路二：用一个数组</h3><p>本质上与思路一相同。思路一中用两个数组分别记录每一个学生与他左邻居和右邻居的关系，实际只用一个数组也可以，记录当前学生被分配的糖果数。从左向右遍历时与思路一相同，从右向左遍历时，同时更新需要分配的糖果数与已分配糖果数的最大值。最后再将这些糖果数相加。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candies</span><span class="hljs-params">(len,<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 更新与左边孩子的关系</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i<span class="hljs-number">-1</span>])<br>                candies[i]=candies[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;ratings[i+<span class="hljs-number">1</span>])<br>                <span class="hljs-comment">// 取最大值才满足条件</span><br>                candies[i]=<span class="hljs-built_in">max</span>(candies[i],candies[i+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>            sum+=candies[i];<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(n)。</p>
<h3 id="思路三：不需要数组"><a href="#思路三：不需要数组" class="headerlink" title="思路三：不需要数组"></a>思路三：不需要数组</h3><p>首先给第一个同学一个糖果，那么对于接下来的一个同学就有三种情况：</p>
<ul>
<li>接下来的同学的 rating 等于前一个同学，那么给接下来的同学一个糖果就行。</li>
<li>接下来的同学的 rating 大于前一个同学，那么给接下来的同学的糖果数要比前一个同学糖果数加 1。</li>
<li>接下来的同学的 rating 小于前一个同学，那么此时不知道应该给这个同学多少个糖果，需要看后面的情况。</li>
</ul>
<p>对于第三种情况，不确定要给几个，因为要是只给 1 个的话，那么有可能接下来还有 rating 更小的同学，总不能一个都不给吧。也不能直接给前一个同学的糖果数减 1，有可能给多了，因为如果后面再没人了的话，其实只要给一个就行了。还有就是，如果后面好几个 rating 越来越小的同学，那么前一个同学的糖果数可能还得追加，以保证最后面的同学至少能有 1 个糖果。来一个例子吧，四个同学，他们的 rating 如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>先给第一个 rating 为 1 的同学一个糖果，然后从第二个同学开始遍历，第二个同学 rating 为3，比 1 大，所以多给一个糖果，第二个同学得到两个糖果。下面第三个同学，他的 rating 为 2，比前一个同学的 rating 小，如果此时给 1 个糖果的话，那么 rating 更小的第四个同学就得不到糖果了，所以要给第四个同学 1 个糖果，而给第三个同学 2 个糖果，此时要给第二个同学追加 1 个糖果，使其能够比第三个同学的糖果数多至少一个。那么就需要统计出有多少个连着的同学的 rating 变小，用变量 cnt 来记录，找出了最后一个减小的同学，那么就可以往前推，每往前一个加一个糖果，这就是个等差数列，可以直接利用求和公式算出这些 rating 减小的同学的糖果之和。然后还要看第一个开始减小的同学的前一个同学需不需要追加糖果，只要比较 cnt 和 pre 的大小，pre 是之前同学得到的最大糖果数，二者做差加 1 就是需要追加的糖果数，加到结果 res 中即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(ratings.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">1</span>;<span class="hljs-comment">// 连续递减序列的最大值</span><br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 连续递减序列的长度</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;ratings.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">//当前是在上坡或者平坡</span><br>            <span class="hljs-keyword">if</span>(ratings[i]&gt;=ratings[i<span class="hljs-number">-1</span>])<br>            &#123;<br>                <span class="hljs-comment">// 之前出现过了下坡</span><br>                <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// previous - count - count - 1 - ... - 1</span><br>                    res+=cnt*(cnt+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span>(cnt&gt;=pre)<br>                        <span class="hljs-comment">// 连续递减序列的最大值应该为 count，将加少了的补上</span><br>                        res+=cnt-pre+<span class="hljs-number">1</span>;<br>                    cnt=<span class="hljs-number">0</span>;<br>                    pre=<span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-comment">// ratings[i] &lt;= ratings[i - 1]</span><br>                pre=(ratings[i]==ratings[i<span class="hljs-number">-1</span>])?<span class="hljs-number">1</span>:pre+<span class="hljs-number">1</span>;<br>                res+=pre;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 统计连续递减序列的长度</span><br>                ++cnt;<br>        &#125;<br>        <span class="hljs-comment">// 判断是否有下坡</span><br>        <span class="hljs-keyword">if</span>(cnt&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            res+=cnt*(cnt+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(cnt&gt;=pre)<br>                res+=cnt-pre+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度 O(n)，空间复杂度 O(1)。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Greedy/">Greedy</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/03/Leetcode%20Notes%E2%80%94%E2%80%94Sort/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Sort</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/10/26/Leetcode%20Notes%E2%80%94%E2%80%94HashMap/">
                        <span class="hidden-mobile">Leetcode Notes——HashMap</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
