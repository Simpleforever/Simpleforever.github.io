

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为链表篇。部分内容搬运自 Leetcode-cn 大佬题解、wind-liang 题解、chenBright 题解。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Linked List">
<meta property="og:url" content="https://simpleforever.github.io/2020/08/18/Leetcode%20Notes%E2%80%94%E2%80%94Linked%20List/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为链表篇。部分内容搬运自 Leetcode-cn 大佬题解、wind-liang 题解、chenBright 题解。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818171256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120318.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120406.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140314.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140328.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115220.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115801.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152400.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152410.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152419.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152425.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152432.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828140817.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826113000.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826110823.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112439.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425101751.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425104123.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426145056.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426154405.jpeg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426161340.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427203956.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204208.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204153.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png">
<meta property="article:published_time" content="2020-08-17T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-30T07:06:18.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Linked List">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818171256.png">
  
  
  <title>Leetcode Notes——Linked List - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Linked List">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-08-18 00:00" pubdate>
        2020年8月18日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      44k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      370 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Linked List</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>链表</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解、<a target="_blank" rel="noopener" href="https://leetcode.wang/">wind-liang</a> 题解、<a target="_blank" rel="noopener" href="https://github.com/chenBright/leetcode">chenBright</a> 题解。</p>
<span id="more"></span>

<h1 id="160-相交链表-easy"><a href="#160-相交链表-easy" class="headerlink" title="160. 相交链表[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a>[easy]</h1><h2 id="解法一：借助unordered-set记录链表的结点"><a href="#解法一：借助unordered-set记录链表的结点" class="headerlink" title="解法一：借助unordered_set记录链表的结点"></a>解法一：借助unordered_set记录链表的结点</h2><p>使用<code>unordered_set</code>记录一个链表的结点，然后遍历另一个链表，查找该链表的结点是否在<code>unordered_set</code>中，第一个在<code>unordered_set</code>中的结点即为第一个共同结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        unordered_set&lt;ListNode*&gt; s;<br>        <span class="hljs-keyword">while</span>(headA!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">insert</span>(headA);<br>            headA=headA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(headB!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(headB)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> headB;<br>            headB=headB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(M+N)。</li>
<li>空间复杂度：O(M)。</li>
</ul>
<h2 id="解法二：快慢指针"><a href="#解法二：快慢指针" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h2><p>如果链表相交，则链表公共节点都在尾部。</p>
<ol>
<li>先计算两个链表长度。</li>
<li>让长链表指针先走多出的长度，然后两个链表同时走，如果相遇则为相交节点。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span>||headB==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* curA=headA;<br>        ListNode* curB=headB;<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(curA!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n++;<br>            curA=curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curB!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            n--;<br>            curB=curB-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// n：链表1长度减去链表2长度的值</span><br>        curA=(n&gt;<span class="hljs-number">0</span>)?headA:headB;<span class="hljs-comment">// 谁长，谁的头变成curA</span><br>        curB=(curA==headA)?headB:headA;<span class="hljs-comment">// 谁短，谁的头变成curB</span><br>        n=<span class="hljs-built_in">abs</span>(n);<br>        <span class="hljs-keyword">while</span>(n--)<br>            curA=curA-&gt;next;<br>        <span class="hljs-keyword">while</span>(curA!=curB)<br>        &#123;<br>            curA=curA-&gt;next;<br>            curB=curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(M+N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="解法三：拼接链表"><a href="#解法三：拼接链表" class="headerlink" title="解法三：拼接链表"></a>解法三：拼接链表</h2><p>利用拼接两链表消除长度差：设长-短链表为 C，短-长链表为 D （分别代表长链表在前和短链表在前的拼接链表），则当 C 走到长短链表交接处时，D 走在长链表中，且与长链表头距离为长度差;</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。当 pA&#x3D;&#x3D;pB 时跳出，返回即可。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200818171256.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA==<span class="hljs-literal">nullptr</span>||headB==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *pA=headA,*pB=headB;<br>        <span class="hljs-keyword">while</span>(pA!=pB)<br>        &#123;<br>            pA=pA==<span class="hljs-literal">nullptr</span>?headB:pA-&gt;next;<br>            pB=pB==<span class="hljs-literal">nullptr</span>?headA:pB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(M+N)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206. 反转链表[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a>[easy]</h1><h2 id="解法一：利用外部空间"><a href="#解法一：利用外部空间" class="headerlink" title="解法一：利用外部空间"></a>解法一：利用外部空间</h2><p>申请一个容器，比如栈。然后不断遍历链表，将链表中的元素添加到容器中，达到逆序的效果。最后，同时遍历链表和容器，将链表中的值改为容器中的值。</p>
<h2 id="解法二：双指针迭代"><a href="#解法二：双指针迭代" class="headerlink" title="解法二：双指针迭代"></a>解法二：双指针迭代</h2><p>申请两个指针，第一个 pre，最初指向 null 。第二个指针 cur 指向 head，然后不断遍历 cur。每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。注意将 cur 的 next 指针指向 pre 前要先保存 cur 的下一个结点。迭代结束后(cur 变成 null )，pre 就是最后一个节点了。直接返回 pre，即新的头结点。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120318.gif" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//申请节点，pre和 cur，pre指向null</span><br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//保存当前节点的下一个节点</span><br>            ListNode* next=cur-&gt;next;<br>            <span class="hljs-comment">//将当前节点指向pre</span><br>            cur-&gt;next=pre;<br>            <span class="hljs-comment">//pre和cur节点都前进一位</span><br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="解法三：递归"><a href="#解法三：递归" class="headerlink" title="解法三：递归"></a>解法三：递归</h2><p>递归的两个条件：</p>
<ol>
<li><p>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null</p>
</li>
<li><p>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">head.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span><br></code></pre></td></tr></table></figure>

<p>其实就是 head 的下一个节点指向 head。递归函数中每次返回的 cur 其实是最后一个节点，在递归函数内部，改变的是当前节点的指向。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200913120406.gif" srcset="/img/loading.gif" lazyload></p>
<p>更详细的递归调用执行过程查看 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">wang_ni_ma</a> 题解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//递归终止条件是当前为空，或者下一个节点为空</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//cur是最后一个节点</span><br>        ListNode* cur=<span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        <span class="hljs-comment">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时cur就是5</span><br>		<span class="hljs-comment">//而head是4，head的下一个是5，下下一个是空</span><br>		<span class="hljs-comment">//所以head.next.next 就是5-&gt;4</span><br>        head-&gt;next-&gt;next=head;<br>        <span class="hljs-comment">//防止链表循环，需要将head.next设置为空</span><br>        head-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">//每层递归函数都返回cur，也就是最后一个节点</span><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。</li>
</ul>
<h1 id="21-合并两个有序链表-easy"><a href="#21-合并两个有序链表-easy" class="headerlink" title="21. 合并两个有序链表[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>[easy]</h1><h2 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><ul>
<li>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束。</li>
<li>返回值：每一层调用都返回排序好的链表头。</li>
<li>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140217.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140314.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200823140328.png" srcset="/img/loading.gif" lazyload  style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>        &#123;<br>            l1-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1-&gt;next,l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            l2-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(l1,l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度。</li>
<li>空间复杂度：O(n+m)，递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为 O(n+m)。</li>
</ul>
<h2 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><blockquote>
<p><strong>dummy</strong>哑结点的作用：</p>
<p>创建哑节点作为结果链表的开头，返回结果是这个节点的下一个位置。目的是：在未遍历之前，我们不知道构建的结果中，开头元素到底是 l1 还是 l2, 为了让代码整齐，创建哑节点。</p>
</blockquote>
<p>当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位，同时将结果链表向后移一位。</p>
<p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。所以只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//合并后l1和l2最多只有一个还未被合并完，直接将链表末尾指向未合并完的链表即可</span><br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n+m) ，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</li>
<li>空间复杂度：O(1) 。只需要常数的空间存放若干变量。</li>
</ul>
<h1 id="23-合并K个升序链表-hard"><a href="#23-合并K个升序链表-hard" class="headerlink" title="23. 合并K个升序链表[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a>[hard]</h1><h2 id="解法一：K指针：K个指针分别指向K条链表"><a href="#解法一：K指针：K个指针分别指向K条链表" class="headerlink" title="解法一：K指针：K个指针分别指向K条链表"></a>解法一：K指针：K个指针分别指向K条链表</h2><h3 id="暴力求min：比较-K-个指针求最小值"><a href="#暴力求min：比较-K-个指针求最小值" class="headerlink" title="暴力求min：比较 K 个指针求最小值"></a>暴力求min：比较 K 个指针求最小值</h3><p>一列一列的比较，将最小的一个存到结果链表里。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115220.jpeg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-type">int</span> minIndex=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-type">bool</span> isBreak=<span class="hljs-literal">true</span>;<span class="hljs-comment">//标记是否遍历完所有链表</span><br>            <span class="hljs-type">int</span> minValue=INT_MAX;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;lists.<span class="hljs-built_in">size</span>();++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(lists[i]!=<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                     <span class="hljs-comment">//找出最小下标</span><br>                    <span class="hljs-keyword">if</span>(lists[i]-&gt;val&lt;minValue)<br>                    &#123;<br>                        minIndex=i;<br>                        minValue=lists[i]-&gt;val;<br>                    &#125;<br>                    <span class="hljs-comment">//存在一个链表不为空，标记改成false</span><br>                    isBreak=<span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(isBreak)<br>                <span class="hljs-keyword">break</span>;<br>            tail-&gt;next=lists[minIndex];<br>            tail=tail-&gt;next;<br>            <span class="hljs-comment">//链表后移一个元素</span><br>            lists[minIndex]=lists[minIndex]-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N*K)，其中 N 为节点总数，每次 O(K) 比较 K 个指针。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="使用优先级队列进行优化"><a href="#使用优先级队列进行优化" class="headerlink" title="使用优先级队列进行优化"></a>使用优先级队列进行优化</h3><p>将链表的头结点放入到小根堆中，每次从小根堆中取出最小值的结点，插入到结果链表中。同时，将取出的结点的下一个结点放入到小根堆中，直到链表为空。循环以上过程，直到小根堆为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-comment">//建立队列</span><br>        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,compare&gt; q;<span class="hljs-comment">//小根堆</span><br>        <span class="hljs-keyword">for</span>(ListNode* node:lists)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(node!=<span class="hljs-literal">nullptr</span>)<br>                q.<span class="hljs-built_in">push</span>(node);<br>        &#125;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//出队列</span><br>            ListNode* tmp=q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            tail-&gt;next=tmp;<br>            <span class="hljs-comment">//如果下一个节点不为空就入队</span><br>            tail=tail-&gt;next;<br>            <span class="hljs-keyword">if</span>(tmp-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>                q.<span class="hljs-built_in">push</span>(tmp-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//定义优先队列的比较器</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">compare</span>&#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* a,ListNode* b)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-comment">//小根堆为&gt;</span><br>            <span class="hljs-keyword">return</span> a-&gt;val&gt;b-&gt;val;<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N*logK)，其中 N 为节点总数，每个节点入队出队都需要 log(K)。</li>
<li>空间复杂度：O(K)。</li>
</ul>
<h2 id="解法二：合并两个有序链表"><a href="#解法二：合并两个有序链表" class="headerlink" title="解法二：合并两个有序链表"></a>解法二：合并两个有序链表</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> 提供了合并两个有序链表的思路，这里只采用迭代的写法。</p>
<h3 id="逐一合并两条链表"><a href="#逐一合并两条链表" class="headerlink" title="逐一合并两条链表"></a>逐一合并两条链表</h3><p>用一个变量 <code>res</code> 来维护合并的链表，第 i 次循环把第 i 个链表和 <code>res</code> 合并，答案保存到 <code>res</code> 中。即第 0 个和第 1 个链表合并，新生成的再和第 2 个链表合并，新生成的再和第 3 个链表合并…直到全部合并完。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        ListNode* res=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">for</span>(ListNode* list:lists)<br>            res=<span class="hljs-built_in">mergeTwoLists</span>(res,list);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(N*K)，N 为链表节点总数。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="分治合并"><a href="#分治合并" class="headerlink" title="分治合并"></a>分治合并</h3><p>对上述方法进行优化，用分治的方法进行合并。</p>
<ul>
<li>k 个链表两两配对，进行第一轮合并，结束后 k 个链表被合并成 k&#x2F;2 个链表。</li>
<li>k&#x2F;2个链表依然两两配对，进行第二轮合并，结束后 k&#x2F;2 个链表被合并成 k&#x2F;4 个链表。</li>
<li>重复上述过程，进行 log(k) 次合并，完成总体合并工作。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200829115801.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists,<span class="hljs-number">0</span>,lists.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==end)<br>            <span class="hljs-keyword">return</span> lists[start];<br>        <span class="hljs-type">int</span> mid=start+(end-start)/<span class="hljs-number">2</span>;<br>        ListNode* left=<span class="hljs-built_in">merge</span>(lists,start,mid);<br>        ListNode* right=<span class="hljs-built_in">merge</span>(lists,mid+<span class="hljs-number">1</span>,end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> k=lists.<span class="hljs-built_in">size</span>();<br>         <span class="hljs-comment">//非递归归并排序的归并思路</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> interval=<span class="hljs-number">1</span>;interval&lt;k;interval*=<span class="hljs-number">2</span>)<span class="hljs-comment">//间隔</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i+interval&lt;k;i+=interval*<span class="hljs-number">2</span>)<br>                lists[i]=<span class="hljs-built_in">mergeTwoLists</span>(lists[i],lists[i+interval]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>时间复杂度分析：</strong></p>
<p>K 条链表的总结点数是 N，平均每条链表有 N&#x2F;K 个节点，因此合并两条链表的时间复杂度是 O(N&#x2F;K)。从 K 条链表开始两两合并成 1 条链表，因此每条链表都会被合并 logK 次，因此 K 条链表会被合并 K∗logK 次，因此总共的时间复杂度是 K∗logK∗N&#x2F;K 即 O(N*logK)。</p>
<h1 id="83-删除排序链表中的重复元素-easy"><a href="#83-删除排序链表中的重复元素-easy" class="headerlink" title="83. 删除排序链表中的重复元素[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a>[easy]</h1><h2 id="解法一：迭代"><a href="#解法一：迭代" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><p>将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。如果不相等则 cur 移动到下一个位置继续循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;val)<br>                cur-&gt;next=cur-&gt;next-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。</li>
<li>空间复杂度：O(1)，没有使用额外的空间。</li>
</ul>
<h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>递归套路解决链表问题：</p>
<ul>
<li>找终止条件：当 head 指向链表只剩一个元素的时候，自然是不可能重复的，因此 return。</li>
<li>想想应该返回什么值：应该返回的自然是已经去重的链表的头节点。</li>
<li>每一步要做什么：宏观上考虑，此时 head.next 已经指向一个去重的链表了，而根据第二步，应该返回一个去重的链表的头节点。因此这一步应该做的是判断当前的 head 和 head.next 是否相等，如果相等则说明重了，返回 head.next，否则返回 head。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">if</span>(head-&gt;val==head-&gt;next-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            head-&gt;next=<span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)， n 是列表中的结点数。</li>
<li>空间复杂度：O(n)，递归栈空间。</li>
</ul>
<h1 id="82-删除排序链表中的重复元素-II-medium"><a href="#82-删除排序链表中的重复元素-II-medium" class="headerlink" title="82. 删除排序链表中的重复元素 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a>[medium]</h1><h2 id="解法一：快慢指针迭代"><a href="#解法一：快慢指针迭代" class="headerlink" title="解法一：快慢指针迭代"></a>解法一：快慢指针迭代</h2><p>快慢指针,用快指针跳过那些有重复数组,慢指针负责和快指针拼接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* slow=dummy;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;val==fast-&gt;next-&gt;val)<br>                fast=fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow-&gt;next==fast)<br>                slow=slow-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                slow-&gt;next=fast-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：递归-1"><a href="#解法二：递归-1" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//如果头结点和后边的节点相等</span><br>        <span class="hljs-keyword">if</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;head-&gt;val==head-&gt;next-&gt;val)<br>        &#123; <br>            <span class="hljs-comment">//跳过所有重复数字</span><br>            <span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;head-&gt;val==head-&gt;next-&gt;val)<br>                head=head-&gt;next;<br>            <span class="hljs-comment">//将所有重复数字去掉后，进入递归</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>        &#125;<br>        <span class="hljs-comment">//头结点和后边的节点不相等</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//保留头结点，后边的所有节点进入递归</span><br>            head-&gt;next=<span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next);<br>            <span class="hljs-comment">//返回头结点</span><br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="19-删除链表的倒数第N个节点-medium"><a href="#19-删除链表的倒数第N个节点-medium" class="headerlink" title="19. 删除链表的倒数第N个节点[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a>[medium]</h1><h2 id="解法一：两次遍历"><a href="#解法一：两次遍历" class="headerlink" title="解法一：两次遍历"></a>解法一：两次遍历</h2><p>删除链表的倒数第 N 个节点可以转换为删除链表从开头数起的 L-n+1 个节点，其中 L 是链表的长度。</p>
<p>首先添加一个哑结点作为辅助，该结点位于链表头部。哑结点用来简化某些极端情况，例如链表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，找出链表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个节点。然后把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* cur=head;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        length-=n;<br>        cur=dummy;<br>        <span class="hljs-keyword">while</span>(length--&gt;<span class="hljs-number">0</span>)<br>            cur=cur-&gt;next;<br>        cur-&gt;next=cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(L)，对链表进行两次遍历，首先计算长度 L，其次找到第 (L - n) 个结点。 操作执行了 2L−n 步。</li>
<li>空间复杂度：O(1)，常量级的额外空间。</li>
</ul>
<h2 id="解法二：快慢指针一次遍历"><a href="#解法二：快慢指针一次遍历" class="headerlink" title="解法二：快慢指针一次遍历"></a>解法二：快慢指针一次遍历</h2><p>设置快慢指针，快指针先走 n+1(因为哑结点的关系需要+1) 步，此时快慢指针之间间隔的节点个数为 n。然后同时移动快慢指针保持这个恒定的间隔，直到快指针指向 null。此时慢指针将指向倒数第 n-1 个节点，修改慢指针的 next 指针指向该结点的下下个结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* fast=dummy;<br>        ListNode* slow=dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;++i)<br>            fast=fast-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        slow-&gt;next=slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(L)，操作执行次数仍为 2L-n。</li>
<li>空间复杂度：O(1)，常量级的额外空间。</li>
</ul>
<h1 id="24-两两交换链表中的节点-medium"><a href="#24-两两交换链表中的节点-medium" class="headerlink" title="24. 两两交换链表中的节点[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>[medium]</h1><h2 id="解法一：迭代-1"><a href="#解法一：迭代-1" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152400.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* pre=dummy;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            pre-&gt;next=cur-&gt;next;<br>            cur-&gt;next=pre-&gt;next-&gt;next;<br>            pre-&gt;next-&gt;next=cur;<br>            pre=cur;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="解法二：递归-2"><a href="#解法二：递归-2" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，应该关注一级调用小单元的情况，也就是单个 f(x)。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152410.png" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<p>其中应该关心的主要有三点：</p>
<ol>
<li>返回值；</li>
<li>调用单元做了什么；</li>
<li>终止条件。</li>
</ol>
<p>在本题中：</p>
<ol>
<li>返回值：交换完成的子链表；</li>
<li>调用单元：设需要交换的两个点为 head 和 n，head 连接后面交换完成的子链表，n 连接 head，完成交换；</li>
<li>终止条件：head 为空指针或者 n 为空指针，也就是当前无节点或者只有一个节点，无法进行交换。</li>
</ol>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152419.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152425.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200825152432.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* n=head-&gt;next;<br>        head-&gt;next=<span class="hljs-built_in">swapPairs</span>(n-&gt;next);<br>        n-&gt;next=head;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(N)，其中 N 指的是链表的节点数量。</li>
<li>空间复杂度：O(N)，递归过程使用的堆栈空间。</li>
</ul>
<h1 id="2-两数相加-medium"><a href="#2-两数相加-medium" class="headerlink" title="2. 两数相加[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>[medium]</h1><h2 id="解法一：模拟加法"><a href="#解法一：模拟加法" class="headerlink" title="解法一：模拟加法"></a>解法一：模拟加法</h2><p>使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值。如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1（即循环的第三个条件 carry!&#x3D;0）。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828140817.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur=dummy;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>||l2!=<span class="hljs-literal">nullptr</span>||carry!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=carry;<br>            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                sum+=l1-&gt;val;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                sum+=l2-&gt;val;<br>                l2=l2-&gt;next;<br>            &#125;<br>            cur-&gt;next=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>            carry=sum/<span class="hljs-number">10</span>;<span class="hljs-comment">//更新进位的值</span><br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：递归-3"><a href="#解法二：递归-3" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>写递归的时候注意递归函数的两个条件，递归出口条件，以及函数内要做什么。</p>
<ol>
<li>递归出口条件：链表 l1 和链表 l2 都为空，且无进位时。</li>
<li>将两个链表的值相加，再赋给结果链表节点。</li>
</ol>
<p>这里需要注意第二个条件，因为进位标志需要通告下一层递归函数，所以需要有一个单独的变量作为记录，因此设置为全局变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* cur=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(l1==<span class="hljs-literal">nullptr</span>&amp;&amp;l2==<span class="hljs-literal">nullptr</span>&amp;&amp;sum==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            sum+=l1-&gt;val;<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            sum+=l2-&gt;val;<br>            l2=l2-&gt;next;<br>        &#125;<br>        cur-&gt;val=sum%<span class="hljs-number">10</span>;<br>        sum/=<span class="hljs-number">10</span>;<br>        cur-&gt;next=<span class="hljs-built_in">addTwoNumbers</span>(l1,l2);<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="445-两数相加-II-medium"><a href="#445-两数相加-II-medium" class="headerlink" title="445. 两数相加 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a>[medium]</h1><h2 id="解法一：栈-头插法"><a href="#解法一：栈-头插法" class="headerlink" title="解法一：栈+头插法"></a>解法一：栈+头插法</h2><p>因为链表中数位的顺序与做加法的顺序是相反的，所以使用栈来逆序处理所有数位。把所有数字压入栈中，再依次取出相加。计算过程中需要注意进位的情况。记录结果链表时使用头插法使链表逆序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk1;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk2;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk1.<span class="hljs-built_in">push</span>(l1-&gt;val);<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            stk2.<span class="hljs-built_in">push</span>(l2-&gt;val);<br>            l2=l2-&gt;next;<br>        &#125;<br>        ListNode* head=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span>(!stk1.<span class="hljs-built_in">empty</span>()||!stk2.<span class="hljs-built_in">empty</span>()||carry!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=carry;<br>            <span class="hljs-keyword">if</span>(stk1.<span class="hljs-built_in">empty</span>())<br>                sum+=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sum+=stk1.<span class="hljs-built_in">top</span>();<br>                stk1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(stk2.<span class="hljs-built_in">empty</span>())<br>                sum+=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sum+=stk2.<span class="hljs-built_in">top</span>();<br>                stk2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ListNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>            carry=sum/<span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//头插法</span><br>            node-&gt;next=head;<br>            head=node;           <br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(max(m,n))，其中 m 与 n 分别为两个链表的长度。需要遍历每个链表。</li>
<li>空间复杂度：O(m+n)，把链表内容放入栈中所用的空间。</li>
</ul>
<h2 id="解法二：递归-4"><a href="#解法二：递归-4" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>先递归计算后面的位，再根据计算结果计算当前的位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> length1=<span class="hljs-built_in">getlength</span>(l1);<br>        <span class="hljs-type">int</span> length2=<span class="hljs-built_in">getlength</span>(l2);<br>        ListNode* res=<span class="hljs-built_in">nextnode</span>(l1,l2,length1,length2);<br>        <span class="hljs-keyword">if</span> (carry&gt;<span class="hljs-number">0</span>) <br>        &#123;<br>            ListNode* node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(carry);<br>            node-&gt;next=res;<br>            res=node;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getlength</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            cnt++;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br><br>     <span class="hljs-function">ListNode* <span class="hljs-title">nextnode</span><span class="hljs-params">(ListNode* l1,ListNode* l2,<span class="hljs-type">int</span> length1,<span class="hljs-type">int</span> length2)</span>    </span><br><span class="hljs-function">     </span>&#123;<br>        <span class="hljs-keyword">if</span>(length1==<span class="hljs-number">0</span>||length2==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *p;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(length1==length2) <br>        &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1-&gt;next,l2-&gt;next,--length1,--length2);<br>            sum=carry+l1-&gt;val+l2-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (length1&gt;length2) &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1-&gt;next,l2,--length1,length2);<br>            sum=carry+l1-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p=<span class="hljs-built_in">nextnode</span>(l1,l2-&gt;next,length1,--length2);<br>            sum=carry+l2-&gt;val;<br>        &#125;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum%<span class="hljs-number">10</span>);<br>        node-&gt;next=p;<br>        carry=sum/<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="876-链表的中间结点-easy"><a href="#876-链表的中间结点-easy" class="headerlink" title="876. 链表的中间结点[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a>[easy]</h1><h2 id="解法一：常规做法"><a href="#解法一：常规做法" class="headerlink" title="解法一：常规做法"></a>解法一：常规做法</h2><p>寻找链表中点的常规做法是两步走：</p>
<ul>
<li>先遍历一遍链表，计算链表的长度 n；</li>
<li>再遍历一遍链表，找到第 n&#x2F;2 个元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur=head;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        cur=head;<br>        <span class="hljs-keyword">while</span>(k&lt;length/<span class="hljs-number">2</span>)<br>        &#123;<br>            k++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：快慢指针-1"><a href="#解法二：快慢指针-1" class="headerlink" title="解法二：快慢指针"></a>解法二：快慢指针</h2><p>使用慢指针<code>slow</code>和快指针<code>fast</code>两个指针同时遍历链表。快指针一次前进两个结点，速度是慢指针的两倍。这样，当快指针到达链表尾部时，慢指针正好到达链表的中部。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826113000.gif" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>不过，这个方法并没有减少时间复杂度的量级 —— 时间复杂度仍然是 O(n)，不过能减少一次遍历。</p>
<p>两个注意点：</p>
<ul>
<li>循环的条件是 <code>fast!=null &amp;&amp; fast.next!=null</code>，防止出现空指针异常。</li>
<li>注意链表结点为奇数个和偶数个的时候，链表中点的含义不一样。不过这种写法正好能满足题意，可以在纸上画一画最后 slow 指针落在什么位置。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 链表元素为奇数个时，slow 指向链表的中点</span><br>    	<span class="hljs-comment">// 链表元素为偶数个时，slow 指向链表两个中点的右边一个</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="234-回文链表-easy"><a href="#234-回文链表-easy" class="headerlink" title="234. 回文链表[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a>[easy]</h1><h2 id="解法一：栈"><a href="#解法一：栈" class="headerlink" title="解法一：栈"></a>解法一：栈</h2><p>使用栈保存结点，再从链表头开始，一一与栈中的值对比。</p>
<p>因为回文链表前后两部分逆序，不需要保存整个链表的值，只需要保存中间节点之前的节点即可。然后从中间结点的后继结点开始遍历链表的后半部分，将遍历的结点与栈弹出的结点相比较。可以使用快慢指针，找到中间节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;ListNode*&gt; s;<br>        ListNode* fast=head;<span class="hljs-comment">//快指针</span><br>        ListNode* slow=head;<span class="hljs-comment">//慢指针</span><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            s.<span class="hljs-built_in">push</span>(slow);<span class="hljs-comment">// 将前一半的结点压入栈中</span><br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// slow 指向第 n / 2 + 1 个结点。</span><br>        <span class="hljs-comment">// 链表结点个数为偶数，fast 指向 NULL，此时 slow 刚刚好指向链表后一半的第一个结点</span><br>        <span class="hljs-comment">// 链表结点个数为奇数，fast-&gt;next 指向 NULL，此时 slow 刚刚好指向链表的中间结点</span><br>        ListNode* right=fast==<span class="hljs-literal">nullptr</span>?slow:slow-&gt;next;<br>        <span class="hljs-comment">// 链表后半部分和栈中元素逐一对比</span><br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">top</span>()-&gt;val!=right-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            s.<span class="hljs-built_in">pop</span>();<br>            right=right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h2 id="解法二：递归-5"><a href="#解法二：递归-5" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>如果使用递归反向迭代节点，同时使用递归函数外的变量向前迭代，就可以判断链表是否为回文。</p>
<p>currentNode 指针是先到尾节点，由于递归的特性再从后往前进行比较。frontPointer 是递归函数外的指针。若 currentNode.val !&#x3D; frontPointer.val 则返回 false。反之，frontPointer 向前移动并返回 true。之所以起作用的原因是递归处理节点的顺序是相反的。由于递归，从本质上，我们同时在正向和逆向迭代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        frontPointer=head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursivelyCheck</span>(head);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ListNode* frontPointer;     <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursivelyCheck</span><span class="hljs-params">(ListNode* currentNode)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(currentNode!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">recursivelyCheck</span>(currentNode-&gt;next))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(currentNode-&gt;val!=frontPointer-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            frontPointer=frontPointer-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)。</li>
</ul>
<h2 id="解法三：双指针-反转"><a href="#解法三：双指针-反转" class="headerlink" title="解法三：双指针+反转"></a>解法三：双指针+反转</h2><p>利用两个指针，快指针每次走两步，慢指针每次走一步。当快指针走完的时候，慢指针来到前半部分链表的尾节点（若链表有奇数个节点，则为中间节点）。然后将单链表右半部分反转。然后利用 p1 和 p2 指针分别从链表头和尾出发，向中间推进，一一比较。为了不破坏原始数据结构，最后再将单链表恢复到原状态，即将右半部分逆序回来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//找到前半部分链表的尾节点</span><br>        ListNode* firstHalfEnd=<span class="hljs-built_in">endOfFirstHalf</span>(head);<br>        <span class="hljs-comment">//反转右半部分</span><br>        ListNode* secondHalfStart=<span class="hljs-built_in">reverseList</span>(firstHalfEnd-&gt;next);<br>        <span class="hljs-comment">//判断是否回文</span><br>        ListNode* p1=head;<br>        ListNode* p2=secondHalfStart;<br>        <span class="hljs-keyword">while</span>(p2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p1-&gt;val!=p2-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p1=p1-&gt;next;<br>            p2=p2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//恢复链表</span><br>        firstHalfEnd-&gt;next=<span class="hljs-built_in">reverseList</span>(secondHalfStart);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            ListNode* next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h1 id="725-分隔链表-medium"><a href="#725-分隔链表-medium" class="headerlink" title="725. 分隔链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a>[medium]</h1><h2 id="解法：拆分链表"><a href="#解法：拆分链表" class="headerlink" title="解法：拆分链表"></a>解法：拆分链表</h2><p>如果链表有 N 个结点，则分隔的链表中每个部分中都有 N&#x2F;k 个结点，且前 N%k 部分有一个额外的结点。</p>
<p>先求出链表的长度，然后求出分隔的链表平均长度，以及余数，然后余数依次给排在前面的平均长度+1即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* root, <span class="hljs-type">int</span> k)</span>    </span>&#123;<br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        ListNode* cur=root;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> size=length/k;<br>        <span class="hljs-type">int</span> mod=length%k;<br>        <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">res</span><span class="hljs-params">(k,<span class="hljs-literal">nullptr</span>)</span></span>;<br>        cur=root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;cur!=<span class="hljs-literal">nullptr</span>&amp;&amp;i&lt;k;++i)<br>        &#123;<br>            res[i]=cur;<br>            <span class="hljs-comment">//给前面的长度+1</span><br>            <span class="hljs-type">int</span> cursize=size+(mod--&gt;<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cursize<span class="hljs-number">-1</span>;++j)<br>                cur=cur-&gt;next;<br>            <span class="hljs-comment">//断链</span><br>            ListNode* next=cur-&gt;next;<br>            cur-&gt;next=<span class="hljs-literal">nullptr</span>;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="328-奇偶链表-medium"><a href="#328-奇偶链表-medium" class="headerlink" title="328. 奇偶链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a>[medium]</h1><h2 id="解法：双指针"><a href="#解法：双指针" class="headerlink" title="解法：双指针"></a>解法：双指针</h2><p>将奇节点放在一个链表里，偶节点放在另一个链表里。然后把偶链表接在奇链表的尾部。</p>
<p>利用 odd 表示奇链表的当前节点，初始化为 head，even 表示偶链表的当前节点，初始化为第二个节点，即 head.next，evenHead 是偶链表的头结点，初始化为第二个节点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200826110823.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *odd=head,*even=head-&gt;next,*evenHead=even;<br>        <span class="hljs-comment">//while退出判断条件可以画一下图，奇数个节点even=null,偶数个节点even-&gt;next=null</span><br>        <span class="hljs-keyword">while</span>(even!=<span class="hljs-literal">nullptr</span>&amp;&amp;even-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            odd-&gt;next=even-&gt;next;<span class="hljs-comment">//相当于odd.next=odd.next.next(跳过一个偶数节点)</span><br>            odd=odd-&gt;next;<span class="hljs-comment">//odd向前前进一位</span><br>            even-&gt;next=odd-&gt;next;<br>            even=even-&gt;next;<span class="hljs-comment">//even向前前进一位</span><br>        &#125;<br>        <span class="hljs-comment">//把偶链表头指针拼接到奇链表的最后</span><br>        odd-&gt;next=evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong>：</p>
<ul>
<li>时间复杂度： O(n)。总共有 n 个节点，每个遍历一次。</li>
<li>空间复杂度： O(1)。只需要 4 个指针。</li>
</ul>
<h1 id="141-环形链表-easy"><a href="#141-环形链表-easy" class="headerlink" title="141. 环形链表[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a>[easy]</h1><h2 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>使用哈希表记录遍历过的结点。如果链表存在环，则在遍历到环的入口时，在哈希表中可以找到该结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">//只要某个节点在set中出现过，说明遍历到重复元素了</span><br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(head)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st.<span class="hljs-built_in">insert</span>(head);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)，访问每个元素最多一次，添加一个结点到哈希表中只需要花费 O(1) 的时间。</li>
<li>空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</li>
</ul>
<h2 id="解法二：双指针"><a href="#解法二：双指针" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>准备两个指针，初始都指向头节点。快指针每次走两步，慢指针每次走一步。如果快指针走到 null，则表示不是环形链表；否则，快指针在环形链表中会”追上”慢指针，即<code>fast == slow</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)，只使用了慢指针和快指针。</li>
</ul>
<h1 id="142-环形链表-II-medium"><a href="#142-环形链表-II-medium" class="headerlink" title="142. 环形链表 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a>[medium]</h1><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a> 的升级版，在判断是否有环的基础上，需要找到链表的入环节点。</p>
<h2 id="解法一：哈希表-1"><a href="#解法一：哈希表-1" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h2><p>遍历链表，并且把遍历过的节点用 <code>HashSet</code> 存起来，如果遍历过程中又遇到了之前的节点，说明这个节点就是要找的入口点。如果到达了 <code>null</code> 就说明没有环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        unordered_set&lt;ListNode*&gt; st;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(head)!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            st.<span class="hljs-built_in">insert</span>(head);<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析：</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(n)，最坏情况下，单链表的所有结点都在存入 set。</li>
</ul>
<h2 id="解法二：双指针-1"><a href="#解法二：双指针-1" class="headerlink" title="解法二：双指针"></a>解法二：双指针</h2><p>准备快慢指针，初始都指向头节点，快指针每次走两步，慢指针每次走一步。如果快指针走到 null，则表示不是环形链表；否则，快指针在环形链表中会”追上”慢指针，即<code>fast == slow</code>。当快慢指针相遇时，快指针回到链表头节点，每次走一步，慢指针停在相遇的位置，每次走一步。当快慢指针再次相遇的时候，则相遇结点为入环结点。</p>
<p>证明方法查看<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/">官方题解</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>            &#123;<br>                fast=head;<br>                <span class="hljs-keyword">while</span>(fast!=slow)<br>                &#123;<br>                    fast=fast-&gt;next;<br>                    slow=slow-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>复杂度分析:</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)，只使用了慢指针和快指针。</li>
</ul>
<h1 id="147-对链表进行插入排序-medium"><a href="#147-对链表进行插入排序-medium" class="headerlink" title="147. 对链表进行插入排序[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a>[medium]</h1><h2 id="解法：模拟数组插入排序"><a href="#解法：模拟数组插入排序" class="headerlink" title="解法：模拟数组插入排序"></a>解法：模拟数组插入排序</h2><p>直接对链表进行插入排序，利用指针<code>prev</code>表示当前已排好序的尾节点，初始化为<code>head</code>。利用指针<code>cur</code>表示当前需要插入的节点，初始化为<code>head-&gt;next</code>。将<code>cur-&gt;val</code>与<code>prev-&gt;val</code>进行比较。</p>
<ul>
<li>如果<code>cur-&gt;val &lt; prev-&gt;val </code>则表示<code>cur</code>需要插入到<code>prev</code>之前的位置，这时从哑结点<code>dummy</code>开始寻找小于插入节点值的最后一个节点（从哑结点开始寻找便于处理插入到<code>head</code>前的情况），将<code>cur</code>插入最后一个节点后面。(数组的插入排序是将插入元素与排好序的尾元素比较后，往前一一比较的，但是链表只能从前往后查找)。</li>
<li>如果<code>cur-&gt;val &gt;= prev-&gt;val </code>则表示插入节点值大于排好序的所有节点值，这时直接检查下一个节点即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* prev=head;<span class="hljs-comment">//排好序的尾节点</span><br>        ListNode* cur=head-&gt;next;<span class="hljs-comment">//当前要插入的节点</span><br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val&lt;prev-&gt;val)<br>            &#123;<br>                ListNode* tmp=dummy;<br>                <span class="hljs-comment">//从头找到一个位置来插入cur，这里是tmp-&gt;next需要注意一下，比如1-3插入2，tmp-&gt;next停在3上，tmp是指在1上</span><br>                <span class="hljs-keyword">while</span>(tmp-&gt;next-&gt;val&lt;cur-&gt;val)<br>                    tmp=tmp-&gt;next;<br>                <span class="hljs-comment">// 因为实际操作还是在一个完整的链表上进行的</span><br>                <span class="hljs-comment">//（1）所以每次要断链取出一个：把要取出的cur断开，把cur-&gt;next接在prev上</span><br>                prev-&gt;next=cur-&gt;next;<br>                <span class="hljs-comment">//（2）把取出的节点插入到链表上</span><br>                cur-&gt;next=tmp-&gt;next;<br>                tmp-&gt;next=cur;<br>                <span class="hljs-comment">//prev-&gt;next为下一次要插入的节点</span><br>                cur=prev-&gt;next;<br>            &#125;<br>            <span class="hljs-comment">//直接检查下个节点</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                prev=cur;<br>                cur=cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="148-排序链表-medium"><a href="#148-排序链表-medium" class="headerlink" title="148. 排序链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a>[medium]</h1><p>题目要求在 <code>O(nlogn)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序。先不管空间复杂度，则根据时间复杂度要求可以想到堆排序、归并排序和快速排序，而稳定的又只有归并排序。</p>
<h2 id="解法一：归并排序（递归法）"><a href="#解法一：归并排序（递归法）" class="headerlink" title="解法一：归并排序（递归法）"></a>解法一：归并排序（递归法）</h2><p>通过递归实现链表归并排序，有以下两个环节：</p>
<ul>
<li>分割 cut 环节：找到当前链表中点，并从中点将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）。<ul>
<li>题目 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a> 通过快慢指针寻找链表中间节点，但是当有两个中间节点时，返回的是第二个中间结点。而本题最好返回第一个，这样可以把链表平均分开。需要修改一下代码，增加一个 pre 指针，让它一直指向 slow 的前一个即可。</li>
<li>找到中点后，执行 <code>midNode.next=null</code> 将链表切断。</li>
<li>递归分割时，输入当前链表左端点 <code>head</code> 和中心节点 <code>midNode</code> 的下一个节点 <code>rightHead</code>(因为链表是从 <code>midNode</code> 切断的)。</li>
<li>当分割成只剩一个节点时结束分割，即 base case。</li>
</ul>
</li>
<li>合并 merge 环节：将两个有序链表合并，转化为一个排序链表，为题目 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112455.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//找到链表中间节点并断开链表 &amp; 递归下探</span><br>        ListNode* midNode=<span class="hljs-built_in">middleNode</span>(head);<br>        ListNode* rightHead=midNode-&gt;next;<br>        midNode-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* left=<span class="hljs-built_in">sortList</span>(head);<br>        ListNode* right=<span class="hljs-built_in">sortList</span>(rightHead);<br>         <span class="hljs-comment">//当前层业务操作（合并有序链表）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//找到链表中间节点（876. 链表的中间结点）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;     <br>        ListNode* prev=<span class="hljs-literal">nullptr</span>; <br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            prev=slow;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next-&gt;next;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> prev;<br>    &#125;<br>	<br>     <span class="hljs-comment">//合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：快速排序（递归法）"><a href="#解法二：快速排序（递归法）" class="headerlink" title="解法二：快速排序（递归法）"></a>解法二：快速排序（递归法）</h2><p>使用快速排序对链表排序，关键在于最后将链表链接好。快速排序的基本思想为：使用一个基准结点，将链表分为左链表、中链表和右链表。对左右链表递归执行这一步。最后要将左中右链表链接好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* left=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*leftHead=left;<br>        ListNode* mid=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*midHead=mid;<br>        ListNode* right=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>),*rightHead=right;<br>        <span class="hljs-type">int</span> pivot=head-&gt;val;<span class="hljs-comment">//基准节点值</span><br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val&lt;pivot)<br>            &#123;<br>                left-&gt;next=head;<br>                left=head;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head-&gt;val==pivot)<br>            &#123;<br>                mid-&gt;next=head;<br>                mid=head;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                right-&gt;next=head;<br>                right=head;<br>            &#125;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//断链</span><br>        left-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        mid-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        right-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">concat</span>(<span class="hljs-built_in">sortList</span>(leftHead-&gt;next),midHead-&gt;next,<span class="hljs-built_in">sortList</span>(rightHead-&gt;next));<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">concat</span><span class="hljs-params">(ListNode* left,ListNode* mid,ListNode* right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* leftTail=<span class="hljs-built_in">getTail</span>(left);<br>        ListNode* midTail=<span class="hljs-built_in">getTail</span>(mid);<br>        midTail-&gt;next=right;<br>        <span class="hljs-keyword">if</span>(leftTail!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            leftTail-&gt;next=mid;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-comment">//没有左链表</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getTail</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">while</span>(head-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>            head=head-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法三：归并排序（从底至顶直接合并）——O-1-空间"><a href="#解法三：归并排序（从底至顶直接合并）——O-1-空间" class="headerlink" title="解法三：归并排序（从底至顶直接合并）——O(1)空间"></a>解法三：归并排序（从底至顶直接合并）——O(1)空间</h2><p>对于非递归的归并排序，需要使用迭代的方式替换解法一中的 cut 环节：<br>cut 环节本质上是通过不断二分得到链表最小节点单元，再通过多轮合并得到排序结果。每一轮合并 merge 操作针对的单元都有固定长度 intv，例如：</p>
<ul>
<li>第一轮合并时<code>intv = 1</code>，即将整个链表切分为多个长度为 1 的单元，并按顺序两两排序合并，合并完成的已排序单元长度为 2。</li>
<li>第二轮合并时<code>intv = 2</code>，即将整个链表切分为多个长度为 2 的单元，并按顺序两两排序合并，合并完成已排序单元长度为 4。</li>
<li>以此类推，直到单元长度<code>intv &gt;= 链表长度</code>，代表已经排序完成。</li>
</ul>
<p>根据以上推论，我们可以仅根据 intv 计算每个单元边界，并完成链表的每轮排序合并，例如:</p>
<ul>
<li>当<code>intv = 1</code>时，将链表第 1 和第 2 节点排序合并，第 3 和第 4 节点排序合并，……。</li>
<li>当<code>intv = 2</code>时，将链表第 1-2 和第 3-4 节点排序合并，第 5-6 和第 7-8 节点排序合并，……。</li>
<li>当<code>intv = 4</code>时，将链表第 1-4 和第 5-8 节点排序合并，第 9-12 和第 13-16 节点排序合并，……。</li>
</ul>
<p>此方法时间复杂度 O(nlogn)，空间复杂度 O(1)。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200828112439.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>链表里操作最难掌握的应该就是各种断链啊，然后再挂接啊。在这里，主要用到链表操作的两个技术：</p>
<ul>
<li><code>mergeTwoLists(l1, l2)</code>，将两个有序链表合并，转化为一个排序链表，为题目 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a>。</li>
<li><code>cut(l, n)</code>，一种 split 操作，即断链操作。它表示，将链表 <code>l</code> 切掉前 n 个节点，并返回后半部分的链表头。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        <span class="hljs-comment">//统计链表长度</span><br>        <span class="hljs-type">int</span> length=<span class="hljs-number">0</span>;<br>        ListNode* node=head;<br>        <span class="hljs-keyword">while</span>(node!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            length++;<br>            node=node-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//循环切割和合并</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> size=<span class="hljs-number">1</span>;size&lt;length;size=size*<span class="hljs-number">2</span>)<br>        &#123;<br>            ListNode* cur=dummy-&gt;next;<br>            ListNode* tail=dummy;<br>            <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                ListNode* left=cur;<br>                <span class="hljs-comment">//链表切掉size,剩下的返还给right</span><br>                ListNode* right=<span class="hljs-built_in">cut</span>(left,size);<br>                <span class="hljs-comment">//链表切掉size,剩下的返还给cur</span><br>                cur=<span class="hljs-built_in">cut</span>(right,size);<br>                tail-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(left,right);<br>                <span class="hljs-comment">//保持最尾端</span><br>                <span class="hljs-keyword">while</span>(tail-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>                    tail=tail-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//将链表L切掉前n个节点 并返回后半部分的链表头</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">cut</span><span class="hljs-params">(ListNode* head,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* p=head;<br>        <span class="hljs-comment">//往前走n-1步</span><br>        <span class="hljs-keyword">while</span>(--n&gt;<span class="hljs-number">0</span>&amp;&amp;p!=<span class="hljs-literal">nullptr</span>)<br>            p=p-&gt;next;<br>        <span class="hljs-keyword">if</span>(p==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* next=p-&gt;next;<br>        p-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>     <span class="hljs-comment">//合并两个有序链表（21. 合并两个有序链表）</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* tail=dummy;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span>&amp;&amp;l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>            &#123;<br>                tail-&gt;next=l1;<br>                l1=l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next=l2;<br>                l2=l2-&gt;next;<br>            &#125;<br>            tail=tail-&gt;next;<br>        &#125;<br>        tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="25-K-个一组翻转链表-hard"><a href="#25-K-个一组翻转链表-hard" class="headerlink" title="25. K 个一组翻转链表[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a>[hard]</h1><h2 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h2><p>大致过程可以分解为：</p>
<ul>
<li>找到待翻转的k个节点（注意：若剩余数量小于 k 的话，则不需要反转，因此直接返回待翻转部分的头结点即可）。</li>
<li>对其进行翻转。并返回翻转后的头结点（注意：翻转为左闭又开区间，所以本轮操作的尾结点其实就是下一轮操作的头结点）。</li>
<li>对下一轮 k 个节点也进行翻转操作。</li>
<li>将上一轮翻转后的尾结点指向下一轮翻转后的头节点，即将每一轮翻转的k的节点连接起来。</li>
</ul>
<p>具体过程看下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425101751.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>||head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* tail=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>        &#123;<br>            <span class="hljs-comment">// 剩余数量小于k的话，不需要反转</span><br>            <span class="hljs-keyword">if</span>(tail==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            tail=tail-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 反转前 k 个元素</span><br>        ListNode* newHead=<span class="hljs-built_in">reverse</span>(head,tail);<br>        <span class="hljs-comment">// 下一轮的开始的地方就是tail</span><br>        head-&gt;next=<span class="hljs-built_in">reverseKGroup</span>(tail,k);<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 左闭又开区间</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(head!=tail)<br>        &#123;<br>            next=head-&gt;next;<br>            head-&gt;next=pre;<br>            pre=head;<br>            head=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：迭代-1"><a href="#解法二：迭代-1" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h2><ul>
<li>链表分区为已翻转部分+待翻转部分+未翻转部分</li>
<li>每次翻转前，要确定翻转链表的范围，这个必须通过 k 此循环来确定</li>
<li>需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来</li>
<li>初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾</li>
<li>经过 k 次循环，end 到达末尾，记录待翻转链表的后继 next &#x3D; end.next</li>
<li>翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环</li>
<li>特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end&#x3D;&#x3D;null，已经到达末尾，说明题目已完成，直接返回即可</li>
<li>时间复杂度为 O(n∗K) 最好的情况为 O(n) 最差的情况为 O(n^2)</li>
<li>空间复杂度为 O(1) 除了几个必须的节点指针外，并没有占用其他空间</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210425104123.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* pre=dummy;<br>        ListNode* end=dummy;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k&amp;&amp;end!=<span class="hljs-literal">nullptr</span>;++i)<br>                end=end-&gt;next;<br>            <span class="hljs-keyword">if</span>(end==<span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">break</span>;<br>            ListNode* start=pre-&gt;next;<br>            ListNode* next=end-&gt;next;<br>            end-&gt;next=<span class="hljs-literal">nullptr</span>;<br>            pre-&gt;next=<span class="hljs-built_in">reverse</span>(start);<br>            start-&gt;next=next;<br>            pre=start;<br>            end=pre;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="补充题目：字节跳动高频题——排序奇升偶降链表"><a href="#补充题目：字节跳动高频题——排序奇升偶降链表" class="headerlink" title="补充题目：字节跳动高频题——排序奇升偶降链表"></a>补充题目：字节跳动高频题——排序奇升偶降链表</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个奇数位升序，偶数位降序的链表，将其重新排序。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">8</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">2</span>-&gt;NULL<br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span>-&gt;<span class="hljs-number">7</span>-&gt;<span class="hljs-number">8</span>-&gt;NULL<br></code></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ul>
<li>按奇偶位置拆分链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和8-&gt;6-&gt;4-&gt;2-&gt;NULL</li>
<li>反转偶链表，得1-&gt;3-&gt;5-&gt;7-&gt;NULL和2-&gt;4-&gt;6-&gt;8-&gt;NULL</li>
<li>合并两个有序链表，得1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL</li>
</ul>
<p>时间复杂度为 O(N)，空间复杂度 O(1)。</p>
<p>注意事项：</p>
<p>在第一步中，循环结束后需要将奇数链表最后节点的 next 指针置空，当链表节点个数为偶数时，不置空会有问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426145056.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode* next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> value):<span class="hljs-built_in">val</span>(value),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>    ListNode* next=<span class="hljs-literal">nullptr</span>;<br>    ListNode* cur=head;<br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        next=cur-&gt;next;<br>        cur-&gt;next=pre;<br>        pre=cur;<br>        cur=next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* tail=dummy;<br>    <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span> &amp;&amp; l2!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)<br>        &#123;<br>            tail-&gt;next=l1;<br>            l1=l1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            tail-&gt;next=l2;<br>            l2=l2-&gt;next;<br>        &#125;<br>        tail=tail-&gt;next;<br>    &#125;<br>    tail-&gt;next=l1==<span class="hljs-literal">nullptr</span>?l2:l1;<br>    ListNode* tmp=dummy-&gt;next;<br>    <span class="hljs-keyword">delete</span> dummy;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function">ListNode* <span class="hljs-title">mysort</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    ListNode* ohead=head;<br>    ListNode* ehead=head-&gt;next;<br>    ListNode* odd=ohead;<br>    ListNode* even=ehead;<br>    <span class="hljs-keyword">while</span>(even!=<span class="hljs-literal">nullptr</span> &amp;&amp; even-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        odd-&gt;next=even-&gt;next;<br>        odd=odd-&gt;next;<br>        even-&gt;next=odd-&gt;next;<br>        even=even-&gt;next;<br>    &#125;<br>    odd-&gt;next=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 见上述注意事项</span><br>    ListNode* reEhead=<span class="hljs-built_in">reverseList</span>(ehead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(ohead,reEhead);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ListNode* one=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);<br>    ListNode* two=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">200</span>);<br>    ListNode* three=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">2</span>);<br>    ListNode* four=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">120</span>);<br>    one-&gt;next=two;<br>    two-&gt;next=three;<br>    three-&gt;next=four;<br>    ListNode* res=<span class="hljs-built_in">mysort</span>(one);<br>    <span class="hljs-keyword">while</span>(res!=<span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        cout&lt;&lt;res-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        res=res-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> one,two,three,four;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="61-旋转链表-medium"><a href="#61-旋转链表-medium" class="headerlink" title="61. 旋转链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a>[medium]</h1><h2 id="解法：快慢指针"><a href="#解法：快慢指针" class="headerlink" title="解法：快慢指针"></a>解法：快慢指针</h2><p>题意：将链表每个节点向右移动 k 个位置，相当于把链表的后面 k % len  个节点移到链表的最前面。（len 为 链表长度）</p>
<ul>
<li>求链表长度；</li>
<li>找出倒数第 k+1 个节点；<ul>
<li>两个指针 <code>slow</code> 和 <code>fast</code> 值距离是 k，先让 <code>fast</code> 指向链表的第 k + 1 个节点，<code>slow</code> 指向第 1 个节点；</li>
<li>然后 <code>slow</code> 和 <code>fast</code> 同时向后移动，当 <code>fast</code> 移动到链表的最后一个节点的时候，那么 <code>slow</code> 指向链表的倒数第 k + 1 个节点</li>
</ul>
</li>
<li>链表重整：将链表的倒数第 k+1 个节点和倒数第 k 个节点断开，并把后半部分拼接到链表的头部。<ul>
<li><code>newHead</code> 是新链表的头部，它应该是原链表倒数第 k 个节点，即 <code>slow.next</code>；</li>
<li><code>slow</code> 需要跟 <code>slow.next</code> 断开；</li>
<li><code>fast</code> 是老链表的结尾，将 <code>fast.next</code> 设置为老链表的开头，实现首尾相接。</li>
</ul>
</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426154405.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode *cur=head;<br>        <span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-number">0</span>)<br>        &#123;<br>            len++;<br>            cur=cur-&gt;next;<br>        &#125;<br>        k=k%len;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        ListNode* fast=head;<br>        ListNode* slow=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;++i)<br>            fast=fast-&gt;next;<br>        <span class="hljs-comment">// 当 fast-&gt;next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点</span><br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        ListNode* newHead=slow-&gt;next;<br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        fast-&gt;next=head;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="86-分隔链表-medium"><a href="#86-分隔链表-medium" class="headerlink" title="86. 分隔链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>[medium]</h1><p>用两个链表，一个链表放小于 <code>x</code> 的节点，一个链表放大于等于 <code>x</code> 的节点。最后，拼接这两个链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        ListNode* less=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* more=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* p1=less;<br>        ListNode* p2=more;<br>        <span class="hljs-keyword">while</span>(head!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val&lt;x)<br>            &#123;<br>                p1-&gt;next=head;<br>                p1=p1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                p2-&gt;next=head;<br>                p2=p2-&gt;next;<br>            &#125;<br>            head=head-&gt;next;<br>        &#125;<br>        p1-&gt;next=more-&gt;next;<br>        p2-&gt;next=<span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 注意断链</span><br>        <span class="hljs-keyword">return</span> less-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="92-反转链表-II-medium"><a href="#92-反转链表-II-medium" class="headerlink" title="92. 反转链表 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>[medium]</h1><h2 id="解法：头插法"><a href="#解法：头插法" class="headerlink" title="解法：头插法"></a>解法：头插法</h2><ul>
<li>定义两个指针，分别称之为 <code>g(guard 守卫)</code> 和 <code>p(point)</code>。首先根据方法的参数 <code>left</code> 确定 <code>g</code> 和 <code>p</code> 的位置。将 <code>g</code> 移动到第一个要反转的节点的前面，将 <code>p</code> 移动到第一个要反转的节点的位置上。以 <code>left=2</code>，<code>right=4</code>为例</li>
<li>将 <code>p</code> 后面的元素删除，然后添加到 <code>g</code> 的后面。也即头插法</li>
<li>根据 <code>left</code> 和 <code>right</code> 重复（2）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210426161340.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* g=dummy;<br>        ListNode* p=dummy-&gt;next;<br>        <span class="hljs-comment">// 将指针移到相应的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;left<span class="hljs-number">-1</span>;++i)<br>        &#123;<br>            p=p-&gt;next;<br>            g=g-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 头插法插入节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;right-left;++i)<br>        &#123;<br>            ListNode* remove=p-&gt;next;<br>            p-&gt;next=remove-&gt;next;<br>            remove-&gt;next=g-&gt;next;<br>            g-&gt;next=remove;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="143-重排链表-medium"><a href="#143-重排链表-medium" class="headerlink" title="143. 重排链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a>[medium]</h1><h2 id="解法：寻找链表中点-链表逆序-合并链表"><a href="#解法：寻找链表中点-链表逆序-合并链表" class="headerlink" title="解法：寻找链表中点 + 链表逆序 + 合并链表"></a>解法：寻找链表中点 + 链表逆序 + 合并链表</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span><br>第一步，将链表平均分成两半<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">4</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">6</span><br>    <br>第二步，将第二个链表逆序<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">3</span><br><span class="hljs-number">6</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">4</span><br>    <br>第三步，依次连接两个链表<br><span class="hljs-number">1</span> -&gt; <span class="hljs-number">6</span> -&gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">5</span> -&gt; <span class="hljs-number">3</span> -&gt; <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>第一步使用快慢指针寻找中点。快指针一次走两步，慢指针一次走一步，当快指针走到终点的话，慢指针会刚好到中点。<strong>如果链表节点个数是偶数的话，slow 需要走到的是左端点</strong>，这样可以把奇数和偶数的情况合并，不需要分开考虑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span> || head-&gt;next==<span class="hljs-literal">nullptr</span> || head-&gt;next-&gt;next==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span>;<br>        ListNode* slow=head;<br>        ListNode* fast=head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        ListNode* newHead=slow-&gt;next;<br>        <span class="hljs-comment">// 注意断链</span><br>        slow-&gt;next=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 第二个链表倒置</span><br>        newHead=<span class="hljs-built_in">reverseList</span>(newHead);<br>        <span class="hljs-built_in">merge</span>(head,newHead);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 反转链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* pre=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next=<span class="hljs-literal">nullptr</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next=cur-&gt;next;<br>            cur-&gt;next=pre;<br>            pre=cur;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">// 依次合并两个链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode* next1=<span class="hljs-literal">nullptr</span>;<br>        ListNode* next2=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">nullptr</span> &amp;&amp; l2!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            next1=l1-&gt;next;<br>            next2=l2-&gt;next;<br>            l1-&gt;next=l2;<br>            l1=next1;<br>            l2-&gt;next=l1;<br>            l2=next2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h2><blockquote>
<p>参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorder-list/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-34/">windliang</a> 题解。</p>
</blockquote>
<h1 id="203-移除链表元素-easy"><a href="#203-移除链表元素-easy" class="headerlink" title="203. 移除链表元素[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a>[easy]</h1><h2 id="解法一：迭代-2"><a href="#解法一：迭代-2" class="headerlink" title="解法一：迭代"></a>解法一：迭代</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode* dummy=<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next=head;<br>        ListNode* cur=dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val!=val)<br>                cur=cur-&gt;next;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                ListNode* next=cur-&gt;next;<br>                cur-&gt;next=next-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法二：递归-6"><a href="#解法二：递归-6" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        head-&gt;next=<span class="hljs-built_in">removeElements</span>(head-&gt;next,val);<br>        <span class="hljs-keyword">if</span>(head-&gt;val==val)<br>            <span class="hljs-keyword">return</span> head-&gt;next;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="237-删除链表中的节点-easy"><a href="#237-删除链表中的节点-easy" class="headerlink" title="237. 删除链表中的节点[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a>[easy]</h1><h2 id="解法：与下一个节点交换"><a href="#解法：与下一个节点交换" class="headerlink" title="解法：与下一个节点交换"></a>解法：与下一个节点交换</h2><p>从链表里删除一个节点 <code>node</code> 的最常见方法是修改之前节点的 <code>next</code> 指针，使其指向之后的节点。</p>
<img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427203956.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>因为我们无法访问想要删除的节点之前的节点，所以始终不能修改该节点的 <code>next</code>指针。相反，必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。</p>
<img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204208.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204137.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/Simpleforever/imgbed/pic2/20210427204153.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>因为知道要删除的节点不是列表的末尾，所以可以保证这种方法是可行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        node-&gt;val=node-&gt;next-&gt;val;<br>        node-&gt;next=node-&gt;next-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="138-复制带随机指针的链表-medium"><a href="#138-复制带随机指针的链表-medium" class="headerlink" title="138. 复制带随机指针的链表[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a>[medium]</h1><h2 id="解法一：DFS-amp-BFS"><a href="#解法一：DFS-amp-BFS" class="headerlink" title="解法一：DFS&amp;BFS"></a>解法一：DFS&amp;BFS</h2><blockquote>
<p>参考 <a href="https://simpleforever.github.io/2020/07/22/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/#25-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6">剑指offer题解——25.复杂链表的复制</a>。</p>
</blockquote>
<h2 id="解法二：哈希表"><a href="#解法二：哈希表" class="headerlink" title="解法二：哈希表"></a>解法二：哈希表</h2><p>遍历链表，建立一张 Hashmap，将链表的所有结点复制一份，存储到哈希表中（key 为原链表的结点，value 为新链表的结点，即复制结点）。再遍历原链表，借助哈希表查表的方式拷贝 next 和 random 指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        unordered_map&lt;Node*,Node*&gt; mp;<br>        Node* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            mp[cur]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur=cur-&gt;next;<br>        &#125;<br>        cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            mp[cur]-&gt;next=mp[cur-&gt;next];<br>            mp[cur]-&gt;random=mp[cur-&gt;random];<br>            cur=cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="解法三：空间O-1-的迭代"><a href="#解法三：空间O-1-的迭代" class="headerlink" title="解法三：空间O(1)的迭代"></a>解法三：空间O(1)的迭代</h2><p>不使用哈希表的额外空间来保存已经拷贝过的结点，而是将链表进行拓展，在每个节点后面添加原节点的拷贝。</p>
<ul>
<li><p>第一步，在每个节点的后面插入复制的节点。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100431.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>第二步，对复制节点的 random 链接进行赋值。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100436.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>第三步，拆分。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20200724100441.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 插入新节点</span><br>        Node* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* next=cur-&gt;next;<br>            Node* clone=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur-&gt;next=clone;<br>            clone-&gt;next=next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-comment">// 建立 random 链接</span><br>        cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* clone=cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random!=<span class="hljs-literal">nullptr</span>)<br>                clone-&gt;random=cur-&gt;random-&gt;next;<br>            cur=clone-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        cur=head;<br>        Node* cloneHead=head-&gt;next;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            Node* clone=cur-&gt;next;<br>            Node* next=clone-&gt;next;<br>            cur-&gt;next=next;<br>            clone-&gt;next=next==<span class="hljs-literal">nullptr</span>?<span class="hljs-literal">nullptr</span>:next-&gt;next;<br>            cur=next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cloneHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>




            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Linked-List/">Linked List</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/08/30/Leetcode%20Notes%E2%80%94%E2%80%94Array%20and%20Matrix/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Array and Matrix</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/08/15/Leetcode%20Notes%E2%80%94%E2%80%94Stack%20and%20Queue/">
                        <span class="hidden-mobile">Leetcode Notes——Stack and Queue</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
