

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/headysmiley.png">
  <link rel="icon" href="/img/headysmiley.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Orleans">
  <meta name="keywords" content="">
  
    <meta name="description" content="记录一下自己 leetcode 的刷题记录，本部分为搜索算法篇。部分内容搬运自 Leetcode-cn 大佬题解。方法论、部分题解等搬运自 @liweiwei1419。">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Notes——Search">
<meta property="og:url" content="https://simpleforever.github.io/2020/11/05/Leetcode%20Notes%E2%80%94%E2%80%94Search/index.html">
<meta property="og:site_name" content="OrleansのBlog">
<meta property="og:description" content="记录一下自己 leetcode 的刷题记录，本部分为搜索算法篇。部分内容搬运自 Leetcode-cn 大佬题解。方法论、部分题解等搬运自 @liweiwei1419。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118211043.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118221858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174228.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174327.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119195422.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119200033.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119202112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119201031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119210609.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121215225.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121220205.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221217.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221306.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125214145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125215309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123174727.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123164029.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123172351.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123165451.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123214501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126210516.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214753.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127211509.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211416.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211729.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127221208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207193035.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201109215649.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201106151555.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201130202158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201204541.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201203647.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201212031.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207204943.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207205104.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207171739.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208211356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208212423.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208213344.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201214170159.png">
<meta property="article:published_time" content="2020-11-04T16:00:00.000Z">
<meta property="article:modified_time" content="2020-12-14T14:01:10.000Z">
<meta property="article:author" content="Orleans">
<meta property="article:tag" content="Search">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118211043.png">
  
  
  <title>Leetcode Notes——Search - OrleansのBlog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"simpleforever.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>OrleansのBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/wallhaven.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Leetcode Notes——Search">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-05 00:00" pubdate>
        2020年11月5日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      92k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      764 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Notes——Search</h1>
            
            <div class="markdown-body">
              <p>记录一下自己 leetcode 的刷题记录，本部分为<strong>搜索算法</strong>篇。部分内容搬运自 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/">Leetcode-cn</a> 大佬题解。方法论、部分题解等搬运自 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/liweiwei1419/">liweiwei1419</a>。</p>
<span id="more"></span>

<h1 id="搜索算法方法论"><a href="#搜索算法方法论" class="headerlink" title="搜索算法方法论"></a>搜索算法方法论</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。</p>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索（breadth-first search，BFS）不同于深度优先搜索，它是一层层进行遍历的，因此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照“广”的方向进行遍历的，也常常用来处理<strong>最短路径</strong>等问题。</p>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>回溯法（backtracking）是优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常来说，排列、组合、选择类问题使用回溯法比较方便。</p>
<p>顾名思义，回溯法的核心是回溯。在搜索到某一节点的时候，如果我们发现目前的节点（及其子节点）并不是需求目标时，我们回退到原来的节点继续搜索，并且把在目前节点修改的状态还原。这样的好处是我们可以始终只对图的总状态进行修改，而非每次遍历时新建一个图来储存状态。在具体的写法上，它与普通的深度优先搜索一样，都有[修改当前节点状态]-&gt;[递归子节点] 的步骤，只是多了回溯的步骤，变成了[修改当前节点状态]-&gt;[递归子节点]-&gt;[回改当前节点状态]。</p>
<p>回溯算法要点：</p>
<ul>
<li>如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法；</li>
<li>回溯算法是在一棵树上的 <strong>深度优先遍历</strong>（<strong>因为要找所有的解，所以需要遍历</strong>）；</li>
<li>组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即 <code>[1, 2, 3]</code> 与 <code>[1, 3, 2]</code>认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。</li>
<li>回溯算法首先需要画出递归树，不同的树决定了不同的代码实现。</li>
</ul>
<h2 id="回溯算法与深度优先遍历"><a href="#回溯算法与深度优先遍历" class="headerlink" title="回溯算法与深度优先遍历"></a>回溯算法与深度优先遍历</h2><p>以下是维基百科中「回溯算法」和「深度优先遍历」的定义。</p>
<p><strong>回溯法</strong> 采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案；</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案。</li>
</ul>
<p><strong>深度优先搜索</strong> 算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。这个算法会 <strong>尽可能深</strong> 的搜索树的分支。当结点 <code>v</code>的所在边都己被探寻过，搜索将 <strong>回溯</strong> 到发现结点 <code>v</code>的那条边的起始结点。这一过程一直进行到已发现从源结点可达的所有结点为止。如果还存在未被发现的结点，则选择其中一个作为源结点并重复以上过程，整个进程反复进行直到所有结点都被访问为止。</p>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>「回溯算法」与「深度优先遍历」都有「不撞南墙不回头」的意思。个人的理解是：「回溯算法」强调了「深度优先遍历」思想的用途，用一个 <strong>不断变化</strong> 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 <strong>回退</strong> 操作对于搜索的合理性。而「深度优先遍历」强调一种遍历的思想，与之对应的遍历思想是「广度优先遍历」。</p>
<h2 id="搜索与遍历"><a href="#搜索与遍历" class="headerlink" title="搜索与遍历"></a>搜索与遍历</h2><p>我们每天使用的搜索引擎帮助我们在庞大的互联网上搜索信息。搜索引擎的「搜索」和「回溯搜索」算法里「搜索」的意思是一样的。</p>
<p>搜索问题的解，可以通过 <strong>遍历</strong> 实现。所以很多教程把「回溯算法」称为爆搜（暴力解法）。因此回溯算法用于 <strong>搜索一个问题的所有的解</strong> ，通过深度优先遍历的思想实现。</p>
<h2 id="与动态规划的区别"><a href="#与动态规划的区别" class="headerlink" title="与动态规划的区别"></a>与动态规划的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>用于求解多阶段决策问题。多阶段决策问题即：</p>
<ul>
<li>求解一个问题分为很多步骤（阶段）；</li>
<li>每一个步骤（阶段）可以有多种选择。</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li>
<li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li>
</ul>
<h1 id="题型一：排列、组合、子集相关问题"><a href="#题型一：排列、组合、子集相关问题" class="headerlink" title="题型一：排列、组合、子集相关问题"></a>题型一：排列、组合、子集相关问题</h1><p>提示：这部分练习可以帮助熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件，<strong>为什么有的时候用 <code>used</code> 数组，有的时候设置搜索起点 <code>begin</code> 变量</strong>，理解状态变量设计的想法。排列例题为 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">46.全排列</a>，组合例题为 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">39.组合总和</a>，子集例题为 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>。此外，关于这三种问题的理解也可以参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-si-xiang-tuan-mie-pai-lie-zu-he-zi-ji-wen-t/">labuladong</a> 题解。</p>
<h2 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46. 全排列[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>[medium]</h2><h3 id="解法：回溯"><a href="#解法：回溯" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>回溯法详细思路叙述参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">liweiwei1419</a> 题解。</p>
<h4 id="从全排列问题开始理解回溯算法"><a href="#从全排列问题开始理解回溯算法" class="headerlink" title="从全排列问题开始理解回溯算法"></a>从全排列问题开始理解回溯算法</h4><p>以数组 <code>[1, 2, 3]</code> 的全排列为例。</p>
<ul>
<li>先写以 1 开头的全排列，它们是：<code>[1, 2, 3], [1, 3, 2]</code>，即 <code>1</code> + <code>[2, 3]</code>的全排列（注意：<strong>递归结构体现在这里</strong>）；</li>
<li>再写以 2 开头的全排列，它们是：<code>[2, 1, 3], [2, 3, 1]</code>，即 <code>2</code> + <code>[1, 3]</code>的全排列；</li>
<li>最后写以 3 开头的全排列，它们是：<code>[3, 1, 2], [3, 2, 1]</code>，即 <code>3</code> + <code>[1, 2]</code>的全排列。</li>
</ul>
<p>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 <strong>当前</strong> 要选择的数字中不能出现。按照这种策略搜索就能够做到 <strong>不重不漏</strong>。这样的思路，可以用一个树形结构表示。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118211043.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>说明：</p>
<ul>
<li><strong>每一个结点表示了求解全排列问题的不同的阶段</strong>，这些阶段通过变量的「不同的值」体现，这些变量的不同的值，称之为「状态」；</li>
<li>使用深度优先遍历有「回头」的过程，在「回头」以后， <strong>状态变量需要设置成为和先前一样</strong> ，因此在回到上一层结点的过程中，需要撤销上一次的选择，这个操作称之为「状态重置」；</li>
<li>深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，<code>path</code>变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 <code>path</code>变量是一个栈；</li>
<li>深度优先遍历通过「回溯」操作，实现了全局使用一份状态变量的效果。</li>
</ul>
<p>使用编程的方法得到全排列，就是在这样的一个树形结构中完成 <strong>遍历</strong>，从树的根结点到叶子结点形成的路径就是其中一个全排列。</p>
<h4 id="设计状态变量"><a href="#设计状态变量" class="headerlink" title="设计状态变量"></a>设计状态变量</h4><ul>
<li>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 <strong>递归</strong> 结构；</li>
<li>递归的终止条件是： <strong>一个排列中的数字已经选够了</strong> ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 <code>depth</code>，或者命名为 <code>index</code>，表示当前要确定的是某个全排列中下标为 <code>index</code>的那个数是多少；</li>
<li>布尔数组 <code>used</code>，初始化的时候都为 <code>false</code> 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 <code>true</code>，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</li>
</ul>
<p>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p>
<h4 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h4><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 保存所有可能的全排列</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!used[i])<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                used[i]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">//print(&quot;  递归之前 =&gt; &quot; + path);</span><br>                <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,path,used,res);<br>                <span class="hljs-comment">// 注意：下面这两行代码发生「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的</span><br>                used[i]=<span class="hljs-literal">false</span>;<br>                path.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">//print(&quot;递归之后 =&gt; &quot; + path);</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="通过打印输出观察"><a href="#通过打印输出观察" class="headerlink" title="通过打印输出观察"></a>通过打印输出观察</h5><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs inform7">  递归之前 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[1, 3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[1]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 1, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[2, 3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[2, 3]</span><br>递归之后 =&gt; <span class="hljs-comment">[2]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 1, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2]</span><br>  递归之前 =&gt; <span class="hljs-comment">[3, 2, 1]</span><br>递归之后 =&gt; <span class="hljs-comment">[3, 2]</span><br>递归之后 =&gt; <span class="hljs-comment">[3]</span><br>递归之后 =&gt; <span class="hljs-comment">[]</span><br>输出 =&gt; <span class="hljs-comment">[<span class="hljs-comment">[1, 2, 3]</span>, <span class="hljs-comment">[1, 3, 2]</span>, <span class="hljs-comment">[2, 1, 3]</span>, <span class="hljs-comment">[2, 3, 1]</span>, <span class="hljs-comment">[3, 1, 2]</span>, <span class="hljs-comment">[3, 2, 1]</span>]</span><br></code></pre></td></tr></table></figure>

<h4 id="另一种实现"><a href="#另一种实现" class="headerlink" title="另一种实现"></a>另一种实现</h4><p>让未排列的元素交换到当前位置上都排一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start&gt;=nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 是后面的数字都在 start 位置上排一次</span><br>            <span class="hljs-built_in">swap</span>(nums[start],nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,start+<span class="hljs-number">1</span>,res);<br>            <span class="hljs-built_in">swap</span>(nums[start],nums[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">liweiwei1419</a> 题解。</p>
<h4 id="理解回溯"><a href="#理解回溯" class="headerlink" title="理解回溯"></a>理解回溯</h4><p>从 <code>[1, 2, 3]</code> 到 <code>[1, 3, 2]</code>，深度优先遍历是这样做的，从 <code>[1, 2, 3]</code> 回到 <code>[1, 2]</code>的时候，需要撤销刚刚已经选择的数 <code>3</code>，因为在这一层只有一个数 <code>3</code> 我们已经尝试过了，因此程序回到上一层，需要撤销对 <code>2</code> 的选择，好让后面的程序知道，选择 <code>3</code>了以后还能够选择 <code>2</code>。</p>
<p>执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做「状态重置」，即「回到过去」、「恢复现场」。</p>
<h3 id="几点说明帮助理解「回溯算法」"><a href="#几点说明帮助理解「回溯算法」" class="headerlink" title="几点说明帮助理解「回溯算法」"></a>几点说明帮助理解「回溯算法」</h3><h4 id="每一次尝试都「复制」，则不需要回溯"><a href="#每一次尝试都「复制」，则不需要回溯" class="headerlink" title="每一次尝试都「复制」，则不需要回溯"></a>每一次尝试都「复制」，则不需要回溯</h4><p>如果在每一个 <strong>非叶子结点</strong> 分支的尝试，都创建 <strong>新的变量</strong> 表示状态，那么</p>
<ul>
<li>在回到上一层结点的时候不需要「回溯」；</li>
<li>在递归终止的时候也不需要做拷贝。</li>
</ul>
<p>这样的做法虽然可以得到解，但也会创建很多中间变量，这些中间变量很多时候是我们不需要的，会有一定空间和时间上的消耗。</p>
<h5 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!used[i])<br>            &#123;<br>                <span class="hljs-comment">// 每一次尝试都创建新的变量表示当前的&quot;状态&quot;</span><br>                <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newPath</span><span class="hljs-params">(path)</span></span>;<br>                newPath.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">newUsed</span><span class="hljs-params">(used)</span></span>;<br>                newUsed[i]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,newPath,newUsed,res);<br>                <span class="hljs-comment">// 无需回溯</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这就好比我们在实验室里做「对比实验」，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：</p>
<ul>
<li>每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；</li>
<li>每一次尝试都使用同样的<strong>新的材料</strong>做实验。</li>
</ul>
<h4 id="为什么不是广度优先遍历"><a href="#为什么不是广度优先遍历" class="headerlink" title="为什么不是广度优先遍历"></a>为什么不是广度优先遍历</h4><ul>
<li>首先是正确性，只有遍历状态空间，才能得到所有符合条件的解，这一点 BFS 和 DFS 其实都可以；</li>
<li>在深度优先遍历的时候，<strong>不同状态之间的切换很容易</strong> ，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；</li>
<li>如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；</li>
<li>如果使用广度优先遍历就得使用队列，然后编写结点类。队列中需要存储每一步的状态信息，<strong>需要存储的数据很大，真正能用到的很少</strong> 。</li>
<li>使用深度优先遍历，直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。我们不用编写结点类，不必手动编写栈完成深度优先遍历。</li>
</ul>
<h4 id="不回溯可不可以"><a href="#不回溯可不可以" class="headerlink" title="不回溯可不可以"></a>不回溯可不可以</h4><p>可以。搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。</p>
<p>就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 O(N)。路径变量在深度优先遍历的时候，结点之间的转换只需要 O(1)。</p>
<p>最后，由于回溯算法的时间复杂度很高，因此在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称为 <strong>剪枝</strong>。</p>
<h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><ul>
<li><p>回溯算法会应用「剪枝」技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但能够剪枝节约的时间更多；</p>
<blockquote>
<p>提示：剪枝是一种技巧，通常需要根据不同问题场景采用不同的剪枝策略，需要在做题的过程中不断总结。</p>
</blockquote>
</li>
<li><p>由于回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>做题的时候，建议 <strong>先画树形图</strong> ，画图能帮助我们想清楚递归结构，想清楚如何剪枝。拿题目中的示例，想一想人是怎么做的，一般这样下来，这棵递归树都不难画出。</p>
<p>在画图的过程中思考清楚：</p>
<ul>
<li>分支如何产生；</li>
<li>题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？</li>
<li>哪些搜索会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？</li>
</ul>
<h2 id="47-全排列-II-medium"><a href="#47-全排列-II-medium" class="headerlink" title="47. 全排列 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>[medium]</h2><h3 id="解法：回溯-剪枝"><a href="#解法：回溯-剪枝" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><p>详细思路叙述参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">liweiwei1419</a> 题解。</p>
<p>在 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a> 的基础上增加了 <strong>序列中的元素可重复</strong> 这一条件，但要求：返回的结果又不能有重复元素。</p>
<p>思路是：在遍历的过程中，一边遍历一遍检测，<strong>在一定会产生重复结果集的地方剪枝</strong>。</p>
<p>一个比较容易想到的办法是在结果集中去重。但是问题来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。</p>
<p>如果要比较两个列表是否一样，一个容易想到的办法是对列表分别排序，然后逐个比对。既然要排序，我们就可以 <strong>在搜索之前就对候选数组排序</strong>，一旦发现某个分支搜索下去可能搜索到重复的元素就停止搜索，这样结果集中不会包含重复列表。</p>
<p>画出树形结构如下：重点想象深度优先遍历在这棵树上执行的过程，哪些地方遍历下去一定会产生重复，这些地方的状态的特点是什么？<br>对比图中标注 ① 和 ② 的地方。相同点是：这一次搜索的起点和上一次搜索的起点一样。不同点是：</p>
<ul>
<li>标注 ① 的地方上一次搜索的相同的数刚刚被撤销；</li>
<li>标注 ② 的地方上一次搜索的相同的数刚刚被使用。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201118221858.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>产生重复结点的地方，正是图中标注了「剪刀」，且被红色框框住的地方。</p>
<p>大家也可以把第 2 个 <code>1</code> 加上 <code>&#39;</code> ，即 <code>[1, 1&#39;, 2]</code>去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。这里还有一个很细节的地方：</p>
<ul>
<li>在图中 ② 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 还在使用中；</li>
<li><strong>在图中 ① 处，搜索的数也和上一次一样，但是上一次的 <code>1</code> 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支</strong>。</li>
</ul>
<p>代码实现方面，在第 46 题的基础上，要加上这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !used[i - <span class="hljs-number">1</span>]) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码就能检测到标注为 ① 的两个结点，跳过它们。注意：这里 <code>used[i - 1]</code> 不加 <code>!</code>，测评也能通过。可以想一想这是为什么。建议做这样几个对比实验：</p>
<ul>
<li>干脆就不写 <code>!used[i - 1]</code>结果是什么样？</li>
<li>写 <code>used[i - 1]</code>结果是什么，代码又是怎样执行的。这里给出的结论是：<code>!used[i - 1]</code>这样的剪枝更彻底。附录会分析原因。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序（升序或者降序都可以），排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,used,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> depth,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(depth==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 剪枝条件：i &gt; 0 是为了保证 nums[i - 1] 有意义</span><br>            <span class="hljs-comment">// 写 !used[i - 1] 是因为 nums[i - 1] 在深度优先遍历的过程中刚刚被撤销选择</span><br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;!used[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(nums,depth+<span class="hljs-number">1</span>,path,used,res);<br>            <span class="hljs-comment">// 回溯部分的代码，和 dfs 之前的代码是对称的</span><br>            used[i]=<span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p><strong>写 <code>used[i - 1]</code> 代码正确，但是不推荐的原因</strong>。参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">liweiwei1419</a> 题解。</p>
<h2 id="784-字母大小写全排列-medium"><a href="#784-字母大小写全排列-medium" class="headerlink" title="784. 字母大小写全排列[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a>[medium]</h2><h3 id="解法：回溯-1"><a href="#解法：回溯-1" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><ul>
<li>这一类搜索问题是在一个隐式的树上进行的搜索问题，即「树形问题」。解决这一类问题， <strong>先画出递归树是十分重要的，可以帮助打开思路</strong> ，然后看着图形把代码写出来；</li>
<li>这个问题所求的解，是这棵树的叶子结点上的值。因此，可以使用深度优先遍历，收集 <strong>所有</strong> 叶子结点的值，<strong>深度优先遍历用于搜索也叫回溯算法</strong>；</li>
<li>回溯算法因为有回头的过程，因此其显著特征是 <strong>状态重置</strong>。参考 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174228.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h4 id="技巧：使用异或运算转换字母大小写"><a href="#技巧：使用异或运算转换字母大小写" class="headerlink" title="技巧：使用异或运算转换字母大小写"></a><strong>技巧</strong>：使用异或运算转换字母大小写</h4><p>先看一看 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin">ASCII 表</a>，A 到 Z，Z 完了以后没有直接到 a，中间隔了 6 个字符。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174205.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>（中间省略）</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119174327.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>发现大写字符与其对应的小写字符的 ASCII 的差为 32，即 2^5，在编程语言中，可以表示为 <code>1 &lt;&lt; 5</code>。而变换大小写这件事等价于：</p>
<ul>
<li>如果字符是小写字符，减去 32 得到大写字符；</li>
<li>如果字符是大写字符，加上 32 得到小写字符。</li>
</ul>
<p>而这两者合并起来，就是给这个字符做一次不进位的加法，即异或上 <code>1 &lt;&lt; 5</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(S,<span class="hljs-number">0</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;S,<span class="hljs-type">int</span> index,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==S.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(S);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 未修改当前字符(字母或者数字)的一条分支</span><br>        <span class="hljs-built_in">dfs</span>(S,index+<span class="hljs-number">1</span>,res);<br>        <span class="hljs-comment">// 修改当前字母的的另一条分支</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(S[index]))<br>        &#123;<br>            S[index]^=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>;<br>            <span class="hljs-built_in">dfs</span>(S,index+<span class="hljs-number">1</span>,res);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39. 组合总和[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a>[medium]</h2><h3 id="解法：回溯-2"><a href="#解法：回溯-2" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>详细思路叙述参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419</a> 题解。</p>
<h4 id="思路一：根据搜索起点画出二叉树"><a href="#思路一：根据搜索起点画出二叉树" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>思路分析：根据示例 1：输入: <code>candidates = [2, 3, 6, 7]</code>，<code>target = 7</code>。</p>
<ul>
<li>候选数组里有 <code>2</code>，如果找到了组合总和为 <code>7 - 2 = 5</code> 的所有组合，再在之前加上 <code>2</code> ，就是 <code>7</code>的所有组合；</li>
<li>同理考虑 <code>3</code>，如果找到了组合总和为 <code>7 - 3 = 4</code> 的所有组合，再在之前加上 <code>3</code> ，就是 <code>7</code>的所有组合，依次这样找下去。</li>
</ul>
<p>基于以上的想法，可以画出如下的树形图。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119195422.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>说明：</p>
<ul>
<li>以 <code>target = 7</code>为 <strong>根结点</strong> ，创建一个分支的时 <strong>做减法</strong> ；</li>
<li>每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 <code>candidate</code>数组的每个元素的值；</li>
<li>减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；</li>
<li>所有从根结点到结点 0 的路径（只能从上往下，没有回路）就是题目要找的一个结果。</li>
</ul>
<p>这棵树有 4 个叶子结点的值 0，对应的路径列表是 <code>[[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]</code>，而示例中给出的输出只有 <code>[[7], [2, 2, 3]]</code>。即：题目中要求每一个符合要求的解是 <strong>不计算顺序</strong> 的。下面分析为什么会产生重复。</p>
<h5 id="针对具体例子分析重复路径产生的原因（难点）"><a href="#针对具体例子分析重复路径产生的原因（难点）" class="headerlink" title="针对具体例子分析重复路径产生的原因（难点）"></a>针对具体例子分析重复路径产生的原因（难点）</h5><p>产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说 <strong>每一个元素可以重复使用</strong>，我们考虑了 <strong>所有的</strong> 候选数，因此出现了重复的列表。</p>
<p>一种简单的去重方案是借助哈希表的天然去重的功能，但实际操作一下，就会发现并没有那么容易。</p>
<p>可不可以在搜索的时候就去重呢？答案是可以的。遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 <strong>按某种顺序</strong> 搜索。具体的做法是：每一次搜索的时候设置 <strong>下一轮搜索的起</strong>点 <code>begin</code>，请看下图。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119200033.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<p>即：从每一层的第 22 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。</p>
<blockquote>
<p>友情提示：如果题目要求，结果集不计算顺序，此时需要按顺序搜索，才能做到不重不漏。「力扣」第 47 题（ <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">全排列 II</a> ）、「力扣」第 15 题（ <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">三数之和</a> ）也使用了类似的思想，使得结果集没有重复。</p>
</blockquote>
<h6 id="实现一-1"><a href="#实现一-1" class="headerlink" title="实现一"></a>实现一</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-comment">// 从根结点到叶子结点的路径</span><br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// target 为负数和 0 的时候不再产生新的孩子结点</span><br>        <span class="hljs-keyword">if</span>(target&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 重点理解这里从 begin 开始搜索的语意</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span><br>            <span class="hljs-built_in">dfs</span>(candidates,i,path,target-candidates[i],res);<br>            <span class="hljs-comment">// 状态重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="剪枝提速"><a href="#剪枝提速" class="headerlink" title="剪枝提速"></a>剪枝提速</h5><ul>
<li>根据上面画树形图的经验，如果 <code>target</code>减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。基于这个想法，可以对输入数组进行排序，添加相关逻辑达到进一步剪枝的目的；</li>
<li>排序是为了提高搜索速度，对于解决这个问题来说非必要。但是搜索问题一般复杂度较高，能剪枝就尽量剪枝。实际工作中如果遇到两种方案拿捏不准的情况，都试一下。</li>
</ul>
<h6 id="实现二-1"><a href="#实现二-1" class="headerlink" title="实现二"></a>实现二</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span><br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 重点理解这里剪枝，前提是候选数组已经有序</span><br>            <span class="hljs-keyword">if</span>(target-candidates[i]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">dfs</span>(candidates,i,path,target-candidates[i],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h5><p>如果对于「回溯算法」的理解还很模糊，建议在「递归」之前和「递归」之后，把 <code>path</code> 变量的值打印出来看一下，以加深对于程序执行流程的理解。</p>
<p>直接查阅@<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">liweiwei1419</a> 题解。</p>
<h4 id="思路二：按照每一个数选与不选画出二叉树"><a href="#思路二：按照每一个数选与不选画出二叉树" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>对于组合来说，还可以根据一个数选和不选画树形图。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119202112.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==candidates.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 直接跳过</span><br>        <span class="hljs-built_in">dfs</span>(candidates,begin+<span class="hljs-number">1</span>,path,target,res);<br>        <span class="hljs-comment">// 选择当前数</span><br>        <span class="hljs-keyword">if</span>(target-candidates[begin]&gt;=<span class="hljs-number">0</span>)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[begin]);<br>            <span class="hljs-built_in">dfs</span>(candidates,begin,path,target-candidates[begin],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119201031.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<h4 id="什么时候使用-used-数组，什么时候使用-begin-变量"><a href="#什么时候使用-used-数组，什么时候使用-begin-变量" class="headerlink" title="什么时候使用 used 数组，什么时候使用 begin 变量"></a>什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code> 变量</h4><p>有些朋友可能会疑惑什么时候使用 <code>used</code> 数组，什么时候使用 <code>begin</code>变量。这里为大家简单总结一下：</p>
<ul>
<li>排列问题，讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code> 视为不同列表时），需要记录哪些数字已经使用过，此时用 <code>used</code>数组；</li>
<li>组合问题，不讲究顺序（即 <code>[2, 2, 3]</code> 与 <code>[2, 3, 2]</code>视为相同列表时），需要按照某种顺序搜索，此时使用 <code>begin</code>变量。</li>
</ul>
<p>注意：具体问题应该具体分析， <strong>理解算法的设计思想</strong> 是至关重要的，请不要死记硬背。</p>
<h2 id="40-组合总和-II-medium"><a href="#40-组合总和-II-medium" class="headerlink" title="40. 组合总和 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a>[medium]</h2><h3 id="解法：回溯-剪枝-1"><a href="#解法：回溯-剪枝-1" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><p>详细思路叙述参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">liweiwei1419</a> 题解。</p>
<p>与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 的差别：</p>
<p>39  <code>candidates</code> 中的数字可以无限制重复被选取；40 <code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p>相同点是：相同数字列表的不同排列视为一个结果。</p>
<h4 id="如何去掉重复的集合（重点）"><a href="#如何去掉重复的集合（重点）" class="headerlink" title="如何去掉重复的集合（重点）"></a>如何去掉重复的集合（重点）</h4><p>为了使得解集不包含重复的组合。有以下 2 种方案：</p>
<ul>
<li>使用 <strong>哈希表</strong> 天然的去重功能，但是编码相对复杂；</li>
<li>这里我们使用和第 39 题和第 15 题（三数之和）类似的思路：不重复就需要按 <strong>顺序</strong> 搜索， <strong>在搜索的过程中检测分支是否会出现重复结果</strong> 。注意：这里的顺序不仅仅指数组 <code>candidates</code>有序，还指按照一定顺序搜索结果。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201119210609.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>由第 39 题我们知道，数组 <code>candidates</code> 有序，也是 <strong>深度优先遍历</strong> 过程中实现「剪枝」的前提。<br>将数组先排序的思路来自于这个问题：去掉一个数组中重复的元素。很容易想到的方案是：先对数组 <strong>升序</strong> 排序，重复的元素一定不是排好序以后相同的连续数组区域的第 1 个元素。也就是说，剪枝发生在：<strong>同一层数值相同的结点第 2、3 … 个结点，因为数值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果</strong>，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比第 1 个结点更多，并且是第 1 个结点的子集。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> len=candidates.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<span class="hljs-comment">// 从根结点到叶子结点的路径</span><br>        <span class="hljs-built_in">dfs</span>(candidates,<span class="hljs-number">0</span>,path,target,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// begin：从候选数组的 begin 位置开始搜索</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;candidates,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> target,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;candidates.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] 肯定也小于 0，因此用 break</span><br>            <span class="hljs-keyword">if</span>(target-candidates[begin]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span><br>            <span class="hljs-keyword">if</span>(i&gt;begin&amp;&amp;candidates[i]==candidates[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span><br>            <span class="hljs-built_in">dfs</span>(candidates,i+<span class="hljs-number">1</span>,path,target-candidates[i],res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>调试示例输出可以查阅 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">liweiwei1419</a> 题解。</p>
<h4 id="讲解小剪枝语句如何避免重复"><a href="#讲解小剪枝语句如何避免重复" class="headerlink" title="讲解小剪枝语句如何避免重复"></a>讲解小剪枝语句如何避免重复</h4><p>参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/xiang-xi-jiang-jie-ru-he-bi-mian-zhong-fu-by-allen/">Allen</a> 题解。</p>
<p>这个避免重复思想最重要的作用是，可以让同一层级，不出现相同的元素，但是却允许了不同层级之间的重复。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">例1:<br>          1<br>         / \<br>       <span class="hljs-number"> 2 </span> <span class="hljs-number"> 2 </span> 这种情况不会发生 <br>       /     \<br>     <span class="hljs-number"> 5 </span>      5<br>例2<br>          1<br>         /<br>       <span class="hljs-number"> 2 </span>     这种情况确是允许的<br>       /<br>     <span class="hljs-number"> 2 </span> <br></code></pre></td></tr></table></figure>

<p>为何会有这种神奇的效果呢？</p>
<p>首先 <code>candidates[i]==candidates[i-1]</code> 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例 1。可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例 2 的情况也会消失。 因为当第二个2出现的时候，他就和前一个 2 相同了。</p>
<p>那么如何保留例 2 呢？</p>
<p>那么就用 <code>i&gt;begin</code> 来避免这种情况，你发现例 1 中的两个 2 是处在同一个层级上的，例 2 的两个 2 是处在不同层级上的。在一个 for 循环中，所有被遍历到的数都是属于同一个层级的。我们要让一个层级中，必须出现且只出现一个 2，那么就放过第一个出现重复的 2，但不放过后面出现的 2。第一个出现的 2 的特点就是<code>i==begin</code>，第二个出现的 2 特点是<code>i&gt;begin</code>。</p>
<h2 id="77-组合-medium"><a href="#77-组合-medium" class="headerlink" title="77. 组合[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">77. 组合</a>[medium]</h2><p>详细思路叙述和调试输出参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">liweiwei1419</a> 题解。</p>
<h3 id="解法：回溯-3"><a href="#解法：回溯-3" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 相似。</p>
<h4 id="思路一：根据搜索起点画出二叉树-1"><a href="#思路一：根据搜索起点画出二叉树-1" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>例如输入：<code>n = 4, k = 2</code>，可以发现如下递归结构：</p>
<ol>
<li>如果组合里有 <code>1</code> ，那么需要在 <code>[2, 3, 4]</code>里再找 1 个数；</li>
<li>如果组合里有 <code>2</code> ，那么需要在 <code>[3, 4]</code>里再找 1 个数。注意：这里不能再考虑 1，因为包含 1 的组合，在第 1 种情况中已经包含。</li>
</ol>
<p>依次类推（后面部分省略），以上描述体现的 <strong>递归</strong> 结构是：在以 n 结尾的候选数组里，选出若干个元素。画出递归结构如下图：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121215225.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>说明：</p>
<ul>
<li>叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量 <code>path</code>，它是一个列表，特别地， <code>path</code>是一个栈；</li>
<li>每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 <code>start</code>，表示在区间  <code>[begin, n]</code>里选出若干个数的组合；</li>
<li>可能有一些分支没有必要执行，放在优化中介绍。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 从 1 开始是题目的设定</span><br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件是：path 的长度等于 k</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历可能的搜索起点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-comment">// 向路径变量里添加一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-comment">// 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素</span><br>            <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="优化：分析搜索起点的上界进行剪枝"><a href="#优化：分析搜索起点的上界进行剪枝" class="headerlink" title="优化：分析搜索起点的上界进行剪枝"></a>优化：分析搜索起点的上界进行剪枝</h5><p>上面的代码，搜索起点遍历到 <code>n</code>，即：递归函数中有下面的代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从当前搜索起点 begin 遍历到 n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin; i &lt;= n; i++) &#123;<br>    path.addLast(i);<br>    dfs(n, k, i + <span class="hljs-number">1</span>, path, res);<br>    path.removeLast();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>事实上，如果 <code>n = 7, k = 4</code>，<strong>从 5 开始搜索就已经没有意义了</strong>，这是因为：即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。因此，<strong>搜索起点有上界</strong>，这个上界是多少，可以举几个例子分析。</p>
<p>分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。</p>
<p>下面的图片绿色部分是剪掉的枝叶，当 <code>n</code> 很大的时候，能少遍历很多结点，节约了时间。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121220205.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>容易知道：搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 <code>path</code> 的长度相关。我们举几个例子分析：</p>
<p>例如：<code>n = 6 ，k = 4</code>：</p>
<p><code>path.size() == 1</code> 的时候，接下来要选择 3 个数，搜索起点最大是 4，最后一个被选的组合是 <code>[4, 5, 6]</code>；</p>
<p><code>path.size() == 2</code> 的时候，接下来要选择 2 个数，搜索起点最大是 5，最后一个被选的组合是 <code>[5, 6]</code>；</p>
<p><code>path.size() == 3</code> 的时候，接下来要选择 1 个数，搜索起点最大是 6，最后一个被选的组合是 <code>[6]</code>。</p>
<p>可以归纳出：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">搜索起点的上界 + 接下来要选择的元素个数 - <span class="hljs-number">1</span> = <span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure>

<p>其中，接下来要选择的元素个数 <code>= k - path.size()</code>，整理得到：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">搜索起点的上界 = n - (k - <span class="hljs-built_in">path</span>.size()) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>所以，剪枝过程就是：把 <code>i &lt;= n</code> 改成 <code>i &lt;= n - (k - path.size()) + 1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有这里 i &lt;= n - (k - path.size()) + 1 与之前代码不同</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=n-(k-path.<span class="hljs-built_in">size</span>())+<span class="hljs-number">1</span>;++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="思路二：按照每一个数选与不选画出二叉树-1"><a href="#思路二：按照每一个数选与不选画出二叉树-1" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>可以按照每一个数选与不选画出二叉树，二叉树最多 <code>n</code> 层。同样可以剪枝。剪枝的思路请见下图「剪枝条件 ② 的加强」。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221217.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>画一个表格更容易看出边界条件。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201121221306.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 基础版本（无剪枝条件②的加强）的递归终止条件：if (begin==n+1)</span><br>        <span class="hljs-keyword">if</span>(begin&gt;n-k+<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 不选当前考虑的数 begin，直接递归到下一层</span><br>        <span class="hljs-built_in">dfs</span>(n,k,begin+<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-comment">// 选当前考虑的数 begin，递归到下一层的时候 k - 1，这里 k 表示还需要选多少个数</span><br>        path.<span class="hljs-built_in">push_back</span>(begin);<br>        <span class="hljs-built_in">dfs</span>(n,k<span class="hljs-number">-1</span>,begin+<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-comment">// 深度优先遍历有回头的过程，因此需要撤销选择</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="216-组合总和-III-medium"><a href="#216-组合总和-III-medium" class="headerlink" title="216. 组合总和 III[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a>[medium]</h2><h3 id="解法：回溯-4"><a href="#解法：回溯-4" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a> 相似。</p>
<h4 id="思路一：根据搜索起点画出二叉树-2"><a href="#思路一：根据搜索起点画出二叉树-2" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125214145.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<ul>
<li>尝试做减法，减到 0 就说明可能找到了一个符合题意的组合，但是题目对组合里元素的个数有限制，因此还需要对元素个数做判断；</li>
<li>如果减到负数，没有必要继续搜索下去；</li>
<li>由于结果集里的元素互不相同，因此<strong>下一层搜索的起点应该是上一层搜索的起点值 + 1</strong>；</li>
<li><strong>根据画出的递归树设计递归方法的参数</strong>。</li>
</ul>
<p>编写代码就是要在这棵递归树上搜索所有符合条件的解，使用的是深度优先遍历。需要设计递归方法，参数有：</p>
<ul>
<li>剩下的数的和是多少，这里命名为 <code>residue</code>，一维剩余元素之和，初始的时候传入 <code>n</code>；</li>
<li>因为题目规定，需要 <code>k</code>个数，每递归一层，需要找的数就减去 1，因此需要一个变量表示还需要搜索多少个数，仍然用 <code>k</code> 表示，到 <code>0</code>的时候搜索结束；</li>
<li>搜索的起点，最小是 1，最大是 9，<strong>事实上，这个最大值有一个上界</strong>。暂时忽略对它的讨论；</li>
<li>需要一个变量 <code>path</code>表示从根结点到叶子结点的路径。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 这一步判断可以放到上一层，减少递归深度</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-i,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="剪枝优化："><a href="#剪枝优化：" class="headerlink" title="剪枝优化："></a>剪枝优化：</h5><ul>
<li><p>首先是对输入的特殊判断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || n &lt;= <span class="hljs-number">0</span> || k &gt; n) &#123;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>n</code> 其实是有上限的，考虑最大的 <code>k</code> 个数字：<code>[9, 8, ... , (9 - k + 1)]</code>，他们的和为 <code>(19 - k) * k / 2</code>，如果比这个数还大，就不用搜索下去了。</p>
</li>
<li><p>每一轮搜索的起点值也有一个上限，起点值最多到 <code>9</code>，找一下规律：</p>
</li>
</ul>
<p>起点值列表： <code>[..., 7, 8, 9]</code></p>
<ul>
<li>找 3 个数，起点最多到 7；</li>
<li>找 2 个数，起点最多到 8。</li>
</ul>
<p>因此一般规律是：<code>起点上界 + k = 10</code>，故 <code>起点上界 = 10 - k</code>。事实上，还可以计算得到一个更小的上界，但是在这题里没有必要了，每次去计算也要消耗时间。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201125215309.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">// 一开始做一些特殊判断</span><br>        <span class="hljs-keyword">if</span>(k&lt;=<span class="hljs-number">0</span>||n&lt;=<span class="hljs-number">0</span>||k&gt;n)<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 寻找 n 的上限：[9, 8, ... , (9 - k + 1)]，它们的和为 (19 - k) * k / 2</span><br>        <span class="hljs-comment">// 比上限还大，就不用搜索了：</span><br>        <span class="hljs-keyword">if</span>(n&gt;(<span class="hljs-number">19</span>-k)*k/<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">1</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 剪枝：[start, 9] 这个区间里的数都不够 k 个，不用继续往下搜索</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">10</span>-begin&lt;k)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 规律是，起点上界 + k = 10，故起点上界 = 10 - k</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;=<span class="hljs-number">10</span>-k;++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span>(residue-i&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>            path.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-i,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="思路二：按照每一个数选与不选画出二叉树-2"><a href="#思路二：按照每一个数选与不选画出二叉树-2" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><p>对于组合来说，还可以根据一个数选和不选画树形图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-comment">// 生成数字</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; nums;        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;++i)<br>            nums.<span class="hljs-built_in">push_back</span>(i);<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 注意begin从0开始，代表nums索引</span><br>        <span class="hljs-built_in">dfs</span>(k,n,<span class="hljs-number">0</span>,nums,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>            &#123;<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(begin&gt;=nums.<span class="hljs-built_in">size</span>()||residue-nums[begin]&lt;<span class="hljs-number">0</span>||k&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        path.<span class="hljs-built_in">push_back</span>(nums[begin]);<br>        <span class="hljs-built_in">dfs</span>(k<span class="hljs-number">-1</span>,residue-nums[begin],begin+<span class="hljs-number">1</span>,nums,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-built_in">dfs</span>(k,residue,begin+<span class="hljs-number">1</span>,nums,path,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78. 子集[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a>[medium]</h2><h3 id="解法一：回溯"><a href="#解法一：回溯" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><h4 id="思路一：根据搜索起点画出二叉树-3"><a href="#思路一：根据搜索起点画出二叉树-3" class="headerlink" title="思路一：根据搜索起点画出二叉树"></a>思路一：根据搜索起点画出二叉树</h4><p>每次看看有几个数能选，然后选一个：</p>
<ul>
<li>用 for 枚举出当前可选的数，比如选第一个数：有 1、2、3 可选。</li>
<li>选了 1，选第二个数，有 2、3 可选；如果选 2，选第二个数，只有 3 可选，如下图</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123174727.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 没有显式的递归终止</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 组合问题，状态在递归完成后要重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="思路二：按照每一个数选与不选画出二叉树-3"><a href="#思路二：按照每一个数选与不选画出二叉树-3" class="headerlink" title="思路二：按照每一个数选与不选画出二叉树"></a>思路二：按照每一个数选与不选画出二叉树</h4><ul>
<li>单看每个元素，都有两种选择：选入子集，或不选入子集。<ul>
<li>比如<code>[1,2,3]</code>，先考察 1，选它或不选它，都会再考察 2，选它或不选它，以此类推。</li>
</ul>
</li>
<li>考察当前枚举的数，基于选它，继续选下去（一个递归分支）；基于不选它，继续选下去（一个递归分支）</li>
<li>在递归子调用中，又面临两种选择：选或不选……</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123164029.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 当前数可选，也可以不选</span><br>        <span class="hljs-comment">// 选了有，进入下一层</span><br>        path.<span class="hljs-built_in">push_back</span>(nums[begin]);<br>        <span class="hljs-built_in">dfs</span>(nums,begin+<span class="hljs-number">1</span>,path,res);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <span class="hljs-comment">// 不选，直接进入下一层</span><br>        <span class="hljs-built_in">dfs</span>(nums,begin+<span class="hljs-number">1</span>,path,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>逐个枚举，空集的幂集只有空集，每增加一个元素，让之前幂集中的每个集合，追加这个元素，就是新增的子集。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123172351.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 当前数字与已经存在的子集组合成新的组合，并将其加入到结果中</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：使用位运算技巧"><a href="#解法三：使用位运算技巧" class="headerlink" title="解法三：使用位运算技巧"></a>解法三：使用位运算技巧</h3><p>数组的每个元素，可以有两个状态：</p>
<ul>
<li>不在子数组中（用 0 表示）；</li>
<li>在子数组中（用 1 表示）。</li>
</ul>
<p>从 0 到 2 的数组个数次幂（不包括）的整数的二进制表示就能表示所有状态的组合。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123165451.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                    cur.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="90-子集-II-medium"><a href="#90-子集-II-medium" class="headerlink" title="90. 子集 II[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a>[medium]</h2><h3 id="解法一：回溯-剪枝"><a href="#解法一：回溯-剪枝" class="headerlink" title="解法一：回溯+剪枝"></a>解法一：回溯+剪枝</h3><p>回溯思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法一思路一相同。剪枝思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a>、 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a> 相同。</p>
<p>剪枝思路：</p>
<p>以 <code>[1, 2, 2&#39;]</code>（2’ 的 “ ‘ “ 是为了理解方便加的） 为例，如果不剪枝将会得到的非空子集为：<code>[[1],[1,2],[1,2,2&#39;],[1,2&#39;],[2],[2,2&#39;],[2&#39;]]</code>。</p>
<ul>
<li>出现重复解的为 [2] [2’] 和 [1, 2] [1, 2’]；</li>
<li>观察选取到重复的解的特点， 重复的解是因为有 2 个或以上个相同的元素（如 2， 2’）在同一层回溯过程中被分别选择， 作为最终解的一部分了。所以处理这种问题， 就是要在回溯过程中区分出来这种数值相同的情况（就是要区分出来 2 &#x3D;&#x3D; 2’）；</li>
<li>因为输入数据已经经过排序， 所以一种显而易见的做法就是在回溯时， 检查当前元素是否和上一个元素相同，即 <code>nums[i - 1] == nums[i]</code>  如果发现和上一个相同了就可以直接跳过（如<code>nums = [1, 2, 2&#39;] nums[1]==nums[2], nums[2]</code> 就直接跳过了）；</li>
<li>需要注意的是<code>nums[i - 1]==nums[i]</code> 的作用是在递归树的同一层上的，也就是防止<code>nums = [1, 2, 2&#39;] 出现 [1, 2]， [1, 2&#39;] </code>两个重复的解 （即： 通过 <code>nums[1] == nums[2]: continue</code> 进行的剪枝）；</li>
<li>而解 [1, 2, 2’] 实际中的 2, 2’ 是位于递归树的不同层级的， 也就是剪枝要从每一层的第二个元素开始， 所以还要增加一个<code>i &gt; start 或者 i != start</code>。最终的思路就是要增加一个 <code>i&gt;start &amp;&amp; nums[i - 1]==nums[i] 或 i!=start &amp;&amp; nums[i - 1]==nums[i]</code> 的剪枝。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-comment">// 排序是剪枝的前提</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> begin,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 没有显式的递归终止</span><br>        res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝关键代码</span><br>            <span class="hljs-keyword">if</span>(i&gt;begin&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>,path,res);<br>            <span class="hljs-comment">// 组合问题，状态在递归完成后要重置</span><br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;  <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：迭代-剪枝"><a href="#解法二：迭代-剪枝" class="headerlink" title="解法二：迭代+剪枝"></a>解法二：迭代+剪枝</h3><p>迭代思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法二相同。</p>
<h4 id="剪枝思路一"><a href="#剪枝思路一" class="headerlink" title="剪枝思路一"></a>剪枝思路一</h4><p>如果有重复的数字，按照原来的迭代方式，会出现重复的数组。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201123214501.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>如上图第 4 行黑色的部分重复，是怎么造成的呢？第 4 行新添加的 2 要加到第 3 行的所有解中，而第 3 行的一部分解是旧解，一部分是新解。可以看到，黑色部分是由第 3 行的旧解产生的，橙色部分是由新解产生的。</p>
<p>而第 2 行到第 3 行，已经在旧解中加入了 2 产生了第 3 行的橙色部分，所以这里如果再在旧解中加 2 产生黑色部分就造成了重复。</p>
<p>所以当有重复数字的时候，只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-type">int</span> start=<span class="hljs-number">1</span>;<span class="hljs-comment">//保存新解的开始位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历之前的所有结果</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                <span class="hljs-comment">// 如果出现重复数字，就跳过所有旧解</span><br>                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]==nums[i<span class="hljs-number">-1</span>]&amp;&amp;j&lt;start)<br>                    <span class="hljs-keyword">continue</span>;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>            &#125;<br>            <span class="hljs-comment">// 更新新解的开始位置</span><br>            start=resLen;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="剪枝思路二"><a href="#剪枝思路二" class="headerlink" title="剪枝思路二"></a>剪枝思路二</h4><p>当有重复数字出现的时候不再按照之前的思路走，而是单独考虑这种情况。</p>
<p>当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 … 什么意思呢，看一个例子。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">数组 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>2 ] <br>[ ]的所有子串 [ ]<br>[<span class="hljs-number"> 1 </span>] 个的所有子串 [ ] [<span class="hljs-number"> 1 </span>] <br>然后出现了重复数字 2，那么记录重复的次数，然后遍历之前每个解即可<br>对于 [ ] 这个解：<br>加<span class="hljs-number"> 1 </span>个 2，变成 [<span class="hljs-number"> 2 </span>] <br>加<span class="hljs-number"> 2 </span>个 2，变成 [<span class="hljs-number"> 2 </span>2 ]<br>加<span class="hljs-number"> 3 </span>个 2，变成 [<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>]<br>对于 [<span class="hljs-number"> 1 </span>] 这个解：<br>加<span class="hljs-number"> 1 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2 ] <br>加<span class="hljs-number"> 2 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>]<br>加<span class="hljs-number"> 3 </span>个 2，变成 [<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 2 </span>2 ]<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<span class="hljs-comment">// 空集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">int</span> dupCount=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 判断当前是否是重复数字，并且记录重复的次数</span><br>            <span class="hljs-keyword">while</span>((i+<span class="hljs-number">1</span>&lt;nums.<span class="hljs-built_in">size</span>())&amp;&amp;nums[i+<span class="hljs-number">1</span>]==nums[i])<br>            &#123;<br>                ++dupCount;<br>                ++i;<br>            &#125;<br>            <span class="hljs-type">int</span> resLen=res.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历之前几个结果的每个解</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;resLen;++j)<br>            &#123;<br>                vector&lt;<span class="hljs-type">int</span>&gt; tmp=res[j];<br>                <span class="hljs-comment">// 每次在上次的结果中多加 1 个重复数字</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=dupCount;++k)<br>                &#123;<br>                    tmp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    res.<span class="hljs-built_in">push_back</span>(tmp);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：位运算-剪枝"><a href="#解法三：位运算-剪枝" class="headerlink" title="解法三：位运算+剪枝"></a>解法三：位运算+剪枝</h3><p>位运算思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">78. 子集</a> 解法三相同。</p>
<p>如果有重复数字，会出现以下情况，对于 nums &#x3D; [ 1 2 2 2 3 ]。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span>  -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>  ]<br></code></pre></td></tr></table></figure>

<p>上边三个数产生的数组重复了。三个中只取其中 1 个，取哪个呢？取从重复数字的开头连续的数字。什么意思呢？就是下边的情况是保留的。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span>         ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span>       ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>     ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>   ]<br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> -&gt; [  <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> ]  <br></code></pre></td></tr></table></figure>

<p>而对于 [ 2 2 ] 来说，除了 1 1 0 0 0 可以产生，下边的几种情况，都是产生的 [ 2 2 ]</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">2<span class="hljs-number"> 2 </span>2<span class="hljs-number"> 2 </span>2 <br>1<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 0 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 1 </span>0<span class="hljs-number"> 1 </span>0 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1 -&gt; [ <span class="hljs-number"> 2 </span>2       ]<br>......<br></code></pre></td></tr></table></figure>

<p>怎么把 1 1 0 0 0 和上边的那么多种情况区分开来呢？看一下出现了重复数字，并且当前是 1 的前一个的二进位。</p>
<p>对于 <strong>1</strong> 1 0 0 0 ，是 1。</p>
<p>对于 1 <strong>0</strong> 1 0 0 , 是 0。</p>
<p>对于 <strong>0</strong> 1 1 0 0 ，是 0。</p>
<p>对于 <strong>0</strong> 1 0 1 0 ，是 0。</p>
<p>对于 0 0 <strong>0</strong> 1 1 ，是 0。</p>
<p>……</p>
<p>可以看到只有第一种情况对应的是 1 ，其他情况都是 0。其实除去从开头是连续的 1 的话，就是两种情况。</p>
<p>第一种就是，占据了开头，类似于这种 1<strong>0</strong>…1….</p>
<p>第二种就是，没有占据开头，类似于这种 <strong>0</strong>…1…</p>
<p>这两种情况，除了第一位，其他位的 1 的前边一定是 0。所以条件是看出现了重复数字，并且当前位是 1 的前一个的二进位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>&lt;&lt;len;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>            <span class="hljs-type">bool</span> illegal=<span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-comment">// 当前位是 1</span><br>                <span class="hljs-keyword">if</span>((i&gt;&gt;j)&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 当前是重复数字，并且前一位是 0，跳过这种情况</span><br>                    <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;nums[j]==nums[j<span class="hljs-number">-1</span>]&amp;&amp;(i&gt;&gt;(j<span class="hljs-number">-1</span>)&amp;<span class="hljs-number">1</span>)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        illegal=<span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        cur.<span class="hljs-built_in">push_back</span>(nums[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!illegal)<br>                res.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="60-排列序列-hard"><a href="#60-排列序列-hard" class="headerlink" title="60. 排列序列[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-sequence/">60. 排列序列</a>[hard]</h2><p>通过 <strong>计算剩余数字个数的阶乘数</strong>，一位一位选出第 <code>k</code> 个排列的数位。</p>
<h3 id="解法一：全排列-剪枝"><a href="#解法一：全排列-剪枝" class="headerlink" title="解法一：全排列+剪枝"></a>解法一：全排列+剪枝</h3><p>使用 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a> 的回溯搜索，依次得到全排列，输出第 k 个全排列。事实上不需要求出所有全排列，所求排列 <strong>一定在叶子结点处得到</strong>，进入每一个分支，可以根据已经选定的数的个数，进而计算还未选定的数的个数，然后计算阶乘，就知道这一个分支的 <strong>叶子结点</strong> 的个数：</p>
<ul>
<li>如果 k 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，即「剪枝」；</li>
<li>如果 k 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126210516.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p><strong>编码注意事项：</strong></p>
<ul>
<li>计算阶乘的时候，可以使用循环计算。注意：0!&#x3D;1，它表示了没有数可选的时候，即表示到达叶子结点了，排列数只剩下 1 个；</li>
<li>题目中说「给定 n 的范围是 [1,9]」，可以把从 0 到 9 的阶乘计算好，放在一个数组里，可以根据索引直接获得阶乘值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">calculateFactorial</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)</span></span>;<span class="hljs-comment">//记录数字是否使用过</span><br>        string path;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">0</span>,used,path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; factorial;<span class="hljs-comment">//阶乘数组</span><br>    <span class="hljs-comment">// 计算阶乘数组</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calculateFactorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        factorial.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            factorial.<span class="hljs-built_in">push_back</span>(factorial[i<span class="hljs-number">-1</span>]*i);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,string &amp;path)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==n)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 计算还未确定的数字的全排列的个数，第 1 次进入的时候是 n - 1</span><br>        <span class="hljs-type">int</span> cnt=factorial[n<span class="hljs-number">-1</span>-index];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(used[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(cnt&lt;k)<br>            &#123;<br>                k-=cnt;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            path+=<span class="hljs-built_in">to_string</span>(i);<br>            used[i]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(n,k,index+<span class="hljs-number">1</span>,used,path);<br>            <span class="hljs-comment">// 注意 1：不可以回溯（重置变量），算法设计是「一下子来到叶子结点」，没有回头的过程</span><br>            <span class="hljs-comment">// 注意 2：这里要加 return，后面的数没有必要遍历去尝试了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：有序数组（链表）模拟"><a href="#解法二：有序数组（链表）模拟" class="headerlink" title="解法二：有序数组（链表）模拟"></a>解法二：有序数组（链表）模拟</h3><p>如果 <code>n = 4</code>，<code>k = 16</code>，现在确定第 1 个数字填啥。如果 <code>k</code> &gt; 后面的数字个数的阶乘。数一数，可以跳过几个阶乘数。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214453.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>其实这个思路很像解法一的「剪枝」，只不过解法一减法，解法二用除法。</p>
<p><strong>算法流程设计</strong>：</p>
<ul>
<li>把候选数放在一个 <strong>有序列表</strong> 里，从左到右根据「剩下的数的阶乘数」确定每一位填谁，公式 k &#x2F; (后面几位的阶乘数) 的值 <strong>恰好等于候选数组的下标</strong>；</li>
<li>选出一个数以后，<code>k</code> 就需要减去相应跳过的阶乘数的倍数，也可直接求余；</li>
<li><strong>已经填好的数需要从候选列表里删除</strong>，注意保持列表的有序性（因为排列的定义是按照字典序）；</li>
<li>由于这里考虑的是下标，第 <code>k</code> 个数，下标为 <code>k - 1</code>，一开始的时候，<code>k--</code>。</li>
</ul>
<p>下面看一个例子：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201126214753.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">getPermutation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 相当于在n个数字的全排列中找到下标为k - 1的那个数，因此k先减1</span><br>        --k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">factorial</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        factorial[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 先算出所有的阶乘值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)<br>            factorial[i]=factorial[i<span class="hljs-number">-1</span>]*i;<br>        <span class="hljs-comment">// 这里使用数组或者链表都行</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>            nums[i<span class="hljs-number">-1</span>]=i;<br>        string res;<br>        <span class="hljs-comment">// i 表示剩余的数字个数，初始化为n-1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-type">int</span> index=k/factorial[i];<br>            res+=<span class="hljs-built_in">to_string</span>(nums[index]);<br>            nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>()+index);<br>            k%=factorial[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="93-复原IP地址-medium"><a href="#93-复原IP地址-medium" class="headerlink" title="93. 复原IP地址[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原IP地址</a>[medium]</h2><h3 id="解法：回溯-剪枝-2"><a href="#解法：回溯-剪枝-2" class="headerlink" title="解法：回溯+剪枝"></a>解法：回溯+剪枝</h3><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127211509.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<ul>
<li>剩余的字符个数大于能组成的合法 IP 片段，则剪枝；</li>
<li>每一个结点可以选择截取的方法只有 3 种：截 1 位、截 2 位、截 3 位，因此每一个结点可以生长出的分支最多只有 3 条分支；</li>
<li>根据截取出来的字符串判断是否是合理的 IP 片段，如果不是，则剪枝；</li>
<li>由于 IP 段最多就 4 个段，因此这棵三叉树最多 4 层，这个条件作为递归终止条件之一；</li>
<li>每一个结点表示了求解这个问题的不同阶段，需要的状态变量有：<ul>
<li><code>residue</code>：记录剩余多少段还没被分割；</li>
<li><code>begin</code>：截取 IP 段的起始位置；</li>
<li><code>path</code>：记录从根结点到叶子结点的一个路径（回溯算法常规变量）；</li>
<li><code>res</code>：记录结果集的变量，常规变量。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(s,len,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> len,<span class="hljs-type">int</span> residue,<span class="hljs-type">int</span> begin,string &amp;path,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(begin==len)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(residue==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 首个IP片段前不需要&#x27;.&#x27;</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">4</span>)<br>            path+=<span class="hljs-string">&quot;.&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=begin;i&lt;begin+<span class="hljs-number">3</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;=len)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 剩下的太多了，就剪枝</span><br>            <span class="hljs-keyword">if</span>(len-i&gt;residue*<span class="hljs-number">3</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 截取片段</span><br>            <span class="hljs-function">string <span class="hljs-title">tmp</span><span class="hljs-params">(s.begin()+begin,s.begin()+i+<span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">valid</span>(tmp))<br>            &#123;<br>                path+=tmp;<br>                <span class="hljs-built_in">dfs</span>(s,len,residue<span class="hljs-number">-1</span>,i+<span class="hljs-number">1</span>,path,res);<br>                <span class="hljs-comment">// 删除tmp,string.erase(index,count);</span><br>                <span class="hljs-comment">// index:要移除的首个字符，count:要移除的字符数</span><br>                path.<span class="hljs-built_in">erase</span>(path.<span class="hljs-built_in">size</span>()-(i-begin+<span class="hljs-number">1</span>),i-begin+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 删除&#x27;.&#x27;</span><br>        <span class="hljs-keyword">if</span>(residue&lt;<span class="hljs-number">4</span>)<br>            path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 s 是否是一个合法的 IP 段</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(string &amp;s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 大于 1 位的时候，不能以 0 开头</span><br>        <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">1</span>&amp;&amp;s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 将 string 转为 int</span><br>        <span class="hljs-type">int</span> num=<span class="hljs-built_in">stoi</span>(s);<br>        <span class="hljs-keyword">return</span> num&gt;=<span class="hljs-number">0</span>&amp;&amp;num&lt;=<span class="hljs-number">255</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17. 电话号码的字母组合[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a>[medium]</h2><h3 id="解法一：DFS-回溯"><a href="#解法一：DFS-回溯" class="headerlink" title="解法一：DFS+回溯"></a>解法一：DFS+回溯</h3><p>建立一个字典，用来保存每个数字所代表的字符串，然后还需要一个变量 index，记录当前生成的字符串的字符个数。在递归函数中首先判断 index，如果跟 digits 中数字的个数相等了，将当前的组合加入结果 res 中，然后返回。通过 digits 中的数字到 phoneMap中取出字符串，然后遍历这个取出的字符串，将每个字符都加到当前的组合后面，并调用递归函数，并用回溯法消除一次遍历操作。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211416.jpeg" srcset="/img/loading.gif" lazyload style="zoom: 50%;" />

<p>对于打印”2345”这样的字符串：</p>
<ul>
<li>第一次递归就是上图中最下面的方格，然后处理完第一个字符 2 之后，将输入的字符改变成”345”并调用第二个递归函数；</li>
<li>第二次递归处理 3，将字符串改变成”45”后再次递归；</li>
<li>第三次递归处理 4，将字符串改变成”5”后继续递归</li>
<li>第四次递归处理5，将字符串改变成””后继续递归；</li>
<li>最后发现字符串为空了，将结果放到列表中并返回。</li>
</ul>
<p>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201116211729.jpeg" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-comment">// 用map记录每个数字按键对应的所有字母</span><br>        unordered_map&lt;<span class="hljs-type">char</span>,string&gt; phoneMap&#123;&#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;;<br>        <span class="hljs-built_in">combine</span>(digits,phoneMap,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;&quot;</span>,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// index是生成临时结果字串的下标</span><br>    <span class="hljs-comment">// str存储临时结果</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(string &amp;digits,unordered_map&lt;<span class="hljs-type">char</span>,string&gt; &amp;phoneMap,<span class="hljs-type">int</span> index,string str,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(index==digits.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(str);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对于当前输入的第index号数字(digits[index])</span><br>        string tmp=phoneMap[digits[index]];<br>        <span class="hljs-comment">// 枚举其对应的所有字母</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;c:tmp)<br>        &#123;<br>            <span class="hljs-comment">// 临时结果压入一个字母</span><br>            str+=c;<br>            <span class="hljs-comment">// 以在当前位置压入该字母这一“情况”为前提，构造此“分支”的后续结果</span><br>            <span class="hljs-built_in">combine</span>(digits,phoneMap,index+<span class="hljs-number">1</span>,str,res);<br>            <span class="hljs-comment">//状态还原，例如临时结果从 &quot;ab&quot; -&gt; &quot;a&quot;，下一次循环尝试&quot;ac&quot; </span><br>            str.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS"><a href="#解法二：BFS" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>在遍历 digits 中所有的数字时，先建立一个临时的字符串数组 tmp，然后跟解法一的操作一样，通过数字到 phoneMap 中取出字符串 chars，然后遍历取出字符串中的所有字符，再遍历当前结果 res 中的每一个字符串，将字符加到后面，并加入到临时字符串数组 tmp 中。取出的字符串 str 遍历完成后，将临时字符串数组赋值给结果 res。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        unordered_map&lt;<span class="hljs-type">char</span>,string&gt; phoneMap&#123;&#123;<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&quot;def&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&quot;ghi&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&quot;jkl&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&quot;mno&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&quot;pqrs&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&quot;tuv&quot;</span>&#125;,&#123;<span class="hljs-string">&#x27;9&#x27;</span>,<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;;<br>        res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;digits.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            vector&lt;string&gt; tmp;<br>            string chars=phoneMap[digits[i]];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c:chars)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;str:res)<br>                    tmp.<span class="hljs-built_in">push_back</span>(str+c);<br>            res=tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="22-括号生成-medium"><a href="#22-括号生成-medium" class="headerlink" title="22. 括号生成[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a>[medium]</h2><h3 id="解法一：DFS-回溯-1"><a href="#解法一：DFS-回溯-1" class="headerlink" title="解法一：DFS+回溯"></a>解法一：DFS+回溯</h3><p>以 <code>n = 2</code> 为例，画树形结构图：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201127221208.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<ul>
<li>当前左右括号都有大于 0 个可以使用的时候，才产生分支；</li>
<li>产生左分支的时候，只看当前是否还有左括号可以使用；</li>
<li>产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；</li>
<li>在左边和右边剩余的括号数都等于 0 的时候结算。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;&quot;</span>,n,n,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-comment">// path 当前递归得到的结果</span><br>    <span class="hljs-comment">// left 左括号还有几个可以使用</span><br>    <span class="hljs-comment">// right 右括号还有几个可以使用</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string path,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span><br>        <span class="hljs-comment">// 在递归终止的时候，直接把它添加到结果集即可</span><br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span>&amp;&amp;right==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(left&gt;right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">dfs</span>(path+<span class="hljs-string">&quot;(&quot;</span>,left<span class="hljs-number">-1</span>,right,res);<br>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">dfs</span>(path+<span class="hljs-string">&quot;)&quot;</span>,left,right<span class="hljs-number">-1</span>,res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>若严格按照「回溯法」的定义去做，全程只用一份状态变量去搜索所有可能的状态（本题中将 path 改成<strong>引用</strong>类型），则有「恢复现场」和「撤销选择」的需要，即回溯。每次都是用新的字符串的话，所用的内存会很多，中间那些变量其实都是不需要的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        string path;<br>        <span class="hljs-built_in">dfs</span>(path,n,n,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;path,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;string&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(left==<span class="hljs-number">0</span>&amp;&amp;right==<span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&gt;right)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            path+=<span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(path,left<span class="hljs-number">-1</span>,right,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;           <br>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            path+=<span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(path,left,right<span class="hljs-number">-1</span>,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-1"><a href="#解法二：BFS-1" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>广度优先遍历，得自己编写结点类，显式使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显式使用栈。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        queue&lt;Node&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(<span class="hljs-string">&quot;&quot;</span>,n,n));<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            Node cur=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(cur.left==<span class="hljs-number">0</span>&amp;&amp;cur.right==<span class="hljs-number">0</span>)<br>                res.<span class="hljs-built_in">push_back</span>(cur.res);<br>            <span class="hljs-keyword">if</span>(cur.left&gt;<span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(cur.res+<span class="hljs-string">&quot;(&quot;</span>,cur.left<span class="hljs-number">-1</span>,cur.right));<br>            <span class="hljs-keyword">if</span>(cur.right&gt;<span class="hljs-number">0</span>&amp;&amp;cur.left&lt;cur.right)<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">Node</span>(cur.res+<span class="hljs-string">&quot;)&quot;</span>,cur.left,cur.right<span class="hljs-number">-1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>        <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Node</span>(string str,<span class="hljs-type">int</span> _left,<span class="hljs-type">int</span> _right):<span class="hljs-built_in">res</span>(str),<span class="hljs-built_in">left</span>(_left),<span class="hljs-built_in">right</span>(_right)<br>        &#123;&#125;<br>        string res;<span class="hljs-comment">// 当前得到的字符串</span><br>        <span class="hljs-type">int</span> left;<span class="hljs-comment">// 剩余左括号数量</span><br>        <span class="hljs-type">int</span> right;<span class="hljs-comment">// 剩余右括号数量</span><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h3><p>思路参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/">Yuyu</a> 题解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;()&quot;</span>&#125;;<br>		vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">dp</span>(n+<span class="hljs-number">1</span>);<br>		dp[<span class="hljs-number">0</span>]=&#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>		dp[<span class="hljs-number">1</span>]=&#123;<span class="hljs-string">&quot;()&quot;</span>&#125;;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i) <br>        &#123;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j) <br>            &#123;<br>				<span class="hljs-keyword">for</span>(string p:dp[j])<br>					<span class="hljs-keyword">for</span>(string q:dp[i-j<span class="hljs-number">-1</span>]) <br>                    &#123;<br>						string str=<span class="hljs-string">&quot;(&quot;</span>+p+<span class="hljs-string">&quot;)&quot;</span>+q;<br>						dp[i].<span class="hljs-built_in">push_back</span>(str);<br>					&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> dp[n];<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="131-分割回文串-medium"><a href="#131-分割回文串-medium" class="headerlink" title="131. 分割回文串[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a>[medium]</h2><h3 id="解法：回溯-5"><a href="#解法：回溯-5" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p>递归树：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207193035.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>思考如何根据这棵递归树编码：</p>
<ol>
<li>每一个结点表示剩余没有扫描到的字符串，产生分支是截取了剩余字符串的前缀；</li>
<li>产生前缀字符串的时候，判断前缀字符串是否是回文。<ul>
<li>如果前缀字符串是回文，则可以产生分支和结点；</li>
<li>如果前缀字符串不是回文，则不产生分支和结点，这一步是剪枝操作。</li>
</ul>
</li>
<li>在叶子结点是空字符串的时候结算，此时<strong>从根结点到叶子结点的路径，就是结果集里的一个结果，使用深度优先遍历，记录下所有可能的结果</strong>。<ul>
<li>采用一个路径变量 <code>path</code> 搜索，<code>path</code> 全局使用一个（注意结算的时候，需要生成一个拷贝），因此在递归执行方法结束以后需要回溯，即将递归之前添加进来的元素拿出去。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        vector&lt;string&gt; path;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// start：起始字符的索引</span><br>    <span class="hljs-comment">// path：记录从根结点到叶子结点的路径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 判断是否回文，不是的话，剪枝</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">checkPalindrome</span>(s,start,i))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// substr(pos,len)</span><br>            string tmp=s.<span class="hljs-built_in">substr</span>(start,i-start+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 s[left...right] 是否回文</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPalindrome</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 严格小于即可</span><br>        <span class="hljs-keyword">while</span>(left&lt;right)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[left++]!=s[right--])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在上一步，验证回文串那里，每一次都得使用“两边夹”的方式验证子串是否是回文子串，为 O(n) 的时间复杂度。于是“用空间换时间”，利用 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a> 的思路，利用动态规划把结果先算出来，这样就可以以 O(1) 的时间复杂度直接得到一个子串是否是回文。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 预处理</span><br>        <span class="hljs-comment">// 状态：dp[i][j] 表示 s[i][j] 是否是回文</span><br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(len,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">// 状态转移方程：在 s[i] == s[j] 的时候，dp[i][j] 参考 dp[i + 1][j - 1]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>;right&lt;len;++right)<br>        &#123;<br>            <span class="hljs-comment">// 注意：left &lt;= right 取等号表示 1 个字符的时候也需要判断</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left=<span class="hljs-number">0</span>;left&lt;=right;++left)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[left]==s[right]&amp;&amp;(right-left&lt;=<span class="hljs-number">2</span>||dp[left+<span class="hljs-number">1</span>][right<span class="hljs-number">-1</span>]))<br>                    dp[left][right]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        vector&lt;string&gt; path;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>,dp,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;dp,vector&lt;string&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(start==s.<span class="hljs-built_in">size</span>())<br>            res.<span class="hljs-built_in">push_back</span>(path);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;s.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 剪枝</span><br>            <span class="hljs-keyword">if</span>(!dp[start][i])<br>                <span class="hljs-keyword">continue</span>;<br>            string tmp=s.<span class="hljs-built_in">substr</span>(start,i-start+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(tmp);<br>            <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>,dp,path,res);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h1 id="题型二：Flood-Fill"><a href="#题型二：Flood-Fill" class="headerlink" title="题型二：Flood Fill"></a>题型二：Flood Fill</h1><p>提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。此类问题不建议修改输入数据，设置 <code>visited</code> 数组是标准的做法。</p>
<h2 id="695-岛屿的最大面积-medium"><a href="#695-岛屿的最大面积-medium" class="headerlink" title="695. 岛屿的最大面积[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a>[medium]</h2><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><blockquote>
<p>经典的方格搜索题目，尽量用 DFS。</p>
</blockquote>
<ul>
<li>计算方格中每个连通岛屿的面积，然后取最大值。</li>
<li>如果在一片土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。</li>
<li>为了确保每个方格不进行重复遍历，每次经过方格时，将这块方格的值置为 0。</li>
</ul>
<p>边界判定一般有两种写法，一种是先判定是否越界，只有在合法的情况下才进行下一步搜索；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（解法一中采用后者，解法二中采用前者）。</p>
<h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,<span class="hljs-built_in">area</span>(grid,i,j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 若坐标不合法，直接返回</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 若该方格不是岛屿，直接返回</span><br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>        grid[i][j]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>+<span class="hljs-built_in">area</span>(grid,i<span class="hljs-number">-1</span>,j)+<span class="hljs-built_in">area</span>(grid,i+<span class="hljs-number">1</span>,j)+<span class="hljs-built_in">area</span>(grid,i,j<span class="hljs-number">-1</span>)+<span class="hljs-built_in">area</span>(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; s;<span class="hljs-comment">// &lt;行索引, 列索引&gt;</span><br>                    s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        <span class="hljs-keyword">auto</span> indexs=s.<span class="hljs-built_in">top</span>();<br>                        s.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row=indexs.first;<br>                        <span class="hljs-type">int</span> col=indexs.second;<br>                        <span class="hljs-comment">// 若坐标不合法，直接进入下一个循环</span><br>                        <span class="hljs-keyword">if</span>(row&lt;<span class="hljs-number">0</span>||col&lt;<span class="hljs-number">0</span>||row&gt;=m||col&gt;=n)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 若该方格不是岛屿，进行下一个循环</span><br>                        <span class="hljs-comment">// 坐标点会重复加入到栈中，所以需要检查</span><br>                        <span class="hljs-keyword">if</span>(grid[row][col]!=<span class="hljs-number">1</span>)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>                        grid[row][col]=<span class="hljs-number">0</span>;<br>                        ++count;<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                    &#125;<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-2"><a href="#解法二：BFS-2" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用队列实现 BFS，每次从队首取出土地，并将接下来想要遍历的土地放在队尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxArea=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">// &lt;行索引, 列索引&gt;</span><br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>                    &#123;<br>                        <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>                        q.<span class="hljs-built_in">pop</span>();<br>                        <span class="hljs-type">int</span> row=indexs.first;<br>                        <span class="hljs-type">int</span> col=indexs.second;<br>                        <span class="hljs-comment">// 若该方格不是岛屿，进行下一个循环</span><br>                        <span class="hljs-comment">// 坐标点会重复加入到队列中，所以需要检查</span><br>                        <span class="hljs-keyword">if</span>(grid[row][col]!=<span class="hljs-number">1</span>)<br>                            <span class="hljs-keyword">continue</span>;<br>                        <span class="hljs-comment">// 标记已遍历过的岛屿，不做重复遍历</span><br>                        grid[row][col]=<span class="hljs-number">0</span>;<br>                        ++count;<br>                        <span class="hljs-comment">// 将相邻的土地入队</span><br>                        <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[row<span class="hljs-number">-1</span>][col]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                        <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;m&amp;&amp;grid[row+<span class="hljs-number">1</span>][col]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                        <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;grid[row][col<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                        <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;n&amp;&amp;grid[row][col+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                    &#125;<br>                    maxArea=<span class="hljs-built_in">max</span>(maxArea,count);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="200-岛屿数量-medium"><a href="#200-岛屿数量-medium" class="headerlink" title="200. 岛屿数量[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a>[medium]</h2><h3 id="解法一：DFS、BFS"><a href="#解法一：DFS、BFS" class="headerlink" title="解法一：DFS、BFS"></a>解法一：DFS、BFS</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> 相同，可使用 DFS 以及 BFS 解决，这里只写出 DFS 代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j);<br>                    ++count;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-string">&#x27;1&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 置0，表示访问过</span><br>        grid[i][j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的一点是，对于算法的输入而言，很多时候是介意修改输入的，除非题目就是要我们修改输入数据。因此，可以创建一个数组，来标记是否已经访问过。这里是 liuyubobobo 老师对这一类问题的解释：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/ru-guo-mian-shi-yu-dao-zhe-ge-wen-ti-zhe-yi-dian-z/">如果面试遇到这个问题，这一点最重要!</a>。</p>
<p>因此建议是：</p>
<ul>
<li>建立 <code>visited</code> 布尔数组辅助完成题目给出的任务。</li>
<li>实在是觉得没有必要用 <code>visited</code> 布尔数组的话，写代码之前可以问一下面试官，和面试官进行沟通。</li>
</ul>
</blockquote>
<p>建立 <code>visited</code> 布尔数组后代码重写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 如果是岛屿中的一个点，并且没有被访问过，就进行深度优先遍历</span><br>                <span class="hljs-keyword">if</span>(!visited[i][j]&amp;&amp;grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j,visited);<br>                    ++count;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 从坐标为 (i, j) 的点开始进行深度优先遍历</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-string">&#x27;1&#x27;</span>||(grid[i][j]=<span class="hljs-string">&#x27;1&#x27;</span>&amp;&amp;visited[i][j]))<br>            <span class="hljs-keyword">return</span>;<br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,visited);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,visited);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：并查集"><a href="#解法二：并查集" class="headerlink" title="解法二：并查集"></a>解法二：并查集</h3><blockquote>
<p>关于连通性问题，并查集也是常用的数据结构。并查集的套路模板可以学习<a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/2.4-shou-ba-shou-she-ji-shu-ju-jie-gou/unionfind-suan-fa-xiang-jie">labuladong的算法小抄</a>。</p>
</blockquote>
<p>对于本题来说，所做的就是分类的问题，把相邻的 <code>1</code> 都分成一类。</p>
<ul>
<li>首先把每个节点各作为一类，用它的行数和列数生成一个 <code>id</code> 标识该类，即函数 <code>getIndex</code> 和构造函数中所做的。</li>
<li>用 <code>nums</code> 来记录当前有多少个岛屿，初始化的时候每个 <code>1</code> 都认为是一个岛屿，然后开始合并。</li>
<li>遍历每个为 <code>1</code> 的节点，将它的右边和下边的 <code>1</code> 和当前节点合并（这里算作一个优化，不需要像解法一那样上下左右）。每进行一次合并，就将 <code>nums</code> 减 <code>1</code> 。</li>
<li>最后返回 <code>nums</code> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parents;<br>    <span class="hljs-type">int</span> nums;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> rows,<span class="hljs-type">int</span> cols)<br>    &#123;<br>        nums=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 记录 1 的个数</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                    ++nums;<br>                <span class="hljs-comment">// 每一个类初始化为它本身</span><br>                parents.<span class="hljs-built_in">push_back</span>(i*cols+j);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 带路径优化的查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> son)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> father=parents[son];<br>        <span class="hljs-keyword">while</span>(father!=son)<br>        &#123;<br>            son=father;<br>            father=parents[son];<br>        &#125;<br>        parents[son]=father;<br>        <span class="hljs-keyword">return</span> father;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span>&#123;<br>        <span class="hljs-type">int</span> father1=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> father2=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-comment">// 发生合并，nums--</span><br>        <span class="hljs-keyword">if</span>(father1!=father2)<br>        &#123;<br>            parents[father2]=father1;<br>            nums--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNums</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        rows=grid.<span class="hljs-built_in">size</span>();<br>        cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(grid,rows,cols)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 将下边右边的 1 节点和当前节点合并</span><br>                    <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;grid[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                        uf.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">getIndex</span>(i,j),<span class="hljs-built_in">getIndex</span>(i+<span class="hljs-number">1</span>,j));<br>                    <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;grid[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                        uf.<span class="hljs-built_in">merge</span>(<span class="hljs-built_in">getIndex</span>(i,j),<span class="hljs-built_in">getIndex</span>(i,j+<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getNums</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="463-岛屿的周长-easy"><a href="#463-岛屿的周长-easy" class="headerlink" title="463. 岛屿的周长[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a>[easy]</h2><h3 id="解法一：直接计算"><a href="#解法一：直接计算" class="headerlink" title="解法一：直接计算"></a>解法一：直接计算</h3><p>一块土地原则上会带来 4 个周长，但岛上的土地存在接壤，每一条接壤，会减掉 2 个边长。所以，总周长 &#x3D; 4 * 土地个数 - 2 * 接壤边的条数。遍历矩阵，遍历到土地，就 land++，如果它的右&#x2F;下边也是土地，则 border++，遍历结束后代入公式。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201109215649.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> land=<span class="hljs-number">0</span>;<span class="hljs-comment">// 土地个数</span><br>        <span class="hljs-type">int</span> border=<span class="hljs-number">0</span>;<span class="hljs-comment">// 接壤边界的条数</span><br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    ++land;<br>                    <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;grid[i+<span class="hljs-number">1</span>][j]==<span class="hljs-number">1</span>)<br>                        ++border;<br>                    <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;grid[i][j+<span class="hljs-number">1</span>]==<span class="hljs-number">1</span>)<br>                        ++border;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> land*<span class="hljs-number">4</span>-border*<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：DFS"><a href="#解法二：DFS" class="headerlink" title="解法二：DFS"></a>解法二：DFS</h3><p><strong>岛屿的周长就是岛屿方格和非岛屿方格相邻的边的数量</strong>。这里的非岛屿方格，既包括水域方格，也包括网格的边界。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201106151555.jpeg" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p>将这个“相邻关系”对应到 DFS 遍历中，就是：每当在 DFS 遍历中，从一个岛屿方格走向一个非岛屿方格，就将周长加 1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">islandPerimeter</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(grid.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 题目限制只有一个岛屿，计算一个即可</span><br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[i][j])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,i,j,visited);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 从一个岛屿方格走向网格边界，周长加 1</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 从一个岛屿方格走向水域方格，周长加 1</span><br>        <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 之前访问过，直接返回0，无周长收益</span><br>        <span class="hljs-keyword">if</span>(visited[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 将方格标记为&quot;已遍历&quot;</span><br>        visited[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 继续往四个方向扩散，目标是遇到边界和水域，答案随着递归出栈向上返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,visited)+<span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,visited)+<span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,visited)+<span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,visited);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="547-朋友圈-medium"><a href="#547-朋友圈-medium" class="headerlink" title="547. 朋友圈[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a>[medium]</h2><h3 id="解法一：DFS-1"><a href="#解法一：DFS-1" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>DFS 搜索，对于某个人，遍历其好友，然后再遍历其好友的好友，那么就能把属于同一个朋友圈的人都遍历一遍，同时标记出已经遍历过的人，然后累积朋友圈的个数。再去对于没有遍历到的人再找其朋友圈的人，这样就能求出个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(M,visited,i);<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;       <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;M,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;M.<span class="hljs-built_in">size</span>();++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(M[i][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[j])<br>            &#123;<br>                visited[j]=<span class="hljs-literal">true</span>;<br>                <span class="hljs-built_in">dfs</span>(M,visited,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-3"><a href="#解法二：BFS-3" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用 BFS 来遍历朋友圈中的所有人。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(len,<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!visited[i])<br>            &#123;<br>                queue&lt;<span class="hljs-type">int</span>&gt; q;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>                &#123;<br>                    <span class="hljs-type">int</span> index=q.<span class="hljs-built_in">front</span>();<br>                    q.<span class="hljs-built_in">pop</span>();<br>                    visited[index]=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(M[index][j]==<span class="hljs-number">1</span>&amp;&amp;!visited[j])<br>                            q.<span class="hljs-built_in">push</span>(j);<br>                    &#125;<br>                &#125;<br>                ++res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：并查集"><a href="#解法三：并查集" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><blockquote>
<p>统计图中连通块数量的题目可以使用并查集。并查集的套路模板可以学习<a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/2.4-shou-ba-shou-she-ji-shu-ju-jie-gou/unionfind-suan-fa-xiang-jie">labuladong的算法小抄</a>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> count;<span class="hljs-comment">// 记录连通分量个数</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        count=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>        --count;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;len;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(M[i][j]==<span class="hljs-number">1</span>&amp;&amp;i!=j)<br>                    uf.<span class="hljs-built_in">unionTree</span>(i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uf.<span class="hljs-built_in">getCount</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域-medium"><a href="#130-被围绕的区域-medium" class="headerlink" title="130. 被围绕的区域[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a>[medium]</h2><h3 id="解法一：DFS-2"><a href="#解法一：DFS-2" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>题目中解释说被包围的区间不会存在于边界上，所以边界上的 O 要特殊处理，只要把边界上的 O 特殊处理了，那么剩下的 O 替换成 X 就可以了。问题转化为，如何寻找和边界联通的 O，需要考虑如下情况。</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp"><span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> O O <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> <span class="hljs-keyword">X</span> O <span class="hljs-keyword">X</span><br><span class="hljs-keyword">X</span> O O <span class="hljs-keyword">X</span><br></code></pre></td></tr></table></figure>

<p>这时候的 O 是不做替换的。因为和边界是连通的。为了记录这种状态，把这种情况下的 O 换成 # 作为占位符，待搜索结束之后，遇到 O 替换为 X（和边界不连通的 O）；遇到 #，替换回 O(和边界连通的 O)。</p>
<h4 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 从边缘O开始搜索</span><br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=board.<span class="hljs-built_in">size</span>()||j&gt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;O&#x27;</span>)<br>            <span class="hljs-keyword">return</span>;<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-built_in">dfs</span>(board,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(board,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(board,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(board,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="非递归写法-1"><a href="#非递归写法-1" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 取出当前stack 顶, 不弹出.</span><br>            <span class="hljs-keyword">auto</span> indexs=s.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-type">int</span> row=indexs.first;<br>            <span class="hljs-type">int</span> col=indexs.second;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row<span class="hljs-number">-1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                board[row<span class="hljs-number">-1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=board.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row+<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                board[row+<span class="hljs-number">1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;              <br>            <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row][col<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                board[row][col<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;                <br>            <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row][col+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                board[row][col+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果上下左右都搜索不到,本次搜索结束，弹出stack</span><br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-4"><a href="#解法二：BFS-4" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>用队列来进行 BFS。和 DFS 不同的是，DFS 中搜索上下左右，只要搜索到一个满足条件，就顺着该方向继续搜索，所以在 DFS 代码中，只要满足条件，就入 stack，然后 continue 本次搜索，进行下一次搜索，直到搜索到没有满足条件的时候出 stack。而 BFS 中，要把上下左右满足条件的都入队，所以搜索的时候就不能 continue。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> rows=board.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-type">bool</span> isEdge=i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    <span class="hljs-built_in">bfs</span>(board,i,j);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>)<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>        board[i][j]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> row=indexs.first;<br>            <span class="hljs-type">int</span> col=indexs.second;<br>            <span class="hljs-keyword">if</span>(row<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row<span class="hljs-number">-1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row<span class="hljs-number">-1</span>,col));<br>                board[row<span class="hljs-number">-1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>                <span class="hljs-comment">// 没有continue</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(row+<span class="hljs-number">1</span>&lt;=board.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row+<span class="hljs-number">1</span>][col]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row+<span class="hljs-number">1</span>,col));<br>                board[row+<span class="hljs-number">1</span>][col]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;              <br>            <span class="hljs-keyword">if</span>(col<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;board[row][col<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col<span class="hljs-number">-1</span>));<br>                board[row][col<span class="hljs-number">-1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;                <br>            <span class="hljs-keyword">if</span>(col+<span class="hljs-number">1</span>&lt;=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>&amp;&amp;board[row][col+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(row,col+<span class="hljs-number">1</span>));<br>                board[row][col+<span class="hljs-number">1</span>]=<span class="hljs-string">&#x27;#&#x27;</span>;<br>            &#125;               <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：并查集-1"><a href="#解法三：并查集-1" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><p>把所有边界上的 O 看做一个连通区域。遇到 O 就执行并查集合并操作，这样所有的 O 就会被分成两类：</p>
<ul>
<li>和边界上的 O 在一个连通区域内的，这些 O 保留。</li>
<li>不和边界上的 O 在一个连通区域内的，这些 O 就是被包围的，替换。</li>
</ul>
<p>由于并查集一般用一维数组来记录，方便查找 parents，所以将二维坐标用 <code>node</code> 函数转化为一维坐标。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(board.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span>;<br>        rows=board.<span class="hljs-built_in">size</span>();<br>        cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 用一个虚拟节点, 边界上的O的父节点都是这个虚拟节点</span><br>        <span class="hljs-type">int</span> dummyNode=rows*cols;<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(rows*cols+<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 遇到O进行并查集操作合并</span><br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 边界上的O,把它和dummyNode合并成一个连通区域</span><br>                    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),dummyNode);<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-comment">// 和上下左右合并成一个连通区域</span><br>                        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;board[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i<span class="hljs-number">-1</span>,j));<br>                        <span class="hljs-keyword">if</span>(i&lt;rows<span class="hljs-number">-1</span>&amp;&amp;board[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i+<span class="hljs-number">1</span>,j));<br>                        <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;board[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j<span class="hljs-number">-1</span>));<br>                        <span class="hljs-keyword">if</span>(j&lt;cols<span class="hljs-number">-1</span>&amp;&amp;board[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                            uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j+<span class="hljs-number">1</span>));                       <br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 和dummyNode在一个连通区域的,保留</span><br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(<span class="hljs-built_in">node</span>(i,j),dummyNode))<br>                    board[i][j]=<span class="hljs-string">&#x27;O&#x27;</span>;<br>                <span class="hljs-keyword">else</span><br>                    board[i][j]=<span class="hljs-string">&#x27;X&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-comment">// 将二维坐标转化为一维坐标</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="417-太平洋大西洋水流问题-medium"><a href="#417-太平洋大西洋水流问题-medium" class="headerlink" title="417. 太平洋大西洋水流问题[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a>[medium]</h2><h3 id="解法：DFS、BFS"><a href="#解法：DFS、BFS" class="headerlink" title="解法：DFS、BFS"></a>解法：DFS、BFS</h3><p>从边界往里面走，即从海洋开始逆流，只能走到比自己更高或者等高的地方。边界能走到的地方，就是能流入对应海洋的地方，进行标记，然后检查两个海洋都可以逆流到的区域。可使用 DFS 以及 BFS 解决，这里只写出 DFS 代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(matrix.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-type">int</span> rows=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">canReachP</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">canReachA</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-comment">//从海洋边界开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>)<br>                    <span class="hljs-built_in">dfs</span>(matrix,i,j,canReachP,matrix[i][j]);<br>                <span class="hljs-keyword">if</span>(i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                    <span class="hljs-built_in">dfs</span>(matrix,i,j,canReachA,matrix[i][j]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(canReachP[i][j]&amp;&amp;canReachA[i][j])<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;canReach,<span class="hljs-type">int</span> pre)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 判断坐标是否合法</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=matrix.<span class="hljs-built_in">size</span>()||j&gt;=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 已经流到过了 || 不能流动</span><br>        <span class="hljs-keyword">if</span>(canReach[i][j]||matrix[i][j]&lt;pre)<br>            <span class="hljs-keyword">return</span>;<br>        canReach[i][j]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(matrix,i<span class="hljs-number">-1</span>,j,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i+<span class="hljs-number">1</span>,j,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i,j<span class="hljs-number">-1</span>,canReach,matrix[i][j]);<br>        <span class="hljs-built_in">dfs</span>(matrix,i,j+<span class="hljs-number">1</span>,canReach,matrix[i][j]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="733-图像渲染-easy"><a href="#733-图像渲染-easy" class="headerlink" title="733. 图像渲染[easy]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a>[easy]</h2><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 相似。</p>
<h3 id="解法一：DFS-3"><a href="#解法一：DFS-3" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>从给定的起点开始，进行深度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格的颜色更新，以防止重复搜索；如果不相同，则进行回溯。注意：因为初始位置的颜色会被修改，所以需要保存初始位置的颜色，以便于之后的更新操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(color!=newColor)<br>            <span class="hljs-built_in">dfs</span>(image,sr,sc,newColor,color);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;image,<span class="hljs-type">int</span> sr,<span class="hljs-type">int</span> sc,<span class="hljs-type">int</span> newColor,<span class="hljs-type">int</span> color)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(sr&lt;<span class="hljs-number">0</span>||sc&lt;<span class="hljs-number">0</span>||sr&gt;=image.<span class="hljs-built_in">size</span>()||sc&gt;=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(image[sr][sc]!=color)<br>            <span class="hljs-keyword">return</span>;<br>        image[sr][sc]=newColor;<br>        <span class="hljs-built_in">dfs</span>(image,sr<span class="hljs-number">-1</span>,sc,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr+<span class="hljs-number">1</span>,sc,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr,sc<span class="hljs-number">-1</span>,newColor,color);<br>        <span class="hljs-built_in">dfs</span>(image,sr,sc+<span class="hljs-number">1</span>,newColor,color);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：BFS-5"><a href="#解法二：BFS-5" class="headerlink" title="解法二：BFS"></a>解法二：BFS</h3><p>从给定的起点开始，进行广度优先搜索。每次搜索到一个方格时，如果其与初始位置的方格颜色相同，就将该方格加入队列，并将该方格的颜色更新，以防止重复入队。注意：因为初始位置的颜色会被修改，所以需要保存初始位置的颜色，以便于之后的更新操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(color==newColor)<br>            <span class="hljs-keyword">return</span> image;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(sr,sc));<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> indexs=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> r=indexs.first;<br>            <span class="hljs-type">int</span> c=indexs.second;<br>            <span class="hljs-keyword">if</span>(r&lt;<span class="hljs-number">0</span>||c&lt;<span class="hljs-number">0</span>||r&gt;=image.<span class="hljs-built_in">size</span>()||c&gt;=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(image[r][c]!=color)<br>                <span class="hljs-keyword">continue</span>;<br>            image[r][c]=newColor;<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r<span class="hljs-number">-1</span>,c));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r+<span class="hljs-number">1</span>,c));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r,c<span class="hljs-number">-1</span>));<br>            q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(r,c+<span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：并查集-2"><a href="#解法三：并查集-2" class="headerlink" title="解法三：并查集"></a>解法三：并查集</h3><p>并查集可以用来解决动态连通性问题。从<code>(0, 0)</code>位置开始依次遍历，这时就不需要同时兼顾上下左右四个方向了，只需要看看它<strong>右边和下面</strong>的像素点颜色是不是和初始点一样都为<code>color</code>，一样就合并。最后只需要把所有和开始位置<code>(sr, sc)</code>在同一个集合的像素点的颜色改为<code>newColor</code>就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并查集</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent;<span class="hljs-comment">// 存储若干棵树</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; size;<span class="hljs-comment">// 记录树的“重量”</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            size.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">/* 返回节点 x 的根节点 */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(parent[x]!=x)<br>        &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x]=parent[parent[x]];<br>            x=parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    <span class="hljs-comment">/* 将 p 和 q 连通 */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionTree</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> rootP=<span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-type">int</span> rootQ=<span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(rootP==rootQ)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span>(size[rootP]&gt;size[rootQ])<br>        &#123;<br>            parent[rootQ]=rootP;<br>            size[rootP]+=size[rootQ];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            parent[rootP]=rootQ;<br>            size[rootQ]+=size[rootP];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p)==<span class="hljs-built_in">find</span>(q);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        <span class="hljs-type">int</span> color=image[sr][sc];<br>        <span class="hljs-keyword">if</span>(newColor==color)<br>            <span class="hljs-keyword">return</span> image;<br>        rows=image.<span class="hljs-built_in">size</span>();<br>        cols=image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(rows*cols)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(image[i][j]==color)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;rows&amp;&amp;image[i+<span class="hljs-number">1</span>][j]==color)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i+<span class="hljs-number">1</span>,j));<br>                    <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;cols&amp;&amp;image[i][j+<span class="hljs-number">1</span>]==color)<br>                        uf.<span class="hljs-built_in">unionTree</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(i,j+<span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(uf.<span class="hljs-built_in">isConnected</span>(<span class="hljs-built_in">node</span>(i,j),<span class="hljs-built_in">node</span>(sr,sc)))<br>                    image[i][j]=newColor;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-comment">// 将二维坐标转化为一维坐标</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">node</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i*cols+j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="79-单词搜索-medium"><a href="#79-单词搜索-medium" class="headerlink" title="79. 单词搜索[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a>[medium]</h2><h3 id="解法：DFS-回溯"><a href="#解法：DFS-回溯" class="headerlink" title="解法：DFS+回溯"></a>解法：DFS+回溯</h3><p>当前字符匹配，在标记数组<code>visited</code>中标记当前元素为已访问，然后向四个方向（上下左右）搜索下一个字符。</p>
<ol>
<li>如果四个方向中，有一个方向可以完全匹配，则立即返回<em><strong>true</strong></em>。</li>
<li>如果四个方向都不匹配，则在标记数组<code>visited</code>中标记当前元素为未访问，回溯到上一层继续搜索。</li>
</ol>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201130202158.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        rows=board.<span class="hljs-built_in">size</span>();<br>        cols=board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(rows,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(cols,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-comment">// 对每一个格子都从头开始搜索</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,i,j,<span class="hljs-number">0</span>,visited))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> rows,cols;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,string &amp;word,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> start,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归终止条件</span><br>        <span class="hljs-keyword">if</span>(start==word.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> board[i][j]==word[start];<br>        <span class="hljs-comment">// 中间匹配了，再继续搜索</span><br>        <span class="hljs-keyword">if</span>(board[i][j]==word[start])<br>        &#123;<br>            <span class="hljs-comment">// 先占住这个位置，搜索不成功的话，要释放掉</span><br>            visited[i][j]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>            &#123;<br>                <span class="hljs-type">int</span> newX=i+direction[k][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> newY=j+direction[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">inArea</span>(newX,newY)&amp;&amp;!visited[newX][newY])<br>                &#123;<br>                    <span class="hljs-comment">// 如果这一次 search word 成功的话，就返回</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,word,newX,newY,start+<span class="hljs-number">1</span>,visited))<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 回溯</span><br>            visited[i][j]=<span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inArea</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> i&gt;=<span class="hljs-number">0</span>&amp;&amp;j&gt;=<span class="hljs-number">0</span>&amp;&amp;i&lt;rows&amp;&amp;j&lt;cols;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1254-统计封闭岛屿的数目-medium"><a href="#1254-统计封闭岛屿的数目-medium" class="headerlink" title="1254. 统计封闭岛屿的数目[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a>[medium]</h2><h3 id="解法：DFS、BFS-1"><a href="#解法：DFS、BFS-1" class="headerlink" title="解法：DFS、BFS"></a>解法：DFS、BFS</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a> 相似。区别在于这题要求封闭，因此需要代入一个变量表示是否封闭。这里只给出DFS代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rows=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> val=<span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">dfs</span>(grid,i,j,val);<br>                    res+=val;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;grid,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">int</span> &amp;val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 走出边界就说明该陆地所在岛屿不是封闭岛屿</span><br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=grid.<span class="hljs-built_in">size</span>()||j&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>        &#123;<br>            val=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(grid[i][j]!=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        grid[i][j]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">dfs</span>(grid,i<span class="hljs-number">-1</span>,j,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i+<span class="hljs-number">1</span>,j,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j<span class="hljs-number">-1</span>,val);<br>        <span class="hljs-built_in">dfs</span>(grid,i,j+<span class="hljs-number">1</span>,val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1020-飞地的数量-medium"><a href="#1020-飞地的数量-medium" class="headerlink" title="1020. 飞地的数量[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-enclaves/">1020. 飞地的数量</a>[medium]</h2><h3 id="解法：DFS、BFS、并查集"><a href="#解法：DFS、BFS、并查集" class="headerlink" title="解法：DFS、BFS、并查集"></a>解法：DFS、BFS、并查集</h3><p>典型的 Flood Fill 问题，可以用 DFS、BFS 和 并查集解决。这里只给出 DFS 代码。从边界的陆地往里搜索，把和边界相接的陆地淹没，剩下的陆地就是飞地，统计个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numEnclaves</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; A)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rows=A.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> cols=A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>||j==<span class="hljs-number">0</span>||i==rows<span class="hljs-number">-1</span>||j==cols<span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(A[i][j]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-built_in">dfs</span>(A,i,j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;rows;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cols;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(A[i][j]==<span class="hljs-number">1</span>)<br>                    ++count;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;A,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>||j&lt;<span class="hljs-number">0</span>||i&gt;=A.<span class="hljs-built_in">size</span>()||j&gt;=A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(A[i][j]!=<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span>;<br>        A[i][j]=<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">dfs</span>(A,i<span class="hljs-number">-1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(A,i+<span class="hljs-number">1</span>,j);<br>        <span class="hljs-built_in">dfs</span>(A,i,j<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs</span>(A,i,j+<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="题型三：最短路径问题"><a href="#题型三：最短路径问题" class="headerlink" title="题型三：最短路径问题"></a>题型三：最短路径问题</h1><p>问题的本质就是在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</p>
<h2 id="1091-二进制矩阵中的最短路径-medium"><a href="#1091-二进制矩阵中的最短路径-medium" class="headerlink" title="1091. 二进制矩阵中的最短路径[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a>[medium]</h2><h3 id="解法：BFS"><a href="#解法：BFS" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><blockquote>
<p>最短路径问题，使用 BFS 解决。</p>
<p>关于为什么 BFS 的结果会是最短的：BFS 按照层次来遍历，搜索到的第一个符合条件的解一定是在层次上最浅的，所以只会有长度一样的解不会有长度更短的解。</p>
</blockquote>
<p>利用队列实现 BFS，同时将访问过的点标记。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>||grid[n<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));<br>        visited[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-literal">true</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; directions=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 遍历当前队列所有的元素</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=q.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=q.<span class="hljs-built_in">front</span>().second;<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 判断是否满足退出的条件</span><br>                <span class="hljs-keyword">if</span>(x==n<span class="hljs-number">-1</span>&amp;&amp;y==n<span class="hljs-number">-1</span>)<br>                    <span class="hljs-keyword">return</span> res+<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> x1=x+directions[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> y1=y+directions[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-comment">// 边界不合法</span><br>                    <span class="hljs-keyword">if</span>(x1&lt;<span class="hljs-number">0</span>||y1&lt;<span class="hljs-number">0</span>||x1&gt;=n||y1&gt;=n)<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// 已访问或者条件不符合</span><br>                    <span class="hljs-keyword">if</span>(visited[x1][y1]||grid[x1][y1]==<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    visited[x1][y1]=<span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(x1,y1));<br>                &#125;               <br>            &#125;<br>            ++res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="127-单词接龙-medium"><a href="#127-单词接龙-medium" class="headerlink" title="127. 单词接龙[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a>[medium]</h2><h3 id="解法一：BFS"><a href="#解法一：BFS" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><blockquote>
<p>无向图中两个顶点之间的最短路径的长度，可以通过广度优先遍历得到。</p>
<p>为什么 BFS 得到的路径最短？<strong>可以把起点和终点所在的路径拉直来看，两点之间线段最短</strong>。</p>
</blockquote>
<ul>
<li><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图；</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201204541.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />
</li>
<li><p>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，复杂度是 O(NwordLen)，这里 N 是单词列表的长度；</p>
</li>
<li><p>为此，在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，复杂度是 O(26×wordLen)，借助哈希表，找到邻居与 N 无关；</p>
</li>
<li><p>使用 BFS 进行遍历，需要的辅助数据结构是：</p>
<ul>
<li>队列；</li>
<li><code>visited</code> 集合。说明：可以直接在 <code>wordSet</code> (由 <code>wordList</code>放进集合中得到)里做删除。但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</li>
</ul>
</li>
</ul>
<p>思路：</p>
<ul>
<li>从起点词出发，每次变一个字母，经过 n 次变换，变成终点词，希望 n 尽量小。</li>
<li>需要找出邻接关系，比如<code>hit</code>它变一个字母会变成 <code>_it</code>、<code>h_t</code>、<code>hi_</code> 形式的单词，然后看这个新词是否存在于 <code>wordSet</code> ，如果存在，就找到了一个下一层的转换词。</li>
<li>同时，要避免重复访问，比如 <code>hot-&gt;dot-&gt;hot</code> 这样变回来，只会徒增转换的长度。因此，使用 <code>visited</code> 集合。</li>
<li>可能下一层的单词有多个，都要考察，哪一条转换路径先遇到终点词，它就最短。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201203647.png" srcset="/img/loading.gif" lazyload style="zoom: 67%;" />

<p>上图中的删除操作改为使用 <code>visited</code> 集合，理由如上所述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(),wordList.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">empty</span>()||wordSet.<span class="hljs-built_in">count</span>(endWord)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 一开始要把开始的单词移除</span><br>        wordSet.<span class="hljs-built_in">erase</span>(beginWord);<br>        <span class="hljs-comment">// 图的广度优先遍历，使用队列和表示是否访问过的 visited 哈希表</span><br>        queue&lt;string&gt; q;<br>        q.<span class="hljs-built_in">push</span>(beginWord);<br>        unordered_set&lt;string&gt; visited;<br>        visited.<span class="hljs-built_in">insert</span>(beginWord);<br>        <span class="hljs-comment">// 开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span><br>        <span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-comment">// 依次遍历当前队列中的单词</span><br>                string curWord=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 如果 curWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">changeWord</span>(curWord,endWord,q,wordSet,visited))<br>                    <span class="hljs-keyword">return</span> step+<span class="hljs-number">1</span>;<br>            &#125;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 尝试对 curWord 修改每一个字符，看看是不是能与 endWord 匹配</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">changeWord</span><span class="hljs-params">(string &amp;curWord,string &amp;endWord,queue&lt;string&gt; &amp;q,unordered_set&lt;string&gt; &amp;wordSet,unordered_set&lt;string&gt; &amp;visited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;endWord.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-comment">// 先保存，然后恢复</span><br>            <span class="hljs-type">char</span> old=curWord[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> j=<span class="hljs-string">&#x27;a&#x27;</span>;j&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==old)<br>                    <span class="hljs-keyword">continue</span>;<br>                curWord[i]=j;<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">count</span>(curWord)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(curWord==endWord)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(curWord)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(curWord);<br>                        <span class="hljs-comment">// 添加到队列以后，必须马上标记为已经访问</span><br>                        visited.<span class="hljs-built_in">insert</span>(curWord);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复</span><br>            curWord[i]=old;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：双向BFS"><a href="#解法二：双向BFS" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h3><blockquote>
<p>已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集，这是双向广度优先遍历的思想。</p>
</blockquote>
<ul>
<li>已知目标顶点的情况下，可以分别从起点和目标顶点（终点）执行广度优先遍历，直到遍历的部分有交集。这种方式搜索的单词数量会更小一些；</li>
<li>更合理的做法是，<strong>每次从单词数量小的集合开始扩散</strong>；</li>
<li>这里 <code>beginVisited</code> 和 <code>endVisited</code>交替使用，等价于单向 BFS 里使用队列，每次扩散都要加到总的 <code>visited</code> 里。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201201212031.png" srcset="/img/loading.gif" lazyload style="zoom: 80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;<br>        <span class="hljs-comment">// 将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordList.begin(),wordList.end())</span></span>;<br>        <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">empty</span>()||wordSet.<span class="hljs-built_in">count</span>(endWord)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 已经访问过的 word 添加到 visited 哈希表里</span><br>        unordered_set&lt;string&gt; visited;<br>        <span class="hljs-comment">// 分别用左边和右边扩散的哈希表代替单向 BFS 里的队列，它们在双向 BFS 的过程中交替使用</span><br>        unordered_set&lt;string&gt; beginVisited;<br>        beginVisited.<span class="hljs-built_in">insert</span>(beginWord);<br>        unordered_set&lt;string&gt; endVisited;<br>        endVisited.<span class="hljs-built_in">insert</span>(endWord);<br>        <span class="hljs-comment">// 执行双向 BFS，左右交替扩散的步数之和为所求</span><br>        <span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!beginVisited.<span class="hljs-built_in">empty</span>()&amp;&amp;!endVisited.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 优先选择小的哈希表进行扩散，考虑到的情况更少</span><br>            <span class="hljs-keyword">if</span>(beginVisited.<span class="hljs-built_in">size</span>()&gt;endVisited.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                unordered_set&lt;string&gt; tmp=beginVisited;<br>                beginVisited=endVisited;<br>                endVisited=tmp;<br>            &#125;<br>            <span class="hljs-comment">// 逻辑到这里，保证 beginVisited 是相对较小的集合，nextLevelVisited 在扩散完成以后，会成为新的 beginVisited</span><br>            unordered_set&lt;string&gt; nextLevelVisited;<br>            <span class="hljs-keyword">for</span>(string word:beginVisited)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">changeWord</span>(word,endVisited,visited,wordSet,nextLevelVisited))<br>                    <span class="hljs-keyword">return</span> step+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">// 原来的 beginVisited 废弃，从 nextLevelVisited 开始新的双向 BFS</span><br>            beginVisited=nextLevelVisited;<br>            step++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 尝试对 word 修改每一个字符，看看是不是能落在 endVisited 中，扩展得到的新的 word 添加到 nextLevelVisited 里</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">changeWord</span><span class="hljs-params">(string &amp;word,unordered_set&lt;string&gt; &amp;endVisited,unordered_set&lt;string&gt; &amp;visited,unordered_set&lt;string&gt; &amp;wordSet,unordered_set&lt;string&gt; &amp;nextLevelVisited)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;word.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-type">char</span> old=word[i];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> j=<span class="hljs-string">&#x27;a&#x27;</span>;j&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j==old)<br>                    <span class="hljs-keyword">continue</span>;<br>                word[i]=j;<br>                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">count</span>(word)!=<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(endVisited.<span class="hljs-built_in">count</span>(word)!=<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(word)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        nextLevelVisited.<span class="hljs-built_in">insert</span>(word);<br>                        visited.<span class="hljs-built_in">insert</span>(word);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 恢复，下次再用</span><br>            word[i]=old;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="752-打开转盘锁-medium"><a href="#752-打开转盘锁-medium" class="headerlink" title="752. 打开转盘锁[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a>[medium]</h2><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a> 相似。详细思路叙述参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock/solution/wo-xie-liao-yi-tao-bfs-suan-fa-kuang-jia-jian-dao-/">labuladong</a> 题解。</p>
<h3 id="解法一：BFS-1"><a href="#解法一：BFS-1" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>第一步，不管 <code>deadends</code> 和 <code>target</code> 的限制，穷举所有可能的密码组合。总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能。比如说从 <code>&quot;0000&quot;</code> 开始，转一次，可以穷举出 <code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code>共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点。题目要求计算最短距离，这就是典型的 BFS 。</p>
<p>第二步，思考一些注意事项和限制：</p>
<ul>
<li>为了避免穷举时走回头路，需要一个 <code>visited</code> 集合记录转过的数字，避免死循环。</li>
<li>找到 <code>target</code> 就应该结束并返回拨动的次数。</li>
<li>对 <code>deadends</code> 进行处理，按道理这些「死亡密码」是不能出现的，也就是说遇到这些密码的时候需要跳过，用一个哈希表记录。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录需要跳过的死亡密码</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">deads</span><span class="hljs-params">(deadends.begin(),deadends.end())</span></span>;<br>        <span class="hljs-comment">// 记录已经穷举过的密码，防止走回头路</span><br>        unordered_set&lt;string&gt; visited;<br>        queue&lt;string&gt; q;<br>        <span class="hljs-comment">// 从起点开始启动广度优先搜索</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        visited.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 将当前队列中的所有节点向周围扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                string cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(deads.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 判断是否到达终点</span><br>                <span class="hljs-keyword">if</span>(cur==target)<br>                    <span class="hljs-keyword">return</span> steps;<br>                <span class="hljs-comment">// 将一个节点的未遍历相邻节点加入队列</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    string up=<span class="hljs-built_in">plusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(up)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(up);<br>                        visited.<span class="hljs-built_in">insert</span>(up);<br>                    &#125;<br>                    string down=<span class="hljs-built_in">minusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(down)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(down);<br>                        visited.<span class="hljs-built_in">insert</span>(down);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里增加步数</span><br>            steps++;<br>        &#125;<br>        <span class="hljs-comment">// 如果穷举完都没找到目标密码，那就是找不到了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 s[j] 向上拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">plusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 s[j] 向下拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">minusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]-=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：双向BFS-1"><a href="#解法二：双向BFS-1" class="headerlink" title="解法二：双向BFS"></a>解法二：双向BFS</h3><p><strong>双向 BFS</strong>，可以进一步提高算法的效率。传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p>
<p>为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 <code>O(N)</code>，但是实际上双向 BFS 确实会快一些。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207204943.jpeg" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207205104.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 <code>target</code>；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。</p>
<p><strong>不过，双向 BFS 也有局限，因为必须知道终点在哪里</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        <span class="hljs-comment">// 记录需要跳过的死亡密码</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">deads</span><span class="hljs-params">(deadends.begin(),deadends.end())</span></span>;<br>        <span class="hljs-comment">// 记录已经穷举过的密码，防止走回头路</span><br>        unordered_set&lt;string&gt; visited;<br>        <span class="hljs-comment">// 用集合不用队列，可以快速判断元素是否存在</span><br>        unordered_set&lt;string&gt; begin;<br>        begin.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        unordered_set&lt;string&gt; end;<br>        end.<span class="hljs-built_in">insert</span>(target);<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!begin.<span class="hljs-built_in">empty</span>()&amp;&amp;!end.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 从元素少的集合扩散</span><br>            <span class="hljs-keyword">if</span>(begin.<span class="hljs-built_in">size</span>()&gt;end.<span class="hljs-built_in">size</span>())<br>            &#123;<br>                <span class="hljs-comment">// 交换 begin 和 end</span><br>                unordered_set&lt;string&gt; tmp=begin;<br>                begin=end;<br>                end=tmp;<br>            &#125;<br>            <span class="hljs-comment">// 哈希集合在遍历的过程中不能修改，用 nextLevel 存储扩散结果</span><br>            unordered_set&lt;string&gt; nextLevel;<br>            <span class="hljs-comment">// 将 begin 中的所有节点向周围扩散</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp;cur:begin)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(deads.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 判断是否到达终点</span><br>                <span class="hljs-keyword">if</span>(end.<span class="hljs-built_in">count</span>(cur)!=<span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> steps;<br>                visited.<span class="hljs-built_in">insert</span>(cur);<br>                <span class="hljs-comment">// 将一个节点的未遍历相邻节点加入集合</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    string up=<span class="hljs-built_in">plusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(up)==<span class="hljs-number">0</span>)<br>                        nextLevel.<span class="hljs-built_in">insert</span>(up);<br>                    string down=<span class="hljs-built_in">minusOne</span>(cur,j);<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(down)==<span class="hljs-number">0</span>)<br>                        nextLevel.<span class="hljs-built_in">insert</span>(down);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 在这里增加步数</span><br>            steps++;<br>            <span class="hljs-comment">// 下一轮 while 就是扩散 nextLevel</span><br>            begin=nextLevel;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 将 s[j] 向上拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">plusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;9&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]+=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 s[j] 向下拨动一次</span><br>    <span class="hljs-function">string <span class="hljs-title">minusOne</span><span class="hljs-params">(string s,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(s[j]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>            s[j]=<span class="hljs-string">&#x27;9&#x27;</span>;<br>        <span class="hljs-keyword">else</span><br>            s[j]-=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>双向 BFS 还是遵循 BFS 算法框架的，只是<strong>不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集</strong>。</p>
<p>另外的一个技巧点就是在 while 循环开始时做一个判断，总是从元素少的集合进行扩散。因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。</p>
<h2 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279. 完全平方数[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a>[medium]</h2><h3 id="解法一：DFS-暴力递归"><a href="#解法一：DFS-暴力递归" class="headerlink" title="解法一：DFS 暴力递归"></a>解法一：DFS 暴力递归</h3><p>考虑所有的分解方案，找出最小的解，举个例子。</p>
<p>n&#x3D;12，先把 n 减去一个平方数，然后求剩下的数分解成平方数和所需的最小个数。</p>
<ul>
<li>把 n 减去 1, 然后求出 11 分解成平方数和所需的最小个数，记做 n1，那么当前方案总共需要 n1+1 个平方数；</li>
<li>把 n 减去 4, 然后求出 8 分解成平方数和所需的最小个数，记做 n2，那么当前方案总共需要 n2+1 个平方数；</li>
<li>把 n 减去 9, 然后求出 3 分解成平方数和所需的最小个数，记做 n3 那么当前方案总共需要 n3+1 个平方数；</li>
<li>下一个平方数是 16，大于 12，不能再分了。</li>
</ul>
<p>接下来只需要从 (n1 + 1)、(n2 + 1)、(n3 + 1) 三种方案中选择最小的个数,  此时就是 12 分解成平方数和所需的最小个数。至于求 11、8、3 分解成最小平方数和所需的最小个数继续用上边的方法去求，直到如果求 0 分解成最小平方数的和的个数, 返回 0 即可。</p>
<p>直接递归会造成许多重复的计算，因此采用 <code>memoization</code> 技术，即记忆化搜索，把过程中的解利用 <code>HashMap</code> 全部保存起来。</p>
<p>Cpp 代码超时！！！Java 不超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n,<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Integer, Integer&gt;());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(n)) <br>            <span class="hljs-keyword">return</span> map.get(n);<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count=Integer.MAX_VALUE;<br>    	<span class="hljs-comment">// 依次减去一个平方数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i*i&lt;=n;i++)<br>            <span class="hljs-comment">// 选最小的</span><br>            count=Math.min(count,dfs(n-i*i,map)+<span class="hljs-number">1</span>);<br>        map.put(n, count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>将解法一改写成动态规划。递归相当于先压栈压栈然后出栈出栈，动态规划可以省去压栈的过程。动态规划的转移方程就对应递归的过程，动态规划的初始条件就对应递归的出口。</p>
<p>使用数组 <code>dp</code> 记录最少平方和，<code>dp[i]</code> 表示成 <code>i</code> 需要的最少平方和，则 <code>dp[n]=1+min&#123; dp[n-1^2],dp[n-2^2],dp[n-3^2],dp[n-4^2],...,dp[n-k^2] &#125;</code>，其中 <code>k</code> 为满足 <code>k^2 &lt;= n</code> 的最大的 <code>k</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<span class="hljs-comment">// 默认初始化值都为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>        &#123;<br>            dp[i]=i;<span class="hljs-comment">// 最坏的情况就是每次+1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=i;++j)<br>                dp[i]=<span class="hljs-built_in">min</span>(dp[i],dp[i-j*j]+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：BFS"><a href="#解法三：BFS" class="headerlink" title="解法三：BFS"></a>解法三：BFS</h3><p>相对于解法一的 DFS ，当然也可以使用 BFS 。DFS 是一直做减法，然后一直减一直减，直到减到 <code>0</code> 算作找到一个解。属于一个解一个解的寻找。BFS 的话，可以一层一层的算。第一层依次减去一个平方数得到第二层，第二层依次减去一个平方数得到第三层。直到某一层出现了 <code>0</code>，此时的层数就是要找到平方数和的最小个数。</p>
<p>举个例子，<code>n = 12</code>，每层的话每个节点依次减 <code>1, 4, 9...</code>。如下图，灰色表示当前层重复的节点，不需要处理。</p>
<p><img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201207171739.jpeg" srcset="/img/loading.gif" lazyload></p>
<p>如上图，当出现 <code>0</code> 的时候遍历就可以停止，此时是第 <code>3</code> 层（从 <code>0</code> 计数），所以最终答案就是 <code>3</code>。</p>
<p>实现的话当然离不开队列，此外需要一个 <code>set</code> 来记录重复的解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> level=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; visited;<br>        q.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size=q.<span class="hljs-built_in">size</span>();<br>            level++;<span class="hljs-comment">// 开始生成下一层</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> cur=q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 依次减 1, 4, 9... 生成下一层的节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j*j&lt;=cur;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> next=cur-j*j;<br>                    <span class="hljs-keyword">if</span>(next==<span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> level;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">count</span>(next)==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        q.<span class="hljs-built_in">push</span>(next);<br>                        visited.<span class="hljs-built_in">insert</span>(next);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法四：数学方法"><a href="#解法四：数学方法" class="headerlink" title="解法四：数学方法"></a>解法四：数学方法</h3><p>四平方和定理，意思是任何正整数都能表示成四个平方数的和。少于四个平方数的，像 <code>12</code> 这种，可以补一个 <code>0</code> 也可以看成四个平方数，<code>12 = 4 + 4 + 4 + 0</code>。知道了这个定理，对于题目要找的解，其实只可能是 <code>1, 2, 3, 4</code> 其中某个数。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Legendre's_three-square_theorem">Legendre’s three-square theorem</a>，这个定理表明，如果正整数 <code>n</code> 被表示为三个平方数的和，那么 <code>n</code> 不等于 <code>n = 4^a*(8b+7)</code> ，<code>a</code> 和 <code>b</code>都是非负整数。</p>
<p>换言之，如果 <code>n = 4^a*(8b+7)</code>，那么他一定不能表示为三个平方数的和，同时也说明不能表示为一个、两个平方数的和，因为如果能表示为两个平方数的和，那么补个 <code>0</code>，就能凑成三个平方数的和了。一个、两个、三个都排除了，所以如果 <code>n = 4^a*(8b+7)</code>，那么 <code>n</code> 只能表示成四个平方数的和了。</p>
<p>代码的话，采取排除的方法。首先考虑答案是不是 <code>1</code>，也就是判断当前数是不是一个平方数。然后考虑答案是不是 <code>4</code>，也就是判断 <code>n</code> 是不是等于 <code>4^a*(8b+7)</code>。然后考虑答案是不是 <code>2</code>，当前数依次减去一个平方数，判断得到的差是不是平方数。以上情况都排除的话，答案就是 <code>3</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSquare</span>(n))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> temp=n;<br>        <span class="hljs-keyword">while</span>(temp%<span class="hljs-number">4</span>==<span class="hljs-number">0</span>)<br>            temp/=<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">if</span>(temp%<span class="hljs-number">8</span>==<span class="hljs-number">7</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i*i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSquare</span>(n-i*i))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">sqrt</span>(n));<br>        <span class="hljs-keyword">return</span> a*a==n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="542-01-矩阵-medium"><a href="#542-01-矩阵-medium" class="headerlink" title="542. 01 矩阵[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a>[medium]</h2><h3 id="解法一：BFS-2"><a href="#解法一：BFS-2" class="headerlink" title="解法一：BFS"></a>解法一：BFS</h3><p>「图 的 BFS」与 「Tree 的 BFS」的区别：</p>
<ul>
<li>Tree 只有 1 个 root，而图可以有多个源点，所以首先需要把多个源点都入队；</li>
<li>Tree 是有向的因此不需要标识是否访问过，而对于无向图来说，必须得标志是否访问过。并且为了防止某个节点多次入队，需要在其入队之前就将其设置成已访问。</li>
</ul>
<p>题目给出了多个<code>1</code>，要找出每个<code>1</code>到<code>0</code>的最近距离。由于<code>1</code>到<code>0</code>的距离和<code>0</code>到<code>1</code>的距离一样的，所以可以换个思维：找出每个<code>0</code>到<code>1</code>的距离。因此，题目可以抽象成：多个起始点的BFS。即从每一个 0 位置向上下左右四个方向进行广播，同时将点距离 0 的长度更新为最短。</p>
<p>首先把每个源点 0 入队，然后从各个 0 <strong>同时开始</strong>一圈一圈的向 1 扩散（每个 1 都是被离它最近的 0 扩散到的 ），扩散的时候可以设置 <code>int[][] dist</code> 来记录距离（即扩散的层次）并同时标志是否访问过。对于本题是可以直接修改原数组 <code>int[][] matrix</code> 来记录距离和标志是否访问的，这里要注意先把 <code>matrix</code> 数组中 <code>1</code> 的位置设置成 <code>-1</code>（设成<code>Integer.MAX_VALUE</code>，<code>m * n</code>，<code>10000</code>都行，只要是个无效的距离值来标志这个位置的 <code>1</code> 没有被访问过就行）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-comment">// 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;matrix.<span class="hljs-built_in">size</span>();++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                <span class="hljs-keyword">else</span><br>                    matrix[i][j]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>            <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> newX=x+direction[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-type">int</span> newY=y+direction[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// 如果四邻域的点是 -1，表示这个点是未被访问过的 1</span><br>                <span class="hljs-comment">// 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1</span><br>                <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;matrix.<span class="hljs-built_in">size</span>()&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()&amp;&amp;matrix[newX][newY]==<span class="hljs-number">-1</span>)<br>                &#123;<br>                    matrix[newX][newY]=matrix[x][y]+<span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：动态规划-1"><a href="#解法二：动态规划-1" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>对于任一点 (i, j)，距离 0 的距离为：<br>$$<br>f(i, j)&#x3D;\left{\begin{array}{ll}<br>1+\min (f(i-1, j), f(i, j-1), f(i+1, j), f(i, j+1)) &amp; \text { if matrix }[\mathrm{i}][\mathrm{j}]&#x3D;&#x3D;1 \<br>0 &amp; \text { if matrix }[\mathrm{i}][\mathrm{j}]&#x3D;&#x3D;0<br>\end{array}\right.<br>$$<br>因此用 dp[i] [j] 来表示距离该位置最近的 0 的距离。dp[i] [j] 是由其上下左右四个状态来决定，无法从一个方向开始递推。</p>
<p>于是尝试将问题分解：</p>
<ul>
<li>距离 (i, j) 最近的 0 的位置，是在其 「左上，右上，左下，右下」4 个方向之一；</li>
<li>因此分别从四个角开始递推，就分别得到了位于「左上方、右上方、左下方、右下方」距离 (i, j) 的最近的 0 的距离，取 min 即可；</li>
<li>通过上两步思路，可以很容易的写出 4 个双重 for 循环，动态规划的解法写到这一步其实已经完全 OK 了；</li>
<li>但是从四个角开始的 4 次递推，有一些重复计算的地方，还可以优化成从任一组对角开始的 2 次递推，比如只写从左上角、右下角开始递推就行了，为啥可以这样呢？<ul>
<li>首先从左上角开始递推 dp[i] [j] 是由其 「左方」和 「左上方」的最优子状态决定的；</li>
<li>然后从右下角开始递推 dp[i] [j] 是由其 「右方」和 「右下方」的最优子状态决定的；</li>
<li>看起来第一次递推的时候，把「右上方」的最优子状态给漏掉了，其实不是的，因为第二次递推的时候「右方」的状态在第一次递推时已经包含了「右上方」的最优子状态了；</li>
<li>看起来第二次递推的时候，把「左下方」的最优子状态给漏掉了，其实不是的，因为第二次递推的时候「右下方」的状态在第一次递推时已经包含了「左下方」的最优子状态了。</li>
</ul>
</li>
</ul>
<p>关于动态规划为什么只考虑左上和右下就可以了。另一个通俗易懂的解释：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-number">0</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-number">1</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br><span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span> <span class="hljs-literal">_</span><br></code></pre></td></tr></table></figure>

<p>如上图，假设某个位置<code>(x,y)</code>离它最近的 0 只有一个，且是在它的右上角，在它“右1上2”的位置。这意味着距离中心1距离为“3&#x3D;1+2”的范围内，所有的位置都是1（或者出界，暂时不考虑出界的情况，不影响结论）。</p>
<p>所以这张图一定是（不考虑左下方的出界情况，不影响）:</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>? ? ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>?<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>&quot;1&quot;<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>? ? ?<br>? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br></code></pre></td></tr></table></figure>

<p>所以来考虑它右一处标为 X 的位置，离这个位置最近的 0，一定就是它“上二”方向的 0：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>? ? ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>?<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>&quot;1&quot; X<span class="hljs-number"> 1 </span>1 ?<br>? ?<span class="hljs-number"> 1 </span>1 <span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>1 ? ?<br>? ? ?<span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 1 </span>? ? ?<br>? ? ? ? <span class="hljs-number"> 1 </span> ? ? ? ?<br></code></pre></td></tr></table></figure>

<p>所以在“考虑左上角的时候”，X 处的位置可以记录到目标 0 的信息，X 处的最短距离被正确记录了。</p>
<p>然后在“考虑右下角的时候”，X 处的最短信息，正好又能被中心“1”观察到，所以中心 1 间接地，记录到了目标 0 的最短距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;<br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 初始化动态规划的数组，所有的距离值都设置为一个很大的数</span><br>        <span class="hljs-comment">// 设置为 INT_MAX-1 的原因是 INT_MAX 会导致溢出</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dist</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,INT_MAX<span class="hljs-number">-1</span>));<br>        <span class="hljs-comment">// 如果 (i, j) 的元素为 0，那么距离为 0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)<br>                    dist[i][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从左上角开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>) <br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 从右下角开始</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;--i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;--j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;m)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i+<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(j+<span class="hljs-number">1</span>&lt;n)<br>                    dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i][j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dist;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="1162-地图分析-medium"><a href="#1162-地图分析-medium" class="headerlink" title="1162. 地图分析[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">1162. 地图分析</a>[medium]</h2><h3 id="解法：BFS-1"><a href="#解法：BFS-1" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><ul>
<li>把所有的 <strong>陆地（<code>1</code>）</strong> 添加到队列中，进行广度优先遍历，看看多少步可以扩散完成；</li>
<li>「扩散完成」的意思是：没有海洋可以扩散。</li>
</ul>
<p><strong>解读题目中的「最远」和「最近」</strong></p>
<ul>
<li>题目问的是「距离陆地区域最远的海洋区域」，其实就是从陆地 <code>1</code> 开始，要扩散多少次，才能把所有的海洋给覆盖掉。「最远」应该从这个角度来理解。</li>
<li>而「该海洋区域到离它最近的陆地区域的距离」，「最近」是因为一定是距离这个最后才扩散到的海洋的最近的陆地才能扩散到它。</li>
</ul>
<p>题目问的是「距离陆地区域最远的海洋区域」，这和以往经验稍微有点出入。一般而言，「广度优先遍历」求的是最短路径，但仔细一想，发现其实广度优先遍历也是适用的：</p>
<blockquote>
<ul>
<li>求最短路径的时候，只要找到目标值，返回即可；</li>
<li>求最长路径的时候，<strong>所有目标值都看完以后，才返回</strong>。</li>
</ul>
</blockquote>
<p>这道题「广度优先遍历」的起点有多个，但完全不影响算法的正确性，可以假想一个虚拟的起点，初始的起点就是由虚拟起点扩散开来的，示意图可以参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/zhen-liang-yan-sou-huan-neng-duo-yuan-kan-wan-miao/">前额叶没长好</a> 题解。</p>
<p>题目中介绍的「曼哈顿距离」，其实就是对广度优先遍历（BFS）<strong>逐层向外扩散</strong>的精准数学解释，<strong>每扩散一次，曼哈顿距离就加 1</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDistance</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=grid.<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    <span class="hljs-comment">// 把陆地添加到队列中</span><br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> size=que.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>||size==n*n)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 方向向量</span><br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">// 注意：先把当前队列的长度保存下来</span><br>            <span class="hljs-type">int</span> curSize=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> newX=x+direction[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> newY=y+direction[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;n&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;n&amp;&amp;!visited[newX][newY]&amp;&amp;visited[newX][newY]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        visited[newX][newY]=<span class="hljs-literal">true</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            steps++;<br>        &#125;<br>        <span class="hljs-comment">// 注意：由于最后一步，没有可以扩散的的区域，但是 step 加了 1，故在退出循环的时候应该减 1</span><br>        <span class="hljs-keyword">return</span> steps<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="994-腐烂的橘子-medium"><a href="#994-腐烂的橘子-medium" class="headerlink" title="994. 腐烂的橘子[medium]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a>[medium]</h2><h3 id="解法：BFS-2"><a href="#解法：BFS-2" class="headerlink" title="解法：BFS"></a>解法：BFS</h3><p>题目要求返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。实际上就是求<strong>腐烂橘子到所有新鲜橘子的最短路径</strong>。</p>
<ul>
<li>一开始，找出所有腐烂的橘子，将它们放入队列，作为第 0 层的结点；</li>
<li>然后进行 BFS 遍历，每个结点的相邻结点可能是上、下、左、右四个方向的结点；<br>由于可能存在无法被污染的橘子，我们需要记录新鲜橘子的数量。在 BFS 中，每遍历</li>
<li>一个橘子（污染了一个橘子），就将新鲜橘子的数量减一。如果 BFS 结束后这个数量仍未减为零，说明存在无法被污染的橘子。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">// 表示新鲜橘子的数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">2</span>)<br>                    que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(i,j));<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    ++cnt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> direction[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;&#125;;<br>        <span class="hljs-type">int</span> steps=<span class="hljs-number">0</span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">while</span>(cnt&gt;<span class="hljs-number">0</span>&amp;&amp;!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> curSize=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;curSize;++i)<br>            &#123;<br>                <span class="hljs-type">int</span> x=que.<span class="hljs-built_in">front</span>().first;<br>                <span class="hljs-type">int</span> y=que.<span class="hljs-built_in">front</span>().second;<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> newX=x+direction[j][<span class="hljs-number">0</span>];<br>                    <span class="hljs-type">int</span> newY=y+direction[j][<span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span>(newX&gt;=<span class="hljs-number">0</span>&amp;&amp;newX&lt;m&amp;&amp;newY&gt;=<span class="hljs-number">0</span>&amp;&amp;newY&lt;n&amp;&amp;!visited[newX][newY]&amp;&amp;grid[newX][newY]==<span class="hljs-number">1</span>)<br>                    &#123;<br>                        cnt-=<span class="hljs-number">1</span>;<br>                        visited[newX][newY]=<span class="hljs-literal">true</span>;<br>                        que.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(newX,newY));<br>                    &#125;<br>                &#125;<br>            &#125;<br>            steps++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt==<span class="hljs-number">0</span>?steps:<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h1 id="题型四：游戏问题"><a href="#题型四：游戏问题" class="headerlink" title="题型四：游戏问题"></a>题型四：游戏问题</h1><h2 id="51-N-皇后-hard"><a href="#51-N-皇后-hard" class="headerlink" title="51. N 皇后[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a>[hard]</h2><h3 id="解法：回溯-6"><a href="#解法：回溯-6" class="headerlink" title="解法：回溯"></a>解法：回溯</h3><p><strong>理解树形结构</strong>：</p>
<p>先尝试画出递归树，以 4 皇后问题为例，画出的递归树如下：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208211356.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>搜索的过程蕴含了 <strong>剪枝</strong> 的思想。「剪枝」的依据是：题目中给出的 「N 皇后」 的摆放规则：1、不在同一行；2、不在同一列；3、不在同一主对角线方向上；4、不在同一副对角线方向上。</p>
<p><strong>小技巧：记住已经摆放的皇后的位置</strong></p>
<p>这里记住已经摆放的位置不能像 Flood Fill 一样，简单地使用 <code>visited</code> 布尔数组。放置的规则是：一行一行考虑皇后可以放置在哪一个位置上，某一行在考虑某一列是否可以放置皇后的时候，需要根据前面已经放置的皇后的位置。</p>
<p>可以使用一个一维数组 <code>queen</code> 来保存所有皇后的列位置，初始化均为 -1， 那么 <code>queen[i]</code>  就是表示第 <code>i</code> 个皇后在 <code>(i, queen[i])</code> 位置。这种记录每个皇后的坐标的方法在验证冲突的时候比较简单，只要从第 0 行遍历到当前行，若跟之前的皇后的列数相同，直接返回 <code>false</code>。</p>
<p><strong>考虑对角线（找规律）</strong>：</p>
<p>为了保证至少两个皇后不同时出现在 <strong>同一对角线方向</strong>。检查策略是，只要「检测」到新摆放的「皇后」与已经摆放好的「皇后」冲突，就尝试摆放同一行的下一个位置，到行尾还不能放置皇后，就退回到上一行。</p>
<p>当两个点在同一条对角线上，那么二者的横坐标差的绝对值等于纵坐标差的绝对值，利用这条性质，可以快速的判断对角线冲突。</p>
<p><strong>编码</strong>：</p>
<p>使用一个 1 到 4 的排列表示一个 4×4 的棋盘，例如：</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208212423.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>得到一个符合要求的全排列以后，生成棋盘的代码就很简单了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-comment">// 记录每一列皇后放置的位置</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">queens</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(queens,n,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            <span class="hljs-comment">// 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果</span><br>            vector&lt;string&gt; board=<span class="hljs-built_in">convert2board</span>(path,n);<br>            res.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-comment">// 符合条件</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(queens,n,row,j))<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(j);<br>                queens[row]=j;<span class="hljs-comment">//放置“皇后”</span><br>                <span class="hljs-built_in">dfs</span>(queens,n,row+<span class="hljs-number">1</span>,path,res);<br>                queens[row]=<span class="hljs-number">-1</span>;<span class="hljs-comment">//还原</span><br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将路径转化为棋盘</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">convert2board</span><span class="hljs-params">(deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;string&gt; board;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:path)<br>        &#123;<br>            string row;<br>            row.<span class="hljs-built_in">append</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>);<br>            row.<span class="hljs-built_in">replace</span>(num,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Q&quot;</span>);<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br><br>    <span class="hljs-comment">// 验证是否符合条件</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row;++i)<br>        &#123;<br>            <span class="hljs-comment">// 某一行与当前行在同一列放置了“皇后”，它们在数组中的值相等</span><br>            <span class="hljs-comment">// 当两个点在同一条对角线上，二者的横坐标差的绝对值等于纵坐标差的绝对值</span><br>            <span class="hljs-keyword">if</span>(queens[i]==col||<span class="hljs-built_in">abs</span>(i-row)==<span class="hljs-built_in">abs</span>(queens[i]-col))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="用空间换时间，进行优化"><a href="#用空间换时间，进行优化" class="headerlink" title="用空间换时间，进行优化"></a>用空间换时间，进行优化</h4><p>每次都调用 <code>isValid</code> 遍历一遍前面的格子，效率是不优的。最好是用数组或哈希表去记录出现过皇后的列、主对角线、副对角线，用空间换取时间。</p>
<p>由于是一行一行考虑放置皇后，摆放的这些皇后肯定不在同一行，为了避免它们在同一列，需要一个长度为 N 的布尔数组 <code>cols</code>，已经放置的皇后占据的列，就需要在对应的列的位置标注为 <code>True</code>。</p>
<p>下面研究一下主对角线或者副对角线上的元素有什么特性。在每一个单元格里写下行和列的 <strong>下标</strong>。</p>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201208213344.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<p>可以像全排列 <code>used</code> 数组那样，再为 「主对角线（Main diagonal）」 和 「副对角线（Sub diagonal）」 设置相应的 <strong>布尔数组变量</strong>，只要排定一个 「皇后」 的位置，就需要占住对应的位置。</p>
<p>其实已经摆放皇后的列下标、占据了哪一条主对角线、哪一条副对角线也可以使用哈希表来记录。实际上哈希表底层也是数组，使用哈希表可以不用处理已经占据位置的皇后的主对角线、副对角线的下标偏移问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        deque&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,path,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; col;<span class="hljs-comment">//记录某一列是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; main;<span class="hljs-comment">//记录主对角线上的单元格是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; sub;<span class="hljs-comment">//记录了副对角线上的单元格是否放置了皇后</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;vector&lt;string&gt;&gt; &amp;res)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            vector&lt;string&gt; board=<span class="hljs-built_in">convert2board</span>(path,n);<br>            res.<span class="hljs-built_in">push_back</span>(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(col.<span class="hljs-built_in">count</span>(j)==<span class="hljs-number">0</span>&amp;&amp;main.<span class="hljs-built_in">count</span>(row-j)==<span class="hljs-number">0</span>&amp;&amp;sub.<span class="hljs-built_in">count</span>(row+j)==<span class="hljs-number">0</span>)<br>            &#123;<br>                path.<span class="hljs-built_in">push_back</span>(j);<span class="hljs-comment">// 放置皇后</span><br>                col.<span class="hljs-built_in">insert</span>(j);<span class="hljs-comment">//记录放了皇后的列</span><br>                main.<span class="hljs-built_in">insert</span>(row-j);<span class="hljs-comment">//记录放了皇后的主对角线</span><br>                sub.<span class="hljs-built_in">insert</span>(row+j);<span class="hljs-comment">//记录放了皇后的副对角线</span><br>                <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,path,res);<br>                sub.<span class="hljs-built_in">erase</span>(row+j);<span class="hljs-comment">//删除对应的记录</span><br>                main.<span class="hljs-built_in">erase</span>(row-j);<br>                col.<span class="hljs-built_in">erase</span>(j);<br>                path.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//撤销该点的皇后</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将路径转化为棋盘</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">convert2board</span><span class="hljs-params">(deque&lt;<span class="hljs-type">int</span>&gt; &amp;path,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;string&gt; board;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;num:path)<br>        &#123;<br>            string row;<br>            row.<span class="hljs-built_in">append</span>(n,<span class="hljs-string">&#x27;.&#x27;</span>);<br>            row.<span class="hljs-built_in">replace</span>(num,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Q&quot;</span>);<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="52-N皇后-II-hard"><a href="#52-N皇后-II-hard" class="headerlink" title="52. N皇后 II[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a>[hard]</h2><h3 id="解法一：回溯-1"><a href="#解法一：回溯-1" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 相同，稍加修改即可。区别在于，51 题需要得到所有可能的解，这道题只需要得到可能的解的数量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; col;<span class="hljs-comment">//记录某一列是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; main;<span class="hljs-comment">//记录主对角线上的单元格是否放置了皇后</span><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; sub;<span class="hljs-comment">//记录了副对角线上的单元格是否放置了皇后</span><br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> &amp;count)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row==n)<br>        &#123;<br>            ++count;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(col.<span class="hljs-built_in">count</span>(j)==<span class="hljs-number">0</span>&amp;&amp;main.<span class="hljs-built_in">count</span>(row-j)==<span class="hljs-number">0</span>&amp;&amp;sub.<span class="hljs-built_in">count</span>(row+j)==<span class="hljs-number">0</span>)<br>            &#123;<br>                col.<span class="hljs-built_in">insert</span>(j);<span class="hljs-comment">//记录放了皇后的列</span><br>                main.<span class="hljs-built_in">insert</span>(row-j);<span class="hljs-comment">//记录放了皇后的主对角线</span><br>                sub.<span class="hljs-built_in">insert</span>(row+j);<span class="hljs-comment">//记录放了皇后的副对角线</span><br>                <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,count);<br>                sub.<span class="hljs-built_in">erase</span>(row+j);<span class="hljs-comment">//删除对应的记录</span><br>                main.<span class="hljs-built_in">erase</span>(row-j);<br>                col.<span class="hljs-built_in">erase</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：DFS-位运算剪枝"><a href="#解法二：DFS-位运算剪枝" class="headerlink" title="解法二：DFS+位运算剪枝"></a>解法二：DFS+位运算剪枝</h3><p>具体思路参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens-ii/solution/dfs-wei-yun-suan-jian-zhi-by-makeex/">makee</a> 题解。</p>
<ol>
<li>使用常规深度优先一层层搜索。</li>
<li>使用三个整形分别标记每一层哪些格子可以放置皇后，这三个整形分别代表列、左斜下、右斜下<code>（_col, ld, rd_）</code>，二进制位为 1 代表不能放置，0 代表可以放置。</li>
<li>核心两个位运算：<ul>
<li><code>x &amp; -x</code> 代表除最后一位 1 保留，其它位全部为 0；</li>
<li><code>x &amp; (x - 1)</code> 代表将最后一位 1 变成 0。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,count);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">int</span> ld,<span class="hljs-type">int</span> rd,<span class="hljs-type">int</span> &amp;count)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(row&gt;=n) <br>        &#123; <br>            ++count; <br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br>        <span class="hljs-comment">// 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历</span><br>        <span class="hljs-type">int</span> bits=~(col|ld|rd)&amp;((<span class="hljs-number">1</span>&lt;&lt;n)<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(bits&gt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> pick=bits&amp;-bits; <span class="hljs-comment">// 注: x &amp; -x</span><br>            <span class="hljs-built_in">dfs</span>(n,row+<span class="hljs-number">1</span>,col|pick,(ld|pick)&lt;&lt;<span class="hljs-number">1</span>,(rd|pick)&gt;&gt;<span class="hljs-number">1</span>,count);<br>            bits&amp;=bits<span class="hljs-number">-1</span>; <span class="hljs-comment">// 注: x &amp; (x - 1)</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="37-解数独-hard"><a href="#37-解数独-hard" class="headerlink" title="37. 解数独[hard]"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a>[hard]</h2><p>思路与 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a> 相似。</p>
<h3 id="解法一：回溯-2"><a href="#解法一：回溯-2" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h3><p>详细思路参考 @<a target="_blank" rel="noopener" href="https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/3.1-hui-su-suan-fa-dfs-suan-fa-pian/sudoku">labuladong的算法小抄</a> 回溯算法最佳实践：解数独。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">backtrack</span>(board,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 找到一个可行解，触发 base case</span><br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">9</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 穷举到最后一列的话就换到下一行重新开始</span><br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">9</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtrack</span>(board,i+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果有预设数字，不用穷举</span><br>        <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">backtrack</span>(board,i,j+<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 对 board[i][j] 进行穷举尝试</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch=<span class="hljs-string">&#x27;1&#x27;</span>;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>;++ch)<br>        &#123;<br>            <span class="hljs-comment">// 如果遇到不合法的数字，就跳过</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isValid</span>(board,i,j,ch))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 做选择</span><br>            board[i][j]=ch;<br>            <span class="hljs-comment">// 继续穷举下一个</span><br>            <span class="hljs-comment">// 如果找到一个可行解，立即结束</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtrack</span>(board,i,j+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 撤销选择</span><br>            board[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 穷举完 1~9，依然没有找到可行解，此路不通</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断 board[i][j] 是否可以填入 n</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c,<span class="hljs-type">char</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-comment">// 判断行是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[r][i]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 判断列是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[i][c]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 判断 3 x 3 方框是否存在重复</span><br>            <span class="hljs-keyword">if</span>(board[(r/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+i/<span class="hljs-number">3</span>][(c/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span>+i%<span class="hljs-number">3</span>]==n)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：回溯-状态压缩（使用bitset）"><a href="#解法二：回溯-状态压缩（使用bitset）" class="headerlink" title="解法二：回溯+状态压缩（使用bitset）"></a>解法二：回溯+状态压缩（使用bitset）</h3><p>详细思路参考 @<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/solution/37-by-ikaruga/">Ikaruga</a> 题解。</p>
<p><strong>状态压缩</strong></p>
<ul>
<li>使用 <code>bitset&lt;9&gt;</code> 来压缩存储每一行、每一列、每一个 <code>3x3</code> 宫格中 <code>1-9</code> 是否出现；</li>
<li>这样每一个格子就可以计算出所有不能填的数字，然后得到所有<strong>能填的数字</strong> <code>getPossibleStatus()</code>；</li>
<li>填入数字和回溯时，只需要更新存储信息；</li>
<li>每个格子在使用时，会根据存储信息重新计算<strong>能填的数字</strong>。</li>
</ul>
<p>回溯</p>
<ul>
<li>每次都使用 <code>getNext()</code> 选择<strong>能填的数字</strong>最少的格子开始填，这样填错的概率最小，回溯次数也会变少；</li>
<li>使用 <code>fillNum()</code> 在填入和回溯时负责更新存储信息；</li>
<li>一旦全部填写成功，一路返回 true ，结束递归。</li>
</ul>
<img src="https://raw.githubusercontent.com/Simpleforever/imgbed/master/pic/20201214170159.png" srcset="/img/loading.gif" lazyload style="zoom:80%;" />

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        rows=vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">9</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;());<br>        cols=vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">9</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;());<br>        cells=vector&lt;vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;&gt;(<span class="hljs-number">3</span>,vector&lt;bitset&lt;<span class="hljs-number">9</span>&gt;&gt;(<span class="hljs-number">3</span>,<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">9</span>&gt;()));<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)<br>            &#123;<br>                <span class="hljs-comment">// 记录有待填入数字的数目</span><br>                cnt+=(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>);<br>                <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 初始化存储状态</span><br>                <span class="hljs-type">int</span> n=board[i][j]-<span class="hljs-string">&#x27;1&#x27;</span>;<br>                rows[i]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>                cols[j]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>                cells[i/<span class="hljs-number">3</span>][j/<span class="hljs-number">3</span>]|=(<span class="hljs-number">1</span>&lt;&lt;n);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(board,cnt);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    vector&lt;bitset&lt;9&gt;&gt; rows;<br>    vector&lt;bitset&lt;9&gt;&gt; cols;<br>    vector&lt;vector&lt;bitset&lt;9&gt;&gt;&gt; cells;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board,<span class="hljs-type">int</span> cnt)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 递归结束条件</span><br>        <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 找出可能性最小的位置（其实就是包含已知信息最多的位置，这样选择的次数是最少的，有点类似贪心的思想）</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; next=<span class="hljs-built_in">getNext</span>(board);<br>        <span class="hljs-comment">// 找出这个坐标(i,j)可以填入的数字</span><br>        bitset&lt;9&gt; bits=<span class="hljs-built_in">getPossibleStatus</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;n&lt;bits.<span class="hljs-built_in">size</span>();++n)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!bits.<span class="hljs-built_in">test</span>(n))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">// 更新存储状态</span><br>            <span class="hljs-built_in">fillNum</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>],n,<span class="hljs-literal">true</span>);<br>            board[next[<span class="hljs-number">0</span>]][next[<span class="hljs-number">1</span>]]=n+<span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board,cnt<span class="hljs-number">-1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            board[next[<span class="hljs-number">0</span>]][next[<span class="hljs-number">1</span>]]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>            <span class="hljs-comment">// 撤销上一步的存储状态</span><br>            <span class="hljs-built_in">fillNum</span>(next[<span class="hljs-number">0</span>],next[<span class="hljs-number">1</span>],n,<span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 选择可能性最少的数字开始填</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> minCnt=<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]!=<span class="hljs-string">&#x27;.&#x27;</span>)<br>                    <span class="hljs-keyword">continue</span>;<br>                bitset&lt;9&gt; cur=<span class="hljs-built_in">getPossibleStatus</span>(i,j);<br>                <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">count</span>()&gt;=minCnt)<br>                    <span class="hljs-keyword">continue</span>;<br>                ret=&#123;i,j&#125;;<br>                minCnt=cur.<span class="hljs-built_in">count</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>    <span class="hljs-function">bitset&lt;9&gt; <span class="hljs-title">getPossibleStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> ~(rows[x]|cols[y]|cells[x/<span class="hljs-number">3</span>][y/<span class="hljs-number">3</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillNum</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n,<span class="hljs-type">bool</span> fillFlag)</span></span><br><span class="hljs-function">    </span>&#123;<br>        rows[x][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        cols[y][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        cells[x/<span class="hljs-number">3</span>][y/<span class="hljs-number">3</span>][n]=(fillFlag)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/leetcode/">leetcode</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Search/">Search</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/15/Leetcode%20Notes%E2%80%94%E2%80%94Divide%20and%20Conquer/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Leetcode Notes——Divide and Conquer</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/03/Leetcode%20Notes%E2%80%94%E2%80%94Sort/">
                        <span class="hidden-mobile">Leetcode Notes——Sort</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
